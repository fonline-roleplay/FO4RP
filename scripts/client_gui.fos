#ifndef CLIENT_GUI
#define CLIENT_GUI

#include "_utils.fos"
#include "client_gui_h.fos"
#include "sprite.fos"

import void ShowContScreen( uint8 screenType, uint8 actionType ) from "client_screen_contmenu";
import KeybData@ InputBoxGetKeybData(int index) from "client_screen_inputbox";

GUIScreen@[] AllScreens;
GUIScreen@[] ActiveScreens;
bool[] KeyPressed;
bool[] MousePressed;
uint[] MousePressTick;
IGUIScreenOpt@  LastScreenOpt = null;
IGUIElementOpt@ LastElementOpt = null;

class GUIElement : IGUIElementOpt
{
    GUIElement( string@ sprName, int path )
    {
		@Surface = Sprite();
        if( @sprName != null )
            Surface.Load( sprName, path );
        DefaultPath = path;
        PosX = 0;
        PosY = 0;
        IsTextInput = false;
        InputMaxLen = 0;
        TextColorFocused = 0;
        TextColorDown = 0;
        IsFocused = false;
        MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
            MousePressed[ i ] = false;
        SwitchEnabled = false;

        // @pm menu
        ElementFastPanelId = 0;
        ElementFastPanelType = 0;
        Visible = true;

        RenderLayer = 3;
        // #pm menu

        @InitCallback = null;
        @DrawCallback = null;
        @MouseClickCallback = null;
        @KeyPressCallback = null;
		@InstanceInitCallback = null;
		
		_JammingState = false;
		IsJamming = false;
    }

    void Draw( int screenX, int screenY )
    {
        if( !Visible )
		{
            return;
		}
		
		bool isDown = false;
		if( DownSpr.Id != 0 )
		{
			isDown = ( MousePressed[ MOUSE_CLICK_LEFT ] || SwitchEnabled );			
			if( !isDown && IsJamming )
			{
				isDown = _JammingState;
			}
		}
        if( isDown )
		{
            DrawSprite( DownSpr.Id, Surface.DrawFrame, screenX + PosX, screenY + PosY, Surface.Width, Surface.Height, true, false, 0 );
		}
		else if( Surface.Id != 0 )
		{
			Surface.Draw( screenX + PosX, screenY + PosY, true, false, 0 );
        }
		
        if( Label != "" )
		{
            DrawText( Label,
                      screenX + PosX,
                      screenY + PosY,
                      Surface.Width != 0 ? Surface.Width : __ScreenWidth, 
                      ( Surface.Height != 0 ? Surface.Height : __ScreenHeight ) - ( isDown ? 2 : 0 ),
                      IsTextInput && IsFocused ? TextColorFocused : ( isDown && TextColorDown != 0 ? TextColorDown : TextColor ), 
                      Font,
                      TextFlags );
		}
		
		if( valid(DrawCallback) )
		{
            DrawCallback.OnDraw( screenX + PosX, screenY + PosY, Surface.Width, Surface.Height );
		}
	}

    bool MouseDown( int click )
    {
        if( Visible && ( DownSpr.Id != 0 || valid( MouseClickCallback ) || IsTextInput ) )
        {
            MousePressed[ click ] = true;
            return true;
        }
        return false;
    }

    void MouseUp( int click, bool isCollision )
    {
        if( valid(MouseClickCallback) && MousePressed[ click ] && isCollision && GetVisible() )
        {
            MouseClickCallback.OnMouseClick( click );
        }
		MousePressed[ click ] = false;
    }

    void MouseMove( int x, int y )
    {}

    bool KeyPress( uint8 key )
    {
        uint8 letter = 0;
        bool  result = ProcessKey( key, Label, letter );
        if( Label.length() > InputMaxLen )
		{
            Label.resize( InputMaxLen );
		}
		
		if( valid( KeyPressCallback ) )
		{
            KeyPressCallback.OnKeyPress( key, letter );
        }
		return result;
    }

    void InputLost()
    {
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
		{
            MousePressed[ i ] = false;
		}
	}

    GUIElement@ GetNewInstance( IGUIInstanceContext@ context )
    {
        GUIElement newElement = this;
		if( valid( InstanceInitCallback ) )
		{
			InstanceInitCallback( context, newElement );
		}		
        return @newElement;
    }

    // Options
    IGUIElementOpt@ CallbackInit( IGUIElementCallbackInit@ callback )
    {
        @InitCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackDraw( IGUIElementCallbackDraw@ callback )
    {
        @DrawCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackMouseClick( IGUIElementCallbackMouseClick@ callback )
    {
        @MouseClickCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackKeyPress( IGUIElementCallbackKeyPress@ callback )
    {
        @KeyPressCallback = callback;
        return this;
    }
	IGUIElementOpt@ CallbackInstanceInit( IGUIElementInstanceInitFunc@ callback )
	{
		@InstanceInitCallback = callback;
        return this;
	}

    IGUIElementOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }

    IGUIElementOpt@ Position( int x, int y, int w, int h )
    {
        PosX = x;
        PosY = y;
        Surface.Width = w;
        Surface.Height = h;
        return this;
    }
	
    IGUIElementOpt@ SetSize( int w, int h )
	{
        Surface.Width = w;
        Surface.Height = h;
        return this;	
	}

    IGUIElementOpt@ Position( string& iniKey )
    {
        PosX = 0;
        PosY = 0;
        Surface.Width = 0;
        Surface.Height = 0;

        // Parse four values from ini option
        string@ str = GetIfaceIniStr( iniKey );
        if( @str == null || str == "" )
		{
			Message( "Error 1 " + iniKey );
			Log( "Error 1 " + iniKey );
            return this;
		}
		
        string@[] @ valuesStr = splitEx( str, " " );
        if( valuesStr.length() != 4 )
		{
			Message( "Error 2 " + iniKey );
			Log( "Error 2 " + iniKey );
            return this;
		}

        int[] values( 4 );
        for( int i = 0; i < 4; i++ )
            if( !StrToInt( valuesStr[ i ], values[ i ] ) )
			{
				Message( "Error 3 " + iniKey );
				Log( "Error 3 " + iniKey );
				return this;
			}

        PosX = values[ 0 ];
        PosY = values[ 1 ];
		if( values[ 2 ] != 0 )
			Surface.Width = values[ 2 ] - values[ 0 ] + 1;
		if( values[ 3 ] != 0 )
			Surface.Height = values[ 3 ] - values[ 1 ] + 1;
        return this;
    }

    IGUIElementOpt@ DownPic( string@ sprName )
    {
        if( @sprName != null )
		{
            DownSpr.Load( sprName, DefaultPath );
        }
		else
		{
            DownSpr.Id = 0;
		}
		
        if( DownSpr.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = DownSpr.Width;
            Surface.Height = DownSpr.Height;
        }
        return this;
    }

    IGUIElementOpt@ DownPicIni( string& iniKey )
    {
        return DownPic( GetIfaceIniStr( iniKey ) );
    }

	IGUIElementOpt@ SetSprite( Sprite@ sprite )
	{
        if( valid( sprite ) )
            @Surface = sprite;
		else
            @Surface = Sprite();
		
		//Surface.RefreshData();
        return this;		
	}

    IGUIElementOpt@ Text( string@ text, int font, uint color, uint downColor, int flags )
    {
        if( !valid(text) )
		{
            Label = "";
        }
		else
		{
            Label = text;
        }
		
		Font = font;
        TextColor = color;
        TextColorDown = downColor;
        TextFlags = flags;
        return this;
    }

    IGUIElementOpt@ TextInput( bool enabled, uint maxLen, uint colorFocused )
    {
        IsTextInput = enabled;
        InputMaxLen = maxLen;
        TextColorFocused = colorFocused;
        return this;
    }

    IGUIElementOpt@ Switch( bool enabled )
    {
        SwitchEnabled = enabled;
        return this;
    }

// @pm menu
    IGUIElementOpt@ SetVisible( bool enabled )
    {
        Visible = enabled;
        return this;
    }

    IGUIElementOpt@ Release()
    {
        MouseClickCallback.OnMouseClick( MOUSE_CLICK_LEFT );
        return this;
    }

    IGUIElementOpt@ SetElementType( uint8 type )
    {
        ElementType = type;
        return this;
    }

    IGUIElementOpt@ SetDescription( string desc )
    {
        Description = desc;
        return this;
    }

    IGUIElementOpt@ SetElementBtnNum( uint8 btnNum )
    {
        ElementBtnNum = btnNum;
        return this;
    }

    IGUIElementOpt@ SetElementFastPanelType( uint8 type )
    {
        ElementFastPanelType = type;
        return this;
    }

    IGUIElementOpt@ SetElementFastPanelId( uint16 id )
    {
        ElementFastPanelId = id;
        return this;
    }

    IGUIElementOpt@ Pic( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
        }
		else
		{
            Surface.Id = 0;
		}
		
        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIElementOpt@ UpPic( string@ sprName )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, DefaultPath );
        }
		else
		{
            Surface.Id = 0;
		}
		
        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIElementOpt@ SetLayer( uint8 layer )
    {
        Layer = layer;
        return this;
    }

    IGUIElementOpt@ SetSpecialValue( uint value )
    {
        SpecialValue = value;
        return this;
    }

    IGUIElementOpt@ SetRenderLayer( uint8 layer )
    {
        RenderLayer = layer;
        return this;
    }

    IGUIElementOpt@ PicSetFrmCount( uint16 count )
    {
        Surface.DrawFrame = count;
        return this;
    }
	
    IGUIElementOpt@ SetJamming( bool isJamming )
    {
        IsJamming = isJamming;
        return this;
    }
	
	void set_JammingState( bool jamming )
    {
        _JammingState = jamming;
    }
	
	bool get_JammingState( )
    {
        return _JammingState;
    }
	
// #pm menu

    // Info
    int     GetPosX() { return PosX; }
    int     GetPosY() { return PosY; }
	void    GetSize( int& w, int& h ) { w = Surface.Width; h = Surface.Height; }
    string@ GetText() { return Label; }
// @pm menu
    bool   GetVisible()       { return Visible; }
    uint8  GetLayer()         { return Layer; }
    uint8  GetType()          { return ElementType; }
    uint8  GetBtnNum()        { return ElementBtnNum; }
    uint8  GetFastPanelType() { return ElementFastPanelType; }
    uint16 GetFastPanelId()   { return ElementFastPanelId; }
    string GetDescription()   { return Description; }
    uint16 GetSurfaceHeight() { return Surface.Height; }
    uint16 GetSurfaceWidth()  { return Surface.Width; }
    uint   GetSpecValue()     { return SpecialValue; }
    uint8  GetRenderLayer()   { return RenderLayer; }

    bool   Visible;
    uint8  Layer;
    uint8  ElementType;
    uint8  ElementBtnNum;
    uint8  ElementFastPanelType;
    uint16 ElementFastPanelId;
    string Description;

    uint8  RenderLayer;
    uint   SpecialValue;
// #pm menu

    // Data
	bool                           _JammingState;
	bool                           IsJamming;
	
    int                            PosX;
    int                            PosY;
    Sprite@                        Surface;
    Sprite                         DownSpr;
    int                            DefaultPath;
    string                         Label;
    int                            Font;
    uint                           TextColor;
    uint                           TextColorFocused;
    uint                           TextColorDown;
    int                            TextFlags;
    bool                           IsTextInput;
    uint                           InputMaxLen;
    bool                           IsFocused;
    bool[] MousePressed;
    bool                           SwitchEnabled;
    IGUIElementCallbackInit@       InitCallback;
    IGUIElementCallbackDraw@       DrawCallback;
    IGUIElementCallbackMouseClick@ MouseClickCallback;
    IGUIElementCallbackKeyPress@   KeyPressCallback;
	IGUIElementInstanceInitFunc@   InstanceInitCallback;
}

class GUIScreen : IGUIScreenOpt
{
    GUIScreen( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
        }
		
		Index = 0;

        IsCanMove = true;
        IsModal = true;
        IsMultiinstance = false;
        IsIgnoreBorders = false;
        IsCloseOnMiss = false;
        IsAutoCursor = false;

        AutoCursorType = CURSOR_DEFAULT;
        AutoCursorPrev = CURSOR_DEFAULT;

        IsHardcoded = false;
        IsLMouseDown = false;

        PosX = __ScreenWidth / 2 - Surface.Width / 2;
        PosY = __ScreenHeight / 2 - Surface.Height / 2;
        LastX = 0;
        LastY = 0;
        @ShowCallback = null;
        @HideCallback = null;
        @MoveCallback = null;
		@InstanceInitCallback = null;
		@ContextFactory = null;
    }

    void Draw()
    {
		Surface.Draw( PosX, PosY );

		for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            Elements[ i ].Draw( PosX, PosY );
		}
    }
	
    bool MouseDown( int click, int x, int y )
    {
        if( Index == CLIENT_SCREEN_CONTMENU && click > MOUSE_CLICK_LEFT )
        {
            IGUIElementOpt @ eDesc;
            int elemCount = Elements.length() - 1;
            int temp = 0;
            int count = this.LastElementNum;
            int countExt = 0;

            if( click == MOUSE_CLICK_WHEEL_UP )
            {
                temp = this.LastElementNum;
                if( !( this.LastElementNum == 1 ? Elements[ elemCount ].GetVisible() : Elements[ this.LastElementNum - 1 ].GetVisible() ) )
                {
                    do
                    {
                        if( countExt > 100 )
                        {
                            Message( "countExt end" );
                            break;
                        }
                        countExt++;
                        count == 1 ? count = elemCount : count--;
                    }
                    while( !( Elements[ count ].GetVisible() ) );
                    this.LastElementNum = count;
                }
                else
                {
                    this.LastElementNum > 1 ? this.LastElementNum -- : this.LastElementNum = elemCount;
                }

            }
            else if( click == MOUSE_CLICK_WHEEL_DOWN )
            {
                temp = this.LastElementNum;
                if( !( this.LastElementNum == elemCount ? Elements[ 1 ].GetVisible() : Elements[ this.LastElementNum + 1 ].GetVisible() ) )
                {
                    do
                    {
                        if( countExt > 100 )
                        {
                            Message( "countExt end" );
                            break;
                        }
                        countExt++;
                        count == elemCount ? count = 1 : count++;
                    }
                    while( !( Elements[ count ].GetVisible() ) );
                    this.LastElementNum = count;
                }
                else
                {
                    this.LastElementNum < elemCount ? this.LastElementNum++ : this.LastElementNum = 1;
                }
            }
            else if( click == MOUSE_CLICK_MIDDLE )
            {
                if( Elements[ this.LastElementNum ].GetVisible() )
                {
                    Elements[ this.LastElementNum ].Release();
                    __isContMenuOpen = false;
                    __HideCursor  = false;
                    return true;
                }
            }
            
            Elements[ 0 ].Text( "" + Elements[ this.LastElementNum ].GetDescription(), FONT_FALLOUT, COLOR_GREEN, COLOR_GREEN, FT_CENTERX | FT_CENTERY );
            Elements[ this.LastElementNum ].Switch( true );
            Elements[ temp ].Switch( false );
            return true;
        }

        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            Elements[ i ].IsFocused = false;
        }
        
		for( uint i = Elements.length(); i > 0; )
        {
            i--;
            GUIElement@ e = Elements[ i ];
            if( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, e.Surface.Width, e.Surface.Height ) && e.MouseDown( click ) )
            {
                e.IsFocused = true;
                return true;
            }
        }

        if( !IsHardcoded && click == MOUSE_CLICK_LEFT )
        {
            if( IS_COLLISION( x, y, PosX, PosY, Surface.Width, Surface.Height ) )
            {
                IsLMouseDown = true;
                LastX = x;
                LastY = y;    
				return true;
            }
            else if( IsCloseOnMiss )
            {
                ::HideScreen( 0, 0, 0, 0 );
                return true;
            }
        }
        return false;
    }
	
    bool MouseUp( int click, int x, int y )
    {
        IsLMouseDown = false;
        bool result = false;
        for( uint i = Elements.length(); i > 0;)
        {
            i--;
            GUIElement@ e = Elements[ i ];
            if( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, e.Surface.Width, e.Surface.Height ) )
            {
                e.MouseUp( click, true );
                result = true;
            }
            else
            {
                e.MouseUp( click, false );
            }
        }
        return result;
    }

    void MouseMove( int x, int y )
    {
        if( IsCanMove && IsLMouseDown )
        {
            int lastPosX = PosX;
            int lastPosY = PosY;
            int offsX = x - LastX;
            int offsY = y - LastY;
            LastX = x;
            LastY = y;
            PosX += offsX;
            PosY += offsY;

            // Check screen borders
            if( !IsIgnoreBorders )
            {
                int px = PosX;
                int py = PosY;
                if( PosX < 0 )
				{
                    PosX = 0;
                }
				
				if( PosY < 0 )
				{
                    PosY = 0;
                }
				
				if( PosX + Surface.Width > __ScreenWidth )
				{
                    PosX = __ScreenWidth - Surface.Width;
				}
				
				if( PosY + Surface.Height > __ScreenHeight )
				{
                    PosY = __ScreenHeight - Surface.Height;
                }
				LastX += PosX - px;
                LastY += PosY - py;
            }
            if( valid(MoveCallback) && ( lastPosX != PosX || lastPosY != PosY ) )
			{
				MoveCallback.OnMove( PosX, PosX );
			}
		}

        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            Elements[ i ].MouseMove( x, y );
            if( Index == CLIENT_SCREEN_CONTMENU && i != 0 )         // [0] is description element pm added
            {
                IGUIElementOpt @ e = Elements[ i ];

                if( IS_COLLISION( x, y, PosX + e.GetPosX(), PosY + e.GetPosY(), e.GetSurfaceWidth(), e.GetSurfaceHeight() ) )
                {
                    if( e.GetVisible() )
                    {
                        Elements[ 0 ].Text( "" + e.GetDescription(), FONT_FALLOUT, COLOR_GREEN, COLOR_GREEN, FT_CENTERX | FT_CENTERY );
                        e.Switch( true );
                        __elementActive = true;
                    }
                }
                else
                {
                    if( __elementActive )
                    {
                        e.Switch( false );
                    }
                }
            }
        }
    }

    bool KeyPress( uint8 key )
    {
        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            GUIElement@ e = Elements[ i ];
            if( valid(e) && e.IsFocused && e.IsTextInput )
			{
                return e.KeyPress( key );
			}
        }
		
        return false;
    }

    void InputLost()
    {
        IsLMouseDown = false;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{ 
           Elements[ i ].InputLost();
		}
    }

	bool IsCollision( int x, int y )
	{
		for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            Elements[ i ].MouseMove( x, y );
            if( Index == CLIENT_SCREEN_CONTMENU && i != 0 )         // [0] is description element pm added
            {
                IGUIElementOpt @ e = Elements[ i ];

                if( IS_COLLISION( x, y, PosX + e.GetPosX(), PosY + e.GetPosY(), e.GetSurfaceWidth(), e.GetSurfaceHeight() ) )
					return false;
			}
		}
		return IS_COLLISION( x, y, PosX, PosY, GetSurfaceWidth(), GetSurfaceHeight() );
	}

    GUIScreen@ GetNewInstance()
    {
		IGUIInstanceContext@ context = null;
		if( valid( ContextFactory ) )
		{
			@context = ContextFactory();
		}
		
        GUIScreen               screen = this;
        IGUIScreenCallbackShow@ newCallback = ShowCallback;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            @screen.Elements[ i ] = Elements[ i ].GetNewInstance( context );
		}
		
		if( valid( InstanceInitCallback ) )
		{
			InstanceInitCallback( context, screen );
		}
		
        return @screen;
    }

    IGUIScreenOpt@ Pic( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
		} 
		else
		{
            Surface.Id = 0;
		}

        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIScreenOpt@ CallbackShow( IGUIScreenCallbackShow@ callback )
    {
        @ShowCallback = callback;
        return this;
    }
    IGUIScreenOpt@ CallbackHide( IGUIScreenCallbackHide@ callback )
    {
        @HideCallback = callback;
        return this;
    }
    IGUIScreenOpt@ CallbackMove( IGUIScreenCallbackMove@ callback )
    {
        @MoveCallback = callback;
        return this;
    }
	IGUIScreenOpt@ CallbackInstanceInit( IGUIScreenInstanceInitFunc@ callback )
	{
		@InstanceInitCallback = callback;
		return this;
	}	
    IGUIScreenOpt@ CallbackContextFactory( IGUIInstanceContextFactoryFunc@ factory )
	{
		@ContextFactory = factory;
		return this;
	}	
    IGUIScreenOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }
    IGUIScreenOpt@ CanMove( bool enabled )
    {
        IsCanMove = enabled;
        return this;
    }
    IGUIScreenOpt@ Modal( bool enabled )
    {
        IsModal = enabled;
        return this;
    }
    IGUIScreenOpt@ Multiinstance( bool enabled )
    {
        IsMultiinstance = enabled;
        return this;
    }
    IGUIScreenOpt@ IgnoreBorders( bool enabled )
    {
        IsIgnoreBorders = enabled;
        return this;
    }
    IGUIScreenOpt@ CloseOnMiss( bool enabled )
    {
        IsCloseOnMiss = enabled;
        return this;
    }
    IGUIScreenOpt@ AutoCursor( bool enabled, int cursorType )
    {
        IsAutoCursor = enabled;
        AutoCursorType = cursorType;
        return this;
    }

    IGUIScreenOpt@ SetElementCount( int8 ElementCount )
    {
        LastElementNum = ElementCount;
        return this;
    }

    // Info
    int GetPosX()
	{
		return PosX;
	}
	
    int GetPosY()
	{
		return PosY;
	}

    uint8 GetLastElement()
	{
		return LastElementNum;
	}
	
    uint16 GetElementsLength()
	{
		return Elements.length();
	}
	
    IGUIElementOpt@ GetElement( uint16 index )
	{
		return Elements[ index ];
	}

    int GetSurfaceHeight() { return Surface.Height; }
    int GetSurfaceWidth()  { return Surface.Width; }

    int8 LastElementNum;

    int Index;
    int PosX;
    int PosY;
    int LastX;
    int LastY;
    Sprite Surface;

    bool IsCanMove;
    bool IsModal;
    bool IsMultiinstance;
    bool IsIgnoreBorders;
    bool IsCloseOnMiss;
    bool IsAutoCursor;

    int AutoCursorType;
    int AutoCursorPrev;

    bool IsHardcoded;
    bool IsLMouseDown;
    IGUIScreenCallbackShow@          ShowCallback;
    IGUIScreenCallbackHide@          HideCallback;
    IGUIScreenCallbackMove@          MoveCallback;
	IGUIScreenInstanceInitFunc@      InstanceInitCallback;
	IGUIInstanceContextFactoryFunc@  ContextFactory;
	
    GUIElement@[]                    Elements;
}

//
// API
//

// Create new screen
IGUIScreenOpt@ GUI_CreateScreen( int screenIndex, string@ sprName )
{
    if( screenIndex == 0 )
	{
        return null;
    }
	DeleteScreen( screenIndex );
    return CreateScreen( screenIndex, sprName );
}

// Create new screen ini
IGUIScreenOpt@ GUI_CreateScreenIni( int screenIndex, string@ iniKey )
{
	return GUI_CreateScreen( screenIndex, GetIfaceIniStr( iniKey + "MainPic" ) ).Position( GetIniValue( iniKey + "MainX", 0 ), GetIniValue( iniKey + "MainY", 0 ) );
}

// @pm menu
void GUI_DeleteScreenElements( int screenIndex )
{
    if( screenIndex == 0 )
        return;
    GUIScreen@ screen = GetScreen( screenIndex );
    screen.Elements.resize( 0 );
}
// #pm menu

// Delete old screen, hardcoded screens included
void GUI_DeleteScreen( int screenIndex )
{
    if( screenIndex == 0 )
        return;
    DeleteScreen( screenIndex );
}

// Add element on screen
IGUIElementOpt@ GUI_AddScreenElement( int screenIndex, string@ sprName, int x, int y )
{
    if( screenIndex == 0 )
        return null;
    if( !valid(GetScreen( screenIndex )) )
        CreateScreen( screenIndex, null );

    GUIScreen@ screen = GetScreen( screenIndex );
    GUIElement element( sprName, PT_ART_INTRFACE );
    element.Position( x, y );

    screen.Elements.insertLast( @element );
    return @element;
}

int GetIniValue( string@ iniKey, int dflt )
{
    string@ str = GetIfaceIniStr( iniKey );
	
    if( !valid(str) || str == "" )
	{
        return dflt;
    }
	
	int res = dflt;
	
    if( !StrToInt( str, res ) )
	{
        return dflt;
    }
	
	return res;
}

IGUIElementOpt@ GUI_AddScreenElementIni( int screenIndex, string@ ini, int defx, int defy )
{
	return GUI_AddScreenElement( screenIndex, GetIfaceIniStr( ini ), GetIniValue( ini + "X", defx ), GetIniValue( ini + "Y", defy ) );
}

IGUIElementOpt@ GUI_AddScreenElementIni( int screenIndex, string@ ini, int defx, int defy, string@ defSpr )
{
	string@ spr = GetIfaceIniStr( ini );
	if( !valid(spr) || spr == "" )
		@spr = defSpr;
	return GUI_AddScreenElement( screenIndex, spr, GetIniValue( ini + "X", defx ), GetIniValue( ini + "Y", defy ) );
}

// Screen options
IGUIScreenOpt@ GUI_GetScreenOptions( int screenIndex )
{
    return GetScreen( screenIndex );
}

// Valid only on IGUIScreenCallbackShow::OnShow callback
IGUIScreenOpt@ GUI_GetScreenOptions()
{
    return LastScreenOpt;
}

// Valid only on IGUIElementCallbackInit::OnInit callback
IGUIElementOpt@ GUI_GetElementOptions()
{
    return LastElementOpt;
}

//
// Engine callbacks
//

void GUI_Init()
{
    AllScreens.resize( 0 );
    ActiveScreens.resize( 0 );
    KeyPressed.resize( 0x100 );
    for( uint i = 0, j = KeyPressed.length(); i < j; i++ )
	{
        KeyPressed[ i ] = false;
	}
	
	MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
	MousePressTick.resize( MOUSE_CLICK_EXT4 + 1 );
	for( int i = 0, j = MousePressed.length(); i < j; i ++ )
	{
		MousePressed[i] = false;
		MousePressTick[i] = 0;
	}
	
    // Register hardcoded screens
    CreateScreen( CLIENT_MAIN_SCREEN_LOGIN, null );
    CreateScreen( CLIENT_MAIN_SCREEN_REGISTRATION, null );
    CreateScreen( CLIENT_MAIN_SCREEN_OPTIONS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_CREDITS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GAME, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GLOBAL_MAP, null );
    CreateScreen( CLIENT_MAIN_SCREEN_WAIT, null );
    CreateScreen( CLIENT_SCREEN_INVENTORY, null );
    CreateScreen( CLIENT_SCREEN_PICKUP, null );
    CreateScreen( CLIENT_SCREEN_MINIMAP, null );
    CreateScreen( CLIENT_SCREEN_CHARACTER, null );
    CreateScreen( CLIENT_SCREEN_DIALOG, null );
    CreateScreen( CLIENT_SCREEN_BARTER, null );
    CreateScreen( CLIENT_SCREEN_PIP_BOY, null );
    CreateScreen( CLIENT_SCREEN_FIX_BOY, null );
    CreateScreen( CLIENT_SCREEN_MENU, null );
    CreateScreen( CLIENT_SCREEN_AIM, null );
    CreateScreen( CLIENT_SCREEN_TEST, null );
    CreateScreen( CLIENT_SCREEN_SPLIT, null );
    CreateScreen( CLIENT_SCREEN_TIMER, null );
    CreateScreen( CLIENT_SCREEN_DIALOGBOX, null );
    CreateScreen( CLIENT_SCREEN_ELEVATOR, null );
    CreateScreen( CLIENT_SCREEN_SAY, null );
    CreateScreen( CLIENT_SCREEN_CHA_NAME, null );
    CreateScreen( CLIENT_SCREEN_CHA_AGE, null );
    CreateScreen( CLIENT_SCREEN_CHA_SEX, null );
    CreateScreen( CLIENT_SCREEN_GM_TOWN, null );
    CreateScreen( CLIENT_SCREEN_INPUT_BOX, null );
    CreateScreen( CLIENT_SCREEN_SKILLBOX, null );
    CreateScreen( CLIENT_SCREEN_USE, null );
    CreateScreen( CLIENT_SCREEN_PERK, null );
    CreateScreen( CLIENT_SCREEN_TOWN_VIEW, null );
    CreateScreen( CLIENT_SCREEN_SAVE_LOAD, null );
    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
	{
        AllScreens[ i ].IsHardcoded = true;
	}
	
    // Keyboard init
    
	
	RunAllFunctions( "GUIInit" );
}

int GUI_GetActiveMainScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.first().Index : CLIENT_SCREEN_NONE;
}

int GUI_GetActiveScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.last().Index : CLIENT_SCREEN_NONE;
}

void GUI_GetActiveScreens( int[]& result )
{
    result.resize( ActiveScreens.length() );
    for( uint i = 0, j = result.length(); i < j; i++ )
	{
        result[ i ] = ActiveScreens[ i ].Index;
	}
}

void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 )
{
    GUIScreen@ screen = GetScreen( screenIndex );
    if( valid(screen) )
    {
        if( !screen.IsMultiinstance )
        {
            // Close all another instances
            for( uint i = ActiveScreens.length(); i > 0;)       // From end
            {
                i--;
                if( ActiveScreens[ i ].Index == screenIndex )
                {
                    ActiveScreens.removeAt( i );
                    if( valid(screen.HideCallback) )
					{
                        screen.HideCallback.OnHide( p0, p1, p2 );
					}
				}
            }
        }

        // Create new instance
        @screen = screen.GetNewInstance();
        ActiveScreens.insertLast( @screen );

        // Set screen cursor
        if( screen.IsAutoCursor )
        {
            screen.AutoCursorPrev = ::GetCurrentCursor();
            ::ChangeCursor( screen.AutoCursorType );
        }

        // Call init callbacks
        @LastScreenOpt = screen;
        // First init elements
        for( uint i = 0, j = screen.Elements.length(); i < j; i++ )
        {
            GUIElement@ e = screen.Elements[ i ];
            if( valid(e.InitCallback) )
            {
                @LastElementOpt = e;
                e.InitCallback.OnInit();
                @LastElementOpt = null;
            }
        }
        // Then show
        if( valid(screen.ShowCallback) )
        {
            screen.ShowCallback.OnShow( p0, p1, p2 );
        }
		
        @LastScreenOpt = null;
    }
}

void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 )
{
    for( uint i = ActiveScreens.length(); i > 0; ) // From end
    {
        i--;
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.Index == screenIndex )
        {
            // Remove
            ActiveScreens.removeAt( i );

            // Hide callback
            if( valid( screen.HideCallback ) )
            {
                screen.HideCallback.OnHide( p0, p1, p2 );
            }

            // Restore cursor
            if( screen.IsAutoCursor )
            {
                ::ChangeCursor( screen.AutoCursorPrev );
            }

            // Store position for non-multiinstance screens
            if( !screen.IsMultiinstance )
            {
                GUIScreen@ instance = GetScreen( screenIndex );
                instance.PosX = screen.PosX;
                instance.PosY = screen.PosY;
            }
			
            break;
        }
    }
}

void GUI_Render()
{
    for( uint i = 0, j = ActiveScreens.length(); i < j; i++ )
    {
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.IsHardcoded )
        {
            if( screen.Index != CLIENT_MAIN_SCREEN_LOGIN )
            {
                ::DrawHardcodedScreen( screen.Index );
                ::GetHardcodedScreenPos( screen.Index, screen.PosX, screen.PosY );
            }
        }
		
        screen.Draw();
    }
}

bool GUI_MouseDown( int click, int x, int y )
{
	MousePressed[click] = true;
    uint len = ActiveScreens.length();
    if( len != 0 )
    {
        GUIScreen@ screen = ActiveScreens[ len - 1 ];
        bool result = screen.MouseDown( click, x, y );
        if( result )
        {
            if( click == MOUSE_CLICK_WHEEL_UP || click == MOUSE_CLICK_WHEEL_DOWN )
			{
                return GUI_MouseUp( click, x, y );
            }
			
			return true;
        }

        if( len > 1 && !screen.IsHardcoded && !screen.IsModal && click == MOUSE_CLICK_LEFT &&
			!IS_COLLISION( x, y, screen.PosX, screen.PosY, screen.Surface.Width, screen.Surface.Height ) )
        {
            for( uint i = ActiveScreens.length() - 1; i > 0;)     // From end
            {
                i--;
                GUIScreen@ nextScreen = ActiveScreens[ i ];
                if( IS_COLLISION( x, y, nextScreen.PosX, nextScreen.PosY, nextScreen.Surface.Width, nextScreen.Surface.Height ) )
                {
                    // Swap screens
                    GUIScreen@ tmpScreen = ActiveScreens[ i ];
                    @ActiveScreens[ i ] = ActiveScreens[ len - 1 ];
                    @ActiveScreens[ len - 1 ] = tmpScreen;
                    return GUI_MouseDown( click, x, y );                 // Click new screen
                }
            }
        }
    }
	
    return false;
}

bool GUI_MouseUp( int click, int x, int y )
{
	MousePressed[click] = false;
    uint len = ActiveScreens.length();
    if( len != 0 )
	{
        return ActiveScreens[ len - 1 ].MouseUp( click, x, y );
	}
	
	return false;
}

void GUI_MouseMove( int x, int y )
{
    uint len = ActiveScreens.length();
    if( len != 0 )
	{
        ActiveScreens[ len - 1 ].MouseMove( x, y );
	}
}

bool GUI_KeyDown( uint8 key )
{
    bool result;

    if( KeyPressed.length() != 0 )
	{
        KeyPressed[ key ] = true;
    }
	
	uint len = ActiveScreens.length();
    if( len != 0 )
    {
		result = ActiveScreens[ len - 1 ].KeyPress( key );
    }
    else
	{
        result = false;
	}
    return result;
}

bool GUI_KeyUp( uint8 key )
{
    if( KeyPressed.length() != 0 )
	{
        KeyPressed[ key ] = false;
    }
	return false;
}

void GUI_InputLost()
{
    for( uint i = 0, j = KeyPressed.length(); i < j; i++ )
	{
        KeyPressed[ i ] = false;
    }
	
	uint len = ActiveScreens.length();
    if( len != 0 )
	{
        ActiveScreens[ len - 1 ].InputLost();
	}
}

//
// Internal
//

IGUIScreenOpt@ CreateScreen( int screenIndex, string@ sprName )
{
    GUIScreen screen( sprName, PT_ART_INTRFACE );
    screen.CanMove( true );
    screen.Position( __ScreenWidth / 2 - screen.Surface.Width / 2, __ScreenHeight / 2 - screen.Surface.Height / 2 );
    screen.Index = screenIndex;
    AllScreens.insertLast( @screen );
    return @screen;
}

void DeleteScreen( int screenIndex )
{
    for( uint i = 0; i < ActiveScreens.length();)
    {
        if( ActiveScreens[ i ].Index == screenIndex )
        {
            ActiveScreens.removeAt( i );
            i = 0;
        }
        else
        {
            i++;
        }
    }

    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
    {
        if( AllScreens[ i ].Index == screenIndex )
        {
            AllScreens.removeAt( i );
            break;
        }
    }
}

GUIScreen@ GetScreen( int screenIndex )
{
    if( screenIndex == 0 )
	{
        return null;
    }
	
	for( uint i = 0, j = AllScreens.length(); i < j; i++ )
	{
        if( AllScreens[ i ].Index == screenIndex )
		{
            return @AllScreens[ i ];
		}
	}
	
	return null;
}

bool ProcessKey( uint8 key, string& text, uint8& letter )
{
    if( KeyPressed.length() == 0 )
	{
        return false;
	}
	
    if( key == DIK_BACK )
    {
        if( text.length() > 0 )
		{
            text.resize( text.length() - 1 );
        }
		
		return true;
    }

    KeybData@ k = InputBoxGetKeybData(key);
    if( valid(k) )
    {
        bool shiftDown = ( KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ] );
        uint len = text.length();
        text.resize( text.length() + 1 );
        text[ len ] = k.Char[ ::GetKeybLang() * 2 + ( shiftDown ? 1 : 0 ) ];
        letter = text[ len ];
        return true;
    }
	
    return false;
}

bool IsMonitorGui( int x, int y )
{
	for( uint i = ActiveScreens.length(); i > 0; i-- )
	{
		if( ActiveScreens[ i - 1 ].IsCollision( x, y ) )
		{
			return true;
		}
	}
	
	return false;
}

bool[] GUI_GetMousePressed()
{
	return MousePressed;
}

#endif //CLIENT_GUI