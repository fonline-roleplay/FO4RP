#ifndef CLIENT_GUI
#define CLIENT_GUI

#include "client_gui_h.fos"
#include "_utils.fos"
#include "_client_defines.fos"
#include "client_names_h.fos"
#include "sprite.fos"
#include "fofmod_h.fos"
#include "critter_item_movement_h.fos"
#include "client_controls.fos"
#include "client_screen_palette_h.fos"

import void InputBoxKeyPressed( uint8 key, uint8 kbData ) from "client_screen_inputbox";
import void InputBoxClipboardInsert()  from "client_screen_inputbox";

uint8 previews = 0;
uint pkm_up_last_tick = 0;

int GM_store_type = -1;
bool playerMenuActive = false;

GUIScreen@[] AllScreens;
GUIScreen@[] ActiveScreens;
bool[] KeyPressed;
bool[] MousePressed;
uint[] MousePressTick;
KeybData@[] KbData;
IGUIScreenOpt@  LastScreenOpt = null;
IGUIElementOpt@ LastElementOpt = null;

class KeybData
{
    KeybData( int8 r, int8 rs, int8 e, int8 es )
    {
        Char.resize( 4 );
        Char[ 0 ] = r;
        Char[ 1 ] = rs;
        Char[ 2 ] = e;
        Char[ 3 ] = es;
    }
    uint8[] Char;     // Russian, Rissian Shift, English, English Shift
}

class GUIElement : IGUIElementOpt
{
    GUIElement( string@ sprName, int path )
    {
		@Surface = Sprite();
        if( @sprName != null )
            Surface.Load( sprName, path );
        DefaultPath = path;
        PosX = 0;
        PosY = 0;
        IsTextInput = false;
        InputMaxLen = 0;
        TextColorFocused = 0;
        TextColorDown = 0;
        IsFocused = false;
        MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
            MousePressed[ i ] = false;
        SwitchEnabled = false;

        // @pm menu
        ElementFastPanelId = 0;
        ElementFastPanelType = 0;
        Visible = true;

        RenderLayer = 3;         // pm add
        // #pm menu

        @InitCallback = null;
        @DrawCallback = null;
        @MouseClickCallback = null;
        @KeyPressCallback = null;
		@InstanceInitCallback = null;
		
		_JammingState = false;
		IsJamming = false;
    }

    void Draw( int screenX, int screenY )
    {
        if( !Visible )
		{
            return;                                                                                                                      // @pm menu
		}
		
		bool isDown = false;
		if( DownSpr.Id != 0 )
		{
			isDown = ( MousePressed[ MOUSE_CLICK_LEFT ] || SwitchEnabled );			
			if( !isDown && IsJamming )
			{
				isDown = _JammingState;
			}
		}
        if( isDown )
		{
            DrawSprite( DownSpr.Id, Surface.DrawFrame, screenX + PosX, screenY + PosY, Surface.Width, Surface.Height, true, false, 0 );  // pm edit (added Sprite::Width \ Sprite::Height)//DrawSprite(DownSpr.Id,-1,screenX+PosX,screenY+PosY,0);
		}
		else if( Surface.Id != 0 )
		{
			Surface.Draw( screenX + PosX, screenY + PosY, true, false, 0 );
        }
		
        if( Label != "" )
		{
            DrawText( Label, screenX + PosX, screenY + PosY,
                      Surface.Width != 0 ? Surface.Width : __ScreenWidth, ( Surface.Height != 0 ? Surface.Height : __ScreenHeight ) - ( isDown ? 2 : 0 ),
                      IsTextInput && IsFocused ? TextColorFocused : ( isDown && TextColorDown != 0 ? TextColorDown : TextColor ), Font, TextFlags );
		}
		
		if( valid(DrawCallback) )
		{
            DrawCallback.OnDraw( screenX + PosX, screenY + PosY, Surface.Width, Surface.Height );
		}
	}

    bool MouseDown( int click )
    {
        if( Visible && ( DownSpr.Id != 0 || valid( MouseClickCallback ) || IsTextInput ) )
        {
            MousePressed[ click ] = true;
			PlaySound( "BUTIN4.ACM" );
            return true;
        }
        return false;
    }

    void MouseUp( int click, bool isCollision )
    {
	   if( valid(MouseClickCallback) && MousePressed[ click ] && isCollision && GetVisible() )
	   {
            MouseClickCallback.OnMouseClick( click ); // @pm menu
	   }
		MousePressed[ click ] = false;
    }

    void MouseMove( int x, int y )
    {}

    bool KeyPress( uint8 key )
    {
        uint8 letter = 0;
        bool  result = ProcessKey( key, Label, letter );
        if( Label.length() > InputMaxLen )
		{
            Label.resize( InputMaxLen );
		}
		
		if( valid( KeyPressCallback ) )
		{
            KeyPressCallback.OnKeyPress( key, letter );
        }
		return result;
    }

    void InputLost()
    {
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
		{
            MousePressed[ i ] = false;
		}
	}

    GUIElement@ GetNewInstance( IGUIInstanceContext@ context )
    {
        GUIElement newElement = this;
		if( valid( InstanceInitCallback ) )
		{
			InstanceInitCallback( context, newElement );
		}		
        return @newElement;
    }

    // Options
    IGUIElementOpt@ CallbackInit( IGUIElementCallbackInit@ callback )
    {
        @InitCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackDraw( IGUIElementCallbackDraw@ callback )
    {
        @DrawCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackMouseClick( IGUIElementCallbackMouseClick@ callback )
    {
        @MouseClickCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackKeyPress( IGUIElementCallbackKeyPress@ callback )
    {
        @KeyPressCallback = callback;
        return this;
    }
	IGUIElementOpt@ CallbackInstanceInit( IGUIElementInstanceInitFunc@ callback )
	{
		@InstanceInitCallback = callback;
        return this;
	}

    IGUIElementOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }

    IGUIElementOpt@ Position( int x, int y, int w, int h )
    {
        PosX = x;
        PosY = y;
        Surface.Width = w;
        Surface.Height = h;
        return this;
    }
	
    IGUIElementOpt@ SetSize( int w, int h )
	{
        Surface.Width = w;
        Surface.Height = h;
        return this;	
	}

    IGUIElementOpt@ Position( string& iniKey )
    {
        PosX = 0;
        PosY = 0;
        Surface.Width = 0;
        Surface.Height = 0;

        // Parse four values from ini option
        string@ str = GetIfaceIniStr( iniKey );
        if( @str == null || str == "" )
		{
			Message( "Error 1 " + iniKey );
			Log( "Error 1 " + iniKey );
            return this;
		}
		
        string@[] @ valuesStr = splitEx( str, " " );
        if( valuesStr.length() != 4 )
		{
			Message( "Error 2 " + iniKey );
			Log( "Error 2 " + iniKey );
            return this;
		}

        int[] values( 4 );
        for( int i = 0; i < 4; i++ )
            if( !StrToInt( valuesStr[ i ], values[ i ] ) )
			{
				Message( "Error 3 " + iniKey );
				Log( "Error 3 " + iniKey );
				return this;
			}

        PosX = values[ 0 ];
        PosY = values[ 1 ];
		if( values[ 2 ] != 0 )
			Surface.Width = values[ 2 ] - values[ 0 ] + 1;
		if( values[ 3 ] != 0 )
			Surface.Height = values[ 3 ] - values[ 1 ] + 1;
        return this;
    }

    IGUIElementOpt@ DownPic( string@ sprName )
    {
        if( @sprName != null )
		{
            DownSpr.Load( sprName, DefaultPath );
        }
		else
		{
            DownSpr.Id = 0;
		}
		
        if( DownSpr.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = DownSpr.Width;
            Surface.Height = DownSpr.Height;
        }
        return this;
    }

    IGUIElementOpt@ DownPicIni( string& iniKey )
    {
        return DownPic( GetIfaceIniStr( iniKey ) );
    }

	IGUIElementOpt@ SetSprite( Sprite@ sprite )
	{
        if( valid( sprite ) )
            @Surface = sprite;
		else
            @Surface = Sprite();
		
		//Surface.RefreshData();
        return this;		
	}

    IGUIElementOpt@ Text( string@ text, int font, uint color, uint downColor, int flags )
    {
        if( !valid(text) )
		{
            Label = "";
        }
		else
		{
            Label = text;
        }
		
		Font = font;
        TextColor = color;
        TextColorDown = downColor;
        TextFlags = flags;
        return this;
    }

    IGUIElementOpt@ TextInput( bool enabled, uint maxLen, uint colorFocused )
    {
        IsTextInput = enabled;
        InputMaxLen = maxLen;
        TextColorFocused = colorFocused;
        return this;
    }

    IGUIElementOpt@ Switch( bool enabled )
    {
        SwitchEnabled = enabled;
        return this;
    }

// @pm menu
    IGUIElementOpt@ SetVisible( bool enabled )   // pm add
    {
        Visible = enabled;
        return this;
    }

    IGUIElementOpt@ Release()     // pm add
    {
        MouseClickCallback.OnMouseClick( MOUSE_CLICK_LEFT );
        return this;
    }

    IGUIElementOpt@ SetElementType( uint8 type )   // pm add
    {
        ElementType = type;
        return this;
    }

    IGUIElementOpt@ SetDescription( string desc )   // pm add
    {
        Description = desc;
        return this;
    }

    IGUIElementOpt@ SetElementBtnNum( uint8 btnNum )   // pm add
    {
        ElementBtnNum = btnNum;
        return this;
    }

    IGUIElementOpt@ SetElementFastPanelType( uint8 type )   // pm add
    {
        ElementFastPanelType = type;
        return this;
    }

    IGUIElementOpt@ SetElementFastPanelId( uint16 id )   // pm add
    {
        ElementFastPanelId = id;
        return this;
    }

    IGUIElementOpt@ Pic( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
        }
		else
		{
            Surface.Id = 0;
		}
		
        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIElementOpt@ UpPic( string@ sprName )   // pm add
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, DefaultPath );
        }
		else
		{
            Surface.Id = 0;
		}
		
        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIElementOpt@ SetLayer( uint8 layer )
    {
        Layer = layer;
        return this;
    }

    IGUIElementOpt@ SetSpecialValue( uint value )
    {
        SpecialValue = value;
        return this;
    }

    IGUIElementOpt@ SetRenderLayer( uint8 layer )
    {
        RenderLayer = layer;
        return this;
    }

    IGUIElementOpt@ PicSetFrmCount( uint16 count )
    {
        Surface.DrawFrame = count;
        return this;
    }    // pm add
	
    IGUIElementOpt@ SetJamming( bool isJamming )
    {
        IsJamming = isJamming;
        return this;
    }
	
	void set_JammingState( bool jamming )
    {
        _JammingState = jamming;
    }
	
	bool get_JammingState( )
    {
        return _JammingState;
    }
	
// #pm menu

    // Info
    int     GetPosX() { return PosX; }
    int     GetPosY() { return PosY; }
	void    GetSize( int& w, int& h ) { w = Surface.Width; h = Surface.Height; }
    string@ GetText() { return Label; }
// @pm menu
    bool   GetVisible()       { return Visible; }
    uint8  GetLayer()         { return Layer; }
    uint8  GetType()          { return ElementType; }
    uint8  GetBtnNum()        { return ElementBtnNum; }
    uint8  GetFastPanelType() { return ElementFastPanelType; }
    uint16 GetFastPanelId()   { return ElementFastPanelId; }
    string GetDescription()   { return Description; }
    uint16 GetSurfaceHeight() { return Surface.Height; }
    uint16 GetSurfaceWidth()  { return Surface.Width; }
    uint   GetSpecValue()     { return SpecialValue; }
    uint8  GetRenderLayer()   { return RenderLayer; }

    bool   Visible;
    uint8  Layer;
    uint8  ElementType;
    uint8  ElementBtnNum;
    uint8  ElementFastPanelType;
    uint16 ElementFastPanelId;
    string Description;

    uint8  RenderLayer;
    uint   SpecialValue;
// #pm menu

    // Data
	bool                           _JammingState;
	bool                           IsJamming;
	
    int                            PosX;
    int                            PosY;
    Sprite@                        Surface;
    Sprite                         DownSpr;
    int                            DefaultPath;
    string                         Label;
    int                            Font;
    uint                           TextColor;
    uint                           TextColorFocused;
    uint                           TextColorDown;
    int                            TextFlags;
    bool                           IsTextInput;
    uint                           InputMaxLen;
    bool                           IsFocused;
    bool[] MousePressed;
    bool                           SwitchEnabled;
    IGUIElementCallbackInit@       InitCallback;
    IGUIElementCallbackDraw@       DrawCallback;
    IGUIElementCallbackMouseClick@ MouseClickCallback;
    IGUIElementCallbackKeyPress@   KeyPressCallback;
	IGUIElementInstanceInitFunc@   InstanceInitCallback;
}

class GUIScreen : IGUIScreenOpt
{
    GUIScreen( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
        }
		
		Index = 0;

        IsCanMove = true;
        IsModal = true;
        IsMultiinstance = false;
        IsIgnoreBorders = false;
        IsCloseOnMiss = false;
        IsAutoCursor = false;

        AutoCursorType = CURSOR_DEFAULT;
        AutoCursorPrev = CURSOR_DEFAULT;

        IsHardcoded = false;
        IsLMouseDown = false;

        PosX = __ScreenWidth / 2 - Surface.Width / 2;
        PosY = __ScreenHeight / 2 - Surface.Height / 2;
        LastX = 0;
        LastY = 0;
        @ShowCallback = null;
        @HideCallback = null;
        @MoveCallback = null;
		@InstanceInitCallback = null;
		@ContextFactory = null;
    }

    void Draw()
    {
		Surface.Draw( PosX, PosY );

		for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            Elements[ i ].Draw( PosX, PosY );
		}

		if(IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME)
		{
			if( valid( controlpanel ) )
			{
				controlpanel.draw();
			}

			CritterCl@ chosen = GetChosen();
			if( !valid( chosen ) )
			{
				return;
			}

			if( LMB_on && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
			{
				if( GetCurrentCursor() == CURSOR_RTSA )
				{
					drawBar( 0xFF, 0x00, 0x00 );
					OutlineAttackTargets();
				}
				else if( GetCurrentCursor() == CURSOR_RTS )
				{
					drawBar( 0x00, 0xFF, 0x00 );
					addNewSelection();	
				}
			}
		}
    }
	
    bool MouseDown( int click, int x, int y )
    {
        if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME && click == MOUSE_CLICK_RIGHT )
		{
            __mouse2Pressed = true;
		}

		if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME )
		{
			if( __waiting )
			{
				return true;
			}

			CritterCl@ chosen = GetChosen();
			int cursorCurrent = GetCurrentCursor();
			if( click == MOUSE_CLICK_LEFT && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
			{
				LMB_x1 = x;
				LMB_y1 = y;
				LMB_x2 = x;
				LMB_y2 = y;
				LMB_on = true;
				if( cursorCurrent == CURSOR_RTS )
				{
					addNewSelection();	
				}
			}
		}

        if( Index == CLIENT_SCREEN_CONTMENU && click > MOUSE_CLICK_LEFT )
        {
            IGUIElementOpt @ eDesc;
            int elemCount = Elements.length() - 1;
            int temp = 0;
            int count = this.LastElementNum;
            int countExt = 0;

            if( click == MOUSE_CLICK_WHEEL_UP )
            {
                temp = this.LastElementNum;
                if( !( this.LastElementNum == 1 ? Elements[ elemCount ].GetVisible() : Elements[ this.LastElementNum - 1 ].GetVisible() ) )
                {
                    do
                    {
                        if( countExt > 100 )
                        {
                            Message( "countExt end" );
                            break;
                        }
                        countExt++;
                        count == 1 ? count = elemCount : count--;
                    }
                    while( !( Elements[ count ].GetVisible() ) );
                    this.LastElementNum = count;
                }
                else
                {
                    this.LastElementNum > 1 ? this.LastElementNum -- : this.LastElementNum = elemCount;
                }

			}
			else if( click == MOUSE_CLICK_WHEEL_DOWN )
            {
                temp = this.LastElementNum;
                if( !( this.LastElementNum == elemCount ? Elements[ 1 ].GetVisible() : Elements[ this.LastElementNum + 1 ].GetVisible() ) )
                {
                    do
                    {
                        if( countExt > 100 )
                        {
                            Message( "countExt end" );
                            break;
                        }
                        countExt++;
                        count == elemCount ? count = 1 : count++;
                    }
                    while( !( Elements[ count ].GetVisible() ) );
                    this.LastElementNum = count;
                }
                else
                {
                    this.LastElementNum < elemCount ? this.LastElementNum++ : this.LastElementNum = 1;
                }
            }
			else if( click == MOUSE_CLICK_MIDDLE )
            {
                if( Elements[ this.LastElementNum ].GetVisible() )
                {
                    Elements[ this.LastElementNum ].Release();
                    __isContMenuOpen = false;
                    __HideCursor  = false;
                    return true;
                }
            }
			
            Elements[ 0 ].Text( "" + Elements[ this.LastElementNum ].GetDescription(), FONT_FALLOUT, COLOR_GREEN, COLOR_GREEN, FT_CENTERX | FT_CENTERY );
            Elements[ this.LastElementNum ].Switch( true );
            Elements[ temp ].Switch( false );
            return true;
        }

        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            Elements[ i ].IsFocused = false;
        }
		
		for( uint i = Elements.length(); i > 0; )
        {
            i--;
            GUIElement@ e = Elements[ i ];
            if( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, e.Surface.Width, e.Surface.Height ) && e.MouseDown( click ) )
            {
                e.IsFocused = true;
                return true;
            }
        }

        if( !IsHardcoded && click == MOUSE_CLICK_LEFT )
        {
            if( IS_COLLISION( x, y, PosX, PosY, Surface.Width, Surface.Height ) )
            {
                IsLMouseDown = true;
                LastX = x;
                LastY = y;    
				return true;
            }
            else if( IsCloseOnMiss )
            {
                ::HideScreen( 0, 0, 0, 0 );
                return true;
            }
        }
        return false;
    }
	
    bool MouseUp( int click, int x, int y )
    {
        if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME )
        {
            LMB_on = false;
            clearShiftGroup();
        }
        IsLMouseDown = false;
        bool result = false;
        for( uint i = Elements.length(); i > 0;)
        {
            i--;
            GUIElement@ e = Elements[ i ];
            if( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, e.Surface.Width, e.Surface.Height ) )
            {
                e.MouseUp( click, true );
                result = true;
            }
            else
            {
                e.MouseUp( click, false );
            }
        }
        return result;
    }

    void MouseMove( int x, int y )
    {
		LMB_x2 = x;
		LMB_y2 = y;
		
        if( IsCanMove && IsLMouseDown )
        {
            int lastPosX = PosX;
            int lastPosY = PosY;
            int offsX = x - LastX;
            int offsY = y - LastY;
            LastX = x;
            LastY = y;
            PosX += offsX;
            PosY += offsY;

            // Check screen borders
            if( !IsIgnoreBorders )
            {
                int px = PosX;
                int py = PosY;
                if( PosX < 0 )
				{
                    PosX = 0;
                }
				
				if( PosY < 0 )
				{
                    PosY = 0;
                }
				
				if( PosX + Surface.Width > __ScreenWidth )
				{
                    PosX = __ScreenWidth - Surface.Width;
				}
				
				if( PosY + Surface.Height > __ScreenHeight )
				{
                    PosY = __ScreenHeight - Surface.Height;
                }
				LastX += PosX - px;
                LastY += PosY - py;
            }
            if( valid(MoveCallback) && ( lastPosX != PosX || lastPosY != PosY ) )
			{
				MoveCallback.OnMove( PosX, PosX );
			}
		}

        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            Elements[ i ].MouseMove( x, y );
            if( Index == CLIENT_SCREEN_CONTMENU && i != 0 )         // [0] is description element pm added
            {
                IGUIElementOpt @ e = Elements[ i ];

                if( IS_COLLISION( x, y, PosX + e.GetPosX(), PosY + e.GetPosY(), e.GetSurfaceWidth(), e.GetSurfaceHeight() ) )
                {
                    if( e.GetVisible() )
                    {
                        Elements[ 0 ].Text( "" + e.GetDescription(), FONT_FALLOUT, COLOR_GREEN, COLOR_GREEN, FT_CENTERX | FT_CENTERY );
                        e.Switch( true );
                        __elementActive = true;
                    }
                }
                else
                {
                    if( __elementActive )
                    {
                        e.Switch( false );
                    }
                }
            }
        }
    }

    bool KeyPress( uint8 key )
    {
		CritterCl@ chosen = GetChosen();

		int screen_type = GUI_GetActiveScreen();
		
		if( key == DIK_ESCAPE )
		{
			if( screen_type == CLIENT_SCREEN_PICKUP && isGM( chosen ) && GM_store_type != -1 )
			{
				RunServerScriptUnsafe( "store@unsafe_StoreMenu", GM_store_type, 0, 0, null, null );
				GM_store_type = -1;
				return false;
			}
			
			if( playerMenuActive )
			{
				RunServerScriptUnsafe( "teleports@unsafe_stopPlayerMenu", 0, 0, 0, null, null );
				playerMenuActive = false;
			}
		}	

		if( screen_type == CLIENT_SCREEN_PICKUP || screen_type == CLIENT_SCREEN_INVENTORY )
		{
			if( KeyPressed[ DIK_LSHIFT ] && key == DIK_Q )
			{
				RunServerScriptUnsafe( "gm@unsafe_show_containments", 0, 0, 0, null, null );
				return false;
			}
		}

		if( !__ConsoleActive )
		{
			if( !KeyPressed[ DIK_LSHIFT ] )
				clearShiftGroup();
		}

        if( Index == CLIENT_MAIN_SCREEN_GAME || Index == CLIENT_MAIN_SCREEN_GLOBAL_MAP )
        {
            if( controlpanel.KeyPress( key ) )
            {
                return true;
            }

            //Use on hotkey
            if( key == DIK_A && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LSHIFT ] && valid( chosen ) )
            {
                if( valid( chosen ) && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
                {
                    GetCurrentCursor() == CURSOR_RTS ? ChangeCursor( CURSOR_RTSA ) : ChangeCursor( CURSOR_RTS );
                    return true;
                }
                
                uint8 mode = 0;				
                ProtoItem@ hand = chosen.GetSlotProto( SLOT_HAND1, mode );
                if( GetCurrentCursor() == CURSOR_USE_WEAPON || GetCurrentCursor() == CURSOR_USE_OBJECT )
                {
                    if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && !__mobhotkeys )
                    {
                        ChangeCursor( CURSOR_DEFAULT );
                    }
                    else
                    {
                        ChangeCursor( GetLastCursor() );
                    }
                    return true;
                }
                else if( mode == 4 )
                {
                    ChangeCursor( CURSOR_USE_OBJECT );
                }
                else if( valid( hand ) && hand.Type == ITEM_TYPE_WEAPON )
                {
                    ChangeCursor( CURSOR_USE_WEAPON );
                }

                return true;
            }
        }
        else if( Index == CLIENT_SCREEN_INPUTBOX )
        {
            uint8 char = 0;
            uint8 charIndex = 0;

            if( ( KeyPressed[ DIK_LCONTROL ] || KeyPressed[ DIK_RCONTROL ] ) && key == DIK_V )
            {
                InputBoxClipboardInsert();
                return false;
            }

            uint8[] disabledKeys = { DIK_BACK, DIK_LEFT, DIK_RIGHT };
            if( disabledKeys.find( key ) == -1 )
            {
                if( GetKeybLang() > 0 )
				{
                    charIndex = 2;
                }
				if( KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ] )
				{                
					charIndex++;
                }
				char = KbData[ key ].Char[ charIndex ];
            }
			
            if( ( key != DIK_ESCAPE || key == DIK_RETURN ) && !__ConsoleActive )
            {
                InputBoxKeyPressed( key, char );
                return true;
            }
        }
		
        if( ( __IsHotkeysUse ) )
        {
            if( ( Index == CLIENT_SCREEN_PIP_BOY ) && ( key == DIK_P ) )
			{
                return false;
            }
			uint8 mainScr = 0;
            for( uint i = 0; i < ActiveScreens.length(); i++ )
            {
                if( ( ActiveScreens[ i ].Index == CLIENT_MAIN_SCREEN_GAME ) || ( ActiveScreens[ i ].Index == CLIENT_MAIN_SCREEN_GLOBAL_MAP ) )
                {
                    mainScr = ActiveScreens[ i ].Index;
                    break;
                }
            }
		}
		
        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            GUIElement@ e = Elements[ i ];
            if( valid(e) && e.IsFocused && e.IsTextInput )
			{
                return e.KeyPress( key );
			}
        }
		
        return false;
    }

    void InputLost()
    {
        IsLMouseDown = false;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{ 
           Elements[ i ].InputLost();
		}
    }

	bool IsCollision( int x, int y )
	{
		for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            Elements[ i ].MouseMove( x, y );
            if( Index == CLIENT_SCREEN_CONTMENU && i != 0 )         // [0] is description element pm added
            {
                IGUIElementOpt @ e = Elements[ i ];

                if( IS_COLLISION( x, y, PosX + e.GetPosX(), PosY + e.GetPosY(), e.GetSurfaceWidth(), e.GetSurfaceHeight() ) )
					return false;
			}
		}
		return IS_COLLISION( x, y, PosX, PosY, GetSurfaceWidth(), GetSurfaceHeight() );
	}

    GUIScreen@ GetNewInstance()
    {
		IGUIInstanceContext@ context = null;
		if( valid( ContextFactory ) )
		{
			@context = ContextFactory();
		}
		
        GUIScreen               screen = this;
        IGUIScreenCallbackShow@ newCallback = ShowCallback;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            @screen.Elements[ i ] = Elements[ i ].GetNewInstance( context );
		}
		
		if( valid( InstanceInitCallback ) )
		{
			InstanceInitCallback( context, screen );
		}
		
        return @screen;
    }

    IGUIScreenOpt@ Pic( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
		} 
		else
		{
            Surface.Id = 0;
		}

        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIScreenOpt@ CallbackShow( IGUIScreenCallbackShow@ callback )
    {
        @ShowCallback = callback;
        return this;
    }
    IGUIScreenOpt@ CallbackHide( IGUIScreenCallbackHide@ callback )
    {
        @HideCallback = callback;
        return this;
    }
    IGUIScreenOpt@ CallbackMove( IGUIScreenCallbackMove@ callback )
    {
        @MoveCallback = callback;
        return this;
    }
	IGUIScreenOpt@ CallbackInstanceInit( IGUIScreenInstanceInitFunc@ callback )
	{
		@InstanceInitCallback = callback;
		return this;
	}	
    IGUIScreenOpt@ CallbackContextFactory( IGUIInstanceContextFactoryFunc@ factory )
	{
		@ContextFactory = factory;
		return this;
	}	
    IGUIScreenOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }
    IGUIScreenOpt@ CanMove( bool enabled )
    {
        IsCanMove = enabled;
        return this;
    }
    IGUIScreenOpt@ Modal( bool enabled )
    {
        IsModal = enabled;
        return this;
    }
    IGUIScreenOpt@ Multiinstance( bool enabled )
    {
        IsMultiinstance = enabled;
        return this;
    }
    IGUIScreenOpt@ IgnoreBorders( bool enabled )
    {
        IsIgnoreBorders = enabled;
        return this;
    }
    IGUIScreenOpt@ CloseOnMiss( bool enabled )
    {
        IsCloseOnMiss = enabled;
        return this;
    }
    IGUIScreenOpt@ AutoCursor( bool enabled, int cursorType )
    {
        IsAutoCursor = enabled;
        AutoCursorType = cursorType;
        return this;
    }

    IGUIScreenOpt@ SetElementCount( int8 ElementCount )
    {
        LastElementNum = ElementCount;
        return this;
    }

    // Info
    int GetPosX()
	{
		return PosX;
	}
	
    int GetPosY()
	{
		return PosY;
	}

    uint8 GetLastElement()
	{
		return LastElementNum;
	}
	
    uint16 GetElementsLength()
	{
		return Elements.length();
	}
	
    IGUIElementOpt@ GetElement( uint16 index )
	{
		return Elements[ index ];
	}

    int GetSurfaceHeight() { return Surface.Height; }
    int GetSurfaceWidth()  { return Surface.Width; }

    int8 LastElementNum;

    int Index;
    int PosX;
    int PosY;
    int LastX;
    int LastY;
    Sprite Surface;

    bool IsCanMove;
    bool IsModal;
    bool IsMultiinstance;
    bool IsIgnoreBorders;
    bool IsCloseOnMiss;
    bool IsAutoCursor;

    int AutoCursorType;
    int AutoCursorPrev;

    bool IsHardcoded;
    bool IsLMouseDown;
    IGUIScreenCallbackShow@          ShowCallback;
    IGUIScreenCallbackHide@          HideCallback;
    IGUIScreenCallbackMove@          MoveCallback;
	IGUIScreenInstanceInitFunc@      InstanceInitCallback;
	IGUIInstanceContextFactoryFunc@  ContextFactory;
	
    GUIElement@[]                    Elements;
}

//
// API
//

// Create new screen
IGUIScreenOpt@ GUI_CreateScreen( int screenIndex, string@ sprName )
{
    if( screenIndex == 0 )
	{
        return null;
    }
	DeleteScreen( screenIndex );
    return CreateScreen( screenIndex, sprName );
}

// Create new screen ini
IGUIScreenOpt@ GUI_CreateScreenIni( int screenIndex, string@ iniKey )
{
	return GUI_CreateScreen( screenIndex, GetIfaceIniStr( iniKey + "MainPic" ) ).Position( GetIniValue( iniKey + "MainX", 0 ), GetIniValue( iniKey + "MainY", 0 ) );
}

// @pm menu
void GUI_DeleteScreenElements( int screenIndex ) // pm add
{
    if( screenIndex == 0 )
        return;
    GUIScreen@ screen = GetScreen( screenIndex );
    screen.Elements.resize( 0 );
}
// #pm menu

// Delete old screen, hardcoded screens included
void GUI_DeleteScreen( int screenIndex )
{
    if( screenIndex == 0 )
        return;
    DeleteScreen( screenIndex );
}

// Add element on screen
IGUIElementOpt@ GUI_AddScreenElement( int screenIndex, string@ sprName, int x, int y )
{
    if( screenIndex == 0 )
        return null;
    if( !valid(GetScreen( screenIndex )) )
        CreateScreen( screenIndex, null );

    GUIScreen@ screen = GetScreen( screenIndex );
    GUIElement element( sprName, PT_ART_INTRFACE );
    element.Position( x, y );

    screen.Elements.insertLast( @element );
    return @element;
}

int GetIniValue( string@ iniKey, int dflt )
{
    string@ str = GetIfaceIniStr( iniKey );
	
    if( !valid(str) || str == "" )
	{
        return dflt;
    }
	
	int res = dflt;
	
    if( !StrToInt( str, res ) )
	{
        return dflt;
    }
	
	return res;
}

IGUIElementOpt@ GUI_AddScreenElementIni( int screenIndex, string@ ini, int defx, int defy )
{
	return GUI_AddScreenElement( screenIndex, GetIfaceIniStr( ini ), GetIniValue( ini + "X", defx ), GetIniValue( ini + "Y", defy ) );
}

IGUIElementOpt@ GUI_AddScreenElementIni( int screenIndex, string@ ini, int defx, int defy, string@ defSpr )
{
	string@ spr = GetIfaceIniStr( ini );
	if( !valid(spr) || spr == "" )
		@spr = defSpr;
	return GUI_AddScreenElement( screenIndex, spr, GetIniValue( ini + "X", defx ), GetIniValue( ini + "Y", defy ) );
}

// Screen options
IGUIScreenOpt@ GUI_GetScreenOptions( int screenIndex )
{
    return GetScreen( screenIndex );
}

// Valid only on IGUIScreenCallbackShow::OnShow callback
IGUIScreenOpt@ GUI_GetScreenOptions()
{
    return LastScreenOpt;
}

// Valid only on IGUIElementCallbackInit::OnInit callback
IGUIElementOpt@ GUI_GetElementOptions()
{
    return LastElementOpt;
}

//
// Engine callbacks
//

void GUI_Init()
{
	initControlPanel();
    AllScreens.resize( 0 );
    ActiveScreens.resize( 0 );
    KeyPressed.resize( 0x100 );
    for( uint i = 0, j = KeyPressed.length(); i < j; i++ )
	{
        KeyPressed[ i ] = false;
	}
	
	MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
	MousePressTick.resize( MOUSE_CLICK_EXT4 + 1 );
	for( int i = 0, j = MousePressed.length(); i < j; i ++ )
	{
		MousePressed[i] = false;
		MousePressTick[i] = 0;
	}
	
    // Register hardcoded screens
    CreateScreen( CLIENT_MAIN_SCREEN_LOGIN, null );
    CreateScreen( CLIENT_MAIN_SCREEN_REGISTRATION, null );
    CreateScreen( CLIENT_MAIN_SCREEN_OPTIONS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_CREDITS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GAME, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GLOBAL_MAP, null );
    CreateScreen( CLIENT_MAIN_SCREEN_WAIT, null );
    CreateScreen( CLIENT_SCREEN_INVENTORY, null );
    CreateScreen( CLIENT_SCREEN_PICKUP, null );
    CreateScreen( CLIENT_SCREEN_MINIMAP, null );
    CreateScreen( CLIENT_SCREEN_CHARACTER, null );
    CreateScreen( CLIENT_SCREEN_DIALOG, null );
    CreateScreen( CLIENT_SCREEN_BARTER, null );
    CreateScreen( CLIENT_SCREEN_PIP_BOY, null );
    CreateScreen( CLIENT_SCREEN_FIX_BOY, null );
    CreateScreen( CLIENT_SCREEN_MENU, null );
    CreateScreen( CLIENT_SCREEN_AIM, null );
    CreateScreen( CLIENT_SCREEN_TEST, null );
    CreateScreen( CLIENT_SCREEN_SPLIT, null );
    CreateScreen( CLIENT_SCREEN_TIMER, null );
    CreateScreen( CLIENT_SCREEN_DIALOGBOX, null );
    CreateScreen( CLIENT_SCREEN_ELEVATOR, null );
    CreateScreen( CLIENT_SCREEN_SAY, null );
    CreateScreen( CLIENT_SCREEN_CHA_NAME, null );
    CreateScreen( CLIENT_SCREEN_CHA_AGE, null );
    CreateScreen( CLIENT_SCREEN_CHA_SEX, null );
    CreateScreen( CLIENT_SCREEN_GM_TOWN, null );
    CreateScreen( CLIENT_SCREEN_INPUT_BOX, null );
    CreateScreen( CLIENT_SCREEN_SKILLBOX, null );
    CreateScreen( CLIENT_SCREEN_USE, null );
    CreateScreen( CLIENT_SCREEN_PERK, null );
    CreateScreen( CLIENT_SCREEN_TOWN_VIEW, null );
    CreateScreen( CLIENT_SCREEN_SAVE_LOAD, null );
    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
	{
        AllScreens[ i ].IsHardcoded = true;
	}
	
    // Keyboard init
    KbData.resize( 0x100 );
    @KbData[ DIK_1 ] =						KeybData( '1', '!', '1', '!' );
    @KbData[ DIK_2 ] =						KeybData( '2', '"', '2', '@' );
    @KbData[ DIK_3 ] =						KeybData( '3', '¹', '3', '#' );
    @KbData[ DIK_4 ] =						KeybData( '4', ';', '4', '$' );
    @KbData[ DIK_5 ] =						KeybData( '5', '%', '5', '%' );
    @KbData[ DIK_6 ] =						KeybData( '6', ':', '6', '^' );
    @KbData[ DIK_7 ] =						KeybData( '7', '?', '7', '&' );
    @KbData[ DIK_8 ] =						KeybData( '8', '*', '8', '*' );
    @KbData[ DIK_9 ] =						KeybData( '9', '(', '9', '(' );
    @KbData[ DIK_0 ] =						KeybData( '0', ')', '0', ')' );
    @KbData[ DIK_MINUS ] =					KeybData( '-', '_', '-', '_' );
    @KbData[ DIK_EQUALS ] =					KeybData( '=', '+', '=', '+' );
    @KbData[ DIK_Q ] =						KeybData( 'é', 'É', 'q', 'Q' );
    @KbData[ DIK_W ] =						KeybData( 'ö', 'Ö', 'w', 'W' );
    @KbData[ DIK_E ] =						KeybData( 'ó', 'Ó', 'e', 'E' );
    @KbData[ DIK_R ] =						KeybData( 'ê', 'Ê', 'r', 'R' );
    @KbData[ DIK_T ] =						KeybData( 'å', 'Å', 't', 'T' );
    @KbData[ DIK_Y ] =						KeybData( 'í', 'Í', 'y', 'Y' );
    @KbData[ DIK_U ] =						KeybData( 'ã', 'Ã', 'u', 'U' );
    @KbData[ DIK_I ] =						KeybData( 'ø', 'Ø', 'i', 'I' );
    @KbData[ DIK_O ] =						KeybData( 'ù', 'Ù', 'o', 'O' );
    @KbData[ DIK_P ] =						KeybData( 'ç', 'Ç', 'p', 'P' );
    @KbData[ DIK_LBRACKET ] =				KeybData( 'õ', 'Õ', '[', '{' );
    @KbData[ DIK_RBRACKET ] =				KeybData( 'ú', 'Ú', ']', '}' );
    @KbData[ DIK_A ] =						KeybData( 'ô', 'Ô', 'a', 'A' );
    @KbData[ DIK_S ] =						KeybData( 'û', 'Û', 's', 'S' );
    @KbData[ DIK_D ] =						KeybData( 'â', 'Â', 'd', 'D' );
    @KbData[ DIK_F ] =						KeybData( 'à', 'À', 'f', 'F' );
    @KbData[ DIK_G ] =						KeybData( 'ï', 'Ï', 'g', 'G' );
    @KbData[ DIK_H ] =						KeybData( 'ð', 'Ð', 'h', 'H' );
    @KbData[ DIK_J ] =						KeybData( 'î', 'Î', 'j', 'J' );
    @KbData[ DIK_K ] =						KeybData( 'ë', 'Ë', 'k', 'K' );
    @KbData[ DIK_L ] =						KeybData( 'ä', 'Ä', 'l', 'L' );
    @KbData[ DIK_SEMICOLON ] =				KeybData( 'æ', 'Æ', ';', ':' );
    @KbData[ DIK_APOSTROPHE ] =				KeybData( 'ý', 'Ý', 39, 39 );
    @KbData[ DIK_Z ] =						KeybData( 'ÿ', 'ß', 'z', 'Z' );
    @KbData[ DIK_X ] =						KeybData( '÷', '×', 'x', 'X' );
    @KbData[ DIK_C ] =						KeybData( 'ñ', 'Ñ', 'c', 'C' );
    @KbData[ DIK_V ] =						KeybData( 'ì', 'Ì', 'v', 'V' );
    @KbData[ DIK_B ] =						KeybData( 'è', 'È', 'b', 'B' );
    @KbData[ DIK_N ] =						KeybData( 'ò', 'Ò', 'n', 'N' );
    @KbData[ DIK_M ] =						KeybData( 'ü', 'Ü', 'm', 'M' );
    @KbData[ DIK_COMMA ] =					KeybData( 'á', 'Á', ',', '<' );
    @KbData[ DIK_PERIOD ] =					KeybData( 'þ', 'Þ', '.', '>' );
    @KbData[ DIK_SLASH ] =					KeybData( '.', ',', '/', '?' );
    @KbData[ DIK_MULTIPLY ] =				KeybData( '*', '*', '*', '*' );
    @KbData[ DIK_SPACE ] =					KeybData( ' ', ' ', ' ', ' ' );
    @KbData[ DIK_GRAVE ] =					KeybData( '¸', '¨', '`', '~' );
    @KbData[ DIK_NUMPAD1 ] =				KeybData( '1', '1', '1', '1' );
    @KbData[ DIK_NUMPAD2 ] =				KeybData( '2', '2', '2', '2' );
    @KbData[ DIK_NUMPAD3 ] =				KeybData( '3', '3', '3', '3' );
    @KbData[ DIK_NUMPAD4 ] =				KeybData( '4', '4', '4', '4' );
    @KbData[ DIK_NUMPAD5 ] =				KeybData( '5', '5', '5', '5' );
    @KbData[ DIK_NUMPAD6 ] =				KeybData( '6', '6', '6', '6' );
    @KbData[ DIK_NUMPAD7 ] =				KeybData( '7', '7', '7', '7' );
    @KbData[ DIK_NUMPAD8 ] =				KeybData( '8', '8', '8', '8' );
    @KbData[ DIK_NUMPAD9 ] =				KeybData( '9', '9', '9', '9' );
    @KbData[ DIK_NUMPAD0 ] =				KeybData( '0', '0', '0', '0' );
    @KbData[ DIK_SUBTRACT ] =				KeybData( '-', '-', '-', '-' );
    @KbData[ DIK_ADD ] =					KeybData( '+', '+', '+', '+' );
    @KbData[ DIK_DECIMAL ] =				KeybData( '.', '.', '.', '.' );
    @KbData[ DIK_DIVIDE ] =					KeybData( '/', '/', '/', '/' );
    @KbData[ DIK_RETURN ] =					KeybData( '\n', '\n', '\n', '\n' );
    @KbData[ DIK_NUMPADENTER ] =			KeybData( '\n', '\n', '\n', '\n' );
    @KbData[ DIK_TAB ] =					KeybData( '\t', '\t', '\t', '\t' );
	
	RunAllFunctions( "GUIInit" );
}

int GUI_GetActiveMainScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.first().Index : CLIENT_SCREEN_NONE;
}

int GUI_GetActiveScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.last().Index : CLIENT_SCREEN_NONE;
}

void GUI_GetActiveScreens( int[]& result )
{
    result.resize( ActiveScreens.length() );
    for( uint i = 0, j = result.length(); i < j; i++ )
	{
        result[ i ] = ActiveScreens[ i ].Index;
	}
}

void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 )
{
    GUIScreen@ screen = GetScreen( screenIndex );
    if( valid(screen) )
    {
        if( !screen.IsMultiinstance )
        {
            // Close all another instances
            for( uint i = ActiveScreens.length(); i > 0;)       // From end
            {
                i--;
                if( ActiveScreens[ i ].Index == screenIndex )
                {
                    ActiveScreens.removeAt( i );
                    if( valid(screen.HideCallback) )
					{
                        screen.HideCallback.OnHide( p0, p1, p2 );
					}
				}
            }
        }

        // Create new instance
        @screen = screen.GetNewInstance();
        ActiveScreens.insertLast( @screen );

        // Set screen cursor
        if( screen.IsAutoCursor )
        {
            screen.AutoCursorPrev = ::GetCurrentCursor();
            ::ChangeCursor( screen.AutoCursorType );
        }

        // Call init callbacks
        @LastScreenOpt = screen;
        // First init elements
        for( uint i = 0, j = screen.Elements.length(); i < j; i++ )
        {
            GUIElement@ e = screen.Elements[ i ];
            if( valid(e.InitCallback) )
            {
                @LastElementOpt = e;
                e.InitCallback.OnInit();
                @LastElementOpt = null;
            }
        }
        // Then show
        if( valid(screen.ShowCallback) )
        {
            screen.ShowCallback.OnShow( p0, p1, p2 );
        }
		
        @LastScreenOpt = null;
    }
}

void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 )
{
    for( uint i = ActiveScreens.length(); i > 0; ) // From end
    {
        i--;
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.Index == screenIndex )
        {
            // Remove
            ActiveScreens.removeAt( i );

            // Hide callback
            if( valid( screen.HideCallback ) )
            {
                screen.HideCallback.OnHide( p0, p1, p2 );
            }

            // Restore cursor
            if( screen.IsAutoCursor )
            {
                ::ChangeCursor( screen.AutoCursorPrev );
            }

            // Store position for non-multiinstance screens
            if( !screen.IsMultiinstance )
            {
                GUIScreen@ instance = GetScreen( screenIndex );
                instance.PosX = screen.PosX;
                instance.PosY = screen.PosY;
            }
			
            break;
        }
    }
}

void GUI_Render()
{
    for( uint i = 0, j = ActiveScreens.length(); i < j; i++ )
    {
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.IsHardcoded )
        {
            if( screen.Index != CLIENT_MAIN_SCREEN_LOGIN )
            {
                ::DrawHardcodedScreen( screen.Index );
                ::GetHardcodedScreenPos( screen.Index, screen.PosX, screen.PosY );
            }
        }
		
        screen.Draw();
    }
}

bool GUI_MouseDown( int click, int x, int y )
{
	MousePressed[click] = true;
    uint len = ActiveScreens.length();
    if( len != 0 )
    {
        GUIScreen@ screen = ActiveScreens[ len - 1 ];
        bool result = screen.MouseDown( click, x, y );
        if( result )
        {
            if( click == MOUSE_CLICK_WHEEL_UP || click == MOUSE_CLICK_WHEEL_DOWN )
			{
                return GUI_MouseUp( click, x, y );
            }
			
			return true;
        }

        if( len > 1 && !screen.IsHardcoded && !screen.IsModal && click == MOUSE_CLICK_LEFT &&
			!IS_COLLISION( x, y, screen.PosX, screen.PosY, screen.Surface.Width, screen.Surface.Height ) )
        {
            for( uint i = ActiveScreens.length() - 1; i > 0;)     // From end
            {
                i--;
                GUIScreen@ nextScreen = ActiveScreens[ i ];
                if( IS_COLLISION( x, y, nextScreen.PosX, nextScreen.PosY, nextScreen.Surface.Width, nextScreen.Surface.Height ) )
                {
                    // Swap screens
                    GUIScreen@ tmpScreen = ActiveScreens[ i ];
                    @ActiveScreens[ i ] = ActiveScreens[ len - 1 ];
                    @ActiveScreens[ len - 1 ] = tmpScreen;
                    return GUI_MouseDown( click, x, y );                 // Click new screen
                }
            }
        }
    }
	
    return false;
}

bool GUI_MouseUp( int click, int x, int y )
{
	MousePressed[click] = false;
    uint len = ActiveScreens.length();
    if( len != 0 )
	{
        return ActiveScreens[ len - 1 ].MouseUp( click, x, y );
	}
	
	return false;
}

void GUI_MouseMove( int x, int y )
{
    uint len = ActiveScreens.length();
    if( len != 0 )
	{
        ActiveScreens[ len - 1 ].MouseMove( x, y );
	}
}

bool GUI_KeyDown( uint8 key )
{
    bool result;

    if( KeyPressed.length() != 0 )
	{
        KeyPressed[ key ] = true;
    }
	
	uint len = ActiveScreens.length();
    if( len != 0 )
    {
        if( ActiveScreens[ len - 1 ].Index == CLIENT_MAIN_SCREEN_GAME && GetCurrentCursor() == CURSOR_USE_WEAPON && ( key == DIK_LCONTROL || key == DIK_RCONTROL ) )
		{
            __IsHexAttack = true;
        }
		result = ActiveScreens[ len - 1 ].KeyPress( key );
    }
    else
	{
        result = false;
	}
// binyan - Hotkeys
    if( __IsHotkeysUse )
	{
        if( previews == 0 )
		{
            previews = key;
		}
	}
    return result;
}

bool GUI_KeyUp( uint8 key )
{
	__IsHexAttack = true;
    if( __IsHotkeysUse )
	{
        if( key == previews )
		{
            previews = 0;
		}
	}
	
    if( KeyPressed.length() != 0 )
	{
        KeyPressed[ key ] = false;
    }
	return false;
}

void GUI_InputLost()
{
    for( uint i = 0, j = KeyPressed.length(); i < j; i++ )
	{
        KeyPressed[ i ] = false;
    }
	
	uint len = ActiveScreens.length();
    if( len != 0 )
	{
        ActiveScreens[ len - 1 ].InputLost();
	}
}

//
// Internal
//

IGUIScreenOpt@ CreateScreen( int screenIndex, string@ sprName )
{
    GUIScreen screen( sprName, PT_ART_INTRFACE );
    screen.CanMove( true );
    screen.Position( __ScreenWidth / 2 - screen.Surface.Width / 2, __ScreenHeight / 2 - screen.Surface.Height / 2 );
    screen.Index = screenIndex;
    AllScreens.insertLast( @screen );
    return @screen;
}

void DeleteScreen( int screenIndex )
{
    for( uint i = 0; i < ActiveScreens.length();)
    {
        if( ActiveScreens[ i ].Index == screenIndex )
        {
            ActiveScreens.removeAt( i );
            i = 0;
        }
        else
        {
            i++;
        }
    }

    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
    {
        if( AllScreens[ i ].Index == screenIndex )
        {
            AllScreens.removeAt( i );
            break;
        }
    }
}

GUIScreen@ GetScreen( int screenIndex )
{
    if( screenIndex == 0 )
	{
        return null;
    }
	
	for( uint i = 0, j = AllScreens.length(); i < j; i++ )
	{
        if( AllScreens[ i ].Index == screenIndex )
		{
            return @AllScreens[ i ];
		}
	}
	
	return null;
}

bool ProcessKey( uint8 key, string& text, uint8& letter )
{
    if( KeyPressed.length() == 0 )
	{
        return false;
	}
	
    if( key == DIK_BACK )
    {
        if( text.length() > 0 )
		{
            text.resize( text.length() - 1 );
        }
		
		return true;
    }

    KeybData@ k = KbData[ key ];
    if( valid(k) )
    {
        bool shiftDown = ( KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ] );
        uint len = text.length();
        text.resize( text.length() + 1 );
        text[ len ] = k.Char[ ::GetKeybLang() * 2 + ( shiftDown ? 1 : 0 ) ];
        letter = text[ len ];
        return true;
    }
	
    return false;
}

void _SetControlCritters( int Id, int p1, int p2, string@ + p3, int[] @ + p4 )
{
    SetControlCritters( Id );
}

void SetGMstore( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	GM_store_type = param0;
}

void SetPlayerMenuActive( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	playerMenuActive = param0 != 0;
}

int LMB_x1;
int LMB_y1;
int LMB_x2;
int LMB_y2;
bool LMB_on;

void drawBar( uint8 r0, uint8 g0, uint8 b0 )
{
	int x1 = MIN( LMB_x1, LMB_x2 ); int y1 = MIN( LMB_y1, LMB_y2 ); 
	int x2 = MAX( LMB_x1, LMB_x2 );	int y2 = MAX( LMB_y1, LMB_y2 );

	int[] ps2 = { 
		x1, y1, COLOR_RGBA( r0, g0, b0, 255 ),
		x2, y1, COLOR_RGBA( r0, g0, b0, 255 ),
		x2, y2, COLOR_RGBA( r0, g0, b0, 255 ),
		x1, y2, COLOR_RGBA( r0, g0, b0, 255 ),
		x1, y1, COLOR_RGBA( r0, g0, b0, 255 ) 
	};
	DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, ps2 );
}

bool IsMonitorGui( int x, int y )
{
	for( uint i = ActiveScreens.length(); i > 0; i-- )
	{
		if( ActiveScreens[ i - 1 ].IsCollision( x, y ) )
		{
			return true;
		}
	}
	
	return false;
}

bool[] GUI_GetMousePressed()
{
	return MousePressed;
}

#endif //CLIENT_GUI