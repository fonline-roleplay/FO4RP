#ifndef CLIENT_GUI
#define CLIENT_GUI

#include "client_gui_h.fos"
#include "_utils.fos"
#include "_client_defines.fos"
#include "client_names_h.fos"
#include "sprite.fos"
#include "fofmod_h.fos"
#include "critter_item_movement_h.fos"

#include "hitchance_h.fos"

import void ShowContScreen( uint8 screenType, uint8 actionType ) from "client_screen_contmenu";

import void InputBoxKeyPressed( uint8 key, uint8 kbData ) from "client_screen_inputbox";
import void InputBoxClipboardInsert()  from "client_screen_inputbox";

import void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item ) from "client_main";

//TODO: client_main_h.fos
import void DrawRectangle( int x, int y, int w, int h, int color ) from "client_avatars";
import int to_hit_hex( bool anyway ) from "client_main";
import void DrawText_info( string& text, int x, int y, int length, int width ) from "client_main";
import void DrawText_warning( string& text, int x, int y, int length, int width ) from "client_main";
import bool updateSINF() from "client_main";

uint8 previews = 0;
uint pkm_up_last_tick = 0;

void _PlaySound( int pos, int repeat, int, string@ soundName, int[] @ )
{
    PlaySound( soundName );
}

int GM_store_type = -1;

GUIScreen@[] AllScreens;
GUIScreen@[] ActiveScreens;
bool[] KeyPressed;
bool[] MousePressed;
uint[] MousePressTick;
KeybData@[] KbData;
IGUIScreenOpt@  LastScreenOpt = null;
IGUIElementOpt@ LastElementOpt = null;
uint FullAutoTick = 0;

class KeybData
{
    KeybData( int8 r, int8 rs, int8 e, int8 es )
    {
        Char.resize( 4 );
        Char[ 0 ] = r;
        Char[ 1 ] = rs;
        Char[ 2 ] = e;
        Char[ 3 ] = es;
    }
    uint8[] Char;     // Russian, Rissian Shift, English, English Shift
}

class GUIElement : IGUIElementOpt
{
    GUIElement( string@ sprName, int path )
    {
        if( @sprName != null )
            Surface.Load( sprName, path );
        DefaultPath = path;
        PosX = 0;
        PosY = 0;
        IsTextInput = false;
        InputMaxLen = 0;
        TextColorFocused = 0;
        TextColorDown = 0;
        IsFocused = false;
        MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
            MousePressed[ i ] = false;
        SwitchEnabled = false;

        // @pm menu
        ElementFastPanelId = 0;
        ElementFastPanelType = 0;
        Visible = true;

        RenderLayer = 3;         // pm add
        // #pm menu

        @InitCallback = null;
        @DrawCallback = null;
        @MouseClickCallback = null;
        @KeyPressCallback = null;
		@InstanceInitCallback = null;
		
		_JammingState = false;
		IsJamming = false;
    }

    void Draw( int screenX, int screenY )
    {
        if( !Visible )
		{
            return;                                                                                                                      // @pm menu
		}
		
		bool isDown = false;
		if( DownSpr.Id != 0 )
		{
			isDown = ( MousePressed[ MOUSE_CLICK_LEFT ] || SwitchEnabled );			
			if( !isDown && IsJamming )
			{
				isDown = _JammingState;
			}
		}
        if( isDown )
		{
            DrawSprite( DownSpr.Id, Surface.DrawFrame, screenX + PosX, screenY + PosY, Surface.Width, Surface.Height, true, false, 0 );  // pm edit (added Sprite::Width \ Sprite::Height)//DrawSprite(DownSpr.Id,-1,screenX+PosX,screenY+PosY,0);
		}
		else if( Surface.Id != 0 )
		{
            DrawSprite( Surface.Id, Surface.DrawFrame, screenX + PosX, screenY + PosY, Surface.Width, Surface.Height, true, false, 0 );  // pm edit (added Sprite::Width \ Sprite::Height)
        }
		
        if( Label != "" )
		{
            DrawText( Label, screenX + PosX, screenY + PosY,
                      Surface.Width != 0 ? Surface.Width : __ScreenWidth, ( Surface.Height != 0 ? Surface.Height : __ScreenHeight ) - ( isDown ? 2 : 0 ),
                      IsTextInput && IsFocused ? TextColorFocused : ( isDown && TextColorDown != 0 ? TextColorDown : TextColor ), Font, TextFlags );
		}
		
		if( @DrawCallback !is null )
		{
            DrawCallback.OnDraw( screenX + PosX, screenY + PosY, Surface.Width, Surface.Height );
		}
	}

    bool MouseDown( int click )
    {
        if( Visible && ( DownSpr.Id != 0 || valid( MouseClickCallback ) || IsTextInput ) )
        {
            MousePressed[ click ] = true;
			PlaySound( "BUTIN4.ACM" );
            return true;
        }
        return false;
    }

    void MouseUp( int click, bool isCollision )
    {
	   if( !( MouseClickCallback is null ) && MousePressed[ click ] && isCollision && GetVisible() )
	   {
            MouseClickCallback.OnMouseClick( click ); // @pm menu
	   }
		MousePressed[ click ] = false;
    }

    void MouseMove( int x, int y )
    {}

    bool KeyPress( uint8 key )
    {
        uint8 letter = 0;
        bool  result = ProcessKey( key, Label, letter );
        if( Label.length() > InputMaxLen )
		{
            Label.resize( InputMaxLen );
		}
		
		if( valid( KeyPressCallback ) )
		{
            KeyPressCallback.OnKeyPress( key, letter );
        }
		return result;
    }

    void InputLost()
    {
        for( uint i = 0, j = MousePressed.length(); i < j; i++ )
		{
            MousePressed[ i ] = false;
		}
	}

    GUIElement@ GetNewInstance( IGUIInstanceContext@ context )
    {
        GUIElement newElement = this;
		if( valid( InstanceInitCallback ) )
		{
			InstanceInitCallback( context, newElement );
		}		
        return @newElement;
    }

    // Options
    IGUIElementOpt@ CallbackInit( IGUIElementCallbackInit@ callback )
    {
        @InitCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackDraw( IGUIElementCallbackDraw@ callback )
    {
        @DrawCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackMouseClick( IGUIElementCallbackMouseClick@ callback )
    {
        @MouseClickCallback = callback;
        return this;
    }
    IGUIElementOpt@ CallbackKeyPress( IGUIElementCallbackKeyPress@ callback )
    {
        @KeyPressCallback = callback;
        return this;
    }
	IGUIElementOpt@ CallbackInstanceInit( IGUIElementInstanceInitFunc@ callback )
	{
		@InstanceInitCallback = callback;
        return this;
	}

    IGUIElementOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }

    IGUIElementOpt@ Position( int x, int y, int w, int h )
    {
        PosX = x;
        PosY = y;
        Surface.Width = w;
        Surface.Height = h;
        return this;
    }
	
    IGUIElementOpt@ SetSize( int w, int h )
	{
        Surface.Width = w;
        Surface.Height = h;
        return this;	
	}

    IGUIElementOpt@ Position( string& iniKey )
    {
        PosX = 0;
        PosY = 0;
        Surface.Width = 0;
        Surface.Height = 0;

        // Parse four values from ini option
        string@ str = GetIfaceIniStr( iniKey );
        if( @str == null || str == "" )
		{
			Message( "Error 1 " + iniKey );
			Log( "Error 1 " + iniKey );
            return this;
		}
		
        string@[] @ valuesStr = splitEx( str, " " );
        if( valuesStr.length() != 4 )
		{
			Message( "Error 2 " + iniKey );
			Log( "Error 2 " + iniKey );
            return this;
		}

        int[] values( 4 );
        for( int i = 0; i < 4; i++ )
            if( !StrToInt( valuesStr[ i ], values[ i ] ) )
			{
				Message( "Error 3 " + iniKey );
				Log( "Error 3 " + iniKey );
				return this;
			}

        PosX = values[ 0 ];
        PosY = values[ 1 ];
		if( values[ 2 ] != 0 )
			Surface.Width = values[ 2 ] - values[ 0 ] + 1;
		if( values[ 3 ] != 0 )
			Surface.Height = values[ 3 ] - values[ 1 ] + 1;
        return this;
    }

    IGUIElementOpt@ DownPic( string@ sprName )
    {
        if( @sprName != null )
		{
            DownSpr.Load( sprName, DefaultPath );
        }
		else
		{
            DownSpr.Id = 0;
		}
		
        if( DownSpr.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = DownSpr.Width;
            Surface.Height = DownSpr.Height;
        }
        return this;
    }

    IGUIElementOpt@ DownPicIni( string& iniKey )
    {
        return DownPic( GetIfaceIniStr( iniKey ) );
    }

	IGUIElementOpt@ SetSprite( Sprite@ sprite )
	{
        if( valid( sprite ) )
            Surface.Id = sprite.Id;
		else
            Surface.Id = 0;
		
		Surface.RefreshData();
        return this;		
	}

    IGUIElementOpt@ Text( string@ text, int font, uint color, uint downColor, int flags )
    {
        if( text is null )
		{
            Label = "";
        }
		else
		{
            Label = text;
        }
		
		Font = font;
        TextColor = color;
        TextColorDown = downColor;
        TextFlags = flags;
        return this;
    }

    IGUIElementOpt@ TextInput( bool enabled, uint maxLen, uint colorFocused )
    {
        IsTextInput = enabled;
        InputMaxLen = maxLen;
        TextColorFocused = colorFocused;
        return this;
    }

    IGUIElementOpt@ Switch( bool enabled )
    {
        SwitchEnabled = enabled;
        return this;
    }

// @pm menu
    IGUIElementOpt@ SetVisible( bool enabled )   // pm add
    {
        Visible = enabled;
        return this;
    }

    IGUIElementOpt@ Release()     // pm add
    {
        MouseClickCallback.OnMouseClick( MOUSE_CLICK_LEFT );
        return this;
    }

    IGUIElementOpt@ SetElementType( uint8 type )   // pm add
    {
        ElementType = type;
        return this;
    }

    IGUIElementOpt@ SetDescription( string desc )   // pm add
    {
        Description = desc;
        return this;
    }

    IGUIElementOpt@ SetElementBtnNum( uint8 btnNum )   // pm add
    {
        ElementBtnNum = btnNum;
        return this;
    }

    IGUIElementOpt@ SetElementFastPanelType( uint8 type )   // pm add
    {
        ElementFastPanelType = type;
        return this;
    }

    IGUIElementOpt@ SetElementFastPanelId( uint16 id )   // pm add
    {
        ElementFastPanelId = id;
        return this;
    }

    IGUIElementOpt@ Pic( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
        }
		else
		{
            Surface.Id = 0;
		}
		
        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIElementOpt@ UpPic( string@ sprName )   // pm add
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, DefaultPath );
        }
		else
		{
            Surface.Id = 0;
		}
		
        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIElementOpt@ SetLayer( uint8 layer )
    {
        Layer = layer;
        return this;
    }

    IGUIElementOpt@ SetSpecialValue( uint value )
    {
        SpecialValue = value;
        return this;
    }

    IGUIElementOpt@ SetRenderLayer( uint8 layer )
    {
        RenderLayer = layer;
        return this;
    }

    IGUIElementOpt@ PicSetFrmCount( uint16 count )
    {
        Surface.DrawFrame = count;
        return this;
    }    // pm add
	
    IGUIElementOpt@ SetJamming( bool isJamming )
    {
        IsJamming = isJamming;
        return this;
    }
	
	void set_JammingState( bool jamming )
    {
        _JammingState = jamming;
    }
	
	bool get_JammingState( )
    {
        return _JammingState;
    }
	
// #pm menu

    // Info
    int     GetPosX() { return PosX; }
    int     GetPosY() { return PosY; }
    string@ GetText() { return Label; }
// @pm menu
    bool   GetVisible()       { return Visible; }              // pm add
    uint8  GetLayer()         { return Layer; }                // pm add
    uint8  GetType()          { return ElementType; }          // pm add
    uint8  GetBtnNum()        { return ElementBtnNum; } // pm add
    uint8  GetFastPanelType() { return ElementFastPanelType; } // pm add
    uint16 GetFastPanelId()   { return ElementFastPanelId; }   // pm add
    string GetDescription()   { return Description; }          // pm add
    uint16 GetSurfaceHeight() { return Surface.Height; }
    uint16 GetSurfaceWidth()  { return Surface.Width; }
    uint   GetSpecValue()     { return SpecialValue; }
    uint8  GetRenderLayer()   { return RenderLayer; }
    // string GetSpriteName()	{ return Surface.Name; }
    // void  SetType(uint8 type) { ElementType = type; } //pm add

    // pm add
    bool   Visible;
    uint8  Layer;
    uint8  ElementType;
    uint8  ElementBtnNum;
    uint8  ElementFastPanelType;
    uint16 ElementFastPanelId;
    string Description;

    uint8  RenderLayer;
    uint   SpecialValue;
// #pm menu

    // Data
	bool                           _JammingState;
	bool                           IsJamming;
	
    int                            PosX;
    int                            PosY;
    Sprite                         Surface;
    Sprite                         DownSpr;
    int                            DefaultPath;
    string                         Label;
    int                            Font;
    uint                           TextColor;
    uint                           TextColorFocused;
    uint                           TextColorDown;
    int                            TextFlags;
    bool                           IsTextInput;
    uint                           InputMaxLen;
    bool                           IsFocused;
    bool[] MousePressed;
    bool                           SwitchEnabled;
    IGUIElementCallbackInit@       InitCallback;
    IGUIElementCallbackDraw@       DrawCallback;
    IGUIElementCallbackMouseClick@ MouseClickCallback;
    IGUIElementCallbackKeyPress@   KeyPressCallback;
	IGUIElementInstanceInitFunc@   InstanceInitCallback;
}

import void qmap_iface() from "qmap_client";

class GUIScreen : IGUIScreenOpt
{
    GUIScreen( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
        }
		
		Index = 0;

        IsCanMove = true;
        IsModal = true;
        IsMultiinstance = false;
        IsIgnoreBorders = false;
        IsCloseOnMiss = false;
        IsAutoCursor = false;

        AutoCursorType = CURSOR_DEFAULT;
        AutoCursorPrev = CURSOR_DEFAULT;

        IsHardcoded = false;
        IsLMouseDown = false;

        PosX = __ScreenWidth / 2 - Surface.Width / 2;
        PosY = __ScreenHeight / 2 - Surface.Height / 2;
        LastX = 0;
        LastY = 0;
        @ShowCallback = null;
        @HideCallback = null;
        @MoveCallback = null;
		@InstanceInitCallback = null;
		@ContextFactory = null;
    }

    void Draw()
    {
        if( Surface.Id != 0 )
		{
            DrawSprite( Surface.Id, -1, PosX, PosY, 0 );
        }

		for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            Elements[ i ].Draw( PosX, PosY );
		}
		
        if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME )
        {
            qmap_iface();
			
			if( valid( controlpanel ) )
			{
				controlpanel.draw();
			}

			if( ( __sinf & SINF_HEX ) != 0 )
            {
                uint16 hexX = 0, hexY = 0;
                GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
                DrawText( hexX + ":" + hexY, __MouseX + 22, __MouseY - 18, 50, 10, COLOR_RED, FONT_FALLOUT, 0 );
            }
			
			CritterCl@ chosen = GetChosen();
            if( !valid( chosen ) )
			{ 
				return; //TODO: Work even without chosen.
			}
			
			if( LMB_on && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
			{
				if( GetCurrentCursor() == CURSOR_RTSA )
				{
					drawBar( 0xFF, 0x00, 0x00 );
					OutlineAttackTargets();
				}
				else if( GetCurrentCursor() == CURSOR_RTS )
				{
					drawBar( 0x00, 0xFF, 0x00 );
					addNewSelection();	
				}
			}

			//Cover indicators for chosen
			if( chosen.Param[ CR_IS_RELAXING ] == 5 )
			{
				int coverType;
				for( uint i = 0; i < 6 ; i++ )
				{
					uint color = 0;
					coverType = GET_COVER_TYPE( i, chosen.Param[ CR_IN_COVER ] );
					if( coverType > 0 )
					{
						switch( coverType )
						{
							case( 1 ):
								color = COLOR_GREEN;
								break;
							case( 2 ):
								color = COLOR_YELLOW;
								break;
							case( 3 ):
								color = COLOR_ORANGE;
								break;
							case( 4 ):
								color = COLOR_RED;
								break;
							default:
								color = COLOR_GREEN;
						}
						uint16 cx = chosen.HexX, cy = chosen.HexY;
						MoveHexByDir( cx, cy, i, 1 );
						int hx = 0, hy = 0;
						GetHexPos( cx, cy, hx, hy );
						DrawText( "?", hx - 7, hy - 9, 13, 13, color, FONT_FALLOUT, 150 );
					}
				}
			}
			
			if( chosen.Param[ ST_LTP_SEQUENCE ] != -1 )
			{	
				int cx = chosen.HexX;//int( __ScreenWidth  * 0.5f - 60 );
				int cy = chosen.HexY;//int( __ScreenHeight * 0.5f - 130 );
				int hx = 0, hy = 0;
				GetHexPos( cx, cy, hx, hy );
				int max_width = 50;
				int max_hight = 10;
				hx -= max_width / 2;
				hy += 15;
				uint8 r0 = 0xDA, g0 = 0xA5, b0 = 0x20;
				int tick_start = chosen.Param[ ST_LTP_TIME ];
				int duration = ( ( chosen.Param[ ST_LTP_SEQUENCE ] + 1 ) * chosen.Param[ ST_LTP_SEQUENCE_WAIT ] * __TimeMultiplier / 1000 );
				int current_length = CLAMP( max_width * ( __FullSecond - tick_start ) / duration, 1, max_width );

				//Can't be automated without OOP - since there is difference in colors or dots.
				int[] drawData;
				drawData.insertLast( hx );
				drawData.insertLast( hy );
				drawData.insertLast( COLOR_RGBA( r0, g0, b0, 200 ) );
				drawData.insertLast( hx + current_length );
				drawData.insertLast( hy );
				drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
				drawData.insertLast( hx + current_length );
				drawData.insertLast( hy + max_hight );
				drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
				drawData.insertLast( hx );
				drawData.insertLast( hy + max_hight );
				drawData.insertLast( COLOR_RGBA( r0, g0, b0, 200 ) );
				drawData.insertLast( hx );
				drawData.insertLast( hy );
				drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
				DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				
				DrawRectangle( hx, hy, hx + max_width, hy + max_hight, COLOR_RGBA( r0, g0, b0, 255 ) );
			}
			
			//Character Voice Radius
			if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_VOICE_R ) )
			{
				drawHexRange( chosen.HexX, chosen.HexY, 50 - chosen.Stat[ ST_SPEECH_VOLUME ], COLOR_RGBA( 0x00, 0x80, 0xFF, 255 ) );
			}
			
			//Character Weapon Radius
			if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_WEAPON_R ) )
			{
				uint8 mode = 0;
				ProtoItem@ ProtoWeapon = chosen.GetSlotProto( SLOT_HAND1, mode );
				uint skillNum = _WeaponSkill( ProtoWeapon, mode );
				if( skillNum > 0 )
				{
					int skillVal = chosen.Skill[ skillNum ];
					int wpnMaxDist = _WeaponMaxDist( ProtoWeapon, mode );
					ItemCl@ weapon = chosen.GetItem( 0, SLOT_HAND1 );
					ProtoItem@ ammo = valid( weapon ) ? GetProtoItem( weapon.AmmoPid ) : null;
					
					if( valid( weapon ) && FLAG( weapon.Proto.Weapon_Perk, WEAPON_PERK_SCOPE_RANGE ) && chosen.Param[ CR_IS_WINDUPED ] > 0 )
					{
						wpnMaxDist *= 2;
					}
					
					bool isShotgun = valid( ammo ) && FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT );

					int radius_1 = 1;
					if( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS || isShotgun )
					{
						radius_1 = wpnMaxDist;
					}
					else
					{
						radius_1 = HitchanceOptimal( wpnMaxDist, skillVal );
					}
					
					if( radius_1 == 0 )
					{
						radius_1 = 1;
					}

					drawHexRange( chosen.HexX, chosen.HexY, radius_1, COLOR_RGBA( 0xFF,0x00, 0x00, 255 ) );
					
					if( valid( weapon ) )
					{
						int radius_2 = 0;
						
						if( ( skillNum == SK_THROWING || ProtoWeapon.Item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER ) && skillVal < MAX_SKILL_DISTANCE )
						{
							radius_2 = skillNum == SK_THROWING ? MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) ) : wpnMaxDist;
						}
						else if( isShotgun )
						{
							radius_2 = wpnMaxDist * 2;
						}
						
						if( radius_2 != 0 )
						{
							drawHexRange( chosen.HexX, chosen.HexY, radius_2, COLOR_RGBA( 0xFF, 0x00, 0x00, 155 ) );
						}
					}
				}
			}
			
			//Combat UI
			if( GetCurrentCursor() == CURSOR_USE_WEAPON )
			{
				uint8 mode = 0;
				ItemCl@ weapon = chosen.GetItem( 0, SLOT_HAND1 );
				bool validWeapon = valid( weapon );
				ProtoItem@ ProtoWeapon = chosen.GetSlotProto( SLOT_HAND1, mode );
				uint skillNum = _WeaponSkill( ProtoWeapon, mode );
				int skillVal = chosen.Skill[ skillNum ];
				
				CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
				if( !valid( target ) )
				{
					uint16 tx = 0, ty = 0;
					GetMonitorHex( __MouseX, __MouseY, tx, ty );
					CritterCl@[] targets;
					GetCrittersHex( tx, ty, 0, FIND_LIFE_AND_KO|FIND_ALL, targets );
					if( targets.length > 0 )
					{
						@target = targets[0];
					}
				}
				
				if( validWeapon )
				{
					uint8 subtype = weapon.Proto.Item_Subtype;
					uint8 blastRadius = weapon.Proto.Blast_Radius;
					bool isGrenade = blastRadius > 0;
					bool isRocket = false;
					bool usesAmmo = weapon.Proto.Weapon_MaxAmmoCount > 0;
					ProtoItem@ ammo = validWeapon ? GetProtoItem( weapon.AmmoPid ) : null;
					bool validAmmo = valid( ammo );
					bool isShotgun = validAmmo && FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT );
					 
					if( usesAmmo && validAmmo )
					{
						if( ammo.Blast_Radius > 0 )
						{
							blastRadius = ammo.Blast_Radius;
							isRocket = true;
						}
						
						int use = _WeaponModeUse( weapon.Mode );
						bool isFullAuto = ( _WeaponAnim2( ProtoWeapon, use ) == ANIM2_AUTO );
						
						if( isFullAuto && MousePressed[ MOUSE_CLICK_LEFT ] )
						{
							uint waitTime = _GetProtoWaitTime( ProtoWeapon, use );
							uint tick = GetTick();
							
							if( ( FullAutoTick + waitTime ) <  tick )
							{
								if( !chosen.IsBusy() )
								{
									if( !valid( target ) || target.IsDead() || target.Id == chosen.Id )
									{
										uint16 hexX = 0, hexY = 0;
										GetMonitorHex( __MouseX, __MouseY, hexX, hexY );

										if( hexX != 0 && hexY != 0 )
										{
											RunServerScriptUnsafe( "general_unsafe@unsafe_hex_attack", hexX, hexY, ProtoWeapon.ProtoId, null, null );
										}
									}
									else
									{
										RunServerScriptUnsafe( "general_unsafe@unsafe_critter_attack", target.Id, 0, ProtoWeapon.ProtoId, null, null );
									}
									
									if( chosen.Param[ CR_FULL_AUTO ] == 0 )
									{
										RunServerScriptUnsafe( "general_unsafe@unsafe_FullAutoState", 0, 0, 0, null, null );
									}
									
									FullAutoTick = tick;
								}
							}
						}
						else if( chosen.Param[ CR_FULL_AUTO ] > 0 || ( !isFullAuto && chosen.Param[ CR_FULL_AUTO ] > 0 ) )
						{
							RunServerScriptUnsafe( "general_unsafe@unsafe_FullAutoStop", 0, 0, 0, null, null );
						}
					}

					uint16 hxX = 0, hxY = 0;
					GetMonitorHex( __MouseX, __MouseY, hxX, hxY );
					if( valid( target ) && target.Id != chosen.Id )
					{
						hxX = target.HexX;
						hxY = target.HexY;
						
						if( target.Param[ CR_IS_RELAXING ] == 5 )
						{
							uint color = 0;
							uint16 hx = chosen.HexX, hy = chosen.HexY;
							uint8 dir = GetDirection( target.HexX, target.HexY, hx, hy );
							int coverType = GET_COVER_TYPE( dir, target.Param[ CR_IN_COVER ] );
							if( coverType > 0 )
							{
								switch( coverType )
								{
									case( 1 ):
										color = COLOR_GREEN;
										break;
									case( 2 ):
										color = COLOR_YELLOW;
										break;
									case( 3 ):
										color = COLOR_ORANGE;
										break;
									case( 4 ):
										color = COLOR_RED;
										break;
									default:
										color = COLOR_GREEN;
								}
								DrawText( "?", __MouseX - 22, __MouseY - 3, 13, 13, color, FONT_FALLOUT, 0 );
							}
						}
					}
					
					if( ( isGrenade || isRocket ) && subtype != ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER )
					{
						drawFanRange( hxX, hxY, blastRadius, COLOR_RGBA( 0xFF, 0x00, 0x00, 20 ) );
						
						if( subtype == ITEM_SUBTYPE_WEAPON_GRENADE_MOLOTOV || subtype == ITEM_SUBTYPE_WEAPON_GRENADE_FLASH || subtype == ITEM_SUBTYPE_WEAPON_GRENADE_SMOKE )
						{
							drawHexRange( hxX, hxY, blastRadius, COLOR_RGBA( 0xFF, 0x00, 0x00, 150 ) );
						}
						else if( subtype != ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER )
						{
							drawFanRange( hxX, hxY, int( blastRadius * 2.5 ), COLOR_RGBA( 0xFF, 0x00, 0x00, 20 ) );
							drawHexRange( hxX, hxY, int( blastRadius * 2.5 ), COLOR_RGBA( 0xFF, 0x00, 0x00, 150 ) );
						}
					}
					
					if( subtype == ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER || isShotgun )
					{
						int[] data;
						
						float a1 = 15.0f, a2 = -30.0f;
						uint wpnMaxDist = _WeaponMaxDist( weapon.Proto, mode );
						if( isShotgun )
						{
							wpnMaxDist *= 2;
							a1 = 5.0f;
							a2 = -10.0f;
						}

						int cx = 0, cy = 0;
						int hx = 0, hy = 0;
						uint16 toX = hxX, toY = hxY;
						int toX_pix = 0, toY_pix = 0;
						uint8 r0 = 0xFF, g0 = 0x00, b0 = 0x00;
						uint16 chx = chosen.HexX, chy = chosen.HexY;

						GetHexCoord( chx, chy, toX, toY, 0.0f, wpnMaxDist );
						GetHexPos( toX, toY, cx, cy );

						//shooting pos
						GetHexPos( chx, chy, hx, hy );
						data.insertLast( hx );
						data.insertLast( hy );
						data.insertLast( COLOR_RGBA( r0, g0, b0, 0 ) );						

						//left corner
						GetHexCoord( chx, chy, toX, toY, a1, wpnMaxDist );
						GetHexPos( toX, toY, toX_pix, toY_pix );
						data.insertLast( toX_pix );
						data.insertLast( toY_pix );
						data.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );

						//cursor pos
						data.insertLast( cx );
						data.insertLast( cy );
						data.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );

						//right corner
						GetHexCoord( chx, chy, toX, toY, a2, wpnMaxDist );
						GetHexPos( toX, toY, toX_pix, toY_pix );
						data.insertLast( toX_pix );
						data.insertLast( toY_pix );
						data.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
						
						//shooting pos
						data.insertLast( hx );
						data.insertLast( hy );
						data.insertLast( COLOR_RGBA( r0, g0, b0, 0 ) );						
						
						DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, data );
					}
				}
			}
			
			// Smart Target Assist
			if( CheckSTA( chosen ) )
			{
				if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_STA ) )
				{
					CritterCl@[] targets;
					
					GetCritters( 0, FIND_LIFE_AND_KO|FIND_ALL, targets );
					for( uint i = 0; i < targets.length(); i ++ )
					{
						CritterCl@ target = targets[i];
						if( !valid( target ) )
						{
							continue;
						}
						
						if( target.IsDead() )
						{
							continue;
						}
						
						if( target.Id == chosen.Id )
						{
							continue;
						}
						
						uint8 r0 = 0xFF, g0 = 0x00, b0 = 0x00;
						if( SameFaction( chosen, target ) )
						{
							r0 = 0x3C; 
							g0 = 0xF8;
							b0 = 0x00;
						}
						OutlineCritter( target, r0, g0, b0 );
					}
				}
			}
        }
    }
	
    bool MouseDown( int click, int x, int y )
    {
        if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME && click == MOUSE_CLICK_RIGHT )
		{
            __mouse2Pressed = true;
		}

        if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME )
        {
            if( __waiting )
			{
				return true;
			}
			
			CritterCl@ chosen = GetChosen();

			int cursorCurrent = GetCurrentCursor();
			if( click == MOUSE_CLICK_LEFT && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
			{
				LMB_x1 = x;
				LMB_y1 = y;
				LMB_x2 = x;
				LMB_y2 = y;
				LMB_on = true;
				if( cursorCurrent == CURSOR_RTS )
				{
					addNewSelection();	
				}
			}
			
			if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) )
			{
				if( cursorCurrent == CURSOR_MOVE )
				{
					ChangeCursor( CURSOR_DEFAULT );
				}
				
				if( click == MOUSE_CLICK_RIGHT )
				{
					ChangeCursor( CURSOR_MOVE );
				}
				else
				{
					if( click == MOUSE_CLICK_MIDDLE )
					{
						if( cursorCurrent == CURSOR_USE_OBJECT )
						{
							ChangeCursor( CURSOR_DEFAULT );
						}
						else if( cursorCurrent == CURSOR_USE_WEAPON )
						{
							ChangeCursor( CURSOR_DEFAULT );
						}
						else if( cursorCurrent == CURSOR_USE_SKILL )
						{
							ChangeCursor( CURSOR_DEFAULT );
						}
					}
				}
			}
			
            if( GetCurrentCursor() == CURSOR_USE_SKILL && __fastPanel )
			{
                __contMenuCrId = 0;
                __contMenuItId = 0;


                CritterCl@ target = GetMonitorCritter( x, y );

                if( !(target is null) )
                {
                    __contMenuCrId = target.Id;
                    if( target.IsDead() )
					{
                        __pickType = 0;
                    }
					else
					{
                        __pickType = 1;
					}
				}

                ItemCl@ trItem = GetMonitorItem( x, y );

                if( !(trItem is null) )
                {
                    __contMenuItId = trItem.Id;
                    __itemHexX = trItem.HexX;
                    __itemHexY = trItem.HexY;
                    __itemPid = trItem.GetProtoId();
                }
                ChangeCursor( CURSOR_DEFAULT );
                ShowContScreen( 26, CHOSEN_NONE );
                return true;
			}
			else if( ( click == MOUSE_CLICK_LEFT && GetCurrentCursor() == CURSOR_MOVE ) || ( click == MOUSE_CLICK_RIGHT && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) ) )
			{
                ItemCl@ exitGrid = GetMonitorItem( x, y );
                if( valid( exitGrid ) && ( exitGrid.GetProtoId() >= EXIT_GRID_PID && exitGrid.GetProtoId() <= EXIT_GRID_PID + 8 ) )
                {
					RunServerScriptUnsafe( "globalmap_group@unsafe_ExitGridClick", exitGrid.HexX, exitGrid.HexY, exitGrid.GetProtoId(), null, null );
					return true;
				}
                return false;
            }
			else if( click == MOUSE_CLICK_LEFT && GetCurrentCursor() == CURSOR_USE_SKILL && chosen.Param[ CR_REMEMBERING_NAME ] > 0 )
			{
				RunServerScriptUnsafe( "general_unsafe@unsafe_StopNamingState", 0, 0, 0, null, null );
				CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
				if( valid( target ) )
				{
					CharClick( target );
				}
                return true;
            }
			else if( click == MOUSE_CLICK_LEFT && ( GetCurrentCursor() == CURSOR_USE_WEAPON || GetCurrentCursor() == CURSOR_RTSA ) )
			{
				CritterCl@ target = GetMonitorCritter( x, y );
				if( !valid( target ) )
				{
					uint16 tx = 0, ty = 0;
					GetMonitorHex( x, y, tx, ty );
					CritterCl@[] targets;
					GetCrittersHex( tx, ty, 0, FIND_LIFE_AND_KO|FIND_ALL, targets );
					if( targets.length > 0 )
					{
						@target = targets[0];
					}
				}
				
				if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
				{
					if( valid( target ) )
					{
						RunServerScriptUnsafe( "mobcontrol@unsafe_attackMob", target.Id, 0, 0, null, control() );
						ChangeCursor( CURSOR_RTS );
						LMB_on = false;
						return true;
					}
				}
				
				uint8 mode = 0;
				ProtoItem@ ProtoWeapon = chosen.GetSlotProto( SLOT_HAND1, mode );
				int use = _WeaponModeUse( mode );
				bool isFullAuto = ( _WeaponAnim2( ProtoWeapon, use ) == ANIM2_AUTO );
				if( !isFullAuto )
				{
					if( !chosen.IsBusy() )
					{
						if( !valid( target ) || target.IsDead() || target.Id == chosen.Id )
						{
							uint16 hexX = 0, hexY = 0;
							GetMonitorHex( x, y, hexX, hexY );

							if( hexX != 0 && hexY != 0 )
							{
								RunServerScriptUnsafe( "general_unsafe@unsafe_hex_attack", hexX, hexY, ProtoWeapon.ProtoId, null, null );
							}
							
							return true;
						}
						else
						{
							RunServerScriptUnsafe( "general_unsafe@unsafe_critter_attack", target.Id, 0, ProtoWeapon.ProtoId, null, null );
							return true;
						}
					}
				}
			}
			else if( click == MOUSE_CLICK_LEFT && GetCurrentCursor() == CURSOR_USE_OBJECT )
			{
				if( chosen.IsBusy() )
				{
					return true;
				}
				
                uint16 hexX = 0, hexY = 0;
                GetMonitorHex( x, y, hexX, hexY );
				CritterCl@ cr = GetMonitorCritter( x, y );
                ItemCl@ it = GetMonitorItem( x, y );
				if( valid( cr ) )
				{
					return false;
				}
				
				if( valid( it ) )
				{
					return false;
				}
				
				RunServerScriptUnsafe( "general_unsafe@unsafe_hex_useItem", hexX, hexY, 0, null, null );
				return true;			
            }
			else if( click == MOUSE_CLICK_RIGHT && KeyPressed[ DIK_LMENU ] )
			{
                if( __mobhotkeys )
                {
                    uint16 cx = __MouseX, cy = __MouseY;
                    CritterCl@ cr = GetMonitorCritter( cx, cy );
                    ItemCl@ it = GetMonitorItem( cx, cy );
                    if( @cr != null )
					{
                        if( cr.IsPlayer() )
						{
                            RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_CRITTER_PLAYER", cr.Id, 0, 0, null, null );	// Player GM pannel
                        }
						else
						{
                            RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_CRITTER_NPC", cr.Id, 0, 0, null, null );	// NPC GM pannel
                        }
						return true;
                    }
					else if( @it != null )
					{
                        RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_ITEM", it.Id, 0, 0, null, null );				// Item GM pannel
                        return true;
                    }
					else
					{
                        uint16 hexX = 0, hexY = 0;
                        GetMonitorHex( cx, cy, hexX, hexY );
                        RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_HEX", hexX, hexY, 0, null, null );				// Hex gm pannel
                        return true;
                    }
                }
			}
			else if( click == MOUSE_CLICK_RIGHT && KeyPressed[ DIK_LCONTROL ] )
			{
				if( __mobhotkeys )
				{
					uint16 hexX = 0, hexY = 0;
					GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
					RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_HEX", hexX, hexY, 0, null, null );					// Hex gm pannel
					return true;
                }
            }
			else if( click == MOUSE_CLICK_MIDDLE && GetCurrentCursor() == CURSOR_DEFAULT )
			{
                __isContMenuOpen = true;
                __contMenuCrId = 0;
                __contMenuItId = 0;
				
                CritterCl@ target = GetMonitorCritter( x, y );
                if( valid( target ) )
                {
                    __contMenuCrId = target.Id;
                    if( target.IsDead() )
					{
                        __pickType = 0;
                    }
					else
					{
                        __pickType = 1;
					}
					::ShowScreen( CLIENT_SCREEN_CONTMENU, x, y, 0 );
					return true;
				}
				
                ItemCl@ trItem = GetMonitorItem( x, y );
                if( valid( trItem ) )
                {
                    __contMenuItId = trItem.Id;
                    __itemHexX = trItem.HexX;
                    __itemHexY = trItem.HexY;
                    __itemPid = trItem.GetProtoId();
					::ShowScreen( CLIENT_SCREEN_CONTMENU, x, y, 0 );
					return true;
                }
            }
        }

        if( Index == CLIENT_SCREEN_CONTMENU && click > MOUSE_CLICK_LEFT )
        {
            IGUIElementOpt @ eDesc;
            int elemCount = Elements.length() - 1;
            int temp = 0;
            int count = this.LastElementNum;
            int countExt = 0;

            if( click == MOUSE_CLICK_WHEEL_UP )
            {
                temp = this.LastElementNum;
                if( !( this.LastElementNum == 1 ? Elements[ elemCount ].GetVisible() : Elements[ this.LastElementNum - 1 ].GetVisible() ) )
                {
                    do
                    {
                        if( countExt > 100 )
                        {
                            Message( "countExt end" );
                            break;
                        }
                        countExt++;
                        count == 1 ? count = elemCount : count--;
                    }
                    while( !( Elements[ count ].GetVisible() ) );
                    this.LastElementNum = count;
                }
                else
                {
                    this.LastElementNum > 1 ? this.LastElementNum -- : this.LastElementNum = elemCount;
                }

			}
			else if( click == MOUSE_CLICK_WHEEL_DOWN )
            {
                temp = this.LastElementNum;
                if( !( this.LastElementNum == elemCount ? Elements[ 1 ].GetVisible() : Elements[ this.LastElementNum + 1 ].GetVisible() ) )
                {
                    do
                    {
                        if( countExt > 100 )
                        {
                            Message( "countExt end" );
                            break;
                        }
                        countExt++;
                        count == elemCount ? count = 1 : count++;
                    }
                    while( !( Elements[ count ].GetVisible() ) );
                    this.LastElementNum = count;
                }
                else
                {
                    this.LastElementNum < elemCount ? this.LastElementNum++ : this.LastElementNum = 1;
                }
            }
			else if( click == MOUSE_CLICK_MIDDLE )
            {
                if( Elements[ this.LastElementNum ].GetVisible() )
                {
                    Elements[ this.LastElementNum ].Release();
                    __isContMenuOpen = false;
                    __HideCursor  = false;
                    return true;
                }
            }
			
            Elements[ 0 ].Text( "" + Elements[ this.LastElementNum ].GetDescription(), FONT_FALLOUT, COLOR_GREEN, COLOR_GREEN, FT_CENTERX | FT_CENTERY );
            Elements[ this.LastElementNum ].Switch( true );
            Elements[ temp ].Switch( false );
            return true;
        }

        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            Elements[ i ].IsFocused = false;
        }
		
		for( uint i = Elements.length(); i > 0; )
        {
            i--;
            GUIElement@ e = Elements[ i ];
            if( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, e.Surface.Width, e.Surface.Height ) && e.MouseDown( click ) )
            {
                e.IsFocused = true;
                return true;
            }
        }

        if( !IsHardcoded && click == MOUSE_CLICK_LEFT )
        {
            if( IS_COLLISION( x, y, PosX, PosY, Surface.Width, Surface.Height ) )
            {
                IsLMouseDown = true;
                LastX = x;
                LastY = y;    
				return true;
            }
            else if( IsCloseOnMiss )
            {
                ::HideScreen( 0, 0, 0, 0 );
                return true;
            }
        }
        return false;
    }
	
    bool MouseUp( int click, int x, int y )
    {
        if( IsHardcoded && Index == CLIENT_MAIN_SCREEN_GAME )
		{
			LMB_on = false;
			clearShiftGroup();
		
			CritterCl@ chosen = GetChosen();
			if( !valid( chosen ) )
			{
				return false; //TODO: Work even without chosen.
			}

			if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && GetCurrentCursor() == CURSOR_RTSA )
			{
				AssaultAttackTargets();
				ChangeCursor( CURSOR_RTS );
			}
			
			if( click == MOUSE_CLICK_RIGHT && __mouse2Pressed )
			{
				__mouse2Pressed = false;
				if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) )
				{
					bool run = KeyPressed[ DIK_LSHIFT ] || ( pkm_up_last_tick != 0 && GetTick() - pkm_up_last_tick <= 300 );
					uint16 hexX = 0, hexY = 0;
					GetMonitorHex (__MouseX, __MouseY, hexX, hexY );
					int cursorLast = GetLastCursor();
					if( !__mobhotkeys ) 
					{
						uint[] actions = { CHOSEN_MOVE, hexX, hexY, run ? 1 : 0, 0, 0, 0 };
						SetChosenActions( actions );
					}
					else
					{
						RunServerScriptUnsafe( "mobcontrol@unsafe_moveMob", hexX, hexY, run ? 1 : 0, null, control() );
					}
					cursorLast == CURSOR_WAIT ? ChangeCursor( CURSOR_DEFAULT ) : ChangeCursor( cursorLast );
					pkm_up_last_tick = GetTick();
					return true;
				}
			}
		}
		
        IsLMouseDown = false;
        bool result = false;
        for( uint i = Elements.length(); i > 0;)
        {
            i--;
            GUIElement@ e = Elements[ i ];
            if( IS_COLLISION( x, y, PosX + e.PosX, PosY + e.PosY, e.Surface.Width, e.Surface.Height ) )
            {
                e.MouseUp( click, true );
                result = true;
            }
            else
            {
                e.MouseUp( click, false );
            }
        }
        return result;
    }

    void MouseMove( int x, int y )
    {
		LMB_x2 = x;
		LMB_y2 = y;
		
        if( IsCanMove && IsLMouseDown )
        {
            int lastPosX = PosX;
            int lastPosY = PosY;
            int offsX = x - LastX;
            int offsY = y - LastY;
            LastX = x;
            LastY = y;
            PosX += offsX;
            PosY += offsY;

            // Check screen borders
            if( !IsIgnoreBorders )
            {
                int px = PosX;
                int py = PosY;
                if( PosX < 0 )
				{
                    PosX = 0;
                }
				
				if( PosY < 0 )
				{
                    PosY = 0;
                }
				
				if( PosX + Surface.Width > __ScreenWidth )
				{
                    PosX = __ScreenWidth - Surface.Width;
				}
				
				if( PosY + Surface.Height > __ScreenHeight )
				{
                    PosY = __ScreenHeight - Surface.Height;
                }
				LastX += PosX - px;
                LastY += PosY - py;
            }
            if( !( MoveCallback is null ) && ( lastPosX != PosX || lastPosY != PosY ) )
			{
				MoveCallback.OnMove( PosX, PosX );
			}
		}

        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            Elements[ i ].MouseMove( x, y );
            if( Index == CLIENT_SCREEN_CONTMENU && i != 0 )         // [0] is description element pm added
            {
                IGUIElementOpt @ e = Elements[ i ];

                if( IS_COLLISION( x, y, PosX + e.GetPosX(), PosY + e.GetPosY(), e.GetSurfaceWidth(), e.GetSurfaceHeight() ) )
                {
                    if( e.GetVisible() )
                    {
                        Elements[ 0 ].Text( "" + e.GetDescription(), FONT_FALLOUT, COLOR_GREEN, COLOR_GREEN, FT_CENTERX | FT_CENTERY );
                        e.Switch( true );
                        __elementActive = true;
                    }
                }
                else
                {
                    if( __elementActive )
                    {
                        // Elements[0].Text("",FONT_FALLOUT,COLOR_GREEN, COLOR_GREEN,FT_CENTERX|FT_CENTERY);
                        e.Switch( false );

                    }
                }
            }
        }
    }

    bool KeyPress( uint8 key )
    {
		CritterCl@ chosen = GetChosen();

		int screen_type = GUI_GetActiveScreen();

		if( screen_type == CLIENT_SCREEN_PICKUP )
		{
			if( !isGM( chosen ) )
			{
				return false;
			}
			
			if( GM_store_type != -1 && key == DIK_ESCAPE )
			{
				RunServerScriptUnsafe( "store@unsafe_StoreMenu", GM_store_type, 0, 0, null, null );
				GM_store_type = -1;
				
				return false;
			}			
		}

		if( screen_type == CLIENT_SCREEN_PICKUP || screen_type == CLIENT_SCREEN_INVENTORY )
		{
			if( KeyPressed[ DIK_LSHIFT ] && key == DIK_Q )
			{
				RunServerScriptUnsafe( "gm@unsafe_show_containments", 0, 0, 0, null, null );
				return false;
			}
		}
		
        //Show interface
		if( key == DIK_F4 )
        {
			__f4Pressed = !__f4Pressed;
			return false;
        }
		
		if( key == DIK_F6 ) //Show NPC names
		{
			__ShowNpcNames = ( __ShowNpcNames ? false : true );
			RunServerScriptUnsafe( "gm@unsafe_sinf", 0, 0, 0, null, null );
			return false;
		}
		
		if( key == DIK_F7 )
        {
			RunServerScriptUnsafe( "player_menu@unsafe_SwapItemVisor", 0, 0, 0, null, null );
			return false;
        }

		if( !__ConsoleActive )
		{
			if( !KeyPressed[ DIK_LSHIFT ] )
				clearShiftGroup();

			if( KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ] )
			{
				if( key == DIK_MINUS || key == DIK_SUBTRACT )
				{
					IncrementMusicVolume( -1 );
					return false;
				}
				else
				if( key == DIK_EQUALS || key == DIK_ADD )
				{
					IncrementMusicVolume( 1 );
					return false;
				}
			}
			else if( KeyPressed[ DIK_LCONTROL ] || KeyPressed[ DIK_RCONTROL ] )
			{
				if( key == DIK_MINUS || key == DIK_SUBTRACT )
				{
					IncrementSoundsVolume( -1 );
					return false;
				}
				else if( key == DIK_EQUALS || key == DIK_ADD )
				{
					IncrementSoundsVolume( 1 );
					return false;
				}
			}
		}	
		
        if( Index == CLIENT_MAIN_SCREEN_GAME || Index == CLIENT_MAIN_SCREEN_GLOBAL_MAP )
        {
			if( controlpanel.KeyPress( key ) )
			{
				return true;
			}

			if( key == DIK_W && !__ConsoleActive 
				 && !KeyPressed[ DIK_LMENU ] && !KeyPressed[ DIK_RMENU ] 
				 && !KeyPressed[ DIK_RCONTROL ] && !KeyPressed[ DIK_LCONTROL ] 
				 && !KeyPressed[ DIK_LSHIFT ] && !KeyPressed[ DIK_RSHIFT ] )
			{
				RunServerScriptUnsafe( "general_unsafe@unsafe_ToggleWeaponRadius", 0, 0, 0, null, null );
			}
			
			//GM stelth.
			if( key == DIK_GRAVE && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] )
			{
				RunServerScriptUnsafe( "main@unsafe_swap_invis", 0, 0, 0, null, null );
				return true;
			}

			// Door autouse.
			if( key == DIK_E && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] )
			{
				RunServerScriptUnsafe( "general_unsafe@unsafe_OpenDoor", 0, 0, 0, "", null );
				return true;
			}
			
			// Autoaim
			if( !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LMENU ] )
			{
				int[][] keybinds =
				{
					{ DIK_NUMPAD0, HIT_LOCATION_NONE },
					{ DIK_NUMPAD9, HIT_LOCATION_NONE },
					{ DIK_NUMPAD7, HIT_LOCATION_EYES },
					{ DIK_NUMPAD8, HIT_LOCATION_HEAD },
					{ DIK_NUMPAD4, HIT_LOCATION_LEFT_ARM },
					{ DIK_NUMPAD5, HIT_LOCATION_TORSO },
					{ DIK_NUMPAD6, HIT_LOCATION_RIGHT_ARM },
					{ DIK_NUMPAD1, HIT_LOCATION_LEFT_LEG },
					{ DIK_NUMPAD2, HIT_LOCATION_GROIN },
					{ DIK_NUMPAD3, HIT_LOCATION_RIGHT_LEG }
				};
				
				for( uint i = 0; i < keybinds.length(); i++ )
				{
					if( keybinds[i][0] == int( key ) ) 
					{
						RunServerScriptUnsafe( "main@unsafe_set_aim", keybinds[i][1], 0, 0, null, null );
						return false;
					}
				}
			}
			
			//Hotkey animations.
			if( !__ConsoleActive && !KeyPressed[ DIK_LMENU ] && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LSHIFT ] )
			{
				int[][] keybinds =
				{
					{ DIK_L, ACTION_DAMAGE, 1 },
					{ DIK_K, ACTION_DAMAGE, 2 },
					{ DIK_U, ACTION_PICK_ITEM, 0 },
					{ DIK_Y, ACTION_DODGE },
					{ DIK_V, ACTION_FIDGET },
					{ DIK_X, ACTION_WINDUP }
				};
				
				uint len = keybinds.length();
				for( uint i = 0; i < len; i++ )
				{
					if( keybinds[i][0] == int( key ) ) 
					{
						CritterCl@ cr = GetMonitorCritter( __MouseX, __MouseY );
						RunServerScriptUnsafe( "general_unsafe@unsafe_animation", keybinds[i][1], ( keybinds[i].length() > 2 ? keybinds[i][2] : 0 ), valid( cr ) ? cr.Id : 0, null, null );
						return true;
					}
				}
			}
			
			//knock.
            if( key == DIK_H && GetCurrentCursor() == CURSOR_DEFAULT && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] )
            {
                CritterCl@ cr = GetMonitorCritter( __MouseX, __MouseY );
				
				if( @cr != null )
				{
					RunServerScriptUnsafe( "gameplay@unsafe_DragAndDrop", cr.Id, 0, 0, null, null );
				}
				
				ChangeCursor( CURSOR_DEFAULT );
                return true;
            }
			
			//Item throw.
            if( key == DIK_J && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LSHIFT ] )
			{
				uint16 hexX = 0, hexY = 0;
            	GetMonitorHex( __MouseX, __MouseY, hexX, hexY);
				if( valid( chosen ) && !chosen.IsBusy() )
				{
					RunServerScriptUnsafe ( "general_unsafe@unsafe_itemthrow", hexX, hexY, 0, null, null );
				}
				
				return true;
            }
			
			//Reload
            if( key == DIK_R && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LSHIFT ] && !KeyPressed[ DIK_LMENU ] )
			{
				if( valid( chosen ) && !chosen.IsBusy() )
				{
					ItemCl@ weapon = chosen.GetItem( 0, SLOT_HAND1 );
					if( valid( weapon ) )
					{
						if( chosen.CountItem( weapon.AmmoPid ) > 0 )
						{
							uint[] actions = { CHOSEN_USE_ITEM, weapon.Id, weapon.GetProtoId(), TARGET_SELF_ITEM, chosen.Id, ITEM_MODE_RELOAD, 0  };
							SetChosenActions( actions );
						}
						else
						{
							RunServerScriptUnsafe( "reload@unsafe_CheckAmmo", weapon.Id, 0, 0, null, null );
						}
					}
				}
				return true;	
			}				

			//Use on hotkey
            if( key == DIK_A && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LSHIFT ] && valid( chosen ) )
			{
				if( valid( chosen ) && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
				{
					GetCurrentCursor() == CURSOR_RTS ? ChangeCursor( CURSOR_RTSA ) : ChangeCursor( CURSOR_RTS );
					return true;
				}
				
				uint8 mode = 0;				
				ProtoItem@ hand = chosen.GetSlotProto( SLOT_HAND1, mode );
				if( GetCurrentCursor() == CURSOR_USE_WEAPON || GetCurrentCursor() == CURSOR_USE_OBJECT )
				{
					if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && !__mobhotkeys )
					{
						ChangeCursor( CURSOR_DEFAULT );
					}
					else
					{
						ChangeCursor( GetLastCursor() );
					}
					return true;
				}
				else if( mode == 4 )
				{
					ChangeCursor( CURSOR_USE_OBJECT );
				}
				else if( valid( hand ) && hand.Type == ITEM_TYPE_WEAPON )
				{
					ChangeCursor( CURSOR_USE_WEAPON );
				}

				return true;
            }

			//Go to cover
			if( key == DIK_SPACE && !__ConsoleActive && !KeyPressed[ DIK_LCONTROL ] && !KeyPressed[ DIK_LSHIFT ] && valid( chosen ) )
			{
				if( !__waiting )
				{
					if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
					{
						RunServerScriptUnsafe( "mobcontrol@unsafe_relaxNPC", 0, 0, 0, null, control() );
					}
					else
					{
						RunServerScriptUnsafe( "general_unsafe@unsafe_relax", chosen.Param[ CR_IS_RELAXING ] == 0 ? 5 : 0, 0, 0, null, null );
					}
					return true;
				}
			}

			//alt + hotkey
			if( KeyPressed[ DIK_LMENU ] || KeyPressed[ DIK_RMENU ] )
			{
				if( key == DIK_Z )
				{
					RunServerScriptUnsafe( "player_menu@unsafe_toggle_WSAD", 0, 0, 0, null, null );
					return true;
				}
				
				if( key == DIK_X )
				{
					RunServerScriptUnsafe( "player_menu@unsafe_toggle_RTS", 0, 0, 0, null, null );
					if( isGM( chosen ) )
					{
						if( !FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys )
						{
							ChangeCursor( CURSOR_RTS );
						}
						else
						{
							ChangeCursor( CURSOR_DEFAULT );
						}
					}
					return true;
				}
				
				if( key == DIK_F && KeyPressed[ DIK_LSHIFT ] )
				{
					RunServerScriptUnsafe( "gm@unsafe_GMSwitch", 0, 0, 0, null, null );
					return true;
				}
				
				if( key == DIK_S )
				{
					uint[] actions = { CHOSEN_NONE, 0, 0, 0, 0, 0, 0 };
					SetChosenActions( actions );
					return true;
				}
				
				CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
				uint targetId = @target !is null ? target.Id : 0;

				switch( key )
				{
					case( DIK_B ):
						RunServerScriptUnsafe( "test@unsafe_getCost",  0, 0, 0, null, null );
						return true;
					case( DIK_C ):
						RunServerScriptUnsafe( "general_unsafe@unsafe_pushing", 0, 0, 0, null, null );
						return true;
					case( DIK_R ):									//Ammo change
					{
						if( valid( chosen ) && !chosen.IsBusy() )
						{
							ItemCl@ weapon = chosen.GetItem( 0, SLOT_HAND1 );
							if( valid( weapon ) )
							{
								RunServerScriptUnsafe( "reload@unsafe_CheckAmmo", weapon.Id, 1, 0, null, null );
							}
						}
						return true;
					}
					case( DIK_ADD ):
						RunServerScriptUnsafe( "general_unsafe@unsafe_VoiceVolumeAdjust", -5, 0, 0, null, null );
						return true;
					case( DIK_SUBTRACT ):
						RunServerScriptUnsafe( "general_unsafe@unsafe_VoiceVolumeAdjust", 5, 0, 0, null, null );
						return true;
					case( DIK_MULTIPLY ):
						RunServerScriptUnsafe( "general_unsafe@unsafe_ToggleVoiceRadius", 0, 0, 0, null, null );
						return true;
					case( DIK_M ):
						RunServerScriptUnsafe( "player_menu@unsafe_StartPlayerMenu", 0, 0, 0, null, null );
						return true;
					case( DIK_N ):
						RunServerScriptUnsafe( "player_menu@unsafe_StartAnimMenu", 0, 0, 0, null, null );
						return true;
				}
			}

			//ctrl + hotkey
			if( KeyPressed[ DIK_LCONTROL ] || KeyPressed[ DIK_RCONTROL ] )
			{
				//Enable hotkeys for client.
				switch( key )
				{
					case( DIK_F ):
					{
						if( isGM( chosen ) )
						{
							__mobhotkeys = !__mobhotkeys;
							Message( TEXTMSG_TEXT, ( __mobhotkeys ? STR_GM_HOTKEY_MODE_ON : STR_GM_HOTKEY_MODE_OFF ) );
							if( __mobhotkeys && FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) )
							{
								ChangeCursor( CURSOR_RTS );
							}
							else
							{
								ChangeCursor( CURSOR_DEFAULT );
							}
						}
						return true;
					}
					case( DIK_R ): //Ammo change
					{
						if( valid( chosen ) && !chosen.IsBusy() )
						{
							ItemCl@ weapon = chosen.GetItem( 0, SLOT_HAND1 );
							if( valid( weapon ) )
							{
								RunServerScriptUnsafe( "reload@unsafe_CheckAmmo", weapon.Id, 1, 0, null, null );
							}
						}
						return true;
					}
				}
			}

			//GM hotkeys:
			if( !__ConsoleActive && ( __mobhotkeys || __usermobhotkeys ) )
			{
				uint16 hexX = 0, hexY = 0;
				GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
				CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
				uint targetId = @target !is null ? target.Id : 0;
				ItemCl@ targetItem = GetMonitorItem( __MouseX, __MouseY );
				uint targetItemId = @targetItem !is null ? targetItem.Id : 0;
				
				bool processed = false;
				
				//GM shift hotkeys
				if( KeyPressed[ DIK_LSHIFT ] )
				{
					processed = true;
					switch( key )
					{
						case(DIK_Q):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_INV, null, null );
							break;
						case(DIK_I):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_HAND1, null, null );
							break;
						case(DIK_O):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_HAND2, null, null );
							break;
						case(DIK_P):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_ARMOR, null, null );
							break;
						case(DIK_J):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_HEAD, null, null );
							break;
						case(DIK_K):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_BACK, null, null );
							break;
						case(DIK_L):
							RunServerScriptUnsafe( "gm@unsafe_show_containments", targetId, targetItemId, SLOT_MISC, null, null );
							break;
						default:
							processed = false;
							break;
					}
				}
				
				//GM ctrl hotkeys
				if( KeyPressed[ DIK_LCONTROL ] )
				{
					processed = true;
					switch( key )
					{
						case( DIK_T ):
							RunServerScriptUnsafe( "gm_commands@unsafe_GM_tel", valid( chosen ) ? chosen.Id : 0, hexX, hexY, null, null );
							break;
						case( DIK_N ):
							RunServerScriptUnsafe( "gm@unsafe_GM_teleport_to_next_player",  0, 0, 0, null, null );
							break;
						case( DIK_G ):
							RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_SELF", 0, 0, 0, null, null );
							break;
						case( DIK_S ):
							RunServerScriptUnsafe( "rp_chat@unsafe_SetChatTarget",  targetId, 0, 0, null, null );
							break;
						case( DIK_D ):
							RunServerScriptUnsafe( "gm@unsafe_GM_voice", hexX, hexY, 0, null, null );
							break;
						case( DIK_Y ):
							RunServerScriptUnsafe( "gm@unsafe_GM_say",  targetId, SAY_NETMSG, 0, null, null );
							break;
						case( DIK_C ):
						{
							if( @target !is null )
							{
								SetControlCritters( targetId );
							}
							break;
						}
						case( DIK_H ):
							RunServerScriptUnsafe( "mobcontrol@unsafe_HomeMob", 0, 0, 0, null, control() );
							break;
						case( DIK_M ):
							RunServerScriptUnsafe( "test@unsafe_weapon_update", 0, 0, 0, null, control() );
							break;
						case( DIK_J ):
							RunServerScriptUnsafe( "test@unsafe_weapon_show", 0, 0, 0, null, control() );
							break;
						case( DIK_K ):
							RunServerScriptUnsafe( "test@unsafe_weapon_hide", 0, 0, 0, null, control() );
							break;
						case( DIK_L ):
							RunServerScriptUnsafe( "test@unsafe_armor_update", 0, 0, 0, null, control() );
							break;
						case( DIK_E ):
							RunServerScriptUnsafe( "mobcontrol@unsafe_MobHoldPosition", hexX, hexY, 0, null, control() );
							break;
						case( DIK_X ):
							RunServerScriptUnsafe( "mobcontrol@unsafe_stopMob", hexX, hexY, 0, null, control() );
							break;
						case( DIK_W ):
							RunServerScriptUnsafe( "mobcontrol@unsafe_moveMob", hexX, hexY, 0, null, control() );
							break;
						case( DIK_A ): //Attack target or run on hex
						{
							if( !valid( target ) )
							{
								RunServerScriptUnsafe( "mobcontrol@unsafe_moveMob", hexX, hexY, 1, null, control() );
							}
							else
							{
								RunServerScriptUnsafe( "mobcontrol@unsafe_attackMob", target.Id, 0, 0, null, control() );
							}
							break;
						}
						case( DIK_Q ): //Cleans selection
						{
							@controlpanel.current = controlpanel.selection;
							controlpanel.selection.clear(); 
							break;
						}						
						case( DIK_B ):
						{
							if( @target !is null )
							{
								RunServerScriptUnsafe( "general_unsafe@unsafe_MobGoHome", targetId, 0, 0, "", null );
							}
							break;
						}
						case( DIK_Z ):
						{
							RunServerScriptUnsafe( "mobcontrol@unsafe_useBandage", 0, 0, 0, "", control() );
							break;
						}
						case( DIK_V ):
						{
							RunServerScriptUnsafe( "mobcontrol@unsafe_useMeds", 0, 0, 0, "", control() );
							break;
						}
						default: processed = false; break;
					}
				}
				if( processed )
				{
					return true;
				}
			}
		}
        else if( Index == CLIENT_SCREEN_INPUTBOX )
        {
            uint8 char = 0;
            uint8 charIndex = 0;

            if( ( KeyPressed[ DIK_LCONTROL ] || KeyPressed[ DIK_RCONTROL ] ) && key == DIK_V )
            {
                InputBoxClipboardInsert();
                return false;
            }

            uint8[] disabledKeys = { DIK_BACK, DIK_LEFT, DIK_RIGHT };
            if( disabledKeys.find( key ) == -1 )
            {
                if( GetKeybLang() > 0 )
				{
                    charIndex = 2;
                }
				if( KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ] )
				{                
					charIndex++;
                }
				char = KbData[ key ].Char[ charIndex ];
            }
			
            if( ( key != DIK_ESCAPE || key == DIK_RETURN ) && !__ConsoleActive )
            {
                InputBoxKeyPressed( key, char );
                return true;
            }
        }
		
        if( ( __IsHotkeysUse ) )
        {
            if( ( Index == CLIENT_SCREEN_PIP_BOY ) && ( key == DIK_P ) )
			{
                return false;
            }
			uint8 mainScr = 0;
            for( uint i = 0; i < ActiveScreens.length(); i++ )
            {
                if( ( ActiveScreens[ i ].Index == CLIENT_MAIN_SCREEN_GAME ) || ( ActiveScreens[ i ].Index == CLIENT_MAIN_SCREEN_GLOBAL_MAP ) )
                {
                    mainScr = ActiveScreens[ i ].Index;
                    break;
                }
            }
		}
		
        for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            GUIElement@ e = Elements[ i ];
            if( valid(e) && e.IsFocused && e.IsTextInput )
			{
                return e.KeyPress( key );
			}
        }
		
        return false;
    }

    void InputLost()
    {
        IsLMouseDown = false;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{ 
           Elements[ i ].InputLost();
		}
    }

	bool IsCollision( int x, int y )
	{
		for( uint i = 0, j = Elements.length(); i < j; i++ )
        {
            Elements[ i ].MouseMove( x, y );
            if( Index == CLIENT_SCREEN_CONTMENU && i != 0 )         // [0] is description element pm added
            {
                IGUIElementOpt @ e = Elements[ i ];

                if( IS_COLLISION( x, y, PosX + e.GetPosX(), PosY + e.GetPosY(), e.GetSurfaceWidth(), e.GetSurfaceHeight() ) )
					return false;
			}
		}
		return IS_COLLISION( x, y, PosX, PosY, GetSurfaceWidth(), GetSurfaceHeight() );
	}

    GUIScreen@ GetNewInstance()
    {
		IGUIInstanceContext@ context = null;
		if( valid( ContextFactory ) )
		{
			@context = ContextFactory();
		}
		
        GUIScreen               screen = this;
        IGUIScreenCallbackShow@ newCallback = ShowCallback;
        for( uint i = 0, j = Elements.length(); i < j; i++ )
		{
            @screen.Elements[ i ] = Elements[ i ].GetNewInstance( context );
		}
		
		if( valid( InstanceInitCallback ) )
		{
			InstanceInitCallback( context, screen );
		}
		
        return @screen;
    }

    IGUIScreenOpt@ Pic( string@ sprName, int path )
    {
        if( @sprName != null )
		{
            Surface.Load( sprName, path );
		} 
		else
		{
            Surface.Id = 0;
		}

        if( Surface.Id != 0 && Surface.Width == 0 && Surface.Height == 0 )
        {
            Surface.Width = Surface.Width;
            Surface.Height = Surface.Height;
        }
        return this;
    }

    IGUIScreenOpt@ CallbackShow( IGUIScreenCallbackShow@ callback )
    {
        @ShowCallback = callback;
        return this;
    }
    IGUIScreenOpt@ CallbackHide( IGUIScreenCallbackHide@ callback )
    {
        @HideCallback = callback;
        return this;
    }
    IGUIScreenOpt@ CallbackMove( IGUIScreenCallbackMove@ callback )
    {
        @MoveCallback = callback;
        return this;
    }
	IGUIScreenOpt@ CallbackInstanceInit( IGUIScreenInstanceInitFunc@ callback )
	{
		@InstanceInitCallback = callback;
		return this;
	}	
    IGUIScreenOpt@ CallbackContextFactory( IGUIInstanceContextFactoryFunc@ factory )
	{
		@ContextFactory = factory;
		return this;
	}	
    IGUIScreenOpt@ Position( int x, int y )
    {
        PosX = x;
        PosY = y;
        return this;
    }
    IGUIScreenOpt@ CanMove( bool enabled )
    {
        IsCanMove = enabled;
        return this;
    }
    IGUIScreenOpt@ Modal( bool enabled )
    {
        IsModal = enabled;
        return this;
    }
    IGUIScreenOpt@ Multiinstance( bool enabled )
    {
        IsMultiinstance = enabled;
        return this;
    }
    IGUIScreenOpt@ IgnoreBorders( bool enabled )
    {
        IsIgnoreBorders = enabled;
        return this;
    }
    IGUIScreenOpt@ CloseOnMiss( bool enabled )
    {
        IsCloseOnMiss = enabled;
        return this;
    }
    IGUIScreenOpt@ AutoCursor( bool enabled, int cursorType )
    {
        IsAutoCursor = enabled;
        AutoCursorType = cursorType;
        return this;
    }

    IGUIScreenOpt@ SetElementCount( int8 ElementCount )
    {
        LastElementNum = ElementCount;
        return this;
    }

    // Info
    int GetPosX()
	{
		return PosX;
	}
	
    int GetPosY()
	{
		return PosY;
	}

    uint8 GetLastElement()
	{
		return LastElementNum;
	}
	
    uint16 GetElementsLength()
	{
		return Elements.length();
	}
	
    IGUIElementOpt@ GetElement( uint16 index )
	{
		return Elements[ index ];
	}

    int GetSurfaceHeight() { return Surface.Height; }
    int GetSurfaceWidth()  { return Surface.Width; }

    int8 LastElementNum;

    int Index;
    int PosX;
    int PosY;
    int LastX;
    int LastY;
    Sprite Surface;

    bool IsCanMove;
    bool IsModal;
    bool IsMultiinstance;
    bool IsIgnoreBorders;
    bool IsCloseOnMiss;
    bool IsAutoCursor;

    int AutoCursorType;
    int AutoCursorPrev;

    bool IsHardcoded;
    bool IsLMouseDown;
    IGUIScreenCallbackShow@          ShowCallback;
    IGUIScreenCallbackHide@          HideCallback;
    IGUIScreenCallbackMove@          MoveCallback;
	IGUIScreenInstanceInitFunc@      InstanceInitCallback;
	IGUIInstanceContextFactoryFunc@  ContextFactory;
	
    GUIElement@[]                    Elements;
}

//
// API
//

// Create new screen
IGUIScreenOpt@ GUI_CreateScreen( int screenIndex, string@ sprName )
{
    if( screenIndex == 0 )
	{
        return null;
    }
	DeleteScreen( screenIndex );
    return CreateScreen( screenIndex, sprName );
}

// Create new screen ini
IGUIScreenOpt@ GUI_CreateScreenIni( int screenIndex, string@ iniKey )
{
	return GUI_CreateScreen( screenIndex, GetIfaceIniStr( iniKey + "MainPic" ) ).Position( GetIniValue( iniKey + "MainX", 0 ), GetIniValue( iniKey + "MainY", 0 ) );
}

// @pm menu
void GUI_DeleteScreenElements( int screenIndex ) // pm add
{
    if( screenIndex == 0 )
        return;
    GUIScreen@ screen = GetScreen( screenIndex );
    // for(uint16 i = 0; i < screen.Elements.length(); i
    screen.Elements.resize( 0 );
}
// #pm menu

// Delete old screen, hardcoded screens included
void GUI_DeleteScreen( int screenIndex )
{
    if( screenIndex == 0 )
        return;
    DeleteScreen( screenIndex );
}

// Add element on screen
IGUIElementOpt@ GUI_AddScreenElement( int screenIndex, string@ sprName, int x, int y )
{
    if( screenIndex == 0 )
        return null;
    if( GetScreen( screenIndex ) is null )
        CreateScreen( screenIndex, null );

    GUIScreen@ screen = GetScreen( screenIndex );
    GUIElement element( sprName, PT_ART_INTRFACE );
    element.Position( x, y );

    screen.Elements.insertLast( @element );
    return @element;
}

int GetIniValue( string@ iniKey, int dflt )
{
    string@ str = GetIfaceIniStr( iniKey );
	
    if( @str is null || str == "" )
	{
        return dflt;
    }
	
	int res = dflt;
	
    if( !StrToInt( str, res ) )
	{
        return dflt;
    }
	
	return res;
}

IGUIElementOpt@ GUI_AddScreenElementIni( int screenIndex, string@ ini, int defx, int defy )
{
	return GUI_AddScreenElement( screenIndex, GetIfaceIniStr( ini ), GetIniValue( ini + "X", defx ), GetIniValue( ini + "Y", defy ) );
}

IGUIElementOpt@ GUI_AddScreenElementIni( int screenIndex, string@ ini, int defx, int defy, string@ defSpr )
{
	string@ spr = GetIfaceIniStr( ini );
	if( @spr is null || spr == "" )
		@spr = defSpr;
	return GUI_AddScreenElement( screenIndex, spr, GetIniValue( ini + "X", defx ), GetIniValue( ini + "Y", defy ) );
}

// Screen options
IGUIScreenOpt@ GUI_GetScreenOptions( int screenIndex )
{
    return GetScreen( screenIndex );
}

// Valid only on IGUIScreenCallbackShow::OnShow callback
IGUIScreenOpt@ GUI_GetScreenOptions()
{
    return LastScreenOpt;
}

// Valid only on IGUIElementCallbackInit::OnInit callback
IGUIElementOpt@ GUI_GetElementOptions()
{
    return LastElementOpt;
}

//
// Engine callbacks
//

void GUI_Init()
{
	initControlPanel();
    AllScreens.resize( 0 );
    ActiveScreens.resize( 0 );
    KeyPressed.resize( 0x100 );
    for( uint i = 0, j = KeyPressed.length(); i < j; i++ )
	{
        KeyPressed[ i ] = false;
	}
	
	MousePressed.resize( MOUSE_CLICK_EXT4 + 1 );
	MousePressTick.resize( MOUSE_CLICK_EXT4 + 1 );
	for( int i = 0, j = MousePressed.length(); i < j; i ++ )
	{
		MousePressed[i] = false;
		MousePressTick[i] = 0;
	}
	
    // Register hardcoded screens
    CreateScreen( CLIENT_MAIN_SCREEN_LOGIN, null );
    CreateScreen( CLIENT_MAIN_SCREEN_REGISTRATION, null );
    CreateScreen( CLIENT_MAIN_SCREEN_OPTIONS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_CREDITS, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GAME, null );
    CreateScreen( CLIENT_MAIN_SCREEN_GLOBAL_MAP, null );
    CreateScreen( CLIENT_MAIN_SCREEN_WAIT, null );
    CreateScreen( CLIENT_SCREEN_INVENTORY, null );
    CreateScreen( CLIENT_SCREEN_PICKUP, null );
    CreateScreen( CLIENT_SCREEN_MINIMAP, null );
    CreateScreen( CLIENT_SCREEN_CHARACTER, null );
    CreateScreen( CLIENT_SCREEN_DIALOG, null );
    CreateScreen( CLIENT_SCREEN_BARTER, null );
    CreateScreen( CLIENT_SCREEN_PIP_BOY, null );
    CreateScreen( CLIENT_SCREEN_FIX_BOY, null );
    CreateScreen( CLIENT_SCREEN_MENU, null );
    CreateScreen( CLIENT_SCREEN_AIM, null );
    CreateScreen( CLIENT_SCREEN_TEST, null );
    CreateScreen( CLIENT_SCREEN_SPLIT, null );
    CreateScreen( CLIENT_SCREEN_TIMER, null );
    CreateScreen( CLIENT_SCREEN_DIALOGBOX, null );
    CreateScreen( CLIENT_SCREEN_ELEVATOR, null );
    CreateScreen( CLIENT_SCREEN_SAY, null );
    CreateScreen( CLIENT_SCREEN_CHA_NAME, null );
    CreateScreen( CLIENT_SCREEN_CHA_AGE, null );
    CreateScreen( CLIENT_SCREEN_CHA_SEX, null );
    CreateScreen( CLIENT_SCREEN_GM_TOWN, null );
    CreateScreen( CLIENT_SCREEN_INPUT_BOX, null );
    CreateScreen( CLIENT_SCREEN_SKILLBOX, null );
    CreateScreen( CLIENT_SCREEN_USE, null );
    CreateScreen( CLIENT_SCREEN_PERK, null );
    CreateScreen( CLIENT_SCREEN_TOWN_VIEW, null );
    CreateScreen( CLIENT_SCREEN_SAVE_LOAD, null );
    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
	{
        AllScreens[ i ].IsHardcoded = true;
	}
	
    // Keyboard init
    KbData.resize( 0x100 );
    @KbData[ DIK_1 ] =						KeybData( '1', '!', '1', '!' );
    @KbData[ DIK_2 ] =						KeybData( '2', '"', '2', '@' );
    @KbData[ DIK_3 ] =						KeybData( '3', '', '3', '#' );
    @KbData[ DIK_4 ] =						KeybData( '4', ';', '4', '$' );
    @KbData[ DIK_5 ] =						KeybData( '5', '%', '5', '%' );
    @KbData[ DIK_6 ] =						KeybData( '6', ':', '6', '^' );
    @KbData[ DIK_7 ] =						KeybData( '7', '?', '7', '&' );
    @KbData[ DIK_8 ] =						KeybData( '8', '*', '8', '*' );
    @KbData[ DIK_9 ] =						KeybData( '9', '(', '9', '(' );
    @KbData[ DIK_0 ] =						KeybData( '0', ')', '0', ')' );
    @KbData[ DIK_MINUS ] =					KeybData( '-', '_', '-', '_' );
    @KbData[ DIK_EQUALS ] =					KeybData( '=', '+', '=', '+' );
    @KbData[ DIK_Q ] =						KeybData( '', '', 'q', 'Q' );
    @KbData[ DIK_W ] =						KeybData( '', '', 'w', 'W' );
    @KbData[ DIK_E ] =						KeybData( '', '', 'e', 'E' );
    @KbData[ DIK_R ] =						KeybData( '', '', 'r', 'R' );
    @KbData[ DIK_T ] =						KeybData( '', '', 't', 'T' );
    @KbData[ DIK_Y ] =						KeybData( '', '', 'y', 'Y' );
    @KbData[ DIK_U ] =						KeybData( '', '', 'u', 'U' );
    @KbData[ DIK_I ] =						KeybData( '', '', 'i', 'I' );
    @KbData[ DIK_O ] =						KeybData( '', '', 'o', 'O' );
    @KbData[ DIK_P ] =						KeybData( '', '', 'p', 'P' );
    @KbData[ DIK_LBRACKET ] =				KeybData( '', '', '[', '{' );
    @KbData[ DIK_RBRACKET ] =				KeybData( '', '', ']', '}' );
    @KbData[ DIK_A ] =						KeybData( '', '', 'a', 'A' );
    @KbData[ DIK_S ] =						KeybData( '', '', 's', 'S' );
    @KbData[ DIK_D ] =						KeybData( '', '', 'd', 'D' );
    @KbData[ DIK_F ] =						KeybData( '', '', 'f', 'F' );
    @KbData[ DIK_G ] =						KeybData( '', '', 'g', 'G' );
    @KbData[ DIK_H ] =						KeybData( '', '', 'h', 'H' );
    @KbData[ DIK_J ] =						KeybData( '', '', 'j', 'J' );
    @KbData[ DIK_K ] =						KeybData( '', '', 'k', 'K' );
    @KbData[ DIK_L ] =						KeybData( '', '', 'l', 'L' );
    @KbData[ DIK_SEMICOLON ] =				KeybData( '', '', ';', ':' );
    @KbData[ DIK_APOSTROPHE ] =				KeybData( '', '', 39, 39 );
    @KbData[ DIK_Z ] =						KeybData( '', '', 'z', 'Z' );
    @KbData[ DIK_X ] =						KeybData( '', '', 'x', 'X' );
    @KbData[ DIK_C ] =						KeybData( '', '', 'c', 'C' );
    @KbData[ DIK_V ] =						KeybData( '', '', 'v', 'V' );
    @KbData[ DIK_B ] =						KeybData( '', '', 'b', 'B' );
    @KbData[ DIK_N ] =						KeybData( '', '', 'n', 'N' );
    @KbData[ DIK_M ] =						KeybData( '', '', 'm', 'M' );
    @KbData[ DIK_COMMA ] =					KeybData( '', '', ',', '<' );
    @KbData[ DIK_PERIOD ] =					KeybData( '', '', '.', '>' );
    @KbData[ DIK_SLASH ] =					KeybData( '.', ',', '/', '?' );
    @KbData[ DIK_MULTIPLY ] =				KeybData( '*', '*', '*', '*' );
    @KbData[ DIK_SPACE ] =					KeybData( ' ', ' ', ' ', ' ' );
    @KbData[ DIK_GRAVE ] =					KeybData( '', '', '`', '~' );
    @KbData[ DIK_NUMPAD1 ] =				KeybData( '1', '1', '1', '1' );
    @KbData[ DIK_NUMPAD2 ] =				KeybData( '2', '2', '2', '2' );
    @KbData[ DIK_NUMPAD3 ] =				KeybData( '3', '3', '3', '3' );
    @KbData[ DIK_NUMPAD4 ] =				KeybData( '4', '4', '4', '4' );
    @KbData[ DIK_NUMPAD5 ] =				KeybData( '5', '5', '5', '5' );
    @KbData[ DIK_NUMPAD6 ] =				KeybData( '6', '6', '6', '6' );
    @KbData[ DIK_NUMPAD7 ] =				KeybData( '7', '7', '7', '7' );
    @KbData[ DIK_NUMPAD8 ] =				KeybData( '8', '8', '8', '8' );
    @KbData[ DIK_NUMPAD9 ] =				KeybData( '9', '9', '9', '9' );
    @KbData[ DIK_NUMPAD0 ] =				KeybData( '0', '0', '0', '0' );
    @KbData[ DIK_SUBTRACT ] =				KeybData( '-', '-', '-', '-' );
    @KbData[ DIK_ADD ] =					KeybData( '+', '+', '+', '+' );
    @KbData[ DIK_DECIMAL ] =				KeybData( '.', '.', '.', '.' );
    @KbData[ DIK_DIVIDE ] =					KeybData( '/', '/', '/', '/' );
    @KbData[ DIK_RETURN ] =					KeybData( '\n', '\n', '\n', '\n' );
    @KbData[ DIK_NUMPADENTER ] =			KeybData( '\n', '\n', '\n', '\n' );
    @KbData[ DIK_TAB ] =					KeybData( '\t', '\t', '\t', '\t' );
	
	RunAllFunctions( "GUIInit" );
}

int GUI_GetActiveMainScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.first().Index : CLIENT_SCREEN_NONE;
}

int GUI_GetActiveScreen()
{
    return ActiveScreens.length() > 0 ? ActiveScreens.last().Index : CLIENT_SCREEN_NONE;
}

void GUI_GetActiveScreens( int[]& result )
{
    result.resize( ActiveScreens.length() );
    for( uint i = 0, j = result.length(); i < j; i++ )
	{
        result[ i ] = ActiveScreens[ i ].Index;
	}
}

void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 )
{
    GUIScreen@ screen = GetScreen( screenIndex );
    if( valid(screen) )
    {
        if( !screen.IsMultiinstance )
        {
            // Close all another instances
            for( uint i = ActiveScreens.length(); i > 0;)       // From end
            {
                i--;
                if( ActiveScreens[ i ].Index == screenIndex )
                {
                    ActiveScreens.removeAt( i );
                    if( !( screen.HideCallback is null ) )
					{
                        screen.HideCallback.OnHide( p0, p1, p2 );
					}
				}
            }
        }

        // Create new instance
        @screen = screen.GetNewInstance();
        ActiveScreens.insertLast( @screen );

        // Set screen cursor
        if( screen.IsAutoCursor )
        {
            screen.AutoCursorPrev = ::GetCurrentCursor();
            ::ChangeCursor( screen.AutoCursorType );
        }

        // Call init callbacks
        @LastScreenOpt = screen;
        // First init elements
        for( uint i = 0, j = screen.Elements.length(); i < j; i++ )
        {
            GUIElement@ e = screen.Elements[ i ];
            if( !( e.InitCallback is null ) )
            {
                @LastElementOpt = e;
                e.InitCallback.OnInit();
                @LastElementOpt = null;
            }
        }
        // Then show
        if( !( screen.ShowCallback is null ) )
        {
            screen.ShowCallback.OnShow( p0, p1, p2 );
        }
		
        @LastScreenOpt = null;
    }
}

void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 )
{
    for( uint i = ActiveScreens.length(); i > 0; ) // From end
    {
        i--;
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.Index == screenIndex )
        {
            // Remove
            ActiveScreens.removeAt( i );

            // Hide callback
            if( valid( screen.HideCallback ) )
            {
                screen.HideCallback.OnHide( p0, p1, p2 );
            }

            // Restore cursor
            if( screen.IsAutoCursor )
            {
                ::ChangeCursor( screen.AutoCursorPrev );
            }

            // Store position for non-multiinstance screens
            if( !screen.IsMultiinstance )
            {
                GUIScreen@ instance = GetScreen( screenIndex );
                instance.PosX = screen.PosX;
                instance.PosY = screen.PosY;
            }
			
            break;
        }
    }
}

void GUI_Render()
{
    for( uint i = 0, j = ActiveScreens.length(); i < j; i++ )
    {
        GUIScreen@ screen = ActiveScreens[ i ];
        if( screen.IsHardcoded )
        {
            if( screen.Index != CLIENT_MAIN_SCREEN_LOGIN )
            {
                ::DrawHardcodedScreen( screen.Index );
                ::GetHardcodedScreenPos( screen.Index, screen.PosX, screen.PosY );
            }
        }
		
        screen.Draw();
    }
}

bool GUI_MouseDown( int click, int x, int y )
{
	MousePressed[click] = true;
    uint len = ActiveScreens.length();
    if( len != 0 )
    {
        GUIScreen@ screen = ActiveScreens[ len - 1 ];
        bool result = screen.MouseDown( click, x, y );
        if( result )
        {
            if( click == MOUSE_CLICK_WHEEL_UP || click == MOUSE_CLICK_WHEEL_DOWN )
			{
                return GUI_MouseUp( click, x, y );
            }
			
			return true;
        }

        if( len > 1 && !screen.IsHardcoded && !screen.IsModal && click == MOUSE_CLICK_LEFT &&
			!IS_COLLISION( x, y, screen.PosX, screen.PosY, screen.Surface.Width, screen.Surface.Height ) )
        {
            for( uint i = ActiveScreens.length() - 1; i > 0;)     // From end
            {
                i--;
                GUIScreen@ nextScreen = ActiveScreens[ i ];
                if( IS_COLLISION( x, y, nextScreen.PosX, nextScreen.PosY, nextScreen.Surface.Width, nextScreen.Surface.Height ) )
                {
                    // Swap screens
                    GUIScreen@ tmpScreen = ActiveScreens[ i ];
                    @ActiveScreens[ i ] = ActiveScreens[ len - 1 ];
                    @ActiveScreens[ len - 1 ] = tmpScreen;
                    return GUI_MouseDown( click, x, y );                 // Click new screen
                }
            }
        }
    }
	
    return false;
}

bool GUI_MouseUp( int click, int x, int y )
{
	MousePressed[click] = false;
    uint len = ActiveScreens.length();
    if( len != 0 )
	{
        return ActiveScreens[ len - 1 ].MouseUp( click, x, y );
	}
	
	return false;
}

void GUI_MouseMove( int x, int y )
{
    uint len = ActiveScreens.length();
    if( len != 0 )
	{
        ActiveScreens[ len - 1 ].MouseMove( x, y );
	}
}

bool GUI_KeyDown( uint8 key )
{
    bool result;

    if( KeyPressed.length() != 0 )
	{
        KeyPressed[ key ] = true;
    }
	
	uint len = ActiveScreens.length();
    if( len != 0 )
    {
        if( ActiveScreens[ len - 1 ].Index == CLIENT_MAIN_SCREEN_GAME && GetCurrentCursor() == CURSOR_USE_WEAPON && ( key == DIK_LCONTROL || key == DIK_RCONTROL ) )
		{
            __IsHexAttack = true;
        }
		result = ActiveScreens[ len - 1 ].KeyPress( key );
    }
    else
	{
        result = false;
	}
// binyan - Hotkeys
    if( __IsHotkeysUse )
	{
        if( previews == 0 )
		{
            previews = key;
		}
	}
    return result;
}

bool GUI_KeyUp( uint8 key )
{
	__IsHexAttack = true;
    if( __IsHotkeysUse )
	{
        if( key == previews )
		{
            previews = 0;
		}
	}
	
    if( KeyPressed.length() != 0 )
	{
        KeyPressed[ key ] = false;
    }
	return false;
}

void GUI_InputLost()
{
    for( uint i = 0, j = KeyPressed.length(); i < j; i++ )
	{
        KeyPressed[ i ] = false;
    }
	
	uint len = ActiveScreens.length();
    if( len != 0 )
	{
        ActiveScreens[ len - 1 ].InputLost();
	}
}

//
// Internal
//

IGUIScreenOpt@ CreateScreen( int screenIndex, string@ sprName )
{
    GUIScreen screen( sprName, PT_ART_INTRFACE );
    screen.CanMove( true );
    screen.Position( __ScreenWidth / 2 - screen.Surface.Width / 2, __ScreenHeight / 2 - screen.Surface.Height / 2 );
    screen.Index = screenIndex;
    AllScreens.insertLast( @screen );
    return @screen;
}

void DeleteScreen( int screenIndex )
{
    for( uint i = 0; i < ActiveScreens.length();)
    {
        if( ActiveScreens[ i ].Index == screenIndex )
        {
            ActiveScreens.removeAt( i );
            i = 0;
        }
        else
        {
            i++;
        }
    }

    for( uint i = 0, j = AllScreens.length(); i < j; i++ )
    {
        if( AllScreens[ i ].Index == screenIndex )
        {
            AllScreens.removeAt( i );
            break;
        }
    }
}

GUIScreen@ GetScreen( int screenIndex )
{
    if( screenIndex == 0 )
	{
        return null;
    }
	
	for( uint i = 0, j = AllScreens.length(); i < j; i++ )
	{
        if( AllScreens[ i ].Index == screenIndex )
		{
            return @AllScreens[ i ];
		}
	}
	
	return null;
}

bool ProcessKey( uint8 key, string& text, uint8& letter )
{
    if( KeyPressed.length() == 0 )
	{
        return false;
	}
	
    if( key == DIK_BACK )
    {
        if( text.length() > 0 )
		{
            text.resize( text.length() - 1 );
        }
		
		return true;
    }

    KeybData@ k = KbData[ key ];
    if( !( k is null ) )
    {
        bool shiftDown = ( KeyPressed[ DIK_LSHIFT ] || KeyPressed[ DIK_RSHIFT ] );
        uint len = text.length();
        text.resize( text.length() + 1 );
        text[ len ] = k.Char[ ::GetKeybLang() * 2 + ( shiftDown ? 1 : 0 ) ];
        letter = text[ len ];
        return true;
    }
	
    return false;
}

void _SetControlCritters( int Id, int p1, int p2, string@ + p3, int[] @ + p4 )
{
    SetControlCritters( Id );
}

void SetGMstore( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	GM_store_type = param0;
}

//Support func for STA
// STA module validation
bool CheckSTA( CritterCl& chosen )
{
	ItemCl@ armor = chosen.GetItem( 0, SLOT_ARMOR );
	if( valid( armor ) )
	{
		if( HidefaceArmor.find( armor.GetProtoId() ) != -1 )
		{
			return true;
		}
	}
	
	ItemCl@ visor = chosen.GetItem( 0, SLOT_HEAD );
	if( valid( visor ) )
	{
		if( VisorsSTA.find( visor.GetProtoId() ) != -1  )
		{
			return true;
		}
	}
	
	return false;
}

// Target Grid Contour Offsets
int[] GetTargetingData( CritterCl& target )
{
	int bodyType = target.Param[ ST_BODY_TYPE ];
	int crType = target.CrType;

	int bt_W_mod = 0;
	int bt_H_mod = 0;
	int bt_X_mod = 0;
	int bt_Y_mod = 0;

	switch( bodyType )
	{
		case( BT_WOMEN ):
			bt_W_mod += 10;
			bt_X_mod += 5;
			break;
		case( BT_CHILDREN ):
			bt_W_mod += 8;
			bt_X_mod += 8;
			bt_Y_mod += 2;
			break;
		case( BT_SUPER_MUTANT ):
			break;
		case( BT_GHOUL ):
			bt_W_mod += 10;
			bt_X_mod += 5;
			break;
		case( BT_BRAHMIN ):
			bt_W_mod -= 5;
			bt_H_mod -= 10;
			bt_X_mod -= 10;
			bt_Y_mod += 5;
			break;
		case( BT_RADSCORPION ):
		{
			switch( crType )
			{
				case( CRTYPE_RADSCORPION_SMALL ):
					bt_W_mod -= 5;
					bt_H_mod -= 10;
					bt_X_mod -= 5;
					bt_Y_mod += 5;
					break;
				case( CRTYPE_RADSCORPION ):
					bt_W_mod -= 15;
					bt_H_mod -= 15;
					bt_X_mod -= 10;
					bt_Y_mod += 10;
					break;
				default:
					bt_W_mod -= 30;
					bt_H_mod -= 25;
					bt_X_mod -= 30;
					bt_Y_mod += 10;
					break;
			}
			break;
		}
		case( BT_RAT ):
		{
			switch( crType )
			{
				case( CRTYPE_RAT ):
					bt_W_mod += 5;
					bt_H_mod -= 5;
					break;
				case( CRTYPE_RAT_PIGRAT ):
					bt_H_mod -= 2;
					bt_Y_mod += 3;
					break;
				default:
					bt_W_mod -= 15;
					bt_H_mod -= 10;
					bt_X_mod -= 10;
					bt_Y_mod += 10;
					break;
			}
			break;
		}
		case( BT_FLOATER ):
			bt_H_mod -= 15;
			bt_X_mod -= 10;
			break;
		case( BT_CENTAUR ):
			bt_W_mod -= 65;
			bt_H_mod -= 45;
			bt_X_mod -= 25;
			bt_Y_mod += 15;
			break;
		case( BT_ROBOT ):
		{
			switch( crType )
			{
				case( CRTYPE_TURRET_MINIGUN ):
					bt_X_mod -= 5;
					break;
				case( CRTYPE_TURRET_PLASMA ):
					bt_W_mod -= 20;
					bt_H_mod -= 5;
					bt_X_mod -= 15;
					bt_Y_mod += 10;
					break;
				case( CRTYPE_TURRET_LASER_TOWER ):
					bt_W_mod -= 25;
					bt_H_mod -= 30;
					bt_X_mod -= 30;
					bt_Y_mod += 15;
					break;
				case( CRTYPE_TURRET_LASER ):
					bt_W_mod -= 25;
					bt_H_mod -= 10;
					bt_X_mod -= 20;
					bt_Y_mod += 15;
					break;
				case( CRTYPE_ROBOT_HANDY ):
					bt_W_mod -= 20;
					bt_H_mod -= 15;
					bt_X_mod -= 15;
					bt_Y_mod += 15;
					break;
				case( CRTYPE_ROBOT_PROTECTRON ):	
				case( CRTYPE_ROBOT_PROTECTRON2 ):

					break;	
				case( CRTYPE_ROBOBRAIN ):
					bt_W_mod -= 10;
					bt_H_mod -= 8;
					bt_X_mod -= 15;
					bt_Y_mod += 10;
					break;
				case( CRTYPE_ROBODOG ):

					break;
				case( CRTYPE_ROBOT ):	
				case( CRTYPE_ROBOT_BLUE ):
					bt_W_mod -= 15;
					bt_H_mod -= 5;
					bt_X_mod -= 15;
					bt_Y_mod += 5;
					break;
				default:
					break;
			}
			break;
		}
		case( BT_DOG ):
		{
			switch( crType )
			{
				case( CRTYPE_DOG_SMALL ):
					bt_W_mod += 15;
					bt_H_mod -= 3;
					bt_X_mod += 5;
					bt_Y_mod += 5;
					break;
				default:
					bt_W_mod += 10;
					bt_H_mod -= 5;
					bt_Y_mod += 5;
					break;
			}
			break;
		}
		case( BT_MANTI ):
			bt_W_mod += 10;
			bt_H_mod -= 5;
			break;
		case( BT_DEATHCLAW ):
		{
			switch( crType )
			{
				case( CRTYPE_DEADCLAW_SMALL ):
					bt_H_mod -= 5;
					bt_Y_mod += 5;
					break;
				case( CRTYPE_DEADCLAW ):
					bt_W_mod -= 15;
					bt_H_mod -= 15;
					bt_Y_mod += 10;
					break;
				default:
					bt_W_mod -= 10;
					bt_H_mod -= 10;
					bt_Y_mod += 10;
					break;
			}
			break;
		}
		case( BT_PLANT ):
			bt_W_mod -= 10;
			bt_H_mod -= 10;
			bt_Y_mod += 6;
			break;
		case( BT_GECKO ):
		{
			switch( crType )
			{
				case( CRTYPE_GECKO_SILV ):
				case( CRTYPE_GECKO_GOLD_SMALL ):
					bt_H_mod -= 15;
					bt_Y_mod += 5;
					break;
				default:
					bt_H_mod -= 15;
					bt_X_mod -= 5;
					bt_Y_mod += 5;
					break;
				}
			break;
		}
		case( BT_ALIEN ):
		{
			switch( crType )
			{
				case( CRTYPE_ALIEN_EGG ):
					bt_W_mod += 10;
					bt_H_mod += 5;
					break;
				default:
					bt_W_mod -= 10;
					bt_H_mod -= 7;
					break;
			}
			break;
		}
		case( BT_GIANT_ANT ):
			bt_W_mod -= 10;
			bt_H_mod -= 10;
			break;
		case( BT_BIG_BAD_BOSS ):
			bt_W_mod -= 15;
			bt_H_mod -= 5;
			bt_X_mod -= 20;
			bt_Y_mod += 10;
			break;
		case( BT_GIANT_BEETLE ):
			bt_H_mod -= 5;
			break;
		case( BT_GIANT_WASP ):
			bt_H_mod -= 15;
			bt_Y_mod -= 60;
			break;
		case( BT_YAO ):
			bt_W_mod -= 15;
			bt_H_mod -= 25;
			bt_X_mod -= 20;
			bt_Y_mod += 10;
			break;
		case( BT_SWAMP_LURKER ):
			bt_W_mod -= 25;
			bt_H_mod -= 10;
			bt_X_mod -= 10;
			break;
		case( BT_CROCS ):
			break;
		case( BT_MILLEPEDE ):
			break;	
		case( BT_LAVASH ):
			break;
		case( BT_SPIDER ):
			break;
		default:
			break;
	}
	
	int[] data = { bt_W_mod, bt_H_mod, bt_X_mod, bt_Y_mod };
	
	return data;
}

int LMB_x1;
int LMB_y1;
int LMB_x2;
int LMB_y2;
bool LMB_on;

void drawBar( uint8 r0, uint8 g0, uint8 b0 )
{
	int x1 = MIN( LMB_x1, LMB_x2 ); int y1 = MIN( LMB_y1, LMB_y2 ); 
	int x2 = MAX( LMB_x1, LMB_x2 );	int y2 = MAX( LMB_y1, LMB_y2 );

	int[] ps2 = { 
		x1, y1, COLOR_RGBA( r0, g0, b0, 255 ),
		x2, y1, COLOR_RGBA( r0, g0, b0, 255 ),
		x2, y2, COLOR_RGBA( r0, g0, b0, 255 ),
		x1, y2, COLOR_RGBA( r0, g0, b0, 255 ),
		x1, y1, COLOR_RGBA( r0, g0, b0, 255 ) 
	};
	DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, ps2 );
}

void OutlineCritter( Critter@ target, uint8 r0, uint8 g0, uint8 b0 )
{
	string cr_sprite_name = GetCritterTypeName( target.CrType ) + "aa.frm";
	uint CrSpriteId = LoadSprite( cr_sprite_name, int( PT_ART_CRITTERS ) );
	
	if( CrSpriteId == 0 )
	{
		return;
	}
	
	int[] targeter_data = GetTargetingData( target );
	int bt_W_mod = targeter_data[0];
	int bt_H_mod = targeter_data[1];
	int bt_X_mod = targeter_data[2];
	int bt_Y_mod = targeter_data[3];
	
	bt_X_mod = int( bt_X_mod / __SpritesZoom );
	bt_Y_mod = int( bt_Y_mod / __SpritesZoom );
	
	int crWidth = int( ( GetSpriteWidth( CrSpriteId, 0 ) + bt_W_mod ) / __SpritesZoom );
	int crHeight = int( ( GetSpriteHeight( CrSpriteId, 0 ) + bt_H_mod ) / __SpritesZoom );
	int step20 = int( 20 / __SpritesZoom );
	int step19 = int( 19 / __SpritesZoom );
	int step18 = int( 18 / __SpritesZoom );
	int step12 = int( 12 / __SpritesZoom );
	int step11 = int( 11 / __SpritesZoom );
	int step10 = int( 10 / __SpritesZoom );
	int step8 = int( 8 / __SpritesZoom );
	int step7 = int( 7 / __SpritesZoom );
	int step5 = int( 5 / __SpritesZoom );
	int step3 = int( 3 / __SpritesZoom );
	int step2 = int( 2 / __SpritesZoom );
	int step1 = int( 1 / __SpritesZoom );
	
	uint8 r1 = 0x00, g1 = 0x00, b1 = 0x00;
	
	uint8 coloured = 255;
	uint8 transparent = 0;
	
	int hx = 0, hy = 0;
	GetHexPos( target.HexX, target.HexY, hx, hy );
	
	array<int> drawData( 116 );
	
	if( true ) 
	{
		
	//reference: https://imgur.com/a/ABNAPuE
	//0
	drawData.insertAt( 0, hx + bt_X_mod - step10 );
	drawData.insertAt( 1, hy - crHeight );
	drawData.insertAt( 2, COLOR_RGBA( r0, g0, b0, coloured ) );
	//1
	drawData.insertAt( 3, hx + bt_X_mod - step20 );
	drawData.insertAt( 4, hy - crHeight );
	drawData.insertAt( 5, COLOR_RGBA( r0, g0, b0, coloured ) );
	//2
	drawData.insertAt( 6, hx + bt_X_mod - step20 );
	drawData.insertAt( 7, hy - crHeight + step10 );
	drawData.insertAt( 8, COLOR_RGBA( r0, g0, b0, coloured ) );
	//3
	drawData.insertAt( 9, hx + bt_X_mod - step20 );
	drawData.insertAt( 10, hy - crHeight + step10 );
	drawData.insertAt( 11, COLOR_RGBA( r0, g0, b0, transparent ) );
	//4
	drawData.insertAt( 12, hx+ bt_X_mod - step19 );
	drawData.insertAt( 13, hy - crHeight + step8 );
	drawData.insertAt( 14, COLOR_RGBA( r0, g0, b0, transparent ) );
	//5
	drawData.insertAt( 15, hx + bt_X_mod - step19 );
	drawData.insertAt( 16, hy - crHeight + step8 );
	drawData.insertAt( 17, COLOR_RGBA( r1, g1, b1, coloured ) );
	//6
	drawData.insertAt( 18, hx + bt_X_mod - step19 );
	drawData.insertAt( 19, hy - crHeight + step1 );
	drawData.insertAt( 20, COLOR_RGBA( r1, g1, b1, coloured ) );
	//7
	drawData.insertAt( 21, hx + bt_X_mod - step12 );
	drawData.insertAt( 22, hy - crHeight + step1 );
	drawData.insertAt( 23, COLOR_RGBA( r1, g1, b1, coloured ) );
	//8
	drawData.insertAt( 24, hx + bt_X_mod - step12 );
	drawData.insertAt( 25, hy - crHeight + step1 );
	drawData.insertAt( 26, COLOR_RGBA( r1, g1, b1, transparent ) );
	//9
	drawData.insertAt( 27, hx + crWidth - step18 );
	drawData.insertAt( 28, hy - crHeight + step1 );
	drawData.insertAt( 29, COLOR_RGBA( r1, g1, b1, transparent ) );
	//10
	drawData.insertAt( 30, hx + crWidth - step18 );
	drawData.insertAt( 31, hy - crHeight + step1 );
	drawData.insertAt( 32, COLOR_RGBA( r1, g1, b1, coloured ) );
	//11
	drawData.insertAt( 33, hx + crWidth - step11 );
	drawData.insertAt( 34, hy - crHeight + step1 );
	drawData.insertAt( 35, COLOR_RGBA( r1, g1, b1, coloured ) );
	//12
	drawData.insertAt( 36, hx + crWidth - step11 );
	drawData.insertAt( 37, hy - crHeight + step8 );
	drawData.insertAt( 38, COLOR_RGBA( r1, g1, b1, coloured ) );
	//13
	drawData.insertAt( 39, hx + crWidth - step11 );
	drawData.insertAt( 40, hy - crHeight + step8 );
	drawData.insertAt( 41, COLOR_RGBA( r0, g0, b0, transparent ) );
	//14
	drawData.insertAt( 42, hx + crWidth - step10 );
	drawData.insertAt( 43, hy - crHeight + step10 );
	drawData.insertAt( 44, COLOR_RGBA( r0, g0, b0, transparent ) );
	//15
	drawData.insertAt( 45, hx + crWidth - step10 );
	drawData.insertAt( 46, hy - crHeight + step10 );
	drawData.insertAt( 47, COLOR_RGBA( r0, g0, b0, coloured ) );
	//16
	drawData.insertAt( 48, hx + crWidth - step10 );
	drawData.insertAt( 49, hy - crHeight );
	drawData.insertAt( 50, COLOR_RGBA( r0, g0, b0, coloured ) );
	//17
	drawData.insertAt( 51, hx + crWidth - step20 );
	drawData.insertAt( 52, hy - crHeight );
	drawData.insertAt( 53, COLOR_RGBA( r0, g0, b0, coloured ) );
	//18
	drawData.insertAt( 54, hx + crWidth - step20 );
	drawData.insertAt( 55, hy - crHeight );
	drawData.insertAt( 56, COLOR_RGBA( r1, g1, b1, transparent ) );
	//19
	drawData.insertAt( 57, hx + crWidth - step18 );
	drawData.insertAt( 58, hy + bt_Y_mod + step2 );
	drawData.insertAt( 59, COLOR_RGBA( r1, g1, b1, transparent ) );
	//20
	drawData.insertAt( 60, hx + crWidth - step18 );
	drawData.insertAt( 61, hy + bt_Y_mod + step2 );
	drawData.insertAt( 62, COLOR_RGBA( r1, g1, b1, coloured ) );
	//21
	drawData.insertAt( 63, hx + crWidth - step11 );
	drawData.insertAt( 64, hy + bt_Y_mod + step2 );
	drawData.insertAt( 65, COLOR_RGBA( r1, g1, b1, coloured ) );
	//22
	drawData.insertAt( 66, hx + crWidth - step11 );
	drawData.insertAt( 67, hy + bt_Y_mod - step5 );
	drawData.insertAt( 68, COLOR_RGBA( r1, g1, b1, coloured ) );
	//23
	drawData.insertAt( 69, hx + crWidth - step11 );
	drawData.insertAt( 70, hy + bt_Y_mod - step5 );
	drawData.insertAt( 71, COLOR_RGBA( r0, g0, b0, transparent ) );
	//24
	drawData.insertAt( 72, hx + crWidth - step10 );
	drawData.insertAt( 73, hy + bt_Y_mod - step7 );
	drawData.insertAt( 74, COLOR_RGBA( r0, g0, b0, transparent ) );
	//25
	drawData.insertAt( 75, hx + crWidth - step10 );
	drawData.insertAt( 76, hy + bt_Y_mod - step7 );
	drawData.insertAt( 77, COLOR_RGBA( r0, g0, b0, coloured ) );
	//26
	drawData.insertAt( 78, hx + crWidth - step10 );
	drawData.insertAt( 79, hy + bt_Y_mod + step3 );
	drawData.insertAt( 80, COLOR_RGBA( r0, g0, b0, coloured ) );
	//27
	drawData.insertAt( 81, hx + crWidth - step20 );
	drawData.insertAt( 82, hy + bt_Y_mod + step3 );
	drawData.insertAt( 83, COLOR_RGBA( r0, g0, b0, coloured ) );
	//28
	drawData.insertAt( 84, hx + crWidth - step20 );
	drawData.insertAt( 85, hy + bt_Y_mod + step3 );
	drawData.insertAt( 86, COLOR_RGBA( r0, g0, b0, transparent ) );
	//29
	drawData.insertAt( 87, hx + bt_X_mod - step10 );
	drawData.insertAt( 88, hy + bt_Y_mod + step3 );
	drawData.insertAt( 89, COLOR_RGBA( r0, g0, b0, transparent ) );
	//30
	drawData.insertAt( 90, hx + bt_X_mod - step10 );
	drawData.insertAt( 91, hy + bt_Y_mod + step3 );
	drawData.insertAt( 92, COLOR_RGBA( r0, g0, b0, coloured ) );
	//31
	drawData.insertAt( 93, hx + bt_X_mod - step20 );
	drawData.insertAt( 94, hy + bt_Y_mod + step3 );
	drawData.insertAt( 95, COLOR_RGBA( r0, g0, b0, coloured ) );
	//32
	drawData.insertAt( 96, hx + bt_X_mod - step20 );
	drawData.insertAt( 97, hy + bt_Y_mod - step7 );
	drawData.insertAt( 98, COLOR_RGBA( r0, g0, b0, coloured ) );
	//33
	drawData.insertAt( 99, hx + bt_X_mod - step20 );
	drawData.insertAt( 100, hy + bt_Y_mod - step7 );
	drawData.insertAt( 101, COLOR_RGBA( r1, g1, b1, transparent ) );
	//34
	drawData.insertAt( 99, hx + bt_X_mod - step19 );
	drawData.insertAt( 100, hy + bt_Y_mod - step5 );
	drawData.insertAt( 101, COLOR_RGBA( r1, g1, b1, transparent ) );
	//35
	drawData.insertAt( 102, hx + bt_X_mod - step19 );
	drawData.insertAt( 103, hy + bt_Y_mod - step5 );
	drawData.insertAt( 104, COLOR_RGBA( r1, g1, b1, coloured ) );
	//36
	drawData.insertAt( 105, hx + bt_X_mod - step19 );
	drawData.insertAt( 106, hy + bt_Y_mod + step2 );
	drawData.insertAt( 107, COLOR_RGBA( r1, g1, b1, coloured ) );
	//37
	drawData.insertAt( 108, hx + bt_X_mod - step12 );
	drawData.insertAt( 109, hy + bt_Y_mod + step2 );
	drawData.insertAt( 110, COLOR_RGBA( r1, g1, b1, coloured ) );
	//38
	drawData.insertAt( 111, hx + bt_X_mod - step12 );
	drawData.insertAt( 112, hy + bt_Y_mod + step2 );
	drawData.insertAt( 113, COLOR_RGBA( r0, g0, b0, transparent ) );
	//39
	drawData.insertAt( 114, hx + bt_X_mod - step10 );
	drawData.insertAt( 115, hy - crHeight );
	drawData.insertAt( 116, COLOR_RGBA( r0, g0, b0, transparent ) );
	}
	
	DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
}

bool IsMonitorGui( int x, int y )
{
	for( uint i = ActiveScreens.length(); i > 0; i-- )
	{
		if( ActiveScreens[ i - 1 ].IsCollision( x, y ) )
		{
			return true;
		}
	}
	
	return false;
}

void drawHexRange( int x, int y, int radius, uint RGBA )
{
	int[] drawData;
	int hx = 0, hy = 0;
	for( uint8 i = 0; i <= 6; i++ )
	{
		uint16 tx = x, ty = y;
		MoveHexByDir( tx, ty, i % 6, radius );
		GetHexPos( tx, ty, hx, hy );
		
		drawData.insertLast( hx );
		drawData.insertLast( hy );
		drawData.insertLast( RGBA );
	}
	
	DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
}

void drawFanRange( int x, int y, int radius, uint RGBA )
{
	int[] drawData;
	int hx = 0, hy = 0;
	for( uint8 i = 0; i < 6; i++ )
	{
		uint16 tx = x, ty = y;
		MoveHexByDir( tx, ty, i, radius );
		GetHexPos( tx, ty, hx, hy );
		drawData.insertLast( hx );
		drawData.insertLast( hy );
		drawData.insertLast( RGBA );
	}
	
	DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
}

#include "client_controls.fos"

#endif //CLIENT_GUI