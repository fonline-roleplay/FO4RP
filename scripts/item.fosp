                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

import void telekineticExplosion(Critter&cr)from"combat";                                                                                                   

void _DoorAutoCloseInit(Item&door,bool firstTime)
{
	door.SetEvent((4),"e_UseAutoCloseDoor");
}

bool e_UseAutoCloseDoor(Item&door,Critter&cr,int skill)
{
	CreateTimeEvent(__FullSecond+((door.Val3==0?2:door.Val3)*__TimeMultiplier*60),"e_AutoCloseDoor",door.Id,true);
	return false;
}

uint e_AutoCloseDoor(uint[]@val)
{
	Item@door=GetItem(val[0]);
	if(not(@door!=null))
	{
		return 0;
	}
	if(!(((door.LockerCondition)&((0x01)))!=0))
	return 0;
	uint16 x=0;
	uint16 y=0;
	Map@map=door.GetMapPosition(x,y);
	if(not(@map!=null))
	{
		return 0;
	}
	
	Critter@cr=map.GetCritter(x,y);
	if((@cr!=null))
	{
		if(cr.IsLife())
		{
			return((3)*__TimeMultiplier*60);
		}
		else
		{
			
			cr.TransitToMap(map.Id,x-1,y,cr.Dir);
		}
	}
	
	if(door.LockerClose())
	return 0;
	
	return((3)*__TimeMultiplier*60);
} 

void _ClosedDoorInit(Item&door,bool firstTime)
{
	door.SetEvent((4),"_UseDoor");
}

bool _UseDoor(Item&door,Critter&cr,int skill)
{
	return true;
} 

void _DialogDoorInit(Item&door,bool firstTime)
{
	door.SetEvent((4),"_UseDialogDoor");
}

bool _UseDialogDoor(Item&door,Critter&cr,int skill)
{
	RunDialog(cr,door.Val3,door.HexX,door.HexY,false);
	return true;
} 

void _HoloInit(Item&item,bool firstTime)
{
	if(item.GetProtoId()!=(58))
	return;
	item.HolodiskNumber=item.Val0;
	item.SetScript("");
	item.Update();
	
}   

void _RndAnim(Item&item,bool firstTime)
{
	int rndFrm=Random(0,item.Val1);
	
	item.AnimStayBegin=rndFrm;
	item.AnimStayEnd=rndFrm;
	item.AnimShowBegin=rndFrm;
	item.AnimShowEnd=rndFrm;
	item.AnimHideBegin=rndFrm;
	item.AnimHideEnd=rndFrm;
	
	return;
}

void _ItemBagInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_ItemBagPick");
	item.SetEvent((3),"e_ItemBagUseItem");
	
}

bool e_ItemBagPick(Item&item,Critter&crit,int skill)
{      
	
	if(skill==(-1)&&item.Accessory==(2))
	{
		
		MoveItem(item,item.GetCount(),crit);
		crit.Say((11),"pick grnd");
		
	}
	return true;
}

import void SwitchState(Item&locker)from"lockers";

bool e_ItemBagUseItem(Item&item,Critter&crit,Item@usedItem)
{
	if((@usedItem!=null)&&usedItem.GetProtoId()==(289))
	{
		Map@map=crit.GetMap();
		if(map.IsHexPassed(item.HexX+2,item.HexY+2))
		{
			string logMsg;
			Item@hole=map.AddItem(item.HexX+2,item.HexY+2,(900),1);
			(hole.LockerCondition=(hole.LockerCondition)|((0x01)));
			logMsg="Init = "+(hole.LockerCondition=(hole.LockerCondition)|((0x01)));
			crit.Say((11),logMsg);
			
			hole.Val4=hole.HexX;
			hole.Val5=hole.HexY;
			hole.Val7=crit.WorldX;
			hole.Val8=crit.WorldY;
			Item@treasureMap=crit.AddItem((901),1);
			treasureMap.Val7=crit.WorldX;
			treasureMap.Val8=crit.WorldY;
			treasureMap.SetLexems("$hexX"+treasureMap.Val7+"$hexY"+treasureMap.Val8);
			
			return true;
		}
	}
	else if(item.Accessory==(2))
	{
		
		crit.ShowScreen((0),0,"");
		crit.ShowContainer(null,item,item.Proto.GroundLevel?(2):(1));
		return true;
	}
	return false;
}                                      

void _ShovelInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_ShovelUse");
}

bool e_ShovelUse(Item&item,Critter&cr,int skill)
{
	if(skill==(211)&&item.Accessory==(1))
	{
		Map@map=cr.GetMap();
		if(map.IsHexPassed(cr.HexX+2,cr.HexY+2))
		{
			string logMsg;
			Item@hole=map.AddItem(cr.HexX+2,cr.HexY+2,(900),1);
			(hole.LockerCondition=(hole.LockerCondition)|((0x01)));
			hole.Val4=hole.HexX;
			hole.Val5=hole.HexY;
			hole.Val7=cr.WorldX;
			hole.Val8=cr.WorldY;
			Item@treasureMap=cr.AddItem((901),1);
			treasureMap.SetLexems("$hexX"+treasureMap.Val7+"$hexY"+treasureMap.Val8);
			return true;
		}
	}
	return false;
}     

void _KeyBunchInit(Item&item,bool firstTime)

{
	
	item.SetEvent((3),"e_KeyBunchAdd");
	
	item.SetEvent((2),"e_KeyBunchUse");
	
	item.SetEvent((4),"e_KeyBunchSkill");
	
}  

bool e_KeyBunchTest(Item&item,Critter&cr,int skill)

{
	
	if(skill==(-2))
	
	{
		
		cr.Say((11),"dude great!");
		
		return true;
		
	}
	
	return false;
	
}            

bool e_KeyBunchSkill(Item&item,Critter&cr,int skill)

{
	
	string msg;
	
	switch(skill)
	
	{
		
		case(213):
		{
			Item@temp=cr.AddItem(82,1);
			msg=Random(0,51);
			temp.SetLexems("$KeyLex"+Random(0,51));
		}
		
		case(-1):
		if(item.Accessory==(2))
		{
			MoveItem(item,item.GetCount(),cr);
			return true;
		}
		
		if(item.ContainerId==cr.Id)
		{
			cr.Say((11),"that's work");
			key=item.Id;
			cr.ShowScreen((0),0,"@");return true;
		}  
		
		case(211):
		
		{ 
			
			Item@[]keys;
			item.GetItems(0,keys);
			if(keys.length()>0)
			{
				cr.Action((10),0,null);
				for(uint8 i=0;i<keys.length();i++)
				{
					MoveItem(keys[i],keys[i].GetCount(),cr);
				}
				cr.Say((11),"SUCK MY BALLS BITCH!!! "+item.Accessory);
				return true;
			}
		}
		case(212):
		{
			Item@[]keys;
			item.GetItems(0,keys);
			int[]keysId;
			if(keys.length()>0)
			{
				for(uint8 i=0;i<keys.length();i++)
				{
					keysId[i]=keys[i].Id; 
					
				}
				cr.RunClientScript("_ItemLexRtn",0,0,0,null,keysId);
			}
			return true;
		}
	}
	return false;
}                                                

bool e_KeyBunchAdd(Item&item,Critter&cr,Item@usedItem)
{
	if(usedItem.GetType()==(7))
	{
		MoveItem(usedItem,usedItem.GetCount(),item,0);
		cr.Say((11),"You're added some key to brunch");
		return true;
	}
	return false;
}

uint key;

bool e_KeyBunchUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if((@onItem!=null)&&onItem.GetType()==(9))
	{
		Item@[]keys;
		item.GetItems(0,keys);
		if(onItem.LockerCondition==(0x02))
		{
			for(uint8 i=0;i<keys.length();i++)
			{
				if(keys[i].LockerId==onItem.LockerId)
				{
					onItem.LockerId=0;
					onItem.LockerComplexity=0;
					cr.Say((11),"You're ulock the door");
				}
			}
		}
	}
	return false;
}  

void KeyUseScreen(Critter&player,uint answerI,string&answerS)
{   
	
	if(answerS.length()!=0)
	{     
		
		Item@key=GetItem(player.StatBase[(90)]);
		key.SetLexems("$KeyLex"+answerS);
		key.Update();
		
	}       
	
}                                

void _LockerInit(Item&item,bool firstTime)
{  
	
	item.SetEvent((2),"e_LockerKeyUse");
	
}      

bool ItemLockedCont(Item&item)
{
	if(item.GetType()==(8))
	{
		uint16 proto=item.GetProtoId();
		if(41<proto&&proto<46)
		{
			return true;
		}
		if(127<proto&&proto<140)
		{
			return true;
		}
		if(180<proto&&proto<190)
		{
			return true;
		}
		if(366<proto&&proto<371)
		{
			return true;
		}
		switch(proto)
		{
			case 245:
			return true;
			case 501:
			return true;
			case 502:
			return true;
			case 521:
			return true;
		}
	}
	return false;
} 

bool e_LockerKeyUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if((@onItem!=null))
	{
		if((onItem.GetType()==(9)||ItemLockedCont(onItem))&&onItem.Val1==0&&onItem.Val0==0)
		{
			if((not((onItem.LockerCondition&(0x01))!=0)))
			{
				if(onItem.LockerCondition!=(0x02)&&onItem.LockerComplexity==0)
				{   
					
					switch(item.GetProtoId())
					{
						case(1317):
						onItem.Val0=1;
						break;
						case(1318):
						onItem.Val0=2;
						break;
						case(1319):
						onItem.Val0=3;
						break;
					}
					
					Item@key=cr.AddItem((1313),1);
					uint keyNumber=Random(0,65534);
					onItem.LockerCondition=(0x02);
					onItem.LockerComplexity=item.Val0;
					Log("Locked, LockerCompl = "+onItem.LockerComplexity);
					onItem.LockerId=keyNumber;
					key.LockerId=keyNumber;
					item.SetLexems("$KeyLex"+"unnamed key");
					cr.StatBase[(90)]=key.Id;
					cr.ShowScreen((5),0,"item@KeyUseScreen");
					key.Update();
					DeleteItem(item);
					return true;
				}
				else
				{
					cr.Say((11),"Дверь уже заперта, сначала взломайте замок.");
					return true;
				}
			}
			else
			{
				cr.Say((11),"Сначала закройте объект");
				return true;
			}
		}
		else
		{
			cr.Say((11),"Этот объект нельзя запереть");
			return true;
		}
		
	}  
	
	return false;
}

void _LightEnvInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_LightEnvSkill");
}

bool e_LightEnvSkill(Item&item,Critter&cr,int skill)
{ 
	
	cr.Say((11),"Don't steal the light!");
	return true; 
	
}   

void _EmptyDisk(Item&item,bool firstTime)
{
	if(firstTime)
	item.HolodiskNumber=0;
}

bool e_FillRegistrationDocs(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.Val1==0)
	{
		cr.Say((11),"Вы вписали своё имя в документ, теперь он действительный");
		string@name=GetPlayerName(cr.Id);
		item.SetLexems("$ModocRegistrationName"+name);
		item.Val1=cr.Id;
		return true;
	}
	else
	{
		string@name=GetPlayerName(item.Val1);
		cr.Say((11),"Документ заполнен на имя: "+name);
		return true;
	}
}              

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                           

import uint GetPlayers(Critter&cr,uint16 radius,bool square,Critter@[]&crs)from"manager";

string dataName; 

bool ShowFlare(Critter@[]crs)
{
	uint8 length=crs.length();
	Map@map=crs[length-1].GetMap();
	if(!(@map!=null))
	return false;
	Location@loc=map.GetLocation();
	if(!(@loc!=null)||loc.AutoGarbage==false)
	{
		crs[crs.length()-1].Say((11),"Запускать ракету здесь - бессмыслеца. Найдите более подходящее место.");
		return false;
	}           
	
	uint flareLocId=loc.Id;
	CreateTimeEvent(__FullSecond+(1000),"e_ShowFlare",flareLocId,false);
	return true;
}

uint e_ShowFlare(uint[]@values)
{
	Location@loc=GetLocation(values[0]);
	if(!(@loc!=null))
	return 0;             
	
	return 0;
}        

void _FlareGun(Item&item,bool firstTime)
{ 
	
	item.SetEvent((4),"e_FlareGunSkill");
	
}

bool e_FlareGunSkill(Item&item,Critter&cr,int skill)
{
	if(skill!=(211))
	return false;
	return FlareGunUse(cr,item);
}

bool FlareGunUse(Critter&cr,Item&item)
{
	if(item.AmmoCount>0)
	{
		Critter@[]crs;
		GetGlobalMapCritters(cr.WorldX,cr.WorldY,200,(0x01)|(0x10),crs);
		crs.insertLast(cr);
		if(!ShowFlare(crs))
		return false;
		item.AmmoCount-=1;
		item.Update();
		cr.Say((11),"Вы запустили сигнальную ракету.");
	}
	return true;
}           

uint expBook;

void _ExpBookInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_ExpBookSkill");
	if(firstTime)
	{
		
		item.SetEvent((2),"e_ExpBookUse");
	}
}

bool e_ExpBookSkill(Item&item,Critter&cr,int skill)
{
	switch(skill)
	{
		case(211):
		expBook=item.Id;
		cr.ShowScreen((5),1,"ExpBookScreen");
		break;
		case(213):
		item.Val1=(item.Val1==0?1:0);
		break;
		case(212):
		cr.Say((11),"item state = "+item.Val1);
		break;
	}
	return true;
}

void ExpBookScreen(Critter&cr,uint answerI,string&answerS)
{
	Item@expBook0=GetItem(expBook);
	expBook0.SetEvent((4),"");
	if(answerS.length()>0)
	StrToInt(answerS,expBook0.Val0);
	cr.Say((11),""+expBook0.Val0+" "+answerI+" "+answerS);
}

bool e_ExpBookUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((11),""+item.Val0);
	if(item.Val0!=0)
	{
		if(item.Val1==0)
		{
			cr.StatBase[(76)]+=item.Val0;
		}
		else
		{
			cr.StatBase[(78)]+=item.Val0;
			cr.Say((11),"U recive "+item.Val0+" skill points");
		}
		DeleteItem(item);
		return true;
	}
	return false;
} 

void _InitMasterKey(Item&key,bool firstTime)
{ 
	
	key.SetEvent((2),"e_MasterKeyUse");
	
}

bool e_MasterKeyUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if((@onItem!=null)&&(onItem.GetType()==(9)||onItem.GetType()==(8)))
	{
		onItem.LockerOpen();
		onItem.LockerComplexity=0;
		
		onItem.LockerId=0;
		
		SwitchState(item);
		item.Update();
	}
	return false;
}

import bool SlotMachineWork(Critter&cr,Item&onehanded,int skill,Item@item)from"casino";

void _InitSlotMachine(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_SlotMachineUse");
	item.SetEvent((3),"e_SlotMachineOnMe");
}

bool e_SlotMachineUse(Item&item,Critter&cr,int skill)
{
	Item@key1=cr.GetItem((833),(1));
	switch(skill)
	{
		case(213):
		if(item.LockerComplexity!=0)
		{
			cr.Say((11),"not repair needed");
			return true;
		}
		else if(@key1!=null)
		{
			item.LockerId=key1.LockerId;
			item.LockerComplexity=100;
			item.Update();
			cr.Say((11),"U are repair slot machine");
		}
		else
		{
			Item@key=cr.AddItem((833),1);
			uint16 rnd=Random(1,65534);
			key.LockerId=rnd;
			item.LockerId=rnd;
			item.LockerComplexity=100;
			item.Update();
			key.Update();
			cr.Say((11),"U are repair slot machine");
			return true;
		}
		case(209):
		if(cr.StatBase[(5)]*2>Random(15,25-(cr.StatBase[(6)]/2)))
		{
			return false;
		}
		else
		{
			cr.Say((6),"do something with machine");
			return true;
		}
		case(-1):
		if(item.LockerComplexity==0||(@key1!=null&&key1.LockerId==item.LockerId))
		cr.ShowContainer(null,item,item.Proto.GroundLevel?(2):(1));
		else if(cr.CountItem((41))>=5)
		{
			SlotMachineWork(cr,item,skill,null);
			return true;
		}
		else
		{
			cr.Say((11),"need money");
			return true;
		}
		
	}
	
	return false;
}

bool e_SlotMachineOnMe(Item&item,Critter&cr,Item@usedItem)
{
	if(@usedItem==null)
	return false;
	SlotMachineWork(cr,item,(-1),usedItem);
	return true;
}     

funcdef uint PROCESS(Critter@,int&,int&,int&);                  

import bool RegisterProcess(uint8 type,any func)from"ltp";

import bool StartProcess(Critter&cr,uint8 type,int param0,int param1,int param2,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,int param0,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,uint time)from"ltp";

import bool StopProcess(Critter&cr)from"ltp";

import bool checkTDH(Critter&cr)from"ltp";
import bool checkTDH(Critter&cr,uint8 type)from"ltp";                       

bool ltp_roul_inited=false;
void ltp_roul_init()
{
	PROCESS@___pfunc=@process_russ_roul;any ___pany;___pany.store(@___pfunc);RegisterProcess((30),___pany);
	ltp_roul_inited=true;
}

uint process_russ_roul(Critter@cr,int&param0,int&param1,int&param2)
{
	if(param0==-1&&(cr is null)){param0=int((30));return(0xF035BCF3);}
	
	if(param0==0)
	{
		Item@item=GetItem(uint(param1));
		if((@item!=null))
		{
			item.AmmoCount--;
			item.Update();
		}
		cr.StatBase[(72)]=1;
		cr.ToKnockout(((Random(0,1)==0?true:false)?(82):(83)),((Random(0,1)==0?true:false)?(86):(87)),((Random(0,1)==0?true:false)?(88):(89)),Random(20,100),cr.HexX,cr.HexY);
		cr.SayMsg((6),(0),(9000));
	}
	else
	{
		cr.SayMsg((6),(0),(9001));
	}
	
	return 0;
}

void _RevolverInit(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_RevolverSkill");
}

bool e_RevolverSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(212))
	{
		if(item.AmmoCount<=0)
		return false;
		if(!ltp_roul_inited)
		ltp_roul_init();
		uint8 russianRoll=Random(10,70)-(cr.StatBase[(6)]/2);
		uint rndTime=Random(3,5)*1000;
		bool roll=(russianRoll>=10)&&(russianRoll<=20);
		
		StartProcess(cr,(30),roll?0:1,item.Id,0,rndTime);        
		
		cr.Say((6),"Взводит курок");
		return true;
	}
	return false;
}  

void _InitPoliceStuff(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_PoliceStuffUse");
	item.SetEvent((4),"e_PoliceStuffPick");
	item.SetEvent((3),"e_PoliceStuffHammer");
} 

bool e_PoliceStuffPick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		Map@map=cr.GetMap();
		Location@loc=map.GetLocation();
		if(LocIsModoc(loc.GetProtoId()))
		{
			if(cr.CountItem((1454))>=1||item.Val0==0)
			{
				return false;
			}
			cr.Say((11),"Вы не уполномочены перенести табличку");
			return true;
		}
		else if(item.Val1==0)
		{
			return false;
		}
		cr.Say((11),"Вы не можете перенести табличку");
		return true;
	}
	return true;
}

bool e_PoliceStuffHammer(Item&item,Critter&cr,Item@usedItem)
{
	int HammerTime=(11-cr.Stat[(0)])*60*10;
	if(item.GetProtoId()==(1458))
	{
		if((cr.Timeout[(232)]==0)&&(cr.StatBase[(77)]>=3))
		{
			if((@usedItem!=null)&&(usedItem.GetProtoId()==(6)))
			{
				if(cr.CountItem((1423))>=1)
				{
					item.Val1+=1;
					cr.DeleteItem((1423),1);
					cr.Say((11),"вы забиваете кувалдой крепежные штыри");
					cr.TimeoutBase[(232)]=__FullSecond+HammerTime;
				}
				else
				cr.Say((11),"нет крепежных штырей");
				return true;
			}
			if((@usedItem!=null)&&(usedItem.GetProtoId()==(20))&&(cr.ParamBase[(213)]>=100))
			{
				if(item.Val1>=1)
				{
					item.Val1-=1;
					cr.Say((11),"вы выдергиваете ломиком крепежные штыри");
					cr.TimeoutBase[(232)]=__FullSecond+HammerTime;
				}
				else
				cr.Say((11),"табличка не закреплена");
				return true;
			}
		}
		cr.Say((11),"у вас недостаточно сил");
	}
	return false;
}

bool e_PoliceStuffUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.GetProtoId()==(1458))
	{
		if(item.Val0==0)
		{
			cr.ShowScreen((5),0,"item@SignUseScreen");
			cr.StatBase[(90)]=item.Id;
		}
		else
		cr.Say((11),"табличка уже заполненна");
	}
	return true;
}

void SignUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@item=GetItem(player.StatBase[(90)]);
		item.SetLexems(""+answerS);
		item.Val0=1;
		item.Update();
	}
} 

import bool SetTrapOnItem(Critter&cr,Item&trap,Item&onItem)from"trap"; 

void _TestTrapInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_TestTrapUse");
}

bool e_TestTrapUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	return false;          
	
}

void _WhistInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_WhistUse");
}

bool e_WhistUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	map.PlaySound("whist.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	cr.Say((6),"Свестит в свисток.");
	return true;
}

void _InitRpNamer(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_RpNamerUse");
}

bool e_RpNamerUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.GetProtoId()==(1460))
	{
		cr.ShowScreen((5),0,"item@RpNamerUseScreen");
		cr.StatBase[(90)]=item.Id;
	}
	return true;
}

void RpNamerUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@item=GetItem(player.StatBase[(90)]);
		player.SetLexems(answerS);
		DeleteItem(item);
	}
}

void _music_fleita(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_fleitaUse");
}

bool e_fleitaUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	if(Random(1,5)>4)
	map.PlaySound("flute.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>3)
	map.PlaySound("flute2.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>2)
	map.PlaySound("flute3.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>1)
	map.PlaySound("flute4.wav",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	else if(Random(1,5)>0)
	map.PlaySound("flute5.ogg",cr.HexX,cr.HexY,cr.Stat[(2)]*5);
	cr.Say((6),"Играет на флейте.");
	Location@loc=map.GetLocation();
	if((loc.WorldX<=50)||(loc.WorldX>=150)||(loc.WorldY<=50)||(loc.WorldY>=150))
	{
		cr.Say((11),"Вы слишком далеко от фермы.");
		return true;
	}
	if((loc.WorldX>=item.Val2-20)&&(loc.WorldX<=item.Val2+20)&&(loc.WorldY>=item.Val3-20)&&(loc.WorldY<=item.Val3+20))
	{
		cr.Say((11),"Тут брамины уже паслись.");
		return true;
	}
	if(loc.Id>=100&&loc.Id<=139)
	{
		cr.Say((11),"Начинаете пасти стадо.");
		item.Val1=map.Id;
		item.Val2=loc.WorldX;
		item.Val3=loc.WorldY;
		cr.AddTimeEvent("cte_BrahminEat",(60*3)*__TimeMultiplier,(43),0);
	}
	return true;
}

uint cte_BrahminEat(Critter&cr,int identifier,uint&rate)
{
	Critter@[]brahmins;
	Item@flute=cr.GetItem((1494),(1));
	Map@map=cr.GetMap();
	if(!(@flute!=null)||!(@map!=null))
	return 0;
	if((map.GetCritters((321),(0x03)|(0x20),brahmins)>0)&&map.Id==flute.Val1)
	{
		for(uint i=0,ii=brahmins.length();i<ii;i++)
		{
			brahmins[i].StatBase[(95)]+=1;
		}
		cr.Say((11),"Брамины кажется насытились тут");
	}
	return 0;
}

void _dosimetr(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_dosimetrUse");
}

bool e_dosimetrUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	Map@map=cr.GetMap();
	cr.Say((6),"Производит замер.");
	Location@loc=map.GetLocation();
	if((loc.WorldX>=item.Val1-20)&&(loc.WorldX<=item.Val1+20)&&(loc.WorldY>=item.Val2-20)&&(loc.WorldY<=item.Val2+20))
	{
		cr.Say((11),"Кажется место правильное, остается только подождать несколько минут.");
		item.Val3=map.Id;
		cr.AddTimeEvent("cte_dosimetrUse",60*3,(43),0);
	}
	return true;
}

uint cte_dosimetrUse(Critter&cr,int identifier,uint&rate)
{
	Item@dosimetr=cr.GetItem((1540),(1));
	Map@map=cr.GetMap();
	if(!(@dosimetr!=null)||!(@map!=null))
	return 0;
	if(map.Id==dosimetr.Val3)
	{
		cr.Say((11),"Индикатор изменил цвет на желтый, можно возвращаться.");
		DeleteItem(dosimetr);
		cr.AddItem((1541),1);
	}
	else
	cr.Say((11),"Время прошло, но индикатор не сменил цвет, кажется мы сделали что-то неправильно.");
	return 0;
}

void _TraderBadge(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_traderbadgeUse");
}

bool e_traderbadgeUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"Показывает значек торговца");
	return true;
}

void _PochtaBadge(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_PochtaBadgeUse");
}

bool e_PochtaBadgeUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"Показывает значек оружейника");
	return true;
}

void _kosakInit(Item&item,bool firstTime)
{
	
}                       

import void Warn(Critter&admin,int param0,int param1,int param2)from"warning";
import void say(Critter&player,int param0,int param1,int param2)from"gm";  

void e_PsiUse(Critter&cr)
{
	uint[]rates;
	uint8 countTimes=cr.GetTimeEvents((56),null,null,rates);
	uint8 countTimes2=cr.GetTimeEvents((57),null,null,rates);
	uint8 countTimes3=cr.GetTimeEvents((58),null,null,rates);
	uint8 countTimes4=cr.GetTimeEvents((59),null,null,rates);
	if(cr.Stat[(195)]>=80&&countTimes3<=0)
	{
		cr.Say((11),"Дикая головная боль охватила вас, тело трясется, из носа потекла кровь.");
		if(cr.StatBase[(67)]!=(10))cr.Say((5),"Из носа течет кровь");
		cr.ToKnockout((((Random(0,1)==1?true:false))?(82):(83)),(((Random(0,1)==1?true:false))?(86):(87)),(((Random(0,1)==1?true:false))?(88):(89)),Random(600,800),cr.HexX,cr.HexY);
		cr.AddTimeEvent("cte_psi_degrad",0,(58),cr.ParamBase[(195)]);
	}
	else if(countTimes3<=0)
	{
		cr.ShowScreen((2),4,"answer_Psi");
		cr.Say((18),"Что требуется?");
		if(countTimes2<=0)cr.Say((19+(0)),"Сверхзрение");
		else if(countTimes2>=1)cr.Say((19+(0)),"Откл. Сверхзрение");
		if(countTimes<=0)cr.Say((19+(1)),"Лечение");
		else if(countTimes>=1)cr.Say((19+(1)),"Прерв. лечение");
		if(countTimes4<=0)cr.Say((19+(2)),"Пси-щит");
		else if(countTimes4>=1)cr.Say((19+(2)),"Остановить пси-щит");
		cr.Say((19+(3)),"Пси-взрыв");
	}
}

void answer_Psi(Critter&cr,uint answerI,string&answerS)
{
	uint[]rates;
	bool psiHealOn=(cr.GetTimeEvents((56),null,null,rates)>0);
	bool psiVisionOn=(cr.GetTimeEvents((57),null,null,rates)>0);
	bool psiShieldOn=(cr.GetTimeEvents((59),null,null,rates)>0);
	bool psiDegrad=(cr.GetTimeEvents((58),null,null,rates)>0);
	
	if(!(@cr!=null)||cr.IsKnockout()||cr.IsDead())
	return;
	if(answerI==0){
		if(!psiVisionOn){
			cr.Say((11),"Вы чувствуете живых существ на расстоянии.");
			cr.AddTimeEvent("cte_psi_vision",0,(57),cr.ParamBase[(702)]);
			cr.ParamBase[(702)]=40;
		}else{
			cr.Say((11),"Вы вернулись к нормальному зрению.");
			cr.EraseTimeEvents((57));
			cr.ParamBase[(702)]=0;
		}
	}
	if(answerI==1){
		if(!psiHealOn){
			cr.StatBase[(72)]+=40;
			cr.Say((5),"Засыпает");
			cr.Say((11),"Вы погружаетесь сон. Раны практически мгновенно зарастают на вашем теле. Следите за вашей силой.");
			cr.ToKnockout((((Random(0,1)==1?true:false))?(82):(83)),(((Random(0,1)==1?true:false))?(86):(87)),(((Random(0,1)==1?true:false))?(88):(89)),Random(120,180),cr.HexX,cr.HexY);
			cr.AddTimeEvent("cte_psi_heal",0,(56),cr.Stat[(7)]);
		}else{
			cr.Say((11),"Вы прервали регенерацию.");
			cr.EraseTimeEvents((56));
		}
	}
	if(answerI==2){
		if(!psiShieldOn){
			cr.Say((11),"Вы окружили себя псионическим полем.");
			cr.AddTimeEvent("cte_psi_shield",0,(59),cr.Stat[(7)]);
		}else{
			cr.Say((11),"Вы перестали поддерживать псионическое поле.");
			cr.EraseTimeEvents((59));
		}
	}
	if(answerI==3){
		if(cr.Stat[(193)]>50)cr.StatBase[(193)]-=50;
		else{
			cr.StatBase[(195)]+=(50-cr.Stat[(193)]);
			cr.StatBase[(193)]=1;
		}
		if(cr.Stat[(193)]<1)cr.StatBase[(193)]=1;
		telekineticExplosion(cr);
		if(cr.Stat[(195)]>80&&!psiDegrad){
			cr.AddTimeEvent("cte_psi_degrad",0,(58),cr.StatBase[(195)]);
		}
	}
	if(cr.Stat[(193)]<=1){cr.StatBase[(193)]=1;}
}

uint cte_psi_heal(Critter&cr,int identifier,uint&rate)
{
	bool psiDegrad=(cr.GetTimeEvents((58),null,null,null)>0);
	int heal=5;
	if(heal>rate)heal=rate;
	bool isHealed=true;
	int i=(730);
	while(i<=(737)){
		if(cr.ParamBase[i]>0)isHealed=false;
		cr.ParamBase[i]-=heal;
		if(cr.ParamBase[i]<0)cr.ParamBase[i]=0;
		i++;
	}
	if(isHealed)heal=0;
	cr.StatBase[(193)]-=heal;
	cr.ParamBase[(739)]-=2;
	cr.StatBase[(72)]+=heal;
	cr.Say((11),"Вы регенерируете.");
	int16 aidTime=13*__TimeMultiplier;
	
	if(cr.Stat[(193)]<1){
		cr.StatBase[(195)]-=cr.ParamBase[(193)]-1;
		cr.StatBase[(193)]=1;
	}
	
	bool psy=true;
	if(isHealed)
	{
		cr.Say((11),"Вы полностью выздоровели.");
		psy=false;
	}
	if(cr.Stat[(195)]>80&&!psiDegrad){
		cr.AddTimeEvent("cte_psi_degrad",0,(58),cr.StatBase[(195)]);
		psy=false;
	}else if(psiDegrad){
		psy=false;
	}
	return psy?aidTime:0;
}

uint cte_psi_vision(Critter&cr,int identifier,uint&rate)
{
	bool psiDegrad=(cr.GetTimeEvents((58),null,null,null)>0);
	int16 aidTime=5*__TimeMultiplier;
	int vis=1;
	cr.ParamBase[(193)]-=vis*2;
	bool psiRepeat=true;
	
	if(cr.ParamBase[(193)]<1){
		cr.ParamBase[(195)]-=cr.ParamBase[(193)]-1;
		cr.ParamBase[(193)]=1;
		if(Random(0,3)==0){
			cr.Say((11),"Ваша энергия на исходе. Вы начинаете медленно сходить с ума.");
			cr.Say((5),"Прерывисто дышит и дрожит");
		}
	}
	if(cr.Stat[(195)]>80&&!psiDegrad){
		cr.AddTimeEvent("cte_psi_degrad",0,(58),cr.StatBase[(195)]);
		psiRepeat=false;
	}else if(psiDegrad){
		psiRepeat=false;
	}
	return psiRepeat?aidTime:0;
}

uint cte_psi_shield(Critter&cr,int identifier,uint&rate)
{
	int16 shieldTick=5*__TimeMultiplier;
	bool psiDegrad=(cr.GetTimeEvents((58),null,null,null)>0);
	
	cr.ParamBase[(193)]-=4;
	if(cr.ParamBase[(193)]<1){
		cr.ParamBase[(195)]-=cr.ParamBase[(193)]-1;
		cr.ParamBase[(193)]=1;
		if(Random(0,3)==0){
			cr.Say((11),"Ваша энергия на исходе. Вы начинаете медленно сходить с ума.");
			cr.Say((5),"Прерывисто дышит и дрожит");
		}
	}
	if(cr.Stat[(195)]>80&&!psiDegrad){
		cr.AddTimeEvent("cte_psi_degrad",0,(58),cr.StatBase[(195)]);
		shieldTick=0;
	}else if(psiDegrad){
		shieldTick=0;
	}
	
	return shieldTick;
}

uint cte_psi_degrad(Critter&cr,int identifier,uint&rate)
{
	uint16 WeaponPid;
	if(cr.ParamBase[(195)]<=95)
	{
		cr.ParamBase[(195)]+=3;
		cr.ParamBase[(702)]=20;
		cr.Say((11),"Из носа течет кровь, в глазах все двоится, кажется, вы видите сквозь стены..");
		cr.Say((5),"Из носа течет кровь. Существо дрожит");
		
	}
	else if(cr.ParamBase[(195)]<=98)
	{
		cr.ParamBase[(195)]+=4;
		cr.ParamBase[(702)]=15;
		cr.StatBase[(1)]-=2;
		cr.Say((11),"Жгучая боль поразила ваши глаза");
		cr.Say((5),"Из носа течет кровь");
	}
	else if(cr.ParamBase[(195)]<=125)
	{
		int roll=Random(1,3);
		cr.ParamBase[(195)]+=3;
		cr.ParamBase[(702)]=10;
		cr.Say((11),"Ваша голова невыносимо болит, из носа хлещет кровь, а тело слабо поддается контролю");
		if(roll==1){cr.Say((5),"Вгрызается зубами в правую руку");cr.DamageBase[(503)]=1;cr.ParamBase[(734)]=60;}
		if(roll==2){cr.Say((5),"Вгрызается зубами в левую руку,");cr.DamageBase[(504)]=1;cr.ParamBase[(735)]=60;}
		if(roll==3){cr.Say((5),"Бьет себя руками по лицу, трясется, глаза широко раскрыты и бешенно бегают, будто бы ища кого-то");cr.ParamBase[(730)]=70;}
	}
	else if(cr.ParamBase[(195)]<=132)
	{
		cr.ParamBase[(195)]+=3;
		cr.StatBase[(0)]-=2;
		cr.ParamBase[(702)]=25;
		cr.Say((11),"Кости ломит, по всему телу распространяется болезненная слабость. Вам холодно.. За стенами что-то шевелится");
		cr.Say((5),"Застывает в неестественной позе, скалится");
	}
	else if(cr.ParamBase[(195)]<=150)
	{
		int roll=Random(1,6);
		cr.StatBase[(72)]=1;
		cr.ParamBase[(195)]+=5;
		cr.StatBase[(7)]-=2;
		cr.StatBase[(0)]=1;
		cr.StatBase[(2)]=3;
		cr.StatBase[(4)]=5;
		cr.ParamBase[(702)]=12;
		if(roll==1){cr.Say((11),"Все тело будто бы скручивается в один маленький комок, вы ощущаете хруст костей, кто-то смеется над вами, некоторые даже позволяют себе бить вас. Голова закипает, вам хочется умереть..");}
		if(roll==2){cr.Say((11),"Вспышка боли расползается по всему телу, рев омерзительных тварей в вашей голове не дает вам покоя. Вы чувствуете, что вас поглощает нечто ужасное, черное и желающее вашей немедленной смерти");}
		if(roll==3){cr.Say((11),"..Кто здесь?.. Что ты забыл в моем теле?!..");}
		if(roll==4){cr.Say((11),"..Теперь ты один из нас..");}
		if(roll==5){cr.Say((11),"..СДОХНИ! СДОХНИ! СДОХНИ!..");}
		if(roll==6){cr.Say((11),"..ЭТО НЕ ТВОЕ ТЕЛО, БРОСЬ ЕГО. БРОСЬ СЕЙЧАС ЖЕ!..");}
		cr.Say((5),"Держится за голову");
		cr.Say((3),"А-А-а-а-а-а-ааааааааа");
	}
	else if(cr.ParamBase[(195)]<=160)
	{
		int roll=Random(1,2);
		int luckRoll=Random(1,20)+cr.Stat[(6)];
		if(luckRoll>19)roll=3;
		cr.ParamBase[(195)]+=3;
		cr.ParamBase[(702)]=0;
		cr.Say((11),"Вокруг все плывет, глаза слипаются, вам хочется уснуть..");
		if(roll==1){cr.Say((5),"Медленно валится вниз");cr.DamageBase[(503)]=1;cr.ParamBase[(734)]=cr.StatBase[(7)]*0.2;cr.ToDead((110),cr);}
		if(roll==2){cr.Say((5),"Вдавливает пальцами глаза внутрь черепа");cr.DamageBase[(502)]=1;cr.ParamBase[(732)]=3000;cr.ToDead((110),cr);}
		if(roll==3)
		{
			cr.Say((5),"Бьет себя руками по лицу, трясется, глаза широко раскрыты и бешенно бегают, будто бы ища кого-то");
			cr.Say((11),"Похоже, вы смогли перебороть свою болезнь. Что-то внутри вас изменилось, а огнестрельное оружие стало жутко ухмыляться при виде вас");
			if(cr.Param[(730)]<90)cr.ParamBase[(730)]=90;
			cr.ParamBase[(193)]=120;
			cr.ParamBase[(195)]=0;
			
		}
		
	}
	return 60*60*__TimeMultiplier;
} 

void _InitGmPistol(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_GmPistolUse");
	item.SetEvent((4),"e_GmPistolPick");
	item.SetEvent((1),"e_GmPistolAttack");
}

bool e_GmPistolUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.GetProtoId()==(1523)&&cr.GetAccess()>=(2))
	{
		cr.ShowScreen((2),3,"answer_GmPistol_GM_menu");
		cr.Say((18),"Что желаешь хозяин?");
		cr.Say((19+(0)),"скачать help");
		cr.Say((19+(1)),"скачать warn");
		cr.Say((19+(2)),"очистить help");
		cr.Say((19+(3)),"очистить warn");
	}
	return true;
}

void answer_GmPistol_GM_menu(Critter&cr,uint answerI,string&answerS)
{
	if(!(@cr!=null))
	return;
	if(answerI==0)
	{
		file f;
		if(f.open("logs\\help_pleads.txt","r")>=0)
		{
			string word="";
			uint pos=0;
			f.setPos(0);
			while(!f.isEndOfFile())
			{
				pos=f.getPos();
				if(pos==0)
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",0,0,0,word,null);
				}
				else
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",1,0,0,word,null);
				}
			}
			f.close();
		}
		else
		Log("can't open!");
	}
	if(answerI==1)
	{
		file f;
		if(f.open("logs\\warnings.txt","r")>=0)
		{
			string word="";
			uint pos=0;
			f.setPos(0);
			while(!f.isEndOfFile())
			{
				pos=f.getPos();
				if(pos==0)
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",0,1,0,word,null);
				}
				else
				{
					f.readLine(word);
					cr.RunClientScript("client_main@loger",1,1,0,word,null);
				}
			}
			f.close();
		}
		else
		Log("can't open!");
	}
	if(answerI==2)
	{
		file f;
		if(f.open("logs\\help_pleads.txt","w")>=0)
		{
			
			f.close();
		}
		else
		Log("can't open!");
	}
	if(answerI==3)
	{
		file f;
		if(f.open("logs\\help_pleads.txt","w")>=0)
		{
			
			f.close();
		}
		else
		Log("can't open!");
	}
}

bool e_GmPistolPick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		DeleteItem(item);
	}
	return false;
}

bool e_GmPistolAttack(Item&item,Critter&cr,Critter&target)
{
	if(cr.IsPlayer())
	{
		if(cr.GetAccess()>=(2))
		{
			cr.StatBase[(90)]=target.Id;
			cr.ShowScreen((2),5,"answer_GmPistolAttack_GM");
			cr.Say((18),"Че те надо, карман?");
			cr.Say((19+(0)),"предупреждение");
			cr.Say((19+(1)),"+ опыт");
			cr.Say((19+(2)),"+ скиллпоинты");
			cr.Say((19+(3)),"+ деньги");
			cr.Say((19+(4)),"+ нокаут");
			return true;
		}
		else
		{
			cr.StatBase[(90)]=target.Id;
			cr.ShowScreen((2),7,"answer_GmPistolAttack_player");
			cr.Say((18),"Сам се тут митолки рисует, а другим, типа, нельзя?");
			cr.Say((19+(0)),"сленг");
			cr.Say((19+(1)),"повергейминг");
			cr.Say((19+(2)),"выход из роли");
			cr.Say((19+(3)),"мародерство");
			cr.Say((19+(4)),"клептомания");
			cr.Say((19+(5)),"метагейм");
			cr.Say((19+(6)),"мультоводство");
			return true;
		}
	}
	return true;
}

import uint GetAllPlayers(Critter@[]&crs)from"manager";

void answer_GmPistolAttack_player(Critter&cr,uint answerI,string&answerS)
{
	Critter@target=GetCritter(cr.Stat[(90)]);
	if(target is null or target.IsNpc())
	{
		cr.Say((11),"Игрок не найден.");
		return;
	}
	if(cr.Param[(95)]>3)
	return;
	cr.ParamBase[(95)]+=1;
	string plead;
	if(answerI==0)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"НА СЕРВЕРЕ ЗАПЕРЩЕН СЛЕНГ И НЕИГРОВОЕ ОБЩЕНИЕ");
		plead=" - сленг";
	}
	else if(answerI==1)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"НЕ СТРОЙТЕ ИЗ СЕБЯ РЕМБО, ПОМНИТЕ ОБ ИНСТИНКТЕ САМОСОХРАНЕНИЯ");
		plead=" - рембо";
	}
	else if(answerI==2)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"ПРИДЕРЖИВАЙТЕСЬ СВОЕЙ ИГРОВОЙ РОЛИ");
		plead=" - несоответствие роли";
	}
	else if(answerI==3)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"БЕЗСИСТЕМНОЕ ЛУТАНИЕ ТРУПОВ ЭТО МАРОДЕРСТВО, ОСТАНОВИТЕСЬ");
		plead=" - мародерство";
	}
	else if(answerI==4)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"НЕ ШАРЬТЕСЬ ГДЕ ПОПАЛО, ПРИСТРЕЛЯТ ЗА ВОРОВСТВО");
		plead=" - клептомания";
	}
	else if(answerI==5)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"ИСПОЛЬЗОВАНИЕ ИНФОРМАЦИИ ПОЛУЧЕННОЙ НЕИГРОВЫМ ПУТЕМ ЗАПРЕЩЕНО");
		plead=" - метагейм";
	}
	else if(answerI==6)
	{
		target.ShowScreen((2),0,"answer_NULL");
		target.Say((18),"ЗАПРЕЩЕНО ВЗАИМОДЕЙСТВИЕ МЕЖДУ СВОИМИ ПЕРСОНАЖАМИ");
		plead=" - мультоводство";
	}
	if(plead!="")
	{
		cr.Say((11),"предупреждение выдано");
		Critter@[]crs;
		GetAllPlayers(crs);
		string str="жалоба от |0xFFFF0000 <|0xFFFFFF00 "+GetPlayerName(cr.Id)+"("+cr.Id+") на "+GetPlayerName(target.Id)+"("+target.Id+")|0xFFFF0000 > |0xFFBB33CC "+plead;
		for(uint i=0,j=crs.length();i<j;i++)
		{
			if(crs[i]is null or crs[i].GetAccess()<(2))
			continue;
			crs[i].Say((11),str);
		}
		file f;
		if(f.open("logs\\warnings.txt","a")>=0)
		{
			f.writeString("жалоба от "+GetPlayerName(cr.Id)+"\t "+cr.Id+"\t на "+GetPlayerName(target.Id)+"\t"+target.Id+"\t"+plead+"\n");
			f.close();
		}
	}
}

void answer_NULL(Critter&cr,uint answerI,string&answerS)
{
	return;
}

void answer_GmPistolAttack_GM(Critter&cr,uint answerI,string&answerS)
{
	Critter@target=GetCritter(cr.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerI==0)
	{
		Warn(cr,target.Id,0,0);
	}
	else if(answerI==1)
	{
		cr.ShowScreen((5),0,"item@GmPistol_exp");
	}
	else if(answerI==2)
	{
		cr.ShowScreen((5),0,"item@GmPistol_skill");
	}
	else if(answerI==3)
	{
		cr.ShowScreen((5),0,"item@GmPistol_money");
	}
	else if(answerI==4)
	{
		cr.ShowScreen((5),0,"item@GmPistol_knockdown");
	}
}

void GmPistol_exp(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.StatBase[(76)]+=number;
		player.Say((11),"вы выдали "+number+" опыта игроку "+target.Id);
	}
}

void GmPistol_skill(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.StatBase[(78)]+=number;
		player.Say((11),"вы выдали "+number+" скиллпоинтов игроку "+target.Id);
	}
}

void GmPistol_money(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.AddItem((41),number);
		player.Say((11),"вы выдали "+number+" монет, персонажу "+target.Id);
	}
}

void GmPistol_knockdown(Critter&player,uint answerI,string&answerS)
{
	Critter@target=GetCritter(player.Stat[(90)]);
	if(!(@target!=null))
	return;
	if(answerS.length()>0)
	{
		int number=0;
		StrToInt(answerS,number);
		target.ToKnockout(((Random(0,1)==0?true:false)?(82):(83)),((Random(0,1)==0?true:false)?(86):(87)),((Random(0,1)==0?true:false)?(88):(89)),number,target.HexX,target.HexY);
		player.Say((11),"вы уронили игрока "+target.Id+" на "+number);
	}
}

void _InitRPStuff(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_RPStuffUse");
}

bool e_RPStuffUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(item.Val0==0)
	{
		cr.ShowScreen((5),0,"item@RPStuffUseScreen");
		cr.StatBase[(90)]=item.Id;
	}
	else
	cr.Say((11),"уже заполненно");
	return true;
}

void RPStuffUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@item=GetItem(player.StatBase[(90)]);
		uint16 itemPid=item.GetProtoId();
		
		switch(itemPid)
		{
			case(1527):
			item.SetLexems(""+answerS);
			break;
			case(1528):
			item.SetLexems(""+answerS);
			break;
			case(1529):
			item.SetLexems(""+answerS);
			break;
			case(1530):
			item.SetLexems(""+answerS);
			break;
			case(1531):
			item.SetLexems(""+answerS);
			break;
			case(1532):
			item.SetLexems(""+answerS);
			break;
			case(1533):
			item.SetLexems(""+answerS);
			break;
		}
		
		item.Val0=1;
		item.Update();
	}
}

void _InitPuti(Item&item,bool firstTime)
{
	item.SetEvent((5),"e_PutiDrop");
}

void e_PutiDrop(Item&item,Critter&cr)
{
	if(cr.CountItem((694))!=0||cr.CountItem((692))!=0)
	{
		cr.AddItem((1534),1);
		cr.Say((11),"Вы не можете снять путы");
	}
	DeleteItem(item);
} 

void _InitCodeDoor(Item&item,bool firstTime)
{
	Log("Depracated function item@_InitCodeDoor at item.Id "+item.Id); 
	
}              

void _InitAidKit(Item&item,bool firstTime)
{
	item.SetLexems("Медикаментов там "+SetupAidLeX(item.Indicator)+".");
}

string SetupAidLeX(uint8 aidValue)
{
	string resultTemp="";
	
	if(aidValue==100)
	resultTemp="полная сумка";
	else if(aidValue>80)
	resultTemp="достаточно";
	else if(aidValue>60)
	resultTemp="чуть больше половины";
	else if(aidValue>40)
	resultTemp="немного меньше половины";
	else if(aidValue>20)
	resultTemp="совсем не много";
	else if(aidValue>10)
	resultTemp="на дне";
	else if(aidValue>0)
	resultTemp="практически нет";
	else if(aidValue==0)
	resultTemp="нет";
	
	return resultTemp;
}

void _AutoDoorInit(Item&item,bool firstTime)
{
	if(item.GetProtoId()==(1544))
	item.SetEvent((7),"e_AutoDoorWalk");
}

void e_AutoDoorWalk(Item&item,Critter&cr,bool entered,uint8 dir)
{
	Item@door=GetItem(item.Val1);
	if(!(@door!=null))
	{
		DeleteItem(item);
		return;
	}
	
	Map@map=cr.GetMap();
	if(entered)
	{
		if((@cr!=null)&&cr.IsPlayer()&&cr.StatBase[(67)]<(5)&&!(((door.LockerCondition)&((0x01)))!=0)&&!(((door.LockerCondition)&((0x02)))!=0)&&!(door.LockerCondition==(0x20))&&map.GetData(24)>0)
		{
			door.LockerOpen();
		}
	}
	else
	{
		if((@cr!=null)&&cr.IsPlayer()&&cr.StatBase[(67)]<(5)&&map.GetData(24)>0)
		{
			uint16 x=0;
			uint16 y=0;
			@map=door.GetMapPosition(x,y);
			if(map.GetCrittersHex(x,y,1,(0x01),null)==0)door.LockerClose();
		}
	}
}

void _PillsInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_PillsUse");
}

bool e_PillsUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"принимает таблетки");
	if(item.GetProtoId()==(333))
	{
		cr.StatBase[(73)]+=1;
		return true;
	}
	else if(item.GetProtoId()==(1548))
	{
		cr.StatBase[(73)]+=1;
		cr.Say((11),"Уровень заражения "+cr.StatBase[(147)]+" "+cr.StatBase[(0x008)]+". Используйте навык доктора на себе, если есть заражение");
		return true;
	}
	return true;
}

void _MercsSignInit(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_MercsSign");
}

bool e_MercsSign(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"показывает плакат с нарисованным копотом");
	return true;
}

void _MercsSign2Init(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_MercsSign2");
}

bool e_MercsSign2(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((6),"показывает нашивку с нарисованным копотом");
	return true;
}

void _InitEmptyHypo(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_EmptyHypoUse");
}

bool e_EmptyHypoUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	bool onSelf=(!(@onCritter!=null)&&!(@onItem!=null)&&!(@onScenery!=null));
	if(onSelf)
	{
		Item@hypo=cr.AddItem((1550),1);
		hypo.Val1=cr.Id;
		hypo.Val2=cr.Stat[(64)];
		hypo.Val3=cr.StatBase[(187)];
		hypo.Val4=cr.Param[(67)];
		hypo.Val5=cr.Stat[(73)];
		hypo.Val6=cr.Stat[(74)];
		cr.StatBase[(90)]=hypo.Id;
		cr.ShowScreen((5),0,"item@HypoUseScreen");
		hypo.Update();
		cr.DeleteItem((318),1);
		cr.Say((11),"Вы взяли у себя образец крови.");
		cr.Say((6),"Берет образец крови");
		return true;
	}
	else if(cr.IsPlayer()&&(@cr!=null)&&(@onCritter!=null))
	{
		if(cr.Timeout[(238)]>0||onCritter.Timeout[(238)]>0)
		{
			cr.Say((11),"Это неуместно");
			return true;
		}
		Item@hypo=cr.AddItem((1550),1);
		hypo.Val1=onCritter.Id;
		hypo.Val2=onCritter.Stat[(64)];
		hypo.Val3=onCritter.StatBase[(187)];
		hypo.Val4=onCritter.Param[(67)];
		hypo.Val5=onCritter.Stat[(73)];
		hypo.Val6=onCritter.Stat[(74)];
		cr.StatBase[(90)]=hypo.Id;
		cr.ShowScreen((5),0,"item@HypoUseScreen");
		hypo.Update();
		cr.DeleteItem((318),1);
		cr.Say((11),"Вы взяли образец крови.");
		cr.Say((6),"Берет образец крови");
		return true;
	}
	else
	cr.Say((11),"Это неуместно");
	return true;
}

void HypoUseScreen(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()!=0)
	{
		Item@Hypo=GetItem(player.StatBase[(90)]);
		Hypo.SetLexems("$HypoLex"+answerS);
		Hypo.Update();
	}
}

void _InitBloodHypo(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_BloodHypoUse");
	item.SetEvent((4),"e_BloodHypoSkill");
}

import void ApplyDesease(Critter&player,int param0,int param1)from"morphes";

bool e_BloodHypoUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	bool onSelf=(!(@onCritter!=null)&&!(@onItem!=null)&&!(@onScenery!=null));
	if(onSelf)
	{
		if(item.Val3!=0)
		{
			if(item.Val1==0&&cr.StatBase[(187)]<=item.Val3)
			{
				if(cr.GetTimeEvents(7,null,null,null)>0&&cr.Stat[(64)]>0)
				{
					cr.EraseTimeEvents(7);
					cr.StatBase[(64)]=0;
				}
				cr.StatBase[(187)]=item.Val3;
			}
			else if(item.Val2!=0||Random(0,1)>0)
			ApplyDesease(cr,cr.Id,item.Val3);
			else if(cr.StatBase[(187)]<item.Val3)
			cr.StatBase[(187)]=item.Val3;
		}
		cr.Say((11),"Вы вкололи шприц себе.");
		cr.Say((6),"Вкалывает шприц");
		DeleteItem(item);
		return true;
	}
	else if(cr.IsPlayer()&&(@cr!=null)&&(@onCritter!=null))
	{
		if(cr.Timeout[(238)]>0||onCritter.Timeout[(238)]>0)
		{
			cr.Say((11),"Это неуместно");
			return true;
		}
		if(item.Val3!=0&&onCritter.IsPlayer())
		{
			if(item.Val1==0&&onCritter.StatBase[(187)]<=item.Val3)
			{
				if(onCritter.GetTimeEvents(7,null,null,null)>0&&onCritter.Stat[(64)]>0)
				{
					onCritter.EraseTimeEvents(7);
					onCritter.StatBase[(64)]=0;
				}
				onCritter.StatBase[(187)]=item.Val3;
			}
			else if(item.Val2!=0||Random(0,1)>0)
			ApplyDesease(cr,onCritter.Id,item.Val3);
			else if(onCritter.StatBase[(187)]<item.Val3)
			onCritter.StatBase[(187)]=item.Val3;
		}
		cr.Say((11),"Вы вкололи шприц.");
		cr.Say((6),"Вкалывает шприц");
		DeleteItem(item);
		return true;
	}
	else
	cr.Say((11),"Это неуместно");
	return true;
}

bool e_BloodHypoSkill(Item&item,Critter&cr,int skill)
{
	if(skill==(212))
	{
		int body=item.Val4;
		if(cr.CountItem((91))==0)
		{
			cr.Say((11),"Вам нужны соответствующие инструменты для анализа крови.");
			return true;
		}
		else if(cr.Skill[(212)]>50||cr.Skill[(212)]>50)
		{
			switch(body)
			{
				case 0:
				cr.Say((11),"Это кровь человека.");
				break;
				case 1:
				cr.Say((11),"Это кровь человека.");
				break;
				case 2:
				cr.Say((11),"Это кровь человека.");
				break;
				case 3:
				cr.Say((11),"Это кровь супермутанта.");
				break;
				case 4:
				cr.Say((11),"Это кровь гуля.");
				break;
				case 5:
				cr.Say((11),"Это кровь брамина.");
				break;
				case 6:
				cr.Say((11),"Это кровь скорпиона");
				break;
				case 7:
				cr.Say((11),"Это кровь крысы");
				break;
				case 8:
				cr.Say((11),"Это кровь летуна");
				break;
				case 9:
				cr.Say((11),"Это кровь кентавра");
				break;
				case 10:
				cr.Say((11),"Это гидравлическая жидкость, непонятно как она попала в шприц.");
				break;
				case 11:
				cr.Say((11),"Это кровь собаки");
				break;
				case 12:
				cr.Say((11),"Это жидкость мантиса");
				break;
				case 13:
				cr.Say((11),"Это кровь смертокогтя");
				break;
				case 14:
				cr.Say((11),"Это жидкость из растения");
				break;
				case 15:
				cr.Say((11),"Это кровь гекко");
				break;
				case 16:
				cr.Say((11),"Это кровь чужого");
				break;
			}
			if(cr.Skill[(212)]>100&&body<=4)
			{
				if(item.Val2==0)
				cr.Say((11),"Уровень лейкоцитов в норме.");
				else if(item.Val2<=50)
				cr.Say((11),"В крови присутствуют следы воздействия какого-то вируса.");
				else
				cr.Say((11),"Заметны образования в крови, видимо воздействие вируса было довольно продолжительным.");
			}
		}
		return true;
	}
	return false;
}

void _InitPackage(Item&item,bool firstTime)
{
	item.SetEvent((5),"e_PackageDrop");
	item.SetEvent((6),"e_PackageMove");
	item.SetEvent((4),"e_PackagePick");
}

void e_PackageDrop(Item&item,Critter&cr)
{
	cr.ModeBase[(539)]=0;
	cr.ModeBase[(540)]=0;
}

void e_PackageMove(Item&item,Critter&crit,uint8 fromSlot)
{
	if(item.CritSlot==(1))
	{
		crit.ModeBase[(539)]=0;
		crit.ModeBase[(540)]=1;
	}
	if(fromSlot==(1))
	{
		crit.ModeBase[(539)]=1;
		crit.ModeBase[(540)]=1;
		crit.Say((11),"Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести.");
	}
}

bool e_PackagePick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		if(cr.CountItem((1542))==0)
		{
			cr.ModeBase[(539)]=1;
			cr.ModeBase[(540)]=1;
			cr.Say((11),"Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести.");
			return false;
		}
		return true;
	}
	return true;
}

void _InitCompas(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_CompasUse");
}

bool e_CompasUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	string output="";
	
	Location@loc=GetLocation(5);
	if(loc!is null)
	{
		int x=cr.WorldX*0.1-loc.WorldX*0.1,y=cr.WorldY*0.1-loc.WorldY*0.1;
		if(cr.Skill[(217)]<100)
		{
			output+="Модок находиться : ";
			
			if(y>0)
			output+="Северо-";
			else if(y<0)
			output+="Юго-";
			if(x>0)
			output+="Западней";
			else if(x<0)
			output+="Восточней";
			else if(y>0)
			output="Модок находиться : Севернее";
			else if(y<0)
			output="Модок находиться : Южнее";
			else
			output="Стрелка постоянно крутится";
		}
		if(cr.Skill[(217)]>=100)
		{
			output="Координаты : x="+x+", y="+y;
		}
	}
	else
	output="Компас заклинило.";
	
	cr.Say((11),output);
	
	return false;
}

void Item_SetFrame(Item&item,uint8 frame)
{
	item.AnimStayBegin=frame;
	item.AnimStayEnd=frame;
	item.AnimShowBegin=frame;
	item.AnimShowEnd=frame;
	item.AnimHideBegin=frame;
	item.AnimHideEnd=frame;
	
	return;
} 

import void AffectPoison(Critter&cr,int value)from"poison";
import void AffectRadiation(Critter&cr,int value)from"radiation";

void ProccessFood(Critter&cr,Item&item)
{
	uint flag=item.Proto.Food_Flags;
	
	if(item.GetProtoId()==(533))cr.AddItem((532),1);
	if(item.GetProtoId()==(1627)||
	item.GetProtoId()==(106)||
	item.GetProtoId()==(124)||
	item.GetProtoId()==(125)||
	item.GetProtoId()==(310)||
	item.GetProtoId()==(311)||
	item.GetProtoId()==(469))
	cr.AddItem((542),1);
	
	if(flag!=0)
	{   
		
		if(((((0x00000004))&(flag))!=0))
		{
			AffectPoison(cr,Random(25,55));
		}
		if(((((0x00000002))&(flag))!=0))
		{
			AffectRadiation(cr,Random(20,55));
		}
	}
	
}

void _GasMask(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_GasMaskUse");
	item.SetEvent((6),"e_GasMaskMove");
}

void e_GasMaskMove(Item&item,Critter&crit,uint8 fromSlot)
{
	if(item.CritSlot==(2))
	{
		crit.Say((11),"Вы одели респиратор.");
	}
	if(fromSlot==(2))
	{
		crit.Say((11),"Вы сняли респиратор.");
	}
}

bool e_GasMaskUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	if(cr.GetItems((2),null)!=0)
	{
		cr.Say((11),"Уберите из рук все лишнее, чтобы нормально одеть респиратор.");
	}
	else
	{
		cr.MoveItem(item.Id,1,(2));
	}
	return true;
}

void _FireFood(Item&item,bool firstTime)
{
	item.SetEvent((2),"e_FireFoodUse");
}

bool e_FireFoodUse(Item&item,Critter&cr,Critter@onCritter,Item@onItem,Scenery@onScenery)
{
	cr.Say((11),"Пока нет функционала.");
	return false;
}

void _BonesInit(Item&item,bool firstTime)
{
	item.SetEvent((3),"e_BonesUseItem");
}

bool e_BonesUseItem(Item&item,Critter&crit,Item@usedItem)
{
	if((@usedItem!=null)&&usedItem.GetProtoId()==(289))
	{
		DeleteItem(item);
		crit.Say((11),"Вы закопали тело.");
		return true;
	}
	return false;
} 

void _InitToken(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_TokenPick");
	item.SetEvent((5),"e_TokenDrop");
	item.SetEvent((6),"e_TokenMove");
}

bool e_TokenPick(Item&item,Critter&cr,int skill)
{
	DeleteItem(item);
	return false;
}

void e_TokenDrop(Item&item,Critter&crit)
{
	DeleteItem(item);
}

void e_TokenMove(Item&item,Critter&crit,uint8 fromSlot)
{
	DeleteItem(item);
}

void SetWorkbench(Critter&cr,int p0,int p1,int p2)
{
	Item@item=GetItem(p0);
	if(!(@item!=null))return;
	item.SetScript("_InitWorkBench");
	item.Update();
}

void _InitWorkBench(Item&item,bool firstTime)
{
	item.SetEvent((4),"e_WorkBenchPick");
	item.SetEvent((3),"e_WorkBenchCloneKey");
}

bool e_WorkBenchCloneKey(Item&item,Critter&crit,Item@usedItem)
{
	if((@usedItem!=null)&&usedItem.GetType()==(7))
	{
		if(crit.CountItem((475))<=0)
		{
			crit.Say((11),"Вам нужна железная болванка.");
			return true;
		}
		Item@newKey=crit.AddItem((1313),1);
		newKey.LockerId=usedItem.LockerId;
		newKey.SetLexems("$KeyLex"+"some key");
		crit.StatBase[(90)]=newKey.Id;
		crit.ShowScreen((5),0,"item@KeyUseScreen");
		newKey.Update();
		crit.DeleteItem((475),1);
		return true;
	}
	return false;
}

bool e_WorkBenchPick(Item&item,Critter&cr,int skill)
{
	if((skill==(-1))&&(item.Accessory==(2)))
	{
		Item@Workplace;
		@Workplace=cr.GetMap().GetItem(cr.HexX,cr.HexY,(1524));
		if(!(@Workplace!=null))
		{
			@Workplace=cr.GetMap().AddItem(cr.HexX,cr.HexY,(1524),1);
			Workplace.SetScript("_WorkplaceInit");
		}
		
		if(cr.CountItem((3978))==0)cr.AddItem((3978),1);
		cr.ShowScreen((9),0,"");
	}
	return true;
}

void _WorkplaceInit(Item&item,bool firstTime)
{
	item.SetEvent((7),"e_WorkplaceWalk");
}

void e_WorkplaceWalk(Item&item,Critter&cr,bool entered,uint8 dir)
{
	if(!entered)
	{
		Item@Token=cr.GetItem((3978),-1);
		if((@Token!=null))DeleteItem(Token);
		Item@Token2=cr.GetItem((3979),-1);
		if((@Token2!=null))DeleteItem(Token2);
	}
}
