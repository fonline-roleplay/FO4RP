                                                                                                               

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
}

uint ParseEntires(Map&map,Entire[]&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	Entire[]entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

string@GetDateString()
{     
	
	return(__Year+"_"+__Month+"_"+__Day);
}

string@GetDateString(int delta)
{
	uint16 year=0,month=0,day_of_week=0,day=0,hour=0,minute=0,second=0;
	
	GetGameTime(__FullSecond+delta,year,month,day,day_of_week,hour,minute,second);
	
	return(year+"_"+month+"_"+day);
}                 

shared interface iManagerModule{
	bool manager_init();
}
shared interface iManager_loop{
	uint global_loop();
}
shared interface iManager_critter_init{
	bool global_critter_init(Critter&cr,bool firstTime);
}
shared interface iManager_critter_finish{
	bool global_critter_finish(Critter&cr,bool toDelete);
}
shared interface iManager_critter_idle{
	bool global_critter_idle(Critter&cr);
}
shared interface iManager_critter_dead{
	bool global_critter_dead(Critter&cr,Critter@killer);
}
shared interface iManager_critter_respawn{
	bool global_critter_respawn(Critter&cr);
}
shared interface iManager_map_critter_in{
	bool global_map_critter_in(Map&map,Critter&cr);
}
shared interface iManager_map_critter_out{
	bool global_map_critter_out(Map&map,Critter&cr);
}
shared interface iManager_world_save{
	bool global_world_save();
}
shared interface iManager_player_registration{
	bool global_player_registration(uint ip,string&name,uint&textMsg,uint&strNum);
}
shared interface iManager_player_login{
	bool global_player_login(uint ip,string&name,uint id,uint&textMsg,uint&strNum);
}
shared interface iManager_time{
	bool global_time(int8 type);
}
shared interface iManagerElement
{
	iManagerModule@GetLink();
	uint GetId();
	string&GetName();
	uint&GetEventFlags();
	int8&GetTimeChangeCall();
	uint8 GetPriority();
}                     

import iManagerElement@manager_add_module(iManagerModule@link,string&name,uint8 priority)from"manager";        

import void FindEncounter(Critter@[]&group,Item@car,uint x,uint y,uint&encounterDescriptor,bool&waitForAnswer,bool empty,int ec)from"worldmap";
import void InviteToEncounter(Critter@[]&group,Item@car,uint encounterDescriptor,int combatMode,uint&mapId,uint16&hexX,uint16&hexY,uint8&dir)from"worldmap";
import bool CheckFoundedEncounter(uint index)from"worldmap";
import uint GetGlobalMapRelief(uint x,uint y)from"worldmap";

import uint GenerateWasteland(Critter&cr,uint8 x,uint8 y)from"mapgen_wasteland";

import void testgen(Critter&cr,int,int,int)from"mapgen_wasteland";    

import void StartArcadeMenu(Critter@cr)from"arcade_menu";

import bool SpawnItemCell(uint mapId)from"local_population";
import void AddCritter(Map&map)from"local_population";

import bool IsTileAvalible(uint hash,uint8 group)from"cimp";
import bool IsTileGround(uint hash)from"cimp";                          

class CellContent
{
	uint[]MapId;
	uint Index;
	uint8 Type;
	int8 Visibility;
	uint8 Durability;
	
	uint[][]Critters;
	
	CellContent()
	{
		
		Index=uint(-1);
		Type=0;
		Visibility=0;
		Durability=0;
		
		Critters.resize((4));
		MapId.resize((5));
		
		MapId[(2)]=0;
	}
	
	CellContent(uint mapId,uint8 type,int8 visibility)
	{
		Index=uint(-1);
		Type=type;
		Visibility=visibility;
		Durability=255;
		
		Critters.resize((4));
		MapId.resize((5));
		MapId[(2)]=mapId;
	}
	
	uint GetCrittersCount(int type)
	{
		if(type>=0)
		{
			if(type>=(4))
			return 0;
			
			return Critters[type].length();
		}
		else
		{
			uint count=0;
			for(uint i=0;i<(4);i++)
			{
				count+=Critters[i].length();
			}
			return count;
		}
	}
	
	uint GetCritters(Critter@[]crs,int type)
	{
		if(type>=0)
		{
			if(type>=(4))
			return 0;
			
			uint[]@crIds=Critters[type];
			Critter@cr=null;
			
			uint k=crs.length(),
			len=crIds.length();
			
			crs.resize(k+len);
			
			for(uint i=0;i<len;i++)
			{
				@cr=GetCritter(crIds[i]);
				if(cr is null)
				continue;
				
				@crs[k++]=cr;
			}
			
			crs.resize(k);
			
			return k;
		}
		else
		{
			uint[]@crIds=Critters[type];
			Critter@cr=null;
			
			uint k=crs.length(),
			len=0;
			
			for(uint i=0;i<(4);i++)
			{
				len=crIds.length();
				crs.resize(k+len);
				
				for(uint t=0;t<len;t++)
				{
					@cr=GetCritter(crIds[t]);
					if(cr is null)
					continue;
					
					@crs[k++]=cr;
				}
				
			}
			
			return k;
		}
	}
	
	bool ShiftCritter(Critter&cr,uint type,bool del)
	{
		if(type>=(4))
		return false;
		
		if(del)
		{
			int index=Critters[type].find(cr.Id);
			
			if(index==-1)
			return false;
			
			Critters[type].removeAt(index);
		}
		else
		{
			Critters[type].insertLast(cr.Id);
		}
		return true;
	}
	
	Map@GetMap()
	{
		return::GetMap(MapId[(2)]);
	}
	
	Map@GetMap(int level)
	{
		return::GetMap(MapId[(2)]+level);
	}
	
}

class Cell
{
	
	uint8 SizeX;
	uint8 SizeY;
	uint8 ParantX;
	uint8 ParantY;
	uint16 X;
	uint16 Y;
	uint8 Wildness;
	CellContent@Content;
	
	uint8 PopulationMax;
	uint16 MonsterType;
	int MonsterCount;
	bool IsHavePopulation;   
	
	Cell()
	{
		
		Wildness=50;
		SizeX=1;
		SizeY=1; 
		
		MonsterType=0;
		MonsterCount=0;
		PopulationMax=50;
		IsHavePopulation=false;
	}
	
	uint8 ChangeWildness(int delta)
	{
		int wild=Wildness+delta;
		wild=(((wild)>(100))?(100):(((wild)<(0))?(0):(wild)));
		Wildness=uint8(wild);
		
		return Wildness;
	}
	
	void DropWildness()
	{
		Wildness=0;
		Log("Wildness "+Wildness);
	}
	
	void ChangeMonsterCount(bool increase)
	{
		if(!increase)
		{
			if(MonsterCount>0)
			MonsterCount--;
		}
		else
		{
			MonsterCount++;
		}
	}
	
	void ChangeMonsterCount(uint8 count,bool increase)
	{
		MonsterCount+=(increase?count:(count-(count*2)));
		MonsterCount=(((MonsterCount)>(PopulationMax))?(PopulationMax):(((MonsterCount)<(0))?(0):(MonsterCount)));
	}
	
	bool SetLocation(uint16 pid)
	{ 
		
		@Content=CellContent();
		if(Content is null)
		return false;
		
		uint id=CreateLocation(pid,X,Y,null);
		
		Location@loc=GetLocation(id);
		if(loc is null)
		return false;
		
		Content.MapId[(2)]=loc.GetMapByIndex(0).Id; 
		
		if(pid!=90)
		Content.Type=(0x2);
		else
		Content.Type=(0x10);
		
		return true;
	}
	
	int CellCreate(uint16 pid,bool force)
	{
		if(Content!is null&&!force)
		return-1;
		
		if(!SetLocation(pid))
		return-2;
		
		return 0;
	}
	
	int CellCreate(uint16 pid,int wildness,int livetime,bool force)
	{
		if(Content!is null&&!force)
		return-1;
		
		if(!SetLocation(pid))
		return-2;
		
		Wildness=wildness;
		Content.Durability=livetime;
		
		return 0;
	}
	
	int CellMove(uint16 x,uint16 y)
	{
		Cell@target=world.GetCell(x,y);
		if(target is null)
		return-1;    
		
		@target.Content=CellContent();
		target.Content.MapId=Content.MapId;
		target.Content.Durability=Content.Durability;
		target.Content.Type=Content.Type;
		
		@this.Content=null; 
		
		return 0;
	}
	
	int CellDelete()
	{
		if(Content is null)
		return-1;
		DeleteLocation(GetMap(Content.MapId[(2)]).GetLocation().Id);
		@Content=null;  
		
		return 0;
	}
	
	int CellSetSize(int x,int y)
	{
		
		for(uint8 i=0;i<y;++i)
		{
			for(uint8 j=0;j<x;++j)
			{
				Cell@child=world.GetCell(X-j,Y+i);
				if(child is null)
				{
					return-1;
				}
				
				if(child.Content is null)
				{
					@child.Content=CellContent();
				}
				
				child.ParantX=X;
				child.ParantY=Y;
				child.Wildness=Wildness;
				
				child.Content.MapId=Content.MapId;
				child.Content.Type=Content.Type;
				child.Content.Durability=Content.Durability;
				
			}
		}
		
		return 0;
	}
	
	bool SpawnLo()
	{
		if(!(Content is null))
		{
			return SpawnItemCell(Content.MapId[(2)]);
		}
		return false;
	}
	
	bool SpawnLo(int level)
	{
		if(!(Content is null))
		{
			return SpawnItemCell(Content.MapId[(2)+level]);
		}
		return false;
	}       
	
	void SetMapLevel(uint[]mapId)
	{
		if(!(Content is null))
		{
			Content.MapId=mapId;
		}
	}
}

class CellWorld:iManagerModule,iManager_map_critter_in,iManager_map_critter_out,iManager_world_save
{
	Cell[]Cells;
	uint16 CellsW;
	uint16 CellsH;
	
	CellWorld()
	{
		AddStartCallback("globalmap_group","start");
		
		CellsW=7*5;
		CellsH=12*5;
		Cells.resize(CellsW*CellsH);
		for(uint y=0;y<CellsH;y++)
		{
			uint cy=y*CellsW;
			for(uint x=0;x<CellsW;x++)
			{
				Cells[x+cy].X=x;
				Cells[x+cy].Y=y;
			}
		}
	}
	
	bool manager_init()
	{
		Init();
		
		return true;
	}
	
	uint GetCells(Cell@[]&cells,uint16 x,uint16 y,uint8 radius)
	{
		uint len=cells.length(),
		len2=len;
		
		if(radius<1)
		return len;
		
		for(uint8 i=1;i<=radius;i++)
		{
			len2+=i*8;
		}
		
		cells.resize(len2);
		int x0=x,y0=y;
		
		int h=1,g=0,u=0,r=1;
		
		for(uint i=len;i<len2;i++)
		{
			u=(g/h);
			
			x0+=(1-u)*r;
			y0+=u*r;
			
			@cells[i]=GetCell(x0,y0);
			g++;
			if(g>=h*2)
			{
				g=0;
				h+=1;
				r*=-1;
			}
		}
		
		return cells.length();
	}
	
	Cell@GetCell(Critter@cr)
	{
		uint16 x=cr.WorldX/10,y=cr.WorldY/10;
		if(x>=CellsW||y>=CellsH)
		return null;
		return Cells[x+y*CellsW];
	}
	
	Cell@GetCell(uint16 x,uint16 y)
	{
		if(x>=CellsW||y>=CellsH)
		return null;
		return Cells[x+y*CellsW];
	}
	
	Cell@GetCell(uint i)
	{
		if(i>=Cells.length())
		return null;
		return Cells[i];
	}
	
	Cell@GetCellByMap(uint id)
	{
		for(uint16 i=0,j=Cells.length();i<j;++i)
		{
			if(Cells[i].Content!is null&&Cells[i].Content.MapId.find(id)!=-1)
			return Cells[i];
		}
		
		return null;
	}
	
	void ShowCells(Critter&cr,Cell&cell)
	{
		int acc=cr.GetAccess();
		bool adm=acc==(3);
		
		bool showStatic=(adm||cr.Param[(703)]!=(3)),
		showWildness=(adm||(cr.Param[(703)]!=(3)&&cr.Param[(217)]>=50)),
		showEncs=(adm||cr.Param[(703)]==(3));
		
		uint8 radius=0;
		int vision=0;
		
		if(acc==(3))
		{
			radius=40;
			vision=255;
		}
		else if(cr.Param[(703)]==(3))
		{
			radius=5;
		}
		else
		{
			radius=(cr.Param[(217)]/100)+1;
			vision=cr.Param[(217)]/4;
		}
		
		Cell@[]cells={cell};
		
		uint len=GetCells(cells,cell.X,cell.Y,radius);
		
		int precision=((vision/256.0f)*5);
		precision=(5-precision)*5;
		
		int[]data_color(len*2),
		data_number(len*2),
		data_char(len*2);
		
		uint8 data_cellSize=1;
		
		uint dc=0,dn=0,dch=0,wild=0,color=0,number=uint(-1),chr=uint(-1),r=0,nr=0,zx=0,zy=0;
		Cell@cell0=null;
		CellContent@cont=null;
		int coord=0;
		
		for(uint i=0;i<len;i++)
		{
			if(i>nr)
			{
				r++;
				nr+=r*8;
			}
			
			Cell@cell0=cells[i];
			if(cell0 is null)
			continue;
			zx=cell0.X;
			zy=cell0.Y;
			
			color=0;
			number=uint(-1);
			chr=uint(-1);
			coord=int((zx&0xFFFF)|(zy<<16));
			
			@cont=cell0.Content;
			if(showStatic and cont!is null and(cont.Type&0x1F)==(0x2)and(vision+cont.Visibility>int(r*20)))
			{
				color=0x442222DD;
				chr=0x0011FF11|(uint(-47)<<24);
			}
			else if(showWildness)
			{
				wild=cell0.Wildness;
				
				if(wild<45||wild>55)
				{
					color=(wild/precision);
					color=0xFF*(1.0f-color*precision/100.0f);
					color=0x44000000|(0xFF-color)<<16|color<<8|color;
				}
			}
			
			if(color!=0)
			{
				data_color[dc++]=coord;
				data_color[dc++]=int(color);
			}
			
			if(chr!=uint(-1))
			{
				data_char[dch++]=coord;
				data_char[dch++]=int(chr);
			}
			
			if(showEncs&&cont!is null&&chr==uint(-1))
			{
				number=cont.GetCrittersCount((0));
				if(adm)
				number|=cont.GetCrittersCount((2))<<16;
				
				if(number==0)
				number=uint(-1);
			}
			
			if(number!=uint(-1))
			{
				data_number[dn++]=coord;
				data_number[dn++]=int(number);
			}     
			
		}  
		
		data_color.resize(dc);
		cr.RunClientScript("client_main@_dr",1,0,0,null,data_color);  
		
		data_number.resize(dn);
		cr.RunClientScript("client_main@_dr",2,0,0,null,data_number);  
		
		data_char.resize(dch);
		cr.RunClientScript("client_main@_dr",3,0,0,null,data_char);   
		
	} 
	
	void CreateCell(uint16 x,uint16 y,uint mapId,uint8 type,int8 visibility)
	{ 
		
		Cell@cell=GetCell(x,y);
		if(cell is null)
		{
			Log("null cell");
			return;
		}
		
		@cell.Content=CellContent();
		cell.Content.MapId[(2)]=mapId;
		cell.Content.Type=type;
		cell.Content.Visibility=visibility;
		
		cell.ParantX=cell.X;
		cell.ParantY=cell.Y;
		
		Map@map=GetMap(mapId);
		if(map is null)
		return;
		
		map.SetData(56,1);
		map.SetData(57,0);
		map.SetData(58,0); 
		
		if(cell.Content==null)
		Log("null content");
	}
	
	Cell@PassCell(Critter&cr)
	{
		Cell@cell=GetCell(cr);
		if(cell is null)
		return null;
		
		int tt=((int(cell.X)&0xFFFF)|(int(cell.Y)<<16));
		if(cr.Param[(96)]!=tt)
		{
			cr.ParamBase[(96)]=tt;
			
			return cell;
		}
		return null;
	}
	
	void Init()
	{
		Map@[]maps;
		uint mlen=GetAllMaps(0,maps);
		for(uint i=0;i<mlen;i++)
		{
			if(maps[i]is null)
			continue;
			
			Map@map=maps[i];
			
			map.SetData(57,0);
			map.SetData(58,0);
		} 
		
		Location@[]locations;
		uint llen=GetAllLocations(0,locations);
		for(uint i=0;i<llen;i++)
		{
			if(locations[i]is null)
			continue;
			
			Location@loc=locations[i];
			
			Map@[]maps_;
			loc.GetMaps(maps_);
			
			if(maps_.length()<=0)
			continue; 
			
			Map@map=maps[0];
			if(map is null)
			continue;
			
			uint[]levels((5)); 
			
			for(uint8 ii=0,jj=maps_.length();ii<jj;++ii)
			{  
				
				int level=GetMapLevelByPid(maps_[ii].GetProtoId());
				levels[(2)+level]=maps_[ii].Id; 
				
			}  
			
			uint8 type=(0x0);
			int8 vis=0;
			
			bool pop=false;
			uint8 sizeX=1,sizeY=1;
			
			if(map.GetData(56)==0)
			{
				uint16 pid=loc.GetProtoId();
				if(LocIsCity(pid))
				vis=50;
				else if(LocIsMasked(pid))
				vis=5;
				else if(LocIsHidden(pid))
				vis=-100;
				else
				continue;
				type=(0x2);
				
				pop=true;
				
				switch(pid)
				{
					case(25):
					sizeX=2;
					sizeY=2;
					break;
					default:
					break;
				}
			}
			else
			{
				type=(0x10);
			}
			
			uint8 locWorldX=loc.WorldX*0.1,locWorldY=loc.WorldY*0.1;
			
			Cell@cell=GetCell(locWorldX,locWorldY);
			if(cell is null)
			continue;
			
			@cell.Content=CellContent();
			cell.Content.MapId.resize((5));
			cell.Content.MapId[(2)]=map.Id;
			cell.Content.Type=type;
			cell.Content.Visibility=vis;
			
			cell.ParantX=locWorldX;
			cell.ParantY=locWorldY;
			
			cell.IsHavePopulation=pop;
			
			cell.SetMapLevel(levels);  
			
			if(sizeX>1||sizeY>1)
			{
				for(uint8 y=0;y<sizeY;++y)
				{
					for(int x=0;x<sizeX;++x)
					{
						Cell@cell=GetCell(locWorldX-x,locWorldY+y);
						if(cell is null)
						continue;
						
						@cell.Content=CellContent();
						cell.Content.MapId.resize((5));
						cell.Content.MapId[(2)]=map.Id;
						cell.Content.Type=type;
						cell.Content.Visibility=vis;
						
						cell.SizeX=sizeX;
						cell.SizeY=sizeY;
						
						cell.ParantX=locWorldX;
						cell.ParantY=locWorldY;
						
						cell.SetMapLevel(levels); 
						
					}
				}
			}
		}
		
		if(IsAnyData("cells_v1")&&IsAnyData("cells_monsters_v1"))
		{
			int[]cells_data,
			cells_monsters_data;
			GetAnyData("cells_v1",cells_data);
			GetAnyData("cells_monsters_v1",cells_monsters_data);
			
			uint len=cells_data.length();
			
			if(len<=Cells.length())
			{
				for(uint i=0;i<len;i++)
				{
					Cells[i].Wildness=uint8(cells_data[i]);
					
					Cells[i].MonsterCount=uint8(cells_monsters_data[i]);
					Cells[i].MonsterType=MonsterTypeTable(Cells[i].Wildness);
				}
			}
		}
	}
	
	bool global_world_save()
	{
		uint clen=Cells.length();
		
		int[]cells_data(clen);
		int[]cells_monsters_data(clen);
		
		int dur=0;
		Cell@cell=null;
		CellContent@cont=null;
		for(uint i=0;i<clen;i++)
		{
			if(Cells[i].Wildness<100)
			Cells[i].Wildness+=Random(0,5-Cells[i].Wildness/20);
			
			@cell=Cells[i];
			
			cells_data[i]=cell.Wildness;
			cells_monsters_data[i]=cell.MonsterCount;
			
			@cont=cell.Content;
			
			if(cont!is null and cont.Type==(0x10))
			{
				dur=cont.Durability;
				dur+=(cont.GetCrittersCount((0))*2-1);
				if(dur<1)
				{
					Map@map=GetMap(cont.MapId[(2)]);
					if(map!is null)
					{
						Location@loc=map.GetLocation();
						if(loc!is null)
						{
							DeleteLocation(loc.Id);
						}
					}
					@cell.Content=null;
				}
				else
				{
					dur=(((dur)>(255))?(255):(((dur)<(1))?(1):(dur)));
					cont.Durability=uint8(dur);
				}
			}
		}
		
		SetAnyData("cells_v1",cells_data);
		SetAnyData("cells_monsters_v1",cells_monsters_data);
		
		return true;
	}
	
	bool global_map_critter_in(Map&map,Critter&cr)
	{
		cells_critter_shift(map,cr,false); 
		
		DypsneaCr(map,cr);
		cr.StatBase[(123)]=map.GetProtoId();
		cr.StatBase[(122)]=-1;
		
		return true;
	}
	bool global_map_critter_out(Map&map,Critter&cr)
	{
		cells_critter_shift(map,cr,true);   
		
		return true;
	}
	
	void cells_critter_shift(Map&map,Critter&cr,bool quit)
	{
		Cell@cell=GetCell(cr);
		if(cell is null)
		return;
		CellContent@cont=cell.Content;
		if(cont is null)
		return;  
		
		if(cr.IsNpc()&&cont.Type==(0x10))
		{
			if(!cont.ShiftCritter(cr,(3),quit))
			{
				Log("ShiftCritter mob fail"+(quit?", quit.":".")+" Id: "+cr.Id);
			}
		}
		else if(cr.IsPlayer()&&cont.MapId[(2)]==map.Id)
		{
			if(!cont.ShiftCritter(cr,((cr.Param[(703)]!=(3))?(0):(2)),quit))
			{
				Log("ShiftCritter player fail"+(quit?", quit.":".")+" Id: "+cr.Id);
			}
		}
		else
		return;
		
		Location@loc=map.GetLocation();
		if(cont.Type==(0x10)and loc!is null and loc.AutoGarbage)
		{
			loc.AutoGarbage=false;
		}
	}
	
	void GlobalPopulation()
	{
		for(uint16 i=0,j=Cells.length();i<j;++i)
		{
			if(Cells[i]is null||!Cells[i].IsHavePopulation)
			continue;          
			
			if(Cells[i].Content is null)
			continue;
			
			for(uint8 ii=0,jj=Cells[i].Content.MapId.length();ii<jj;++ii)
			{
				
				Map@map=GetMap(Cells[i].Content.MapId[ii]);
				if(map is null)
				continue;
				
				AddCritter(map);
			} 
			
		}
	}
	
	void GlobalSpawnLo()
	{
		for(uint16 i=0,j=Cells.length();i<j;++i)
		{
			if(Cells[i]is null||Cells[i].Content is null)
			continue;
			
			Cells[i].SpawnLo();
		}
	}
	
}

CellWorld world;       

void start()
{
	iManagerModule@module=world;
	iManagerElement@manager=manager_add_module(module,"CellWorld",20); 
	
}

bool ChangeWildness(uint i,int delta)
{
	Cell@cell=world.GetCell(i);
	if(cell is null)
	return false;
	
	cell.ChangeWildness(delta);
	return true;
}          

bool ChangeWildness(uint16 x,uint16 y,int delta)
{
	Cell@cell=world.GetCell(x,y);
	if(cell is null)
	return false;
	
	cell.ChangeWildness(delta);
	return true;
} 

void CellInfo(Critter&cr,int p0,int p1,int p2)
{
	Cell@cell=null;
	if(p0==0&&p1==0)
	{
		@cell=world.GetCell(cr);
	}
	else if(p0>0&&p1>0)
	{
		@cell=world.GetCell(uint16(p0),uint16(p1));
	}
	
	if(cell is null)
	return;
	
	cr.Say((11),"Cell: "+cell.X+":"+cell.Y+" Wildness: "+cell.Wildness);
	cr.Say((11),"Population: "+cell.MonsterCount+" Type: "+cell.MonsterType);
	
	CellContent@cont=cell.Content;
	
	if(cont is null)
	return;
	
	cr.Say((11),"MapId: "+cont.MapId[(2)]+" Type: "+cont.Type+" Index: "+cont.Index);
	cr.Say((11),"Visibility: "+cont.Visibility+" Durability: "+cont.Durability);
	cr.Say((11),"Online: "+cont.GetCrittersCount((0))+"/"+cont.GetCrittersCount((1))+"/"+cont.GetCrittersCount((2))+" Mobs: "+cont.GetCrittersCount((3)));
}

void CellMove(Critter&cr,int p0,int p1,int p2)
{
	Cell@cell=world.GetCell(cr);
	Cell@targetCell=world.GetCell(p0,p1);
	
	if(cell is null||targetCell is null)
	return;
	
	@targetCell=cell;
	@cell=Cell();
}

void ChWild(Critter&cr,int p0,int p1,int p2)
{
	uint16 x=p0,
	y=p1;
	
	if(p0==-1&&p1==-1)
	{
		x=cr.WorldX/10;
		y=cr.WorldY/10;
	}
	
	if(ChangeWildness(x,y,p2))
	Log("Ok.");
	else
	Log("Fail.");
}            

void global_process(int processType,Critter&cr,Item@car,
float&curX,float&curY,float&toX,float&toY,float&speed,
uint&encounterDescriptor,bool&waitForAnswer)
{
	int movementType=((@car!=null)?car.Proto.Car_MovementType:(0));
	int curXi=int(curX);
	int curYi=int(curY);
	
	if(processType==(0))
	{
		
		float lastDist=(sqrt((((curX)-(toX))*((curX)-(toX)))+(((curY)-(toY))*((curY)-(toY))))); 
		
		float speedPix=speed*float(__GlobalMapMoveTime)/1000.0f;
		float speedAngle=atan2(toY-curY,toX-curX);
		float speedX=cos(speedAngle)*speedPix;
		float speedY=sin(speedAngle)*speedPix;
		
		float speedMod=1.0f;
		if(movementType==(0))
		{  
			
			switch(GetGlobalMapRelief(curXi,curYi))
			{
				case 0x0:
				speedMod=1.00f;
				break;
				case 0x1:
				speedMod=0.55f;
				break;
				case 0x2:
				speedMod=0.60f;
				break;
				case 0x3:
				speedMod=0.65f;
				break;
				case 0x4:
				speedMod=0.70f;
				break;
				case 0x5:
				speedMod=0.75f;
				break;
				case 0x6:
				speedMod=0.80f;
				break;
				case 0x7:
				speedMod=0.85f;
				break;
				case 0x8:
				speedMod=0.90f;
				break;
				case 0x9:
				speedMod=0.95f;
				break;
				case 0xA:
				speedMod=1.00f;
				break;
				case 0xB:
				speedMod=1.10f;
				break;
				case 0xC:
				speedMod=1.20f;
				break;
				case 0xD:
				speedMod=1.30f;
				break;
				case 0xE:
				speedMod=1.40f;
				break;
				case 0xF:
				speedMod=1.50f;
				break;
				default:
				break;
			}
		}
		
		if((@car!=null)&&speedMod!=1.0f)
		{
			float pass=float(car.Proto.Car_Passability);
			if(pass>100.0f&&speedMod<1.0f)
			speedMod+=(1.0f-speedMod)*(pass-100.0f)/100.0f;
			else if(pass>100.0f&&speedMod>1.0f)
			speedMod-=(speedMod-1.0f)*(pass-100.0f)/100.0f;
			else if(pass<100.0f&&speedMod<1.0f)
			speedMod-=(1.0f-speedMod)*(100.0f-pass)/100.0f;
			else if(pass<100.0f&&speedMod>1.0f)
			speedMod+=(speedMod-1.0f)*(100.0f-pass)/100.0f;
		} 
		
		curX+=speedX*speedMod;
		curY+=speedY*speedMod;
		
		int oldXi=curXi;
		int oldYi=curYi;
		curXi=int(curX);
		curYi=int(curY); 
		
		if(oldXi!=curXi||oldYi!=curYi)
		{
			
			int gmWidth=__GlobalMapWidth*__GlobalMapZoneLength;
			int gmHeight=__GlobalMapHeight*__GlobalMapZoneLength;
			if(curXi<0||curYi<0||curXi>=gmWidth||curYi>=gmHeight)
			{
				if(curXi<0)
				curXi=0;
				if(curXi>=gmWidth)
				curXi=gmWidth-1;
				if(curYi<0)
				curYi=0;
				if(curYi>=gmHeight)
				curYi=gmHeight-1; 
				
				curX=float(curXi);
				curY=float(curYi);
				speed=0.0f;
				return;
			} 
			
			int relief=GetGlobalMapRelief(oldXi,oldYi);
			int steps=((((((curXi-oldXi)>0)?(curXi-oldXi):-(curXi-oldXi)))>((((curYi-oldYi)>0)?(curYi-oldYi):-(curYi-oldYi))))?((((curXi-oldXi)>0)?(curXi-oldXi):-(curXi-oldXi))):((((curYi-oldYi)>0)?(curYi-oldYi):-(curYi-oldYi))));
			int newXi=oldXi;
			int newYi=oldYi;
			if(steps>0)
			{
				float xx=float(oldXi);
				float yy=float(oldYi);
				float oxx=float(curXi-oldXi)/float(steps);
				float oyy=float(curYi-oldYi)/float(steps);
				
				for(int i=0;i<steps;i++)
				{
					xx+=oxx;
					yy+=oyy;
					int xxi=int(xx>=0.0f?xx+0.5f:xx-0.5f);
					int yyi=int(yy>=0.0f?yy+0.5f:yy-0.5f);
					
					if(xxi==350||yyi==600)
					break;
					
					uint relief_=GetGlobalMapRelief(xxi,yyi);
					if(movementType==(0)&&relief!=0&&relief_==0)
					break;
					if(movementType==(2)&&relief_!=0)
					break;
					
					newXi=xxi;
					newYi=yyi;
				}
			}
			
			if(newXi!=curXi||newYi!=curYi)
			{
				
				curX=float(newXi);
				curY=float(newYi);
				speed=0.0f;
				return;
			} 
			
			int oldZoneX=oldXi/__GlobalMapZoneLength;
			int oldZoneY=oldYi/__GlobalMapZoneLength;
			int curZoneX=curXi/__GlobalMapZoneLength;
			int curZoneY=curYi/__GlobalMapZoneLength; 
			
			if(oldZoneX!=curZoneX||oldZoneY!=curZoneY)
			{
				Critter@[]@group=cr.GetGlobalGroup();
				ScanZone(group,curZoneX,curZoneY);
			} 
			
			float curDist=(sqrt((((curX)-(toX))*((curX)-(toX)))+(((curY)-(toY))*((curY)-(toY)))));
			if(curDist<=0.01f||curDist>lastDist)
			{
				curX=toX;
				curY=toY;
				speed=0.0f;
				return;
			}
		} 
		
		if((@car!=null))
		{
			int fuel=car.Charge;
			int deterioration=car.Deterioration;
			
			if(fuel<=0||deterioration>=int(car.Proto.Car_MaxDeterioration))
			{
				uint str=(fuel<=0?(10255):(10256));
				cr.SayMsg((11),(3),str);
				speed=0.0f;
				return;
			} 
			
			fuel-=car.Proto.Car_FuelConsumption*__GlobalMapMoveTime/500;
			deterioration+=car.Proto.Car_DeteriorationRate*__GlobalMapMoveTime/500;
			if(fuel<0)
			fuel=0;
			if(deterioration>int(car.Proto.Car_MaxDeterioration))
			deterioration=int(car.Proto.Car_MaxDeterioration);
			
			if(fuel!=car.Charge||deterioration!=car.Deterioration)
			{
				car.Charge=fuel;
				car.Deterioration=deterioration;
				car.Update();
			}
		}                  
		
		Cell@cell=world.PassCell(cr);
		
		if(cell!is null)
		{
			Critter@[]@group=cr.GetGlobalGroup(); 
			
			Critter@leader=group[0];
			if(int(group.length())>leader.Stat[(3)]+leader.Perk[(399)])
			{
				leader.SayMsg((11),(3),(10258));
				speed=0.0f;
				return;
			}
			
			uint8 wild=cell.ChangeWildness((cr.Param[(703)]!=(3))?-1:1);
			
			world.ShowCells(cr,cell);
			
			CellContent@cont=cell.Content;
			if(cont is null or(cont.Type&0x1F)==(0x10))
			{
				if(cont!is null and cont.MapId[(2)]!=0&&GetMap(cont.MapId[(2)])!is null)
				{
					
					int chance=0;
					if(cr.Param[(703)]!=(3))
					{
						if(cont.GetCrittersCount((2))>0||cont.GetCrittersCount((3))>0)
						chance=cr.Skill[(217)]/2;
						else if(cont.GetCrittersCount((0))>0)
						chance=cr.Skill[(217)]/3;
						else
						chance=-1;
					}
					else
					{
						if(cont.GetCrittersCount((0))>0)
						chance=0;
						else
						chance=-1;
					}
					
					if(chance<0)
					{}
					else if(Random(0,100)>chance)
					{
						encounterDescriptor=uint(-1);
					}
					else
					{
						encounterDescriptor=uint(-1);
						waitForAnswer=true;
						cr.Say((15),"Вы видите нечто недалеко от вас");
						cr.Say((41),"");
					}
				}
				else
				{
					@cell.Content=null;
					
					FindEncounter(cr.GetGlobalGroup(),car,curXi,curYi,encounterDescriptor,waitForAnswer,false,wild);
				}
			}
			else if(cont.Visibility>0)
			(encounterDescriptor=uint(-1));
		}
	}
	else if(processType==(1))
	{                            
		
		Cell@cell=world.GetCell(cr);
		if(cell!is null)
		{
			CellContent@cont=cell.Content;
			if(cont is null or(cont.Type&0x1F)==(0x10))
			{
				if(cont!is null and cont.MapId[(2)]!=0&&GetMap(cont.MapId[(2)])!is null)
				{
					encounterDescriptor=uint(-1);
					cont.Index=uint(-1);
				}
				else
				{
					@cell.Content=null;
					
					FindEncounter(cr.GetGlobalGroup(),car,curXi,curYi,encounterDescriptor,waitForAnswer,true,0);
				}
			}
			else
			(encounterDescriptor=uint(-1));
		}
	}
	else if(processType==(4))
	{
		
		if(cr.StatBase[(121)]>0)
		{
			cr.Say((11),"Вы не можете передвигаться при выборе логова.");
			return;
		}
		Critter@[]@group=cr.GetGlobalGroup(); 
		
		Critter@leader=group[0];
		if(int(group.length())>leader.Stat[(3)]+leader.Perk[(399)])
		{
			leader.SayMsg((11),(3),(10258));
			if((@car!=null))
			CheckForLocationWithoutParking(cr,car,curX,curY);
			return;
		} 
		
		speed=(2.0f); 
		
		if(cr.GetAccess()>(1))
		speed*=4;
		else if(cr.Param[(703)]==(3))
		speed*=2;
		
		if((@car!=null))
		{
			
			uint strNum=0;
			if(group.length()>car.Proto.Car_CrittersCapacity)
			strNum=(10257);
			else if(car.Charge==0)
			strNum=(10255);
			else if(car.Deterioration>=car.Proto.Car_MaxDeterioration)
			strNum=(10256);
			if(strNum!=0)
			{
				leader.SayMsg((11),(3),strNum);
				speed=0.0f;
				CheckForLocationWithoutParking(cr,car,curX,curY);
				return;
			}
			
			speed=car.Proto.Car_Speed*(2.0f)/20.0f;  
			
			if(car.Proto.Car_MovementType==(2))
			{
				if(GetGlobalMapRelief(curXi,curYi)!=0)
				{
					const int maxx=__GlobalMapWidth*__GlobalMapZoneLength;
					const int maxy=__GlobalMapHeight*__GlobalMapZoneLength;
					const int[]ox={-1,0,1,0};
					const int[]oy={0,-1,0,1};
					for(int i=1,ii=__GlobalMapZoneLength;i<=ii;i++)
					{
						for(int j=0;j<4;j++)
						{
							int xx=curXi+ox[j]*i;
							int yy=curYi+oy[j]*i;
							if(xx>=0&&xx<maxx&&yy>=0&&yy<maxy&&GetGlobalMapRelief(xx,yy)==0)
							{
								curX=float(xx);
								curY=float(yy);
								
								j=4;
								i=ii;
							}
						}
					}
				}
			}
		}
		else
		{
			
			int speedDiv=100-cr.Perk[(344)]*25;
			if(speedDiv<=0)
			speedDiv=1;
			speed=speed*100.0f/float(speedDiv);
		}
	}
	else if(processType==(2)||processType==(5))
	{
		Cell@cell=world.GetCell(cr);
		if(cell!is null)
		world.ShowCells(cr,cell);
	}
	else if(processType==(6))
	{ 
		
		if(curX==toX&&curY==toY)
		{  
			
		}
	}
	else if(processType==(7))
	{
		if(GetGlobalMapRelief(curXi,curYi)==0)
		{
			
			Critter@[]@group=cr.GetGlobalGroup();
			group[0].SayMsg((11),(3),(10259));
			return;
		}
		
		cr.LeaveGlobalGroup();
	}
}   

void global_invite(Critter&leader,Item@car,uint encounterDescriptor,int combatMode,uint&mapId,uint16&hexX,uint16&hexY,uint8&dir)
{                   
	
	Cell@cell=world.GetCell(leader);
	if(cell is null)
	return;
	
	CellContent@cont=cell.Content;
	
	if(encounterDescriptor!=uint(-1)&&cont is null)
	{
		@cell.Content=CellContent();
		@cont=cell.Content;
		cont.Type|=(0x10);
		cont.Durability=5;
	}   
	
	uint8 type=(cont.Type&0x1f);
	
	if(type==(0x10))
	{
		
		if(cont.MapId[(2)]!=0)
		{
			Map@map=GetMap(cont.MapId[(2)]);
			if(map!is null and map.GetEntireCoords(0,0,hexX,hexY,dir))
			{
				
				GetEnterHexFromGlobal(leader,cell,hexX,hexY);
				cont.Index=uint(-1);
				mapId=map.Id;
			}
		}
		else
		{  
			
			GetEnterHexFromGlobal(leader,cell,hexX,hexY); 
			
			InviteToEncounter(leader.GetGlobalGroup(),car,encounterDescriptor,(1),mapId,hexX,hexY,dir);
			cont.Index=encounterDescriptor;
			cont.MapId[(2)]=mapId;
		}
	}
	else if(type==(0x2))
	{
		if(encounterDescriptor!=uint(-1))
		Log("stat, encounterDescriptor WTF?!");
		
		Map@map=GetMap(cont.MapId[(2)]);
		if(map!is null and map.GetEntireCoords(0,0,hexX,hexY,dir))
		{
			
			GetEnterHexFromGlobal(leader,cell,hexX,hexY);
			cont.Index=uint(-1);
			mapId=map.Id;
		}
	}
	
}

void ScanZone(Critter@[]&group,int zx,int zy)
{
	uint[]locIds1,locIds2;
	bool locIds2Founded=false;
	
	GetZoneLocationIds(zx,zy,1,locIds1);
	
	for(uint i=0;i<group.length();i++)
	{
		Critter@cr=group[i];
		if(!cr.IsPlayer())
		continue;
		
		int lookLen=cr.PerkBase[(346)]!=0?2:1;
		
		if(lookLen==2&&!locIds2Founded)
		{
			GetZoneLocationIds(zx,zy,2,locIds2);
			locIds2Founded=true;
		} 
		
		int mapw=__GlobalMapWidth;
		int maph=__GlobalMapHeight;
		for(int x=-lookLen;x<=lookLen;x++)
		{
			for(int y=-lookLen;y<=lookLen;y++)
			{
				int zx_=zx+x;
				int zy_=zy+y;
				if(zx_>=0&&zx_<mapw&&zy_>=0&&zy_<maph)
				{
					int fog=(zx==zx_&&zy==zy_?(3):(1));
					if(cr.GetFog(zx_,zy_)<fog)
					cr.SetFog(zx_,zy_,fog);
				}
			}
		}           
		
	}
}

void CheckForLocationWithoutParking(Critter&cr,Item&car,float&curX,float&curY)
{
	Location@[]locations;
	if(GetVisibleLocations(curX,curY,0,cr,locations)!=0)
	{
		Location@loc=locations[0];
		Map@map=loc.GetMapByIndex(0);
		
		bool placeFounded=false;
		Entire[]entires;
		ParseEntires(map,entires,car.Proto.Car_Entrance);
		for(uint i=0;i<entires.length();i++)
		{
			if(map.CheckPlaceForItem(entires[i].HexX,entires[i].HexY,car.GetProtoId()))
			{
				placeFounded=true;
				break;
			}
		}
		
		if(!placeFounded)
		{
			curX=loc.WorldX+int(loc.Radius)*(Random(0,1)==0?int(1):int(-1));
			curY=loc.WorldY+int(loc.Radius)*(Random(0,1)==0?int(1):int(-1));
		}
	}
}     

void TransitCritterToCell(Critter&cr,Scenery&grid)
{
	if(@world==null)
	{
		cr.Say((11),"world !valid");
		return;
	} 
	
	if(@grid==null)
	{
		cr.Say((11),"grid !valid");
		return;
	}
	
	Cell@cell=world.GetCell(cr);           
	
	if(@cell==null)
	{
		cr.Say((11),"cell !valid");
		return;
	}
	if(@cell.Content==null)
	{
		cr.Say((11),"cont !valid");
		return;
	}       
	
	Map@map=cr.GetMap();
	if(@map==null)
	{
		cr.Say((11),"map !valid");
		return;
	}
	
	int8 offsetCellX=0,offsetCellY=0;
	uint8 direction=cr.GetMap().GetScenParam(grid.HexX,grid.HexY,grid.ProtoId,0);
	uint16 destCellX=cell.X,destCellY=cell.Y,oldHexX=0,oldHexY=0;
	
	if(!map.GetEntireCoords((255),0,oldHexX,oldHexY))
	{
		cr.Say((11),"no ent");
		return;
	}
	
	offsetCellX=((cr.HexX-oldHexX)/(150));
	offsetCellY=((cr.HexY-oldHexY)/(150));
	
	SetMapDirection(direction,destCellX,destCellY,offsetCellX,offsetCellY);  
	
	uint16 tempX=0,tempY=0;            
	
	tempX=(direction!=5&&direction!=1?cr.HexX:grid.HexX);
	tempY=(direction!=3&&direction!=7?cr.HexY:grid.HexY);
	
	if(cell.SizeX>1||cell.SizeY>1)
	{
		uint8 tempHexX=((cr.HexX-oldHexX)/(150)),
		tempHexY=((cr.HexY-oldHexY)/(150));   
		
		if(tempX>1)
		{
			tempX-=(tempHexX)*(150);
		}
		if(tempY>1)
		{
			tempY-=(tempHexY)*(150);
		}  
		
	}
	
	oldHexX=(((int(tempX-oldHexX))>0)?(int(tempX-oldHexX)):-(int(tempX-oldHexX)));
	oldHexY=(((int(tempY-oldHexY))>0)?(int(tempY-oldHexY)):-(int(tempY-oldHexY)));
	
	uint8 worldOffsetX=((((150)-oldHexX)*100)/(150)),worldOffsetY=((((150)-oldHexY)*100)/(150)); 
	
	uint16 wX=cell.X*10,wY=cell.Y*10+(10);     
	
	Cell@transitCell=world.GetCell(destCellX,destCellY);
	uint16 mapId=0;  
	
	if(transitCell is null||transitCell.Content is null)
	{    
		
		cr.SayMsg((11),(0),(15000));
		return;
	}
	
	int level=GetMapLevelByPid(map.GetProtoId());  
	
	mapId=transitCell.Content.MapId[(2)+level];   
	
	@map=GetMap(mapId);
	if(mapId==0||map is null)
	{
		cr.Say((11),"mapId !valid");return;
	}
	uint16 destHexX=0,destHexY=0;
	if(!map.GetEntireCoords((255),0,destHexX,destHexY))
	{
		cr.Say((11),"no dest ent");
		return;
	}
	SetHexDirection(cell,transitCell,direction,oldHexX,oldHexY); 
	
	if(map.IsHexPassed(destHexX+oldHexX,destHexY+oldHexY))
	{
		if(CheckMonsterTransitePlace(cr,map,destHexX+oldHexX,destHexY+oldHexY)){
			cr.StatBase[(133)]=direction;
			cr.StatBase[(134)]=destHexX+oldHexX;
			cr.StatBase[(135)]=destHexY+oldHexY;
			cr.StatBase[(136)]=mapId;
			
			ShowAnswerScreen(cr);
		}else{
			cr.SetWorldPos(destCellX*10,destCellY*10);
			cr.TransitToMap(mapId,destHexX+oldHexX,destHexY+oldHexY,direction);
		}  
		
		return;
	}
	cr.Say((11),"Вы не можете туда перейти. Гексы заняты.");
	return;     
	
}                                                           

bool CheckMonsterTransitePlace(Critter&cr,Map&map,uint16 hexX,uint16 hexY){
	
	if(!(map is null)){
		
		Critter@[]mobs;
		
		uint8 radius=cr.Skill[(217)]/(20);
		uint8 temp=map.GetCrittersHex(hexX,hexY,radius,(0x01),null);
		
		if(temp>0){
			return true;
		}
	}
	return false;
}

void ShowAnswerScreen(Critter&cr){
	cr.ShowScreen((2),1,"answer_Mob");
	cr.Say((18),"Вы чувствуете опасность. Перейти?");
	cr.Say((19+(0)),"Да");
}

void answer_Mob(Critter&cr,uint answerI,string&answerS)
{
	if(answerI==0){
		Map@map=GetMap(cr.StatBase[(136)]);
		if(map is null){cr.Say((11),"Mapid error.");return;}
		
		cr.SetWorldPos(map.GetLocation().WorldX,map.GetLocation().WorldY);
		cr.TransitToMap(map.Id,cr.StatBase[(134)],cr.StatBase[(135)],cr.StatBase[(133)]);
	}
}

bool GetEnterHexFromGlobal(Critter&leader,Cell&cell,uint16&hexX,uint16&hexY)
{
	
	if(cell.Content==null)
	return false;
	Map@map=GetMap(cell.Content.MapId[(2)]);
	if(map!is null)
	{
		uint16 placeMapHexX=0,placeMapHexY=0;
		if(map.GetEntireCoords((255),0,placeMapHexX,placeMapHexY))
		{
			uint8 tempX=leader.WorldX-cell.X*10;
			uint8 tempY=leader.WorldY-cell.Y*10;
			int8 tempN=-1; 
			
			uint8 placeCellX=(((150)*0.1)*tempX),placeCellY=(((150)*0.1)*tempY);
			
			if(tempY<=3&&tempX>=0)
			tempN=0;
			else if(tempY>=0&&tempX>=5)
			tempN=1;
			else if(tempY>=5&&tempX>=0)
			tempN=2;
			else if(tempY>=0&&tempX<=3)
			tempN=3;  
			
			switch(tempN)
			{
				
				case 0:
				placeMapHexX+=placeCellX;
				break;
				case 1:
				placeMapHexX+=(5);
				placeMapHexY+=placeCellY;
				break;
				case 2:
				placeMapHexX+=placeCellX;
				placeMapHexY+=(150)-(5);
				break;
				case 3:
				placeMapHexX+=(150);
				placeMapHexY+=placeCellY;
				break;
				default:
				break;
			}               
			
			hexX=placeMapHexX;
			hexY=placeMapHexY;
			
			return true;
		}
	}
	return false;
}

bool SetMapDirection(uint8 direction,uint16&destCellX,uint16&destCellY,int8&offsetCellX,int8&offsetCellY)
{
	Cell@cell=world.GetCell(destCellX,destCellY);
	if(cell is null||cell.Content is null)
	return false;
	
	int tempX=0,tempY=0;
	
	if(cell.X!=cell.ParantX||cell.Y!=cell.ParantY)
	{
		Cell@parantCell=world.GetCell(cell.ParantX,cell.ParantY);
		Log("parant != coords");
		
		if(parantCell is null||parantCell.Content is null)
		return false;
		
		tempX=cell.X-parantCell.X;
		tempY=cell.X-parantCell.X;
		
		destCellX=parantCell.X;
		destCellY=parantCell.Y;
	}
	
	Cell@targetCell=null;
	
	uint sizeX=cell.SizeX,
	sizeY=cell.SizeY;                                            
	
	switch(direction)
	{
		case 0:
		destCellX++;
		destCellY--;
		break;
		case 1:
		destCellX++;
		destCellY+=offsetCellY;
		break;
		case 2:
		destCellX++;
		destCellY+=sizeY;
		break;
		case 3:
		destCellX-=offsetCellX;
		destCellY+=sizeY;
		break;
		case 4:
		destCellX-=sizeX;
		destCellY+=sizeY;
		break;
		case 5:
		destCellX-=sizeX;
		destCellY+=offsetCellY;
		break;
		case 6:
		destCellX-=sizeX;
		destCellY--;
		break;
		case 7:
		destCellX-=offsetCellX;
		destCellY--;
		break;
		default:
		return false;
	}     
	
	@targetCell=world.GetCell(destCellX,destCellY);
	if(targetCell is null||targetCell.Content is null)
	{
		Log("fail");
		return false;
	} 
	
	return true;
}

void SetHexDirection(Cell&cell,Cell&targetCell,uint8&direction,uint16&hexX,uint16&hexY)
{                     
	
	uint16 mapSizeX=(150),
	mapSizeY=(150);
	
	bool bigSizeX=false,
	bigSizeY=false;
	
	if(targetCell.SizeX>1||targetCell.SizeY>1)
	{   
		
		int tempX=targetCell.ParantX-cell.ParantX,
		tempY=targetCell.ParantY-cell.ParantY;
		
		uint tempXX=(((tempX)>0)?(tempX):-(tempX)),
		tempYY=(((tempY)>0)?(tempY):-(tempY));   
		
		if(tempX!=0)
		{
			mapSizeX=((((150)*tempX)>0)?((150)*tempX):-((150)*tempX));
			bigSizeX=true;
		}
		if(tempY!=0)
		{
			mapSizeY=((((150)*tempY)>0)?((150)*tempY):-((150)*tempY));
			bigSizeY=true;
		}         
		
	}                        
	
	switch(direction)
	{
		case 0:
		hexX=mapSizeX-hexX;
		hexY=mapSizeY-hexY;
		direction=0;
		break;
		case 1:
		hexX=mapSizeX-hexX;
		if(bigSizeY)
		{
			hexY=mapSizeY+hexY;
		}
		direction=1;
		break;
		case 2:
		hexX=mapSizeX-hexX-(5);
		hexY=mapSizeY-hexY;
		direction=2;
		break;
		case 3:
		if(bigSizeX)
		{
			hexX=mapSizeX+hexX;
		}
		hexY=mapSizeY-hexY;
		direction=Random(2,3);
		break;
		case 4:
		hexX=mapSizeX-hexX;
		hexY=mapSizeY-hexY;
		direction=3;
		break;
		case 5:
		hexX=mapSizeX-hexX;
		if(bigSizeY)
		{
			hexY=mapSizeY+hexY;
		}
		direction=4;
		break;
		case 6:
		hexX=mapSizeX-hexX;
		hexY=mapSizeY-hexY-(5);
		direction=5;
		break;
		case 7:
		if(bigSizeX)
		{
			hexX=mapSizeX+hexX;
		}
		hexY=mapSizeY-hexY;
		direction=(Random(0,1)>0?5:0);
		break;
		default:
		return;
	}       
	
	return;
}

void SetOffSetNonStandartMaps(Cell&cell,uint8 direction,uint16 hexX,uint16 hexY,int8 offsetCellX,int8 offsetCellY,uint16&destCellX,uint16&destCellY)
{
	uint16 tempX=hexX/(150),
	tempY=hexY/(150);     
	
	switch(direction)
	{
		case 0:
		destCellX+offsetCellX;
		destCellY-offsetCellY;
		break;
		case 1:
		destCellX+offsetCellX;
		break;
		case 2:
		destCellX+offsetCellX;
		destCellY+offsetCellY;
		break;
		case 3:
		destCellY+offsetCellY;
		break;
		case 4:
		destCellX-offsetCellX;
		destCellY+offsetCellY;
		break;
		case 5:
		destCellX-offsetCellX;
		break;
		case 6:
		destCellX-offsetCellX;
		destCellY-offsetCellY;
		break;
		case 7:
		destCellY-offsetCellY;
		break;
		default:
		break;
	} 
	
}

void SetWorldDirection(uint8 direction,uint16&wX,uint16&wY,uint8 worldOffsetX,uint8 worldOffsetY)
{     
	
	wY-=worldOffsetY*0.1;
	
	switch(direction)
	{
		case 0:
		wX+=worldOffsetX*0.1;
		break;
		case 1:
		wX+=worldOffsetX*0.1;
		break;
		case 2:
		wX+=worldOffsetX*0.1;
		break;
		case 3:
		wY+=worldOffsetY*0.1;
		break;
		case 4:
		wX-=worldOffsetX*0.1;
		break;
		case 5:
		wX-=worldOffsetX*0.1;
		break;
		case 6:
		wX-=worldOffsetX*0.1;
		break;
		case 7:
		wX+=worldOffsetX*0.1;
		break;
		default:
		return;
	}
}                            

void RefrashCoords(Critter&cr)
{
	
	Cell@cell=world.GetCell(cr);
	if(@cell==null)
	return;
	
}      

void Ttransit(Item&item,bool firstTime)
{ 
	
}          

void unsafe_ExitGridClick(Critter&cr,int hexX,int hexY,int protoId,string@param3,int[]@param4)
{
	if(cr.IsKnockout()||cr.IsDead())
	{
		cr.Say((11),"Вы не можете перейти.");
		return;
	}
	if(cr.Timeout[(239)]>0)
	{
		cr.Say((11),"Таймаут на переходы. Ждите.");
		return;
	}
	
	Scenery@grid=cr.GetMap().GetScenery(hexX,hexY,protoId);
	if(grid!is null)
	{
		uint8 length=cr.GetMap().GetPathLength(cr,grid.HexX,grid.HexY,0);
		
		if((((int(cr.HexX-grid.HexX))>0)?(int(cr.HexX-grid.HexX)):-(int(cr.HexX-grid.HexX)))<=(3)&&(((int(cr.HexY-grid.HexY))>0)?(int(cr.HexY-grid.HexY)):-(int(cr.HexY-grid.HexY)))<=(3))
		{ 
			
			TransitCritterToCell(cr,grid);
			return; 
			
		}
		cr.Say((11),"Вы слишком далеко от сетки выхода.");
		
	}
	
}

void unsafe_GetMapPid(Critter&cr,int hexX,int hexY,int protoId,string@param3,int[]@param4)
{
	
	Scenery@grid=cr.GetMap().GetScenery(hexX,hexY,protoId);
	if(grid!is null)
	{
		
		Cell@cell=world.GetCell(cr);
		if(cell!is null&&cell.Content!is null)
		{
			int8 offsetCellX=0,offsetCellY=0,level=GetMapLevelByPid(cr.GetMap().GetProtoId());
			uint8 direction=cr.GetMap().GetScenParam(hexX,hexY,protoId,0);
			uint16 destCellX=cell.X,destCellY=cell.Y,oldHexX=0,oldHexY=0;
			
			if(!GetMap(cell.Content.MapId[(2)+level]).GetEntireCoords((255),0,oldHexX,oldHexY))
			{
				cr.Say((11),"no ent");
				return;
			}
			
			oldHexX=grid.HexX-oldHexX;
			oldHexY=grid.HexY-oldHexY;
			
			cr.StatBase[(122)]=direction;
			if(SetMapDirection(direction,destCellX,destCellY,offsetCellX,offsetCellY))
			{         
				
				uint16 mapId=GetCellMap(destCellX*10,destCellY*10,level);
				if(mapId!=-1)
				{
					Map@map=GetMap(mapId);
					if(map!is null)
					{
						cr.StatBase[(123)]=map.GetProtoId();
						
						return;
					}
				}     
				
			}
		}
	}
	cr.StatBase[(123)]=0;
	return;
}

int GetCellMap(uint16 x,uint16 y)
{
	Cell@cell=world.GetCell(x*0.1,y*0.1);
	if(@cell==null||cell.Content is null)
	return-1;
	return cell.Content.MapId[(2)];
}

int GetCellMap(uint16 x,uint16 y,int level)
{
	Cell@cell=world.GetCell(x*0.1,y*0.1);
	if(@cell==null||cell.Content is null)
	return-1;
	return cell.Content.MapId[(2)+level];
}      

CellContent@CreateContent(Cell&cell,uint mapId,uint8 type,int8 visibility)
{
	@cell.Content=CellContent(mapId,type,visibility);
	return cell.Content;
}

void CreateCell(uint16 x,uint16 y,uint mapId,uint8 type,int8 visibility)
{
	world.CreateCell(x,y,mapId,type,visibility);
}

void FindTransitHex(Map&map,uint16&hexX,uint16&hexY,uint8 radius,uint8&side)
{
	for(uint16 i=hexY-(radius*0.5),j=hexY+(radius*0.5);i<j;++i)
	{
		for(uint16 ii=hexX-(radius*0.5),jj=hexX+(radius*0.5);ii<jj;++ii)
		{
			Scenery@scen=map.GetScenery(ii,i,(4053));
			if(scen is null)
			continue;
			
			hexX=ii;
			hexY=i;
			
			side=map.GetScenParam(scen.HexX,scen.HexY,scen.ProtoId,0);
			
			return;
		}
	}
}

void cellvisibleset(Critter&cr,int vis,int,int)
{
	Cell@cell=world.GetCell(cr.WorldX*0.1,cr.WorldY*0.1);
	if(cell is null||cell.Content is null)
	return;
	
	if(vis==100)
	vis*=-1;
	cell.Content.Visibility=vis;
	
}

void ChangeMonsterCount(uint8 x,uint8 y,bool increase)
{
	Cell@cell=world.GetCell(x*0.1,y*0.1);
	if(cell is null)
	return;
	
	cell.ChangeMonsterCount(increase);
} 

void ChangeMonsterCount(Critter&cr,bool increase)
{
	Cell@cell=world.GetCell(cr);
	if(cell is null)
	return;
	
	cell.ChangeMonsterCount(increase);
}

void ChangeMonsterCount(Critter&cr,uint8 count,bool increase)
{
	Cell@cell=world.GetCell(cr);
	if(cell is null)
	return;
	
	cell.ChangeMonsterCount(count,increase);
}   

const uint16[]wild_1=
{
	311,
	311,
	312,
	319
};

const uint16[]wild_2=
{
	313,
	314,
	316,
	318
};

const uint16[]wild_3=
{
	315,
	317,
	318,
	320
};

const uint16[]wild_5=
{
	315,
	317,
	318,
	320,
	324,
};

const uint16[]wild_6=
{
	324,
	325
};

const uint16[]wild_7=
{
	325,
	327
};

const uint16[]wild_8=
{
	328,
	329
};

const uint16[]wild_10={326};

uint16 MonsterTypeTable(uint8 wild)
{
	uint16 type=0;
	
	wild*=0.1;
	
	switch(wild)
	{
		case 1:
		type=wild_1[Random(0,wild_1.length()-1)];
		break;
		case 2:
		type=wild_2[Random(0,wild_2.length()-1)];
		break;
		case 3:
		type=wild_3[Random(0,wild_3.length()-1)];
		break;
		case 4:
		type=wild_3[Random(0,wild_3.length()-1)];
		break;
		case 5:
		type=wild_3[Random(0,wild_3.length()-1)];
		break;
		case 6:
		type=wild_6[Random(0,wild_6.length()-1)];
		break;
		case 7:
		type=wild_7[Random(0,wild_7.length()-1)];
		break;
		case 8:
		type=wild_8[Random(0,wild_8.length()-1)];
		break;
		case 9:
		type=wild_8[Random(0,wild_8.length()-1)];
		break;
		case 10:
		type=wild_10[Random(0,wild_10.length()-1)];
		break;
		default:
		type=311;
		break;
	}
	
	return type;
}             

void SpawMonstersCritter(Critter&cr)
{
	Cell@cell=world.GetCell(cr);
	if(cell is null||cell.Content is null)
	return;
	
	SpawMonstersCell(cell,cell.MonsterCount);
}

void SpawMonstersCell(Cell&cell,uint16 count)
{
	
	for(uint8 i=0,j=cell.Content.MapId.length();i<j;++i)
	{
		Map@map=GetMap(cell.Content.MapId[i]);
		if(map is null)
		continue;
		
		int level=GetMapLevelByPid(map.GetProtoId());
		uint8[]tileGroups;
		
		if(level<0)
		{
			tileGroups.insertLast(4);
			tileGroups.insertLast(5);
			tileGroups.insertLast(7);
		}
		else
		{
			tileGroups.insertLast(1);
			tileGroups.insertLast(2);
			tileGroups.insertLast(3);
		}
		
		uint16 hexX=0,hexY=0,tempX=0,tempY=0;
		
		map.GetEntireCoords(255,0,hexX,hexY); 
		
		uint16 type=wild_1[Random(0,wild_1.length()-1)]; 
		
		bool condition=false;
		
		uint8 sizeX=cell.SizeX,sizeY=cell.SizeY;
		uint hash=0;
		
		for(uint8 i=0;i<count;++i)
		{
			do
			{
				tempX=Random(hexX,hexX+(sizeX*(150))-5);
				tempY=Random(hexY,hexY+(sizeY*(150))-5);          
				
			}
			while(!map.IsHexPassed(tempX,tempY));
			
			Critter@npc=map.AddNpc(type,tempX,tempY,3,null,null,"mob@_MobInit");
			
			if(npc is null)
			continue;
			npc.StatBase[(106)]=24;
			
			npc.StatBase[(120)]=200;
			
			Log("npc added "+npc.HexX+":"+npc.HexY);
		}
	}
}

void GlobalCellPopulation()
{
	world.GlobalPopulation();
}

void GlobalCellSpawnLo()
{
	world.GlobalSpawnLo();
}

void DropWild()
{
	for(uint16 i=0,j=world.Cells.length();i<j;++i)
	{
		if(world.Cells[i]is null)
		return;
		
		world.Cells[i].DropWildness();
	} 
	
}

void ReduseWildByWildness(Critter&cr)
{
	Cell@cell=world.GetCell(cr);
	if(cell is null)
	return;
	
	cell.ChangeWildness(cell.Wildness/cell.MonsterCount);
}

void ForcePopulation(Critter&cr,int count,int type,int)
{
	if(count>1)
	count=1;
	
	for(uint8 i=0;i<count;++i)
	{
		if(type>0)
		{
			SpawMonstersCritter(cr);
		}
		else
		{
			GlobalCellPopulation();
		}
	}
}

void ForceSpawnLo(Critter&cr,int count,int type,int)
{
	GlobalCellSpawnLo();
}

void CellWorldPop(Critter&cr,int count,int,int)
{
	for(uint16 i=0,j=world.Cells.length();i<j;++i)
	{
		if(world.Cells[i].MonsterCount>0)
		{
			Log("cell "+world.Cells[i].X+":"+world.Cells[i].Y+" pop "+world.Cells[i].MonsterCount);
		}
	}
}

void CellAnyData(Critter&cr,int count,int,int)
{
	int[]monstersData;
	if(IsAnyData("cells_monsters_v1"))
	{
		GetAnyData("cells_monsters_v1",monstersData);
		
		for(uint16 i=0,j=monstersData.length();i<j;++i)
		{
			Log("cell "+i+" pop "+monstersData[i]);
		}
	}
	
}

void CellSetAnyData(Critter&cr,int min,int max,int add)
{
	if(max<=0)
	max=1;
	if(min>=max)
	min=max-1;
	int[]monstersData;
	if(IsAnyData("cells_monsters_v1"))
	{
		GetAnyData("cells_monsters_v1",monstersData);
		
		for(uint16 i=0,j=monstersData.length();i<j;++i)
		{
			if(add>0)
			monstersData[i]+=Random(min,max);
			else
			monstersData[i]=Random(min,max);
			
		}
		
		SetAnyData("cells_monsters_v1",monstersData);
	}
	
}

int CellLocationCreate(int pid,int x,int y,int force)
{
	Cell@cell=world.GetCell(x,y);
	if(cell is null)
	return-1;
	
	return cell.CellCreate(pid,force>0?true:false);
}

int CellLocationCreate(int pid,int x,int y,int wild,int livetime,int force)
{
	Cell@cell=world.GetCell(x,y);
	if(cell is null)
	return-1;
	
	return cell.CellCreate(pid,wild,livetime,force>0?true:false);
}

int CellLocationMove(int x,int y,int x1,int y1)
{
	Cell@cell=world.GetCell(x,y);
	if(cell is null)
	return-1;
	
	return cell.CellMove(x1,y1);
}

int CellLocationDelete(int x,int y)
{
	Cell@cell=world.GetCell(x,y);
	if(cell is null)
	return-1;
	
	return cell.CellDelete();
}

int CellLocationSize(int x,int y,int sizeX,int sizeY)
{
	Cell@cell=world.GetCell(x,y);
	if(cell is null)
	return-1;
	
	return cell.CellSetSize(sizeX,sizeY);
}

int GetMapLevelByPid(uint pid)
{
	int level=0;
	switch(pid)
	{
		case(61):
		level=-1;
		break;
		case(64):
		level=-1;
		break;
		case(66):
		level=-1;
		break;
		case(68):
		level=-1;
		break;
		case(70):
		level=-1;
		break;
		case(72):
		level=-1;
		break;
		case(74):
		level=-1;
		break;
		case(76):
		level=-1;
		break;
		case(78):
		level=-1;
		break;
		case(80):
		level=-1;
		break;
		case(82):
		level=-1;
		break;
		case(84):
		level=-1;
		break;
		case(89):
		level=-1;
		break;
		case(59):
		level=-2;
		break;
		case(90):
		level=1;
		break;
		case(91):
		level=2;
		break;
		case(31):
		level=-1;
		break;
		case(37):
		level=-2;
		break;
		case(97):
		level=-2;
		break;
		case(39):
		level=-2;
		break;
		case(28):
		level=2;
		break;
		case(29):
		level=2;
		break;
		case(32):
		level=2;
		break;
		case(33):
		level=2;
		break;
		default:
		level=0;
		break;
	}
	
	return level;
	
}

void DypsneaCr(Map&map,Critter&cr)
{
	if(map.GetProtoId()==(89)&&(443<cr.HexX)&&(cr.HexX<540)&&(369<cr.HexY)&&(cr.HexY<435))return;
	
	if(map.GetData(25)>0)
	{
		GameVar@dyspnea=GetLocalVar((9990),map.Id);
		if(!(dyspnea is null))
		{
			if(cr.GetTimeEvents((49),null,null,null)<1)
			{
				cr.AddTimeEvent("cte_Dyspnea",5*__TimeMultiplier,(49),1);
			}
		}
		
		cr.Say((11),"Вам тяжело дышать.");
	}
	else
	{
		if(cr.GetTimeEvents((49),null,null,null)>0)
		{
			cr.EraseTimeEvents((49));
		}
		if(cr.StatBase[(126)]<100)
		{
			cr.AddTimeEvent("cte_Dyspnea",5*__TimeMultiplier,(49),0);
			cr.Say((11),"Здесь дышиться легче.");
		}
	}
	
}

uint cte_Dyspnea(Critter&cr,int identifier,uint&rate)
{
	Map@map=cr.GetMap();
	if(!(map is null))
	{
		if(map.GetData(25)>0)
		{
			GameVar@dyspnea=GetLocalVar((9990),map.Id);
			if(!(dyspnea is null))
			{
				
				Item@respirator=cr.GetItem(0,(2));
				if(!(respirator is null)&&respirator.GetProtoId()==(1399)&&respirator.Indicator>0)
				{
					uint8 ind=respirator.Indicator;
					if(Random(0,15)==0)
					{
						ind--;
						ind=(((ind)>(100))?(100):(((ind)<(0))?(0):(ind)));
						respirator.Indicator=ind;
						respirator.Update();
					}
					cr.StatBase[(126)]--;
				}
				else
				{
					cr.StatBase[(126)]-=5;
				}
			}
		}
		else
		{
			cr.StatBase[(126)]+=cr.Stat[(2)]*5;
			if(cr.StatBase[(126)]>=100)return 0;
		}
	}
	
	return 5*__TimeMultiplier;
}
