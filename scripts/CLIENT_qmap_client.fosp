                                                    

string[]__critterHistoryInfo;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

class Sprite
{
	Sprite()
	{
		Id=0;
		Hash=0;
		Width=0;
		Height=0;
		FrmCount=0;
		DrawFrame=-1;
	}
	
	void Load(string&name,int path)
	{
		if(name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		RefreshData();
	}
	
	void Load(uint nameHash,uint8 dir)
	{
		Id=LoadSprite(nameHash,dir);
		Hash=nameHash;
		RefreshData();
	}
	
	void LoadByIni(string&iniKey,int path)
	{
		string@name=GetIfaceIniStr(iniKey);
		if(@name!=null&&name.length()>0)
		Id=LoadSprite(name,path);
		else
		Id=0;
		RefreshData();
	}
	
	void Draw(int x,int y)
	{
		if(Id!=0)
		DrawSprite(Id,DrawFrame,x,y,0);
	}
	
	void Draw(int x,int y,uint8 sprIndex)
	{
		if(Id!=0)
		DrawSprite(Id,DrawFrame,x,y,0);
	}
	
	uint GetHashName()
	{
		return Hash;
	}
	
	private void RefreshData()
	{
		if(Id!=0)
		{
			Width=GetSpriteWidth(Id,0);
			Height=GetSpriteHeight(Id,0);
			FrmCount=GetSpriteCount(Id);
			DrawFrame=-1;
		}
		else
		{
			Width=0;
			Height=0;
			FrmCount=0;
			DrawFrame=-1;
		}
	}
	
	uint Id;
	uint Hash;
	int Width;
	int Height;
	uint FrmCount;
	int DrawFrame;
}       

MapTileData[]MapTileDatabase;

MapTileData@currMTD=null;

bool inited=false;

bool local_enabled=false;

bool server_enabled=true;

bool refreshMap=false;
bool updateTiles=false;

Sprite[]sprites;

uint getSprite(uint hash)
{
	uint sn=uint(-1);
	if(hash==0)
	return sn;
	
	for(uint i=0,len=sprites.length();i<len;i++)
	{
		if(sprites[i].Id!=0&&sprites[i].Hash==hash)
		{
			sn=i;
			break;
		}
	}
	if(sn==uint(-1))
	{
		sn=sprites.length();
		sprites.grow(1);
		sprites[sn].Load(hash,0);
		if(sprites[sn].Id==0)
		{
			sn=uint(-1);
			sprites.removeLast();
			
			Message("Не найден спрайт с хэшем "+hash+" "+int(hash));
		}
	}
	
	return sn;
}  

void CheckSprites()
{          
	
}                                                                                                            

class MapTileData
{
	uint Id;  
	
	int[]TileHashs;
	
	int[]Tiles;  
	
	uint[]TileSprites;
	
	uint Selected;
	uint SelTick;
	
	MapTileData()
	{
		Id=0;
		
		TileHashs.resize(0);
		Tiles.resize(0);
		TileSprites.resize(0);
		
		Selected=0;
		SelTick=0;
	}
	
	uint16 TileHashCount()
	{
		return TileHashs.length();
	}
	
	uint TileCount()
	{
		return Tiles.length()>>1;
	}
	
	bool SetFullHash(int[]&data)
	{
		TileHashs.resize(0);
		TileHashs=data;
		
		sprites.resize(0);
		ReloadSprites();
		return true;
	}
	
	bool SetOneHash(uint16 hs,int hash)
	{
		
		if(hs>=TileHashCount())
		{
			TileHashs.resize(hs+1);
			
		}
		
		TileHashs[hs]=hash;
		
		ReloadSprite(hs);
		
		return true;
	}                      
	
	bool LoadTiles(int param,int[]&data)
	{
		bool ck=true;
		
		if(param==2)
		{
			
			ck=ck&&DMO64_insertLast(Tiles,data);
		}
		else
		{
			if(data.length()<1||data.length()%2!=0)
			ck=false;
			else if(param==0)
			{
				DMO64_add(Tiles,data,true);
			}
			else
			{
				
				Tiles.resize(0);
				Tiles=data;
			}
		}
		
		updateScreen();
		
		return ck;
	}
	
	bool SetTile(uint16 hs,uint16 val,uint16 hexX,uint16 hexY,uint8 layer)
	{
		bool ck=DMO64_set(Tiles,hs,val,DMO64_makeHex(hexX,hexY,layer),true);
		
		updateScreen();
		
		return ck;
	}
	
	bool ReloadSprites()
	{
		TileSprites.resize(0);
		
		uint len=TileHashCount();
		
		if(len==0)
		return true;
		
		TileSprites.resize(len);
		
		uint hash=0,sn=0;
		
		for(uint i=1;i<len;i++)
		{
			hash=uint(TileHashs[i]);
			
			sn=getSprite(hash);
			
			TileSprites[i]=sn;  
			
		}
		
		return true;
	}
	
	bool ReloadSprite(uint16 hs)
	{
		if(TileSprites.length()<hs+1)
		{
			uint len=TileSprites.length();
			TileSprites.resize(hs+1);
			for(uint i=len;i<hs;i++)
			TileSprites[i]=uint(-1);
		}
		
		if(hs==0)
		return true;
		
		uint hash=uint(TileHashs[hs]);
		
		uint sn=uint(-1);
		
		if(hash==0)
		{
			TileSprites[hs]=sn;
		}
		else
		{
			sn=getSprite(hash);
			TileSprites[hs]=sn;
		}   
		
		return true;
	}
	
	bool Draw()
	{
		CritterCl@chosen=GetChosen();
		
		if(chosen is null)
		return false;
		
		int x=0,y=0;
		uint16 hs=0,val=0,hexX=0,hexY=0;
		uint ts=0,spriteId=0;
		uint8 layer=0; 
		
		for(uint i=0,len=TileCount();i<len;i++)
		{
			DMO64_get(Tiles,i,hs,val,hexX,hexY,layer); 
			
			NativeField@field=GetField(hexX,hexY);
			if(field is null)
			continue;
			
			if(layer<2)
			{
				hexX=(hexX<<1);
				hexY=(hexY<<1);
			}
			else if(layer==2)
			{
				field.IsNotPassed=true;
				field.IsNoLight=true;
				field.IsNotRaked=true;
				field.IsWall=true;
			}
			else if(layer==3)
			{
				field.IsNotPassed=true;
				field.IsNoLight=true;field.IsScen=true;
			}
			else if(layer>4)
			continue;     
			
			if(hs==0||hs==0xFFFF)
			continue;
			
			if(!GetHexPos(hexX,hexY,x,y)||x<-100||y<-100||x>__ScreenWidth+100||y>__ScreenHeight+100)
			continue;
			
			if(TileSprites.length()<=hs)
			continue;
			ts=TileSprites[hs];
			if(ts==uint(-1)||sprites.length()<=ts)
			{
				
				continue;
			}
			spriteId=sprites[ts].Id;
			
			if(spriteId==0)
			continue;
			
			if(layer==0)
			{    
				
				::SetTile(hexX,hexY,false,spriteId,0,0,0);
				updateTiles=true;
				Tiles[i*2]=0;
			}
			else if(layer==1)
			{           
				
				::SetTile(hexX,hexY,true,spriteId,0,0,0);
				updateTiles=true;
				Tiles[i*2]=0;
			}
			else if(layer==2)
			{ 
				
				NativeSprite@sprite=AddMapSprite(hexX,hexY,spriteId,0,__MapHexWidth>>1,__MapHexHeight>>1,23,0);
				sprite.EggType=5;
				
			}
			else if(layer==3)
			{ 
				
				NativeSprite@sprite=AddMapSprite(hexX,hexY,spriteId,0,__MapHexWidth>>1,__MapHexHeight>>1,23,0);
				
			}
			else if(layer==4)
			{ 
				
				NativeSprite@sprite=AddMapSprite(hexX,hexY,spriteId,0,__MapHexWidth>>1,__MapHexHeight>>1,24,0);
				
			}
		}  
		
		Selected=0;   
		
		return true;
	}
	
	bool ApplySelection()
	{
		int x=0,y=0;
		uint16 hs=0,val=0,hexX=0,hexY=0;
		uint ts=0,spriteId=0;
		uint8 layer=0;
		
		DMO64_get(Tiles,Selected,hs,val,hexX,hexY,layer);
		
		if(hs==0)
		return false;
		
		ts=TileSprites[hs];
		if(ts==uint(-1)||sprites.length()<=ts)
		return false;
		spriteId=sprites[ts].Id;
		
		if(spriteId==0)
		return false;
		
		NativeSprite@sprite=GetSprite(spriteId,hexX,hexY);
		if(sprite is null)
		return false;
		
		Message("Вы видите стену.");
		sprite.ContourType=1;
		sprite.ContourColor=0xFFFF0000;
		
		SelTick=0;
		
		return true;
	}
	
	bool DropSelection()
	{
		int x=0,y=0;
		uint16 hs=0,val=0,hexX=0,hexY=0;
		uint ts=0,spriteId=0;
		uint8 layer=0;
		
		DMO64_get(Tiles,Selected,hs,val,hexX,hexY,layer);
		
		if(hs==0)
		return false;
		
		ts=TileSprites[hs];
		if(ts==uint(-1)||sprites.length()<=ts)
		{
			return false;
		}
		spriteId=sprites[ts].Id;
		
		if(spriteId==0)
		return false;
		
		NativeSprite@sprite=GetSprite(spriteId,hexX,hexY);
		if(sprite is null)
		return false;
		
		sprite.ContourType=0;
		sprite.ContourColor=0;
		
		Selected=0;
		SelTick=0;
		
		return true;
	}
	
	void Draw_iface()
	{
		CritterCl@chosen=GetChosen();
		
		if(chosen is null)
		return;
		
		int x=0,y=0;
		uint16 hs=0,val=0,hexX=0,hexY=0;
		uint ts=0,spriteId=0;
		uint8 layer=0;
		
		bool sel_ck=false;
		
		NativeSprite@sprite=GetMonitorSprite(0,0);
		if(sprite!is null)
		{
			string str="SprId: "+sprite.GetSprId();
			str+="("+sprite.SprId;
			str+=") HexX: "+sprite.HexX;
			str+=" HexY: "+sprite.HexY+"\n";
			
			int x1=0,y1=0;
			sprite.GetPos(x1,y1);
			
			str+="X: "+x1;
			str+=" Y: "+y1+"\n";
			
			str+="ET: "+sprite.EggType;
			str+=" CT: "+sprite.ContourType;
			str+=" CC: "+sprite.ContourColor;
			str+=" C: "+sprite.Color;
			str+=" FM: "+sprite.FlashMask+"\n";
			
			str+="DOT: "+sprite.DrawOrderType;
			str+=" DOP: "+sprite.DrawOrderPos;
			str+=" TI: "+sprite.TreeIndex;
			
			for(uint i=0,len=TileCount();i<len;i++)
			{
				DMO64_get(Tiles,i,hs,val,hexX,hexY,layer);
				
				if(hexX!=sprite.HexX||hexY!=sprite.HexY)
				continue;
				
				str+="\nDMO: "+i+" hs1: "+hs;
				
				if(hs==0)
				continue;
				
				str+=" hash: "+uint(TileHashs[hs]);
				
				ts=TileSprites[hs];
				if(ts==uint(-1)||sprites.length()<=ts)
				{
					continue;
				}
				spriteId=sprites[ts].Id;
				
				if(spriteId==0)
				continue;
				
				str+=" sprId: "+spriteId;
				
				if(GetSprId(spriteId,0)!=sprite.GetSprId())
				continue;
				
				str+=" OK.";
				
				sel_ck=true;
				
				if(Selected!=i)
				{
					if(Selected!=0)
					{
						if(!DropSelection())
						Message("Can't drop selection.");
					}
					
					Selected=i;
					SelTick=GetTick()+500;
				}
			}
			
			DrawText(str,__MouseX+30,__MouseY,400,400,0xFFFF0000,(5),(0x0200));
		}
		
		if(!sel_ck&&Selected!=0)
		{
			if(!DropSelection())
			Message("Can't drop selection. (2)");
		}
		
		return;
	}
}                             

void DrawMapTiles()
{        
	
	if(!(currMTD is null)&&currMTD.Id!=0)
	{
		bool ck=(currMTD.Id==uint(-1));
		
		if((server_enabled&&!ck)||(local_enabled&&ck))
		currMTD.Draw();
	} 
	
}

MapTileData@getMTD(uint id)
{
	if(id==0)
	return null;
	
	MapTileData@mtd=findMTD(id);
	
	if(mtd is null)
	{
		MapTileDatabase.grow(1);
		@mtd=MapTileDatabase.last();
	}
	
	mtd.Id=id;
	@currMTD=mtd;
	
	if(mtd is null)
	Message("mtd is null");
	return mtd;
}

MapTileData@findMTD(uint id)
{
	if(id==0)
	return null;
	if(!(currMTD is null)&&currMTD.Id==id)
	return currMTD;
	
	for(uint i=0;i<MapTileDatabase.length();i++)
	{
		if(MapTileDatabase[i].Id!=id)
		continue;
		return MapTileDatabase[i];
	}
	
	return null;
}

uint findMTDi(uint id)
{
	if(id==0)
	return uint(-1);
	
	for(uint i=0;i<MapTileDatabase.length();i++)
	{
		if(MapTileDatabase[i].Id!=id)
		continue;
		return i;
	}
	
	return uint(-1);
}                                                                 

void updateScreen()
{
	refreshMap=true;
}

void qmap_loop()
{
	if(refreshMap)
	{
		RefreshMap(false,false,false);
		refreshMap=false;
		
	}
	if(updateTiles)
	{
		RefreshMap(true,false,false);
		RefreshMap(false,true,false);
		updateTiles=false;
	}
	
	if((currMTD!is null)&&currMTD.Id!=0)
	{
		if(currMTD.SelTick!=0&&currMTD.SelTick<GetTick())
		{
			
			currMTD.ApplySelection();
			
		}
	}
}

void qmap_iface()
{
	if((__sinf&(0x80))!=0&&(currMTD!is null)&&currMTD.Id!=0)
	{
		bool ck=(currMTD.Id==uint(-1));
		
		if((server_enabled&&!ck)||(local_enabled&&ck))
		currMTD.Draw_iface();
	}
}

void __SetFullHash(int id,int count,int param2,string@param3,int[]@data)
{
	MapTileData@mtd=getMTD(uint(id));  
	
	if((mtd is null)||(data is null))
	return;  
	
	mtd.SetFullHash(data);
	
	if(mtd.TileHashCount()!=uint(count))
	Message("Tiles error! Invalid data size: "+mtd.TileHashCount()+"!="+uint(count));
}

void __SetOneHash(int id,int hs,int hash,string@param3,int[]@param4)
{
	MapTileData@mtd=getMTD(uint(id));    
	
	if(!(mtd is null))
	mtd.SetOneHash(uint16(hs),hash);
}

void __SetTiles(int id,int count,int param,string@param3,int[]@data)
{
	MapTileData@mtd=getMTD(uint(id));  
	
	if((mtd is null)||(data is null))
	{
		Message("mtd or data is null!");
		return;
	}  
	
	mtd.LoadTiles(param,data);
	
	if(mtd.TileCount()!=uint(count))
	Message("Tiles error! Invalid data size: "+mtd.TileCount()+"!="+uint(count));
}

void __SetTile(int id,int data01,int data02,string@param3,int[]@param4)
{
	MapTileData@mtd=getMTD(uint(id));  
	
	if(mtd is null)
	return;
	
	uint16 hs=uint16(data01&0xFFFF),
	val=uint16((data01>>16)&0xFFFF),
	hexX=uint16(data02&0xFFF),
	hexY=uint16((data02>>12)&0xFFF);
	uint8 layer=uint8((data02>>24)&0xFF);  
	
	mtd.SetTile(hs,val,hexX,hexY,layer);
}

void __delMTD(int id,int param1,int param2,string@param3,int[]@param4)
{
	uint mtd=findMTDi(uint(id));  
	
	if(mtd==uint(-1))
	return;
	
	if(!(currMTD is null)&&(currMTD.Id==MapTileDatabase[mtd].Id))
	@currMTD=null;
	
	sprites.resize(0);
	
	MapTileDatabase.removeAt(mtd); 
	
}

uint fast_rnd(uint&seed)
{
	uint offset=12923;
	uint multiplier=4079;
	
	seed=seed*multiplier+offset;
	return seed;
}

uint NoiseSeed=0;

float Noise2d(int x,int y)
{
	int n=x+y*75;
	n=(n<<13)^n;
	return(1.0f-((n*(n*n*15731+NoiseSeed)+1376312589)&0x7fffffff)/1073741824.0f);
}

float SmoothNoise2d(int x,int y)
{
	float corners=(Noise2d(x-1,y-1)+Noise2d(x+1,y-1)+Noise2d(x-1,y+1)+Noise2d(x+1,y+1))/16,
	sides=(Noise2d(x-1,y)+Noise2d(x+1,y)+Noise2d(x,y-1)+Noise2d(x,y+1))/8,
	center=Noise2d(x,y)/4;
	return corners+sides+center;
}

import uint[][]@GetSandHashes()from"qmap_sand";

bool des_gen_inited=false;
uint[][]sandSprites((8));  

float[]sandCaps={1.0f,0.05f,0.05f,0.05f,-0.05f,-1.0f};
uint[]sandZones={0,(4),(2),(3),(6),(5)};  

void InitDesertGenerator()
{
	Message("DesertGenerator initiation...");  
	
	uint[][]@sandHashes=GetSandHashes();
	
	for(uint i=0;i<(8);i++)
	{
		sandSprites[i].resize(0);
		uint sHlen=sandHashes[i].length();   
		
		for(uint j=0;j<sHlen;j++)
		{
			if(i==(2)&&j!=3)
			continue;
			if(i==(4)&&j>2)
			break;
			if(i==(3)&&j>0)
			break;
			
			uint sn=getSprite(sandHashes[i][j]);
			if(sn==uint(-1))
			{
				Message("Load sprite fail.");
				return;
			}
			sandSprites[i].insertLast(sn);
		}
	} 
	
	string frm=".frm";
	
	for(uint i=1;i<=9;i++)
	{
		currMTD.SetOneHash(i,GetStrHash("art/scenery/tree"+i+frm));
	}
	for(uint i=20;i<=30;i++)
	{
		currMTD.SetOneHash(i,GetStrHash("art/scenery/rock"+i+frm));
	}
	
	currMTD.SetOneHash(31,GetStrHash("art/scenery/cac1000.frm"));
	currMTD.SetOneHash(32,GetStrHash("art/scenery/cac2000.frm"));
	currMTD.SetOneHash(33,GetStrHash("art/scenery/tirs002.frm"));
	
	for(uint i=1;i<=5;i++)
	{
		currMTD.SetOneHash(40+i,GetStrHash("art/scenery/bone0"+i+frm));
	}
	
	for(uint i=1;i<=9;i++)
	{
		currMTD.SetOneHash(50+i,GetStrHash("art/scenery/weed0"+i+frm));
	}
	for(uint i=10;i<=26;i++)
	{
		currMTD.SetOneHash(50+i,GetStrHash("art/scenery/weed"+i+frm));
	}
	
	des_gen_inited=true;
	
	Message("DesertGenerator inited.");
}

float getXint(float min,float max,float val)
{
	return(val-min)/(max-min);
}

int getInterI(uint a,uint b,float x)
{
	float xx=a*(1.0f-x)+b*x;
	if((xx%1.0f)<0.5f)
	return floor(xx);
	else
	return ceil(xx);
}

void GenerateDesert()
{
	CritterCl@cr=GetChosen();
	if(cr is null)
	return;
	
	if(currMTD is null)
	{
		Message("currMTD is null");
		return;
	}
	currMTD.Tiles.resize(2);  
	
	InitDesertGenerator();
	
	string dir="art/tiles/";                
	
	uint16 hx0=0,hy0=0,
	hx=398,hy=398,
	tw=(hx-hx0)>>1,th=(hy-hy0)>>1;
	
	float[]noiseBuffer;
	GenerateDesert(noiseBuffer,200);
	
	for(uint y=0;y<200;y++)
	{
		for(uint x=0;x<200;x++)
		{
			float val=noiseBuffer[x+y*200];
			
			float simpN=Noise2d(x,y)+1; 
			
			uint z=0;
			
			for(z=0;z<sandCaps.length();z++)
			{
				if(val<sandCaps[z])
				continue;
				break;
			}
			
			if(z==0||z>=sandCaps.length())
			{
				Message("z error");
				continue;
			}
			
			uint[]@sandspr=sandSprites[sandZones[z]];
			uint n=0;      
			
			n=uint(floor(simpN/2*sandspr.length()));
			
			SetTile(hx0+x*2,hy0+y*2,false,sprites[sandspr[n]].Id,0,0,0);                          
			
			if(val>sandCaps[1])
			{ 
				
				if(val>0.30f)
				currMTD.SetTile(getInterI(4,9,simpN/2),0,hx0+x*2,hy0+y*2,3);     
				
			}      
			
		}
	}                     
	
}
