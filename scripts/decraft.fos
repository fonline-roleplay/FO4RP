#ifndef DECRAFT
#define DECRAFT

#include "_utils.fos"
#include "_ltp.fos"
#include "gathering_h.fos"
#include "handcuffs_h.fos"
#include "repair_h.fos"
#include "decraft.fosh"
#include "craft_recipes.fosh"

dictionary DecraftList;
dictionary decraftItems; //Global variable for decraft ingredients

class DecraftOutput
{
    uint16 Pid = 0;
    uint Count = 0;

    DecraftOutput(uint16 pid, uint count)
    {
        if(pid == 0 || count == 0) return;
        this.Pid = pid;
        this.Count = count;
    }
}

class DecraftOutputArray
{
    DecraftOutput@[] DecraftOutputs;
	dictionary pidAssosiateList;
	uint Tier = 1;
	uint Tools = 0;
    
    void Add(uint16 pid, uint count)
    {
        if(pid == 0 || count == 0) return;

		uint index;
		if( pidAssosiateList.get( ""+pid, index ) )
		{
			DecraftOutputs[index].Count += count;
			return;
		}

        DecraftOutput@ newElem = DecraftOutput(pid, count);
        Add(newElem);
		pidAssosiateList.set(""+pid, this.length() - 1);
    }

    void Add(DecraftOutput@ newElem)
    {
        DecraftOutputs.insertLast(newElem);
    }

	uint length()
	{
		return DecraftOutputs.length();
	}

    DecraftOutput@ get_opIndex(int index) 
    {
        if(index >= int(this.length())) return null;
        return DecraftOutputs[index];
    }
}

DecraftOutputArray@ ProcessDecraftRecipe(CraftRecipe@ recipe)
{
	if( !valid( recipe ) ) 
		return null;
	
	DecraftOutputArray@ Decraft;

	if( DecraftList.exists( ""+recipe.Output[0] ) )
	{
		DecraftList.get(""+recipe.Output[0], @Decraft);
		return Decraft;
	}
	@Decraft = DecraftOutputArray();
	Decraft.Tier = recipe.Tier;
	Decraft.Tools = recipe.Tools;

	for(uint i = 0, len = recipe.Resources.length(); i < len; i++)
	{
		uint16 pid = recipe.Resources[i];
		uint count = recipe.ResourcesCount[i];
		if( NonDecraftableResources.find( pid ) != -1 ) continue;

		CraftRecipe@ ComponentRecipe = GetCraftByItemPID( pid );
		if( !valid( ComponentRecipe ) || (ComponentRecipe.Resources.length() == 1 && ComponentRecipe.ResourcesCount[0] == 1) ) 
		{
			Decraft.Add(pid, count);
			continue;
		}

		DecraftOutputArray@ ComponentDecraft = ProcessDecraftRecipe(ComponentRecipe);
		if(!valid(ComponentDecraft)) continue;

		for(uint j = 0, jlen = ComponentDecraft.length(); j < jlen; j++)
		{
			DecraftOutput@ currCompDecraftRes = ComponentDecraft[j];
			if(!valid(currCompDecraftRes)) continue;
			Decraft.Add(currCompDecraftRes.Pid, currCompDecraftRes.Count * count);
		}
	}

	if(Decraft.length() > 0)
		DecraftList.set( ""+recipe.Output[0], Decraft );
	
	return Decraft;
}

void AddManualDecraftList()
{
	DecraftOutputArray@ Decraft;

	// Example
	// @Decraft = DecraftOutputArray();
	// Decraft.Add(PID_TUBE, 1);
	// DecraftList.set( ""+PID_SUN, Decraft );
}

void InitDecraft()
{
	AddManualDecraftList();

	Log("1");
	for(uint i = 0, len = GetMaxCraftsCount(); i < len; i++)
	{
		CraftRecipe@ currRecipe = GetCraftByPID(i);
		if(!valid(currRecipe)) continue;
		ProcessDecraftRecipe(currRecipe);
	}
	Log("2");
}

DecraftOutputArray@ GetDecraftByPID(uint16 pid)
{
	DecraftOutputArray@ Decraft;
	if( DecraftList.get(""+pid, @Decraft) )
	{
		return Decraft;
	}
	return null;
}

uint FindFirstTool(uint toolFlag)
{
	for( int i = 0; i < 32; i ++ )
	{			
		if( ISBIT( toolFlag, i ) ) return i;
	}
	
	return 255;
}

bool HasTool(Critter& cr, uint toolFlag)
{
	if(!valid(cr)) return false;
	if(toolFlag == 255) return true;

	Item@[] crInv;
	cr.GetItems( -1, crInv );

	for(uint i = 0, len = crInv.length(); i < len; i++)
	{
		Item@ currItem = crInv[i];
		if(!valid(currItem)) continue;
		
		ProtoItem@ currProto = GetProtoItem(currItem.GetProtoId());
		if(!valid(currProto)) continue;
		
		if( FLAG(1 << toolFlag, currProto.Tool_Perk) ) return true;
	}
	
	return false;
}

bool TryDisassembleItem( Critter& cr, Item& item )
{
	if( !valid( item ) || !valid(cr) )
	{
		return false;
	}
	
	if( IsTired( cr ) )
	{
		return false;
	}
	
	if( HandsTied( cr ) )
	{
		return false;
	}
	
	if( cr.IsInjured() )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_TO_DECRAFT );
		return false;
	}

	uint16 pid = item.GetProtoId();
	DecraftOutputArray@ Decraft = GetDecraftByPID(pid);
	
	if( !valid(Decraft) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NO_IDEA );
		return false;
	}

	uint firstTool = FindFirstTool(Decraft.Tools);

	if ( !HasTool(cr, firstTool) || !HasTool(cr, 2) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_HOLD_TOOL );
		for( int i = 0; i < 32; i ++ )
		{
			if( ISBIT( Decraft.Tools, i ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_HOLD_TOOL_PID, "$proto@msg item " + ( ProtoToolPids[i] * 100 ) + "@" );
			}
		}

		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_GAINED_PARTS );
		for( uint i = 0, len = Decraft.length(); i < len; i++ )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_GAINED_PARTS_PID, "$proto@msg item " + ( Decraft[i].Pid * 100 ) + "@" );
		}
		return true;
	}
	
	if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		uint ammoCount = item.AmmoCount;
		
		if( ammoCount > 0 )
		{
			Item@ ammo = cr.AddItem( item.AmmoPid, ammoCount );
			item.AmmoCount = 0;
			item.Update();
			
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_AMMO_EJECTED, "$proto@msg item " + ( ammo.Proto.ProtoId * 100 + 2 ) + "@$count" + ammoCount );
		}
	}

	start_decraft( cr, item, Decraft );
    return true;
}

bool ltp_decraft_inited = false;
void ltp_decraft_init()
{
	LTPREG( LTP_DECRAFT, process_decraft )
	ltp_decraft_inited = true;
}

bool start_decraft( Critter& cr, Item& item, DecraftOutputArray@ Decraft )
{
	if( !ltp_decraft_inited )
	{
		ltp_decraft_init();
	}

	uint amount = Decraft.length();
	
	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	int decraft_rate = ( cr.Skill[SK_REPAIR] ) + ( cr.Stat[ST_AGILITY] * 10 ) + ( cr.Stat[ST_INTELLECT] * 10 ) + OBJECT_DPA_BASE; 
	cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ceil( float( ( amount * 200 ) / ( CLAMP( decraft_rate, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) ) );
	
	uint[] values = { cr.Id };
	
	CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "repair@e_RepairSound", values, true);
	CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);	

	_CritAnimateUse( cr );

	StartProcess( cr, LTP_DECRAFT, 0, amount, item.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
	return true;
}

uint process_decraft( Critter@ cr, int& param0, int& param1, int& param2 )
{
	LTPROCESS( cr, param0, LTP_DECRAFT )
  	
	Item@ item = GetItem( param2 );
	
	if( valid( item ) )
    {
		param0++;
		
		if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
		{
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_FINISH_DECRAFT );
			DecraftResult( cr, item );
			return 0;
		}
		
		uint[] values = { cr.Id };
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "repair@e_RepairSound", values, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);

		_CritAnimateUse( cr );
		
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}
	
	return 0;
}

bool DecraftResult( Critter& cr, Item& item ) 
{
	if(!valid(item)) return false;
	uint16 pid = item.GetProtoId();
	DecraftOutputArray@ Decraft = GetDecraftByPID(pid);
	
	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_GAINED_DECRAFT, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
    for( uint8 i = 0; i < Decraft.length(); i++ )
	{
		DecraftOutput@ currOutput = Decraft[i];
		if(!valid(currOutput)) continue;

		uint count = currOutput.Count;
		int maxSkill = Decraft.Tier * DECRAFT_SK_MUL + DECRAFT_SK_MOD;    
		int successRoll = Random( 1, maxSkill );

		if(cr.Param[SK_SCIENCE] < successRoll)
		{
			count /= 2;
		}

		if( GetDeteriorationProcent( item ) > 40 || (10 - item.BrokenCount) < 4)
		{
			count /= 2;
		}

		count = count < 1 ? 1 : count;

		Item@ gainedItem = cr.AddItem( currOutput.Pid, count );
		if( valid( gainedItem ) )
		{
			if( gainedItem.Proto.Weapon_MaxAmmoCount > 0 )
			{
				gainedItem.AmmoCount = 0;
			}
			
			if( item.IsDeteriorable() && gainedItem.IsDeteriorable() )
			{
				SetDeterioration( gainedItem, GetDeteriorationProcent( item ) );
			}
			
			gainedItem.Update();
		}
		
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_GAINED_DECRAFT_PID, "$proto@msg item " + ( gainedItem.Proto.ProtoId * 100 ) + "@$count" + currOutput.Count );
	}
	
	if ( item.GetCount() > 1 )
	{
		item.SetCount(item.GetCount() - 1);
		StartMenuAskAction( cr, item );
	}
	else
	{
		DeleteItem( item );
	}
	
	return true;
}

//~run decraft _GetDecraftOutput pid 0 0
void _GetDecraftOutput( Critter& player, int param0, int param1, int param2 )
{
	if(param0 <= 0) return;
	if( !DecraftList.exists( ""+param0 ) ) return;

	DecraftOutputArray@ Decraft;
	DecraftList.get(""+param0, @Decraft);

	if(!valid(Decraft)) return;

	player.Say(SAY_NETMSG, "Output for pid " + param0 + " is:");
	for(uint i = 0, len = Decraft.length(); i < len; i++)
	{
		DecraftOutput@ currOut = Decraft[i];
		if(!valid(currOut)) continue;

		player.Say(SAY_NETMSG, "PID " + GetConstantName(CONSTANTS_ITEM, currOut.Pid) + ", Count " + currOut.Count);
	}
}

#endif // DECRAFT