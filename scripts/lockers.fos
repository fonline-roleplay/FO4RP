#ifndef LOCKERS
#define LOCKERS

#include "_utils.fos"
#include "lockers_h.fos"
#include "_ltp.fos"
#include "gateway_h.fos"
#include "terminal_h.fos"

import bool canPutItemInContainer( Critter& cr, Item@ item, Item@ container ) from "main";

import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

bool UseItemOnLocker( Critter& cr, Item& locker, Item& item )
{
    if( item.GetType() == ITEM_TYPE_KEY )
    {
        if( item.LockerId == locker.LockerId )
        {
            if( !FLAG( locker.LockerCondition, LOCKER_ISOPEN ) )
            {
				Map@ map = cr.GetMap();
				if( hasKey( locker ) ) 
				{
					bool thisSide = hasKeyAround( cr, locker );
					uint keySide = thisSide ? STR_KEY_THIS_SIDE : STR_KEY_OTHER_SIDE;
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, keySide );
					return false;
				}

                if( FLAG( locker.LockerCondition, LOCKER_LOCKED ) )
                {
                    UNSETFLAG( locker.LockerCondition, LOCKER_LOCKED );
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_UNLOCK_DOOR );
					cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_UNLOCKS );
                }
                else
                {
                    SETFLAG( locker.LockerCondition, LOCKER_LOCKED );
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOCK_DOOR );
					cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_LOCKS );
                }
				PlayGenericSound( map, cr.HexX, cr.HexY, "ui_lockpicking_unlock.wav", 4 );
                return true;
            }
            cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CLOSE_DOOR );
            return true;
        }
        else
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_KEY );
            return true;
        }
    }
	
	if( valid( locker ) && locker.GetProtoId() == PID_MAILBOX )
	{
		if( ( FLAG( locker.LockerCondition, LOCKER_ISOPEN ) || canPutItemInContainer( cr, item, locker ) ) )
		{
			MoveItem( item, 1, locker, 0 );
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_SEND_MAIL );
			return true;
		}		
		
		return false;
	}	
	
    return true;
}

bool hasKeyAround( Critter& cr, Item& locker )
{
	Item@[] list = getItemsAround( cr );
	Item@ found = null;
	for( uint i = 0, len = list.length(); i < len; i++ )
	{
		@ found = list[i];
		if( !valid( found ) )
		{
			continue;
		}
		
		if( found.GetType() == ITEM_TYPE_KEY && found.LockerId == locker.LockerId )
		{
			return true;
		}
	}
	return false;
}

bool hasKey( Item& locker, int dir = NO_DIR )
{
	Item@[] list = getItemsAround( locker );
	Item@ found = null;
	for( uint i = 0, len = list.length(); i < len; i++ )
	{
		@ found = list[i];
		if( !valid( found ) )
		{
			continue;
		}
		
		if( found.GetType() == ITEM_TYPE_KEY && found.LockerId == locker.LockerId )
		{
			return true;
		}
	}
	return false;
}

bool hasKey( Critter& cr, Item& locker )
{
	Item@[] keys;
	Item@ found = null;
	cr.GetItemsByType( ITEM_TYPE_KEY, keys );
	for( uint i = 0, len = keys.length(); i < len; i ++ )
	{
		@ found = keys[i];
		if( !valid( found ) )
		{
			continue;
		}
		
		if( found.LockerId != locker.LockerId )
		{
			continue;
		}
		else
		{
			return true;
		}
	}
	return false;
}

bool LockpickMenu( Critter& cr, Item& locker ) // REFACTOR THIS SHIT TO SUCKLESS!!!
{
	cr.StatBase[ ST_VAR0 ] = locker.Id;
	
	string[] data = { 
		"lockers@answer_LOCKPICK", 
		BTN( STR_CHOOSE_YOUR_ACTION ),
		BTN( STR_KNOCK ),
		BTN( STR_SMASH ),
		BTN( STR_LOCKPICK )
	};
	
	if( locker.Proto.Item_Subtype != ITEM_SUBTYPE_BRIEFCASE )
	{
		if( hasKeyAround( cr, locker ) )
		{
			data.insertLast( BTN( STR_EXTRACT_KEY ) );
			data.insertLast( ( FLAG( locker.LockerCondition, LOCKER_LOCKED ) ? BTN( STR_UNLOCK ) : BTN( STR_LOCK ) ) );
		}
		else if( IsKeyAviable( cr, locker.LockerId ) ) 
		{
			data.insertLast( BTN( STR_INSERT_KEY ) );
			data.insertLast( ( FLAG( locker.LockerCondition, LOCKER_LOCKED ) ? BTN( STR_UNLOCK ) : BTN( STR_LOCK ) ) );
		}
	}
	
	DIALOG_MENU_NEW( cr, data );
	
	return true;
}

bool UseSkillOnLocker( Critter& cr, Item& locker, int skill )
{
	if( FLAG( locker.LockerCondition, LOCKER_NOOPEN ) )
	{
		LogCrimeMovement( cr, locker, "cant open NOOPEN" ); 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
		return true;
	}
	
    Map@ map = cr.GetMap();
    if( !valid( map ) )
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        return true;
    }

	if( skill == SKILL_PICK_ON_GROUND )
    {
		if( FLAG( locker.LockerCondition, LOCKER_ELECTRO ) && !FLAG( locker.LockerCondition, LOCKER_ISOPEN ) && ( locker.GetType() == ITEM_TYPE_DOOR || locker.GetType() == ITEM_TYPE_CONTAINER ) )
        {
            cr.RunClientScript( "client_screen_codedoor@ShowScreen", locker.Id, locker.CODEDOOR_CODE, 0, "Enter password", null );
			LogCrimeMovement( cr, locker, "enters password" ); 
            return true;
        }
		
        if( locker.GetType() == ITEM_TYPE_DOOR )
        {
            if( FLAG( locker.LockerCondition, LOCKER_ISOPEN ) && valid( map.GetCritter( locker.HexX, locker.HexY ) ) )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				LogItemMovement( cr, locker, "can't close the door because someone is in the way" ); 
                return true;
            }
            // Check key
            if( !FLAG( locker.LockerCondition, LOCKER_ISOPEN ) && locker.LockerId != 0 && !FLAG( locker.LockerCondition, LOCKER_BROKEN ) && FLAG( locker.LockerCondition, LOCKER_LOCKED ) )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ITEM_LOCKER_NEED_KEY );
				LockerBudge( locker );
				
                if( !isGM( cr ) )
				{
					LogCrimeMovement( cr, locker, "can't open locked because has no key" ); 
					PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), locker.LockerCondition, 15 );
					return true;
				}
				else
				{
					LogCrimeMovement( cr, locker, "opens locked door by GM force" ); 
				}
			}
            // Change state
            if( FLAG( locker.LockerCondition, LOCKER_ISOPEN ) )
			{
				Map@ mapl = GetMap( locker.MapId );
				if( !valid( mapl ) )
				{
					return true;
				}
				
				if( mapl.IsHexPassed( locker.HexX, locker.HexY) )
				{
					LogItemMovement( cr, locker, "closes" ); 
					locker.LockerClose();
					ToggleDoorBlocker( mapl, locker, true );
					PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), locker.LockerCondition, 15 );
				}
				else
				{
					LogItemMovement( cr, locker, "can't close door because of blocked hex" ); 
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_HEX_BLOCKED );
					PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), 2, 15 );
				}
				return true;
			}
			else
			{
				LogItemMovement( cr, locker, "opens" ); 
				ToggleDoorBlocker( map, locker, false );
				locker.LockerOpen();
				PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), locker.LockerCondition, 15 );
				return true;
			}
        }
        else if( locker.GetType() == ITEM_TYPE_CONTAINER )
        {
			if( locker.Accessory != ACCESSORY_CRITTER && FLAG( locker.Flags, ITEM_CAN_PICKUP ) )
            {
                int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - ItemsWeight( cr );
                int contWeight = 0;
                Item@[] items;
				Item@ contItm = null;
                uint len = locker.GetItems( uint( -1 ), items );
				
                for( uint i = 0; i < len; i++ )
                {
					@ contItm = items[ i ];
                    if( !valid( contItm ) )
					{
                        continue;
					}
                    contWeight += int( contItm.Proto.Weight * contItm.GetCount() );
                }

                if( freeWeight >= ( contWeight + int( locker.Proto.Weight ) ) )
                {
					LogItemMovement( cr, locker, "picks up" ); 
                    MoveItem( locker, 0, cr );
                    return true;
                }
            }
            // Check key
            if( !FLAG( locker.LockerCondition, LOCKER_ISOPEN ) && locker.LockerId != 0 && !FLAG( locker.LockerCondition, LOCKER_BROKEN ) && FLAG( locker.LockerCondition, LOCKER_LOCKED ) )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ITEM_LOCKER_NEED_KEY );
				LockerBudge( locker );
				
                if( !isGM(cr) )
				{
					LogCrimeMovement( cr, locker, "cant open locked because has no key" );
					PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), locker.LockerCondition, 15 );
					return true;
				}
				else
				{
					LogCrimeMovement( cr, locker, "opens with GM power" );
				}
			}
            // Is changeble
            if( locker.Proto.Container_Changeble )
            {
                // Change state
                if( FLAG( locker.LockerCondition, LOCKER_ISOPEN ) )
				{
					LogItemMovement( cr, locker, "closes" ); 
					PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), locker.LockerCondition, 15 );
                    locker.LockerClose();
				}
                else
                {
                    ShowContainer( cr, locker, locker.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
					LogItemMovement( cr, locker, "opens" );
					PlayDoorSound( map, locker.HexX, locker.HexY, locker.GetProtoId(), locker.LockerCondition, 15 );
                    locker.LockerOpen();
                }
				return true;
            }
            else
            {
				locker.Accessory == ACCESSORY_CRITTER ? ShowContainer( cr, locker, TRANSFER_SELF_CONT ) 
													  : ShowContainer( cr, locker, locker.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
                
				LogItemMovement( cr, locker, "looks into" );
				return true;
            }
        }
    }
    else if( skill == SK_STEAL )
    {
        if( locker.GetType() == ITEM_TYPE_CONTAINER )
        {
			if( locker.GetProtoId() == PID_STASH_BOX)
			{
				return false;
			}
			if( ( !locker.Proto.Container_Changeble || FLAG( locker.LockerCondition, LOCKER_ISOPEN ) ) && !FLAG( locker.LockerCondition, LOCKER_LOCKED ) )
			{
				ShowContainer( cr, locker, locker.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
				LogItemMovement( cr, locker, "looks using SK_STEAL into" );
				return true;
			}
			else if( FLAG( locker.LockerCondition, LOCKER_LOCKED ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CONTAINER_IS_LOCKED );
			}
			else
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOOR_IS_CLOSED );
			}
        }		
		return false;
	}
    else if( skill == SK_LOCKPICK )
    {
        if( cr.Timeout[ TO_SK_LOCKPICK ] > 0 && !isGM( cr ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
			LogItemMovement( cr, locker, "can't lockpick because of tiredness" );
            return true;
        }
		
		if( locker.LockerComplexity == 500 && !isGM( cr ) )
		{
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_LOCKPICK_FAIL );
			LogItemMovement( cr, locker, "can't lockpick GM lock" );
			return true;
		}

        if( locker.LockerCondition == LOCKER_ELECTRO )
        {
			if( !HasElectronicLockpicks( cr ) )
			{
				LogItemMovement( cr, locker, "can't lockpick without electronic lockpick" );
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_E_LOCKPICK );
				return true;
			}
			
			StartMenuHacking( cr, locker );
			return true;
        }
        else
        {
			LogItemMovement( cr, locker, "interacts with a lock" );
            return LockpickMenu( cr, locker );
        }
    }
    else if( skill == SKILL_TAKE_ALL_CONT )
    {
        return false;
    }
	else if( skill == SK_SCIENCE )
	{
		if( ( locker.GetType() == ITEM_TYPE_DOOR || ( locker.GetType() == ITEM_TYPE_CONTAINER && locker.Proto.Container_Changeble ) ) && FLAG( locker.LockerCondition, LOCKER_ELECTRO ) && _LockerIsOpen( locker ) )
		{
			if( cr.Skill[ SK_SCIENCE ] >= int( locker.LockerComplexity ) )
			{
				string passwordInfo = "Set new password";
				int[] data = { 0 };
				cr.RunClientScript( "client_screen_numberpad@ShowScreen", locker.Id, 0, 0, passwordInfo, data );
			}
			else
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MSG_SKILL_TOO_LOW_PASSWORD );
			}
			
			return true;
		}
	}

    return false;
}

void answer_LOCKPICK( Critter& player, uint answerI, string& answerS )
{
    Item@ lockItm = GetItem( player.Stat[ ST_VAR0 ] );
    if( !valid( lockItm ) )
	{
        return;
    }
	
	Item@lockpick = player.GetItem( 0, SLOT_HAND1 );
	Map@ map = player.GetMap();
	
	if( GetDistantion( lockItm.HexX, lockItm.HexY, player.HexX, player.HexY ) > 2 )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_FAR_FROM_DOOR );
		return;
	}

    if( answerI == 0 )
    {
        map.SetTextMsg( lockItm.HexX, lockItm.HexY, COLOR_GRAY, TEXTMSG_TEXT, STR_MAPMSG_KNOCK );
        player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_STR_YOU_KNOCK );
		LogItemMovement( player, lockItm, "knocks on the" ); 
    }
	
    if( answerI == 1 )
    {
		map.SetTextMsg( lockItm.HexX, lockItm.HexY, COLOR_RED, TEXTMSG_TEXT, STR_MAPMSG_LOUD_BANG );
		LogItemMovement( player, lockItm, "bangs on the" ); 
	
		return;
	}
	
    if( answerI == 2 )
    {
		if( hasKey( lockItm ) ) 
        {
			bool thisSide = hasKeyAround( player, lockItm );
			uint keySide = thisSide ? STR_KEY_THIS_SIDE : STR_KEY_OTHER_SIDE;
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, keySide );
			LogCrimeMovement( player, lockItm, "can't lockpick because there is a key in the door" ); 
            return;
        }

		if( FLAG( lockItm.LockerCondition, LOCKER_ISOPEN ) && InteractContainer.find( lockItm.GetProtoId() ) == -1 )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOOR_OPEN );
			LogCrimeMovement( player, lockItm, "can't lockpick - the door is open" ); 
            return;
        }
		
        if( lockItm.LOCK_TYPE == LOCK_NONE )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NO_LOCK );
			LogCrimeMovement( player, lockItm, "cant lockpick - no lock" ); 
            return;
        }

		if( !valid( lockpick ) || ( lockpick.GetProtoId() != PID_HAIRPIN && lockpick.GetProtoId() != PID_EXP_LOCKPICK_SET && lockpick.GetProtoId() != PID_LOCKPICKS ) )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NO_LOCKPICKING_TOOL );
			LogCrimeMovement( player, lockItm, "can't lockpick - no lockpicks" ); 
            return;
        }

		if( lockItm.LOCK_TYPE == LOCK_LOW )
		{
            lockItm.STORED_CODE = Random( 1, 9 ) * 10 + Random( 1, 9 );
            lockItm.ENTERED_CODE = 11;
        }
        
        if( lockItm.LOCK_TYPE == LOCK_MED )
        {
            lockItm.STORED_CODE = Random( 1, 9 ) * 100 + Random( 1, 9 ) * 10 + Random( 1, 9 );
            lockItm.ENTERED_CODE = 111;
        }
        
        if( lockItm.LOCK_TYPE == LOCK_HARD )
        {
            lockItm.STORED_CODE = Random( 1, 9 ) * 1000 + Random( 1, 9 ) * 100 + Random( 1, 9 ) * 10 + Random( 1, 9 );
            lockItm.ENTERED_CODE = 1111;
        }

        if( valid( lockpick ) && lockpick.LOCK_TYPE != 0 && ( lockpick.GetProtoId() == PID_HAIRPIN || lockpick.GetProtoId() == PID_EXP_LOCKPICK_SET || lockpick.GetProtoId() == PID_LOCKPICKS) )
        {
			lockpick.LOCK_TYPE = 0;
            _SubItem( lockpick, 1 );
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOCKPICKING_BROKEN );
			map.PlaySound( LockpickBreak[ Random( 0, LockpickBreak.length() -1 ) ], player.HexX, player.HexY, 2 );
			LogCrimeMovement( player, lockItm, "breaks the lockpick" ); 
            return;
        }
		else if( valid( lockpick ) && Random( 0, 1 ) == 0 )
		{
            lockpick.LOCK_TYPE = 10;
		}
		
        player.StatBase[ ST_VAR1 ] = 1;     // lockpick position
        player.StatBase[ ST_VAR2 ] = 0;     // remaining attempts

        player.ShowScreen( SCREEN_DIALOGBOX, 8, "answer_LOCKPICK_lock" );
        player.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_STATE_OF_LOCK_IS_UNKNOWN );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_EXAMINE_THE_LOCK );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 1 ), TEXTMSG_TEXT, STR_MOVE_FURTHER );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 2 ), TEXTMSG_TEXT, STR_MOVE_BACKWARD );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 3 ), TEXTMSG_TEXT, STR_MOVE_UP );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 4 ), TEXTMSG_TEXT, STR_MOVE_DOWN );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 5 ), TEXTMSG_TEXT, STR_TURN );
        player.SayMsg( SAY_DIALOGBOX_BUTTON( 6 ), TEXTMSG_TEXT, STR_REMOVE_LOCKPICK );
		player.SayMsg( SAY_DIALOGBOX_BUTTON( 7 ), TEXTMSG_TEXT, STR_LOCK_THE_LOCK );
		
        player.TimeoutBase[ TO_SK_LOCKPICK ] = LOCKPICK_TIMEOUT( player );
		
		map.PlaySound( "ui_lockpicking_enter.wav", player.HexX, player.HexY, 2 );
		LogCrimeMovement( player, lockItm, "begins to break the lock, code is: " + lockItm.STORED_CODE ); 
    }

	if( answerI == 3 )
	{
		if( hasKey( lockItm ) )
		{
			if( hasKeyAround( player, lockItm ) )
			{
				LogItemMovement( player, lockItm, "takes out key from the lock" ); 
				takeKey( player, lockItm );
			}
			else
			{
				LogItemMovement( player, lockItm, "can't put in the key, there is one already from the other side" ); 
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_KEY_OTHER_SIDE );
			}
		}
		else if( hasKey( player, lockItm ) ) 
		{
			LogItemMovement( player, lockItm, "inserts key in the lock" ); 
			putKey( player, lockItm );
		}
		else
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_NEED_KEY );
		}
	}

	if( answerI == 4 )
	{
		bool thisSide = false;
		if( hasKey( lockItm ) ) 
		{
			thisSide = hasKeyAround( player, lockItm );
		}
		else if( IsKeyAviable( player, lockItm.LockerId ) )
		{
			thisSide = true;
		}
		
		if( thisSide )
		{
			if( FLAG( lockItm.LockerCondition, LOCKER_LOCKED ) )
			{
				UNSETFLAG( lockItm.LockerCondition, LOCKER_LOCKED );
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_UNLOCK_DOOR );
				LogItemMovement( player, lockItm, "unlocks" ); 
				player.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_UNLOCKS );
				PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_unlock.wav", 6 );
			}
			else
			{
				SETFLAG( lockItm.LockerCondition, LOCKER_LOCKED );
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOCK_DOOR );
				LogItemMovement( player, lockItm, "locks" ); 
				player.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_LOCKS );
				PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_unlock.wav", 6 );
			}
		}
		else 
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_KEY_OTHER_SIDE ); 
			LogCrimeMovement( player, lockItm, "can't lockpick - key on the other side" ); 
		}

		LockpickMenu( player, lockItm );
	}
}

bool takeKey( Critter& cr, Item& locker )
{
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return false;
	}
	
	Item@[] list = getItemsAround( locker );
	for( uint i = 0, len = list.length(); i < len; i++ )
	{
		if( list[i].GetType() == ITEM_TYPE_KEY && list[i].LockerId == locker.LockerId )
		{
			if( list[i].KEY_EVENT != 0 )
			{
				EraseTimeEvent( list[i].KEY_EVENT );
				list[i].KEY_EVENT = 0;
			}
			
			MoveItem( list[i], 1, cr );
			UNSETFLAG( list[i].Flags, ITEM_HIDDEN );
			list[i].Update();
			PlayGenericSound( map, cr.HexX, cr.HexY, "ui_lockpicking_enter.wav", 6 );
			cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_EJECT_KEY );
			return true;
		}
	}
	return false;
}

bool putKey( Critter& cr, Item& locker )
{
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return false;
	}
	
	Item@[] keys;
	Item@ key = null;
	cr.GetItemsByType( ITEM_TYPE_KEY, keys );
	uint len = keys.length();
	if( len > 0 )
	{
		for( uint i = 0; i < len; i ++ )
		{
			if( keys[i].LockerId != locker.LockerId )
			{
				continue;
			}
			else
			{
				@key = keys[i];
			}
		}
	}
	
	if( !valid( key ) )
	{
		return false;
	}
	
	MoveItem( key, 1, map, cr.HexX, cr.HexY );
	SETFLAG( key.Flags, ITEM_HIDDEN );
	uint[] vals = { key.Id, locker.Id };
	key.KEY_EVENT = CreateTimeEvent( AFTER( REAL_DAY( 10 ) ), "e_KeyRust", vals, true );

	key.Update();
	PlayGenericSound( map, cr.HexX, cr.HexY, "ui_lockpicking_enter.wav", 6 );
	cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_INJECTS_KEY );
	return true;
}

uint e_KeyRust( uint[]@ values )
{
	if( !valid( values ) || values.length() != 2 )
	{
		return 0;
	}
	
	Item@ key = GetItem( values[0] );
	Item@ door = GetItem( values[1] );
	if( !valid( key ) || !valid( door ) )
	{
		return 0;
	}
	
	Map@ map = GetMap( key.MapId );
	
	if( !valid( map ) || !FLAG( key.Flags, ITEM_HIDDEN ) )
	{
		return 0;
	}
	
	UNSETFLAG( key.Flags, ITEM_HIDDEN );
	
	uint16 x = key.HexX, y = key.HexY;
	map.MoveHexByDir( x, y, GetDirection( door.HexX, door.HexY, key.HexX, key.HexY ), 1 );
	
	MoveItem( key, 1, map, x, y ); 
	
	return 0;
}

void answer_LOCKPICK_lock( Critter& player, uint answerI, string& answerS )
{
    Item@ lock = GetItem( player.Stat[ ST_VAR0 ] );
    if( !valid( lock ) )
	{
        return;
    }
	
	Map@ map = player.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
    int base = player.Skill[ SK_LOCKPICK ] - lock.LockerComplexity;
    base = CLAMP( base, 50, 300 );
	
    Item@ lockpick = player.GetItem( 0, SLOT_HAND1 );
	uint lockpickPid = 0;
	if( valid( lockpick ) )
	{
		lockpickPid = lockpick.GetProtoId();
		switch( lockpickPid )
		{
			case( PID_LOCKPICKS ):
				base += LOCKPICKS_BONUS;
				break;
			case( PID_EXP_LOCKPICK_SET ):
				base += LARGE_LOCKPICKS_BONUS;
				break;
			default:
				break;
		}
	}
	
	if( GetDistantion( lock.HexX, lock.HexY, player.HexX, player.HexY ) > 2 )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_FAR_BREAK_LOCKPICKS );
		map.PlaySound( LockpickBreak[ Random( 0, LockpickBreak.length() -1 ) ], player.HexX, player.HexY, 2 );
		_SubItem( lockpick, 1 );
		return;
	}

    string state = "$state";
    int curComb = 0;
	
	int curPos = int( ( lock.ENTERED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );

    if( answerI == 0 )
    {
        if( lock.LOCK_TYPE == LOCK_LOW )
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCK_PADLOCK );
        }
		else if( lock.LOCK_TYPE == LOCK_MED )
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCK_DOOR_LOCK );
        }
		else if( lock.LOCK_TYPE == LOCK_HARD )
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCK_SAFE_LOCK );
		}
	}
	
    if( answerI == 1 )
    {
        if( player.Timeout[ TO_SK_LOCKPICK ] > int( REAL_SECOND( 1 ) ) )
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_STUCK );
        }
		else if( player.StatBase[ ST_VAR1 ] < lock.LOCK_TYPE + 1 )
		{
            player.StatBase[ ST_VAR1 ]++;
			curPos = int( ( lock.ENTERED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
			
			state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_FURTHER );           
			player.TimeoutBase[ TO_SK_LOCKPICK ] = __FullSecond + REAL_SECOND( 2 );
        }
		else
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_END );           
		}
		PlayGenericSound( map, player.HexX, player.HexY, _GetOneRandom( LockpickMove ), 4 );
    }
	
    if( answerI == 2 )
    {
        if( player.Timeout[ TO_SK_LOCKPICK ] > int( REAL_SECOND( 1 ) ) )
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_STUCK );
		}
		else if( player.StatBase[ ST_VAR1 ] > 1 )
		{
            player.StatBase[ ST_VAR1 ]--;
			curPos = int( ( lock.ENTERED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
			
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_BACKWARDS );
		    player.TimeoutBase[ TO_SK_LOCKPICK ] = __FullSecond + REAL_SECOND( 2 );
		}
		else 
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_CLOSEST );
		}
		PlayGenericSound( map, player.HexX, player.HexY, _GetOneRandom( LockpickMove ), 4 );
	}
	
    if( answerI == 3 )
    {
        curPos = int( ( lock.ENTERED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
        if( curPos < 9 )
        {
            curComb = int( ( lock.STORED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
            lock.ENTERED_CODE += int( pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
            curPos++;
			state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_MOVED_UP );
            if( player.Timeout[ TO_SK_LOCKPICK ] > 0 )
			{
				PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
                state += STR_INSERT_TEXT_LINE( STR_BAD_MOVE );
                if( Random( 0, 1 ) == 0 )
				{
                    int bar = Random( 1, lock.LOCK_TYPE + 1 );
                    curComb = int( ( lock.STORED_CODE % pow( 10, bar ) ) / pow( 10, bar - 1 ) );
                    lock.STORED_CODE += int( ( Random( 1, 9 ) - curComb ) * pow( 10, bar - 1 ) );
                }
            }
			else if( curComb == curPos && base > Random( 0, 100 ) )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                    PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
                }
				state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
			else if( ( curComb == ( curPos - 1 ) || curComb == ( curPos + 1 ) ) && base > Random( 0, 100 ) && Random( 0, 1 ) == 0 )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                   PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
                }
				state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
			else if( ( curComb == ( curPos - 2 ) || curComb == ( curPos + 2 ) ) && base > Random( 0, 100 ) && Random( 0, 3 ) == 0 )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                    PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
				}
                state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
			else if( base < Random( 0, 100 ) && Random( 0, 9 ) == 0 )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                   PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
				}
                state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
            player.TimeoutBase[ TO_SK_LOCKPICK ] = __FullSecond + REAL_SECOND( 10 - player.Skill[ SK_LOCKPICK ] * 10 / 300 );
        }
        else
		{
			state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_TOP );
		}
		map.PlaySound( LockpickMove[ Random( 0, LockpickMove.length() -1 ) ], player.HexX, player.HexY, 2 );
    }
	
    if( answerI == 4 )
    {
        curPos = int( ( lock.ENTERED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
        if( curPos > 1 )
        {
            curComb = int( ( lock.STORED_CODE % pow( 10, player.StatBase[ ST_VAR1 ] ) ) / pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
            lock.ENTERED_CODE -= int( pow( 10, player.StatBase[ ST_VAR1 ] - 1 ) );
            curPos--;
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_MOVED_DOWN );
            if( player.Timeout[ TO_SK_LOCKPICK ] > int( REAL_SECOND( 1 ) ) )
			{
                PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
                state += STR_INSERT_TEXT_LINE( STR_BAD_MOVE );
                if( Random( 0, 1 ) == 0 )
				{
                    int bar = Random( 1, lock.LOCK_TYPE + 1 );
                    curComb = int( ( lock.STORED_CODE % pow( 10, bar ) ) / pow( 10, bar - 1 ) );
                    lock.STORED_CODE += int( ( Random( 1, 9 ) - curComb ) * pow( 10, bar - 1 ) );
                }
            }
			else if( curComb == curPos && base > Random( 0, 100 ) )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                    PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
				}
                state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
			else if( ( curComb == ( curPos - 1 ) || curComb == ( curPos + 1 ) ) && base > Random( 0, 100 ) && Random( 0, 1 ) == 0 )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                    PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
				}
                state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
			else if( ( curComb == ( curPos - 2 ) || curComb == ( curPos + 2 ) ) && base > Random( 0, 100 ) && Random( 0, 3 ) == 0 )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                    PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
                }
                state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
			else if( base < Random( 0, 100 ) && Random( 0, 9 ) == 0 )
			{
                if( player.Skill[ SK_LOCKPICK ] < Random( 0, 200 ) )
				{
                    PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_forcefail.wav", 10 );
				}
                state += STR_INSERT_TEXT_LINE( STR_HEAR_CLICK );
            }
            player.TimeoutBase[ TO_SK_LOCKPICK ] = __FullSecond + REAL_SECOND( 10 - player.Skill[ SK_LOCKPICK ] * 10 / 300 );
        }
		else
		{
			state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_TOP );
		}
		map.PlaySound( LockpickMove[ Random( 0, LockpickMove.length() -1 ) ], player.HexX, player.HexY, 2 );
	}
	
    if( answerI == 5 )
    {
        if( lock.STORED_CODE == lock.ENTERED_CODE )
        {
            if( lock.GetType() == ITEM_TYPE_CONTAINER )
			{
				ShowContainer( player, lock, lock.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
            }
			else
			{
				lock.LockerOpen();
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOCKPICKING_SUCCESS );
			}
			lock.LockerCondition = LOCKER_ISOPEN;
            lock.Update();
            
			if( valid( lockpick ) )
			{
                lockpick.LOCK_TYPE = 0;
            }
			PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_unlock.wav", 6 );
			
			LogCrimeMovement( player, lock, "successfully lockpicks" ); 
            return;
        }
		else if( player.StatBase[ ST_VAR2 ] < Random( 0, player.Skill[ SK_LOCKPICK ] / 2 ) )
		{
			state += STR_INSERT_TEXT_LINE( STR_WONT_BUDGE );
            player.StatBase[ ST_VAR2 ]++;
			PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_picktension_01_lpm.wav", 6 );
        }
		else
		{
            player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_LOCKPICK_FAIL );
            if( valid( lockpick ) && Random( 0, 1 ) == 0 )
			{
                lockpick.LOCK_TYPE = 0;
			}
			map.PlaySound( "ui_lockpicking_forcefail.wav", player.HexX, player.HexY, 5 );
            return;
        }
    }
    if( answerI == 6 )
    {
        if( player.StatBase[ ST_VAR1 ] > 1 )
		{
            state += STR_INSERT_TEXT_LINE( STR_LOCKPICK_BOTTOM );
        }
		else
		{
            lockpick.LOCK_TYPE = 0;
            player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_LOCKPICK_EXTRACTED );
			PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_enter.wav", 6 );
            return;
        }
    }
	
    if( answerI == 7 )
    {
		lockpick.LOCK_TYPE = 0;
		int realskill = player.Skill[ SK_LOCKPICK ];
		switch( lockpickPid )
		{
			case( PID_LOCKPICKS ):
				realskill += 25;
				break;
			case( PID_EXP_LOCKPICK_SET ):
				realskill += 50;
				break;
			default:
				break;
		}
		
        if( ( realskill - lock.LockerComplexity ) < 0 )
		{
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SKILL_TOO_LOW_TO_LOCK );
			LogCrimeMovement( player, lock, "did not lock the door with a lockpick because of low skill" ); 
			return;
		}
		else if( FLAG( lock.LockerCondition, LOCKER_LOCKED ) )
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOOR_ALREADY_LOCKED );
			LogCrimeMovement( player, lock, "did not lock the door with a lockpick because the door is locked already" ); 
			return;
		}
		else if( FLAG( lock.LockerCondition, LOCKER_ISOPEN ) && InteractContainer.find( lock.GetProtoId() ) == -1 )
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CLOSE_DOOR );
			LogCrimeMovement( player, lock, "did not lock the door with a lockpick because the door is open" ); 
			return;
        }
		else
		{
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOCKED_DOOR );
			lock.LockerCondition = LOCKER_LOCKED;
			PlayGenericSound( map, player.HexX, player.HexY, "ui_lockpicking_unlock.wav", 6 );
			LogCrimeMovement( player, lock, "locks the door with a lockpick" ); 
            return;
		}
    }
	_CritAnimateUse( player );
    state += "$toung" + STR_INSERT_TEXT_LINE( STR_LOCK_TOUNG_DESC )
		  + "$posToung" + curPos 
		  + "$posLockpick" + player.StatBase[ ST_VAR1 ]
		;

	state += "$secret";
	if( player.Param[ QST_GAMEMODE ] == GAME_TEST )
	{
		state += STR_INSERT_TEXT_LINE( STR_LOCK_SECRET_INFO )
			  + "$code" + lock.STORED_CODE
			  + "$attempt" + lock.ENTERED_CODE
			;
	}
	
    player.ShowScreen( SCREEN_DIALOGBOX, 8, "answer_LOCKPICK_lock" );
    player.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_LOCK_STATE_DESC, state );
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_EXAMINE_THE_LOCK );
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 1 ), TEXTMSG_TEXT, STR_MOVE_FURTHER );
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 2 ), TEXTMSG_TEXT, STR_MOVE_BACKWARD );
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 3 ), TEXTMSG_TEXT, STR_MOVE_UP	);	
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 4 ), TEXTMSG_TEXT, STR_MOVE_DOWN );
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 5 ), TEXTMSG_TEXT, STR_TURN );
    player.SayMsg( SAY_DIALOGBOX_BUTTON( 6 ), TEXTMSG_TEXT, STR_REMOVE_LOCKPICK	);
	player.SayMsg( SAY_DIALOGBOX_BUTTON( 7 ), TEXTMSG_TEXT, STR_LOCK_THE_LOCK );	
}

bool IsKeyAviable( Critter& cr, uint lockerId )
{
    if( lockerId == 0 )
	{
        return false;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return false;
	}

    Item@[] keys;
    Item@ key = null;
    uint len = cr.GetItems( -1, keys );
    for( uint i = 0; i < len; i++ )
    {
        @key = keys[i];
        if( !valid( key ) )
		{
            continue;
		}
		
        if( key.GetType() == ITEM_TYPE_KEY && key.LockerId == lockerId )
        {
            return true;
        }
        
        if( key.GetProtoId() == PID_KEY_BUNCH || key.GetProtoId() == PID_FNKEYBT )
        {
            PlayGenericSound( map, cr.HexX, cr.HexY, "keys.ogg", 6 );
            
            Item@[] sub_keys;
            uint count = key.GetItems( 0, sub_keys );
            for( uint j = 0; j < count; j++ )
            {
                @key = sub_keys[j];
				if( !valid( key ) )
				{
					continue;
				}
                    
                if( key.LockerId == lockerId )
                {
                    return true;
                }
            }
        }
    }
    return false;
}

uint GetKeyId( Critter& cr, uint lockerId )
{
    if( lockerId == 0 || _CritFingersDoorId( cr.Id ) == lockerId || _CritEyesDoorId( cr.Id ) == lockerId )
	{
        return 0;
    }
	Item@[] keys;
    for( uint i = 0, j = cr.GetItemsByType( ITEM_TYPE_KEY, keys ); i < j; i++ )
	{
        if( keys[ i ].LockerId == lockerId )
		{
            return keys[ i ].Id;
		}
	}
	return 0;
}

void SwitchState( Item& locker )
{
    if( locker.GetType() == ITEM_TYPE_DOOR || locker.GetType() == ITEM_TYPE_CONTAINER )
    {
        if( !FLAG( locker.LockerCondition, LOCKER_NOOPEN ) )
        {
            if( FLAG( locker.LockerCondition, LOCKER_ISOPEN ) )
			{
                locker.LockerClose();
            }
			else
			{
                locker.LockerOpen();
			}
		}
    }
}

void LockerBudge( Item& item )
{
    Map@ map = GetMap( item.MapId );
    if( !valid( map ) )
	{
        return;
	}
	string sound = item.GetType() == ITEM_TYPE_DOOR ? "SLDOORSC.mp3" : "ILCNTNRB.mp3"; // fix to sound database
    map.PlaySound( sound, item.HexX, item.HexY, 8 );
}

bool ltp_lock_remove_inited = false;
void ltp_lock_remove_init()
{
	LTPREG( LTP_LOCK_REMOVE, process_lock_remove )
	ltp_lock_remove_inited = true;
}

bool TryRemoveLock( Critter& cr, Item& item, Item& targetItem )
{
	if( !valid( item ) )
	{
		return false;
	}
	
	if( !valid( targetItem ) )
	{
		return false;
	}
	
	if( !ltp_lock_remove_inited )
	{
		ltp_lock_remove_init();
	}
	
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CRITTER_LOOT_DELAY * 2;
	cr.ParamBase[ ST_LTP_SEQUENCE ] = 0;
	cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
	StartProcess( cr, LTP_LOCK_REMOVE, 0, item.Id, targetItem.Id, cr.Param[ ST_LTP_SEQUENCE_WAIT ] );
	cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_REMOVE_LOCK );
	return true;
}

uint process_lock_remove( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_LOCK_REMOVE )
	Item@ tool = GetItem( param1 );

    if( !valid( tool ) )
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
        return 0;
	}
	
	Item@ targetItem = GetItem( param2 );
	if( !valid( targetItem ) )
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
        return 0;
	}
	
	LockRemoval( cr, tool, targetItem );

	return 0;
}

bool LockRemoval( Critter& cr, Item& item, Item& targetItem )
{
	uint8 itemType = targetItem.GetType();
	uint16 pid = item.GetProtoId();
	if( ( ( itemType == ITEM_TYPE_DOOR || itemType == ITEM_TYPE_CONTAINER ) && targetItem.LOCK_TYPE != 0 && _LockerIsOpen( targetItem ) && !FLAG( targetItem.LockerCondition, LOCKER_LOCKED ) ) 
		|| ( itemType == ITEM_TYPE_CONTAINER && InteractContainer.find( targetItem.GetProtoId() ) != -1 && targetItem.LOCK_TYPE != 0 && !FLAG( targetItem.LockerCondition, LOCKER_LOCKED  ) ) )
	{
		uint16 pid_locker = 0;
		switch( targetItem.LOCK_TYPE )
		{
			case( LOCK_LOW ):
				pid_locker = PID_LOCK_LOW;
				break;
			case( LOCK_MED ):
				pid_locker = PID_LOCK_MED;
				break;
			case( LOCK_HARD ):
				pid_locker = PID_LOCK_HARD;
				break;
			case( LOCK_CODE ):
				pid_locker = PID_LOCK_CODE;
				break;	
			default:
				break;
		}
		
		if( pid_locker != 0 )
		{
			if( pid == PID_MULTI_TOOL || pid == PID_SUPER_TOOL_KIT )
			{
				Item@ locker = cr.AddItem( pid_locker, 1 );
				locker.Update();
			}

			if( item.GetProtoId() == PID_CROWBAR )
			{
				uint16 amount = 1;
				switch( pid_locker )
				{
					case( PID_LOCK_LOW ):
						amount = 3;
						break;
					case( PID_LOCK_MED ):
						amount = 6;
						break;
					case( PID_LOCK_HARD ):
						amount = 10;
						break;
					case( PID_LOCK_CODE ):
						amount = 6;
						break;
					default:
						amount = 1;
						break;
				}
				
				cr.AddItem( PID_CRAFT_M_BARS, Random( 1, amount ) );
			}
		}
		
		targetItem.LOCK_TYPE = 0;
		targetItem.CODEDOOR_CODE = 0;
		targetItem.ENTERED_CODE = 0;
		targetItem.STORED_CODE = 0;
		targetItem.LockerComplexity = 0;
		targetItem.LockerId = 0;
		targetItem.LockerCondition = LOCKER_ISOPEN;
		targetItem.Update();
		
		Map@ map = cr.GetMap();
		PlayGenericSound( map, cr.HexX, cr.HexY, "ILCNTNRC.mp3", 20 );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_REMOVED_LOCK );
		LogCrimeMovement( cr, targetItem, " had its lock removed" );
	}
	
	cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
	
	return true;
}

bool KeyBunchUse( Critter& cr, Item@ item, Item@ targetItem )
{
	Item@[] keys;
	Item@ key = null;
	uint count = item.GetItems( uint( -1 ), keys );
	Map@ map = cr.GetMap();
	if( valid( map ) )
	{
		PlayGenericSound( map, cr.HexX, cr.HexY, "keys.ogg", 6 );
	}

	for( uint i = 0; i < count; i++ )
	{
		@ key = keys[i];
		if( !valid( key ) )
		{
			continue;
		}
		
		if( key.LockerId == targetItem.LockerId )
		{
			UseItemOnLocker( cr, targetItem, key );
			return true;
		}
	}
	
	return false;
}

bool TryInstallLock( Critter& cr, Item& item, Item& onItem )
{
	if( !valid( item ) )
	{
		return false;
	}
	
	if( !valid( onItem ) )
	{
		return false;
	}
	
	uint16 pid = item.GetProtoId();
	uint16 tpid = onItem.GetProtoId();
	uint8 type = onItem.GetType();
	
	if( tpid == PID_TERMINAL )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NO_LOCK_TERMINAL );
		return false; 
	}
	
	if( tpid == PID_TENT_DOOR_EW || tpid == PID_TENT_DOOR_NS )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_LOCK );
		return false; 
	}
	
	if( ( ( type == ITEM_TYPE_DOOR || ( type == ITEM_TYPE_CONTAINER && onItem.Proto.Container_Changeble ) ) && onItem.CODEDOOR_CODE == 0 ) 
			|| ( InteractContainer.find( tpid ) != -1 || onItem.Proto.Item_Subtype == ITEM_SUBTYPE_BRIEFCASE ) && onItem.LOCK_TYPE == LOCK_NONE )
	{
		if( _LockerIsClose( onItem ) || InteractContainer.find( tpid ) != -1 )
		{
			Item@ used = null;
			if( pid == PID_LOCK_CODE )
			{
				if( !hasItem( cr, PID_COPPER_WIRE ) )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_REQUIRES_WIRE );
					return true;
				}
				
				@used = cr.GetItem( PID_COPPER_WIRE, -1 ); 
			}
			else
			{
				if( !hasItem( cr, PID_CRAFT_M_BARS ) )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_METAL_PART );
					return true;
				}
				
				@used = cr.GetItem( PID_CRAFT_M_BARS, -1 ); 
			}
			
			if( onItem.LockerCondition != LOCKER_LOCKED && onItem.LockerComplexity == 0 && !FLAG( onItem.LockerCondition, LOCKER_ELECTRO ) && onItem.ENTERED_CODE == 0 )
			{
				if( !ltp_lock_install_inited )
				{
					ltp_lock_install_init();
				}
	
				cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CRITTER_LOOT_DELAY * 2;
				cr.ParamBase[ ST_LTP_SEQUENCE ] = 0;
				cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
				StartProcess( cr, LTP_LOCK_INSTALL, used.Id, item.Id, onItem.Id, cr.Param[ ST_LTP_SEQUENCE_WAIT ] );
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_INSTALL_LOCK );
				return true;
			}
			else
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOOR_LOCKED );
				return true;
			}
		}
		else 
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOOR_NOT_CLOSED );
			return true;
        }
	}
	else
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOOR_CANT_LOCK );
		return true;
	}
}

bool ltp_lock_install_inited = false;
void ltp_lock_install_init()
{
	LTPREG( LTP_LOCK_INSTALL, process_lock_set )
	ltp_lock_install_inited = true;
}

uint process_lock_set( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_LOCK_INSTALL )
	
	Item@ used = GetItem( param0 );
	if( !valid( used ) )
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
        return 0;
	}
	
	Item@ tool = GetItem( param1 );
    if( !valid( tool ) )
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
        return 0;
	}
	
	Item@ targetItem = GetItem( param2 );
	if( !valid( targetItem ) )
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
        return 0;
	}
	
	if( tool.GetProtoId() == PID_LOCK_CODE )
	{
		UseCodeLock( cr, tool, targetItem, used );
	}
	else
	{
		InstallLock( cr, tool, targetItem, used );
	}
	
	return 0;
}

bool InstallLock( Critter& cr, Item& item, Item& targetItem, Item& used )
{
	uint key_pid = PID_BLANK_KEY;
	switch( item.GetProtoId() )
	{
		case( PID_LOCK_LOW ):
			targetItem.LOCK_TYPE = LOCK_LOW;
			key_pid = PID_TEMPLE_KEY;
			break;
		case( PID_LOCK_MED ):
			targetItem.LOCK_TYPE = LOCK_MED;
			key_pid = PID_JAIL_KEY;
			break;
		case( PID_LOCK_HARD ):
			targetItem.LOCK_TYPE = LOCK_HARD;
			key_pid = PID_VAULT_13_SHACK_KEY;
			break;
		default:
			return false;
	}

	_SubItem( used, 1 );
	
	Item@ key = cr.AddItem( key_pid, 1 );
	key.LockerId = Random( 0, 65534 );

	targetItem.LockerId = key.LockerId;
	targetItem.LockerCondition = LOCKER_LOCKED;
	targetItem.LockerComplexity = cr.Skill[ SK_LOCKPICK ];

	//Log( "An item #" + targetItem.Id + " is locked. Lock complexity is: " + targetItem.LockerComplexity + "." );
	LogCrimeMovement( cr, targetItem, "is locked. Lock complexity is: " + targetItem.LockerComplexity + "." );
	_SubItem( item, 1 );

	key.SetLexems( null );
	key.Update();

	cr.StatBase[ ST_LAST_DOOR_ID ] = key.Id;
	cr.StatBase[ ST_LAST_CONT_ID ] = key.Accessory;
	ShowInputBoxScreen( cr, "general_unsafe@unsafe_addLexem#Description:", 0, INPUTBOX_CLOSE_ON_ENTER );
	cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
	return true;
}

bool UseCodeLock( Critter& cr, Item& codeLock, Item& locker, Item& used )
{
	if( !valid( codeLock ) )
	{
		return false;
	}

	if( !valid( used ) )
	{
		return false;
	}

	if( valid( locker ) )
	{
		uint16 pid = locker.GetProtoId();
		uint8 type = locker.GetType();
		
		if( ( type == ITEM_TYPE_DOOR || ( type == ITEM_TYPE_CONTAINER && locker.Proto.Container_Changeble ) ) && locker.ENTERED_CODE == 0 ) 
        {
            if( InteractContainer.find( pid ) == -1 )
            {
				locker.LOCK_TYPE = LOCK_CODE;
				string passwordInfo = "Set new password";
				int[] lockId = { codeLock.Id };
				cr.RunClientScript( "client_screen_numberpad@ShowScreen", locker.Id, 0, 0, passwordInfo, lockId );
				_SubItem( used, 1 );
				cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			}
		}
		
		return true;
	}

	return false;
}

#endif //LOCKERS