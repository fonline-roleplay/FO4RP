// Author: heX, cvet

/*
        Generic mob ai
        Только для мобов животных.
        Var6..Var9 заняты.
        рекомендуеться выставлять TeamId в диапазоне: 24..33
        33 - не групируется, это значит что мобы не будут помогать друг другу.
        также учтите что группа 0 тоже не группируется.

        TODO:
        сделать чтобы VarFear както уменьшался
        включать обработчик idle только если рядом есть игрок.
        таблица типа поведения монстров.
        трусость мобов - сначало нужно отбегать от атакующего, затем старатся приблизится к дому на расстоянии от атакующего.
        {
                атака тех кто атакует (нужно для блокировки чита 'бегун')
                при условии что злость(Fury) меньше X (нужно для блокировки 'pin-pong' чита)
                и текущий враг не на расстоянии поражения
                и новый враг на не слишком большой дистанции
        }
        отступление если игрок атакует из недостижимой точки (чит 'безопастной атаки').
        ? блокировка возвращения домой если мы уже стоим впритык к противнику и успешно атакуем его.
        ? отступать домой только если вся группа так решила.

        тест:
        DONE запрет атаковать всех из своей группы (ситуация вознимает если они блокируют проход)
        DONE трусость мобов - если то он не должен идти в атаку при атаке

        ok:
        DONE трусость мобов - отступление если мало жизней
        DONE скан при возвращении домой (Watch)
        DONE сброс VarX при респавне
        DONE трусость мобов - добавить отступление при больших потерях
        DONE блокировка GoHo если они уже дома
        DONE остановка преследования при большой дистанции - отладить (несрабатывает)
 */

#include "_colors.fos"
#include "_macros.fos"
#include "_npc_pids.fos"

import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import bool AddWalkPlane( Critter& npc, uint priority, uint16 hexX, uint16 hexY, uint8 dir, bool run, uint cut ) from "npc_planes";
import uint EraseAttackPlane( Critter& npc, Critter& target ) from "npc_planes";

import bool ChangeWildness( uint16 x, uint16 y, int delta ) from "globalmap_group";
import void ChangeMonsterCount( Critter& cr, bool increase ) from "globalmap_group";
import void ReduseWildByWildness( Critter& cr ) from "globalmap_group";

// OPTIONS:
#define DISTANCE_ATTACK          ( 10 ) // расстояние начала атаки
#define DISTANCE_GROUP_RADIUS    ( 35 ) // расстояние на котором группа видит друг друга (и помогает атаковать противника)
#define DISTANCE_GO_HOME         ( 15 ) // расстояние от дома при котором моб идет домой
#define MAX_FURY                 ( 2 )  // сколько раз нужно разозлить НПС чтобы он стал игнорить границы обитания
#define DISTANCE_HELP            ( 35 ) // расстояние помощи
#define TIME_TEST_GO_HOME        ( 10 ) // переодичность тестирования на возврат домой и отмену атаки

// номера сообщений
#define MSG_GROUP_ATTACK         ( 16001 )
#define MSG_GROUP_FURY           ( 16002 )

// переименования VarX (для удобства и абстрактности)
#define VarAttacked              StatBase[ ST_VAR6 ]
#define VarFury                  StatBase[ ST_VAR7 ]
#define VarFear                  StatBase[ ST_VAR8 ]
#define VarMaxFear               StatBase[ ST_VAR9 ]

const uint16[] Pids_BestialMobs =
{
	NPC_PID_RegularRat,
	NPC_PID_Mantis,
	NPC_PID_Ant,
	NPC_PID_RegularPigRat,
	NPC_PID_Molerat,
	NPC_PID_MutatedMolerat,
	NPC_PID_SmallSilverGecko,
	NPC_PID_GoldenGecko,
	NPC_PID_WildDog,
	NPC_PID_SmallRadscorpion,
	NPC_PID_LargeRadscorpion,
	NPC_PID_Brahmin,
	// NPC_PID_SporePlant,	// - Отключил. У них нет ножек, нужен другой 'алгоритм'.
	NPC_PID_Alien,
	NPC_PID_SmDeathclaw,
	NPC_PID_Deathclaw,
	NPC_PID_ToughDeathclaw,
	NPC_PID_FireGecko,
	NPC_PID_Centaur,
	NPC_PID_Floater,
	NPC_PID_MirelurkWeak
};

void GM_MobInit( Critter& npc ) // Export
{
    npc.SetScript( "_MobInit" );
}

void GM_MobBossInit( Critter& npc ) // Export
{
    npc.SetScript( "_BossMobInit" );
}

void GM_MobMinionInit( Critter& npc ) // Export
{
	npc.PerkBase[ PE_SILENT_RUNNING ] = 1;
    npc.SetScript( "_MinionMobInit" );
}

void _MobsMapInit( Map& map, bool firstTime )
{
    ActivateMobScript( map );
}

void _MobInit( Critter& npc, bool firstTime )
{
    npc.ModeBase[ MODE_NO_HOME ] = 0;

    uint16 locPid = npc.GetMap().GetLocation().GetProtoId();
    if( LOCATION_IS_CITY( locPid ) )
        // npc.StatBase[ST_REPLICATION_TIME]= 6 * 60 * __TimeMultiplier; // 6 real hours
        npc.StatBase[ ST_REPLICATION_TIME ] = __FullSecond + REAL_HOUR( 2 );
    else
        npc.StatBase[ ST_REPLICATION_TIME ] = -1;      // Newer

    ResetVars( npc );

    npc.ShowCritterDist1 = DISTANCE_ATTACK;
    npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_1, "_ShowPlayer" );
    npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER, "_HidePlayer" );    // отсутствие "_1" это не ошибка, так надо.

    // дистанция мнгновенной атаки
	npc.ShowCritterDist2=1;
    npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_2, "_ShowPlayerFastAttack" );
    npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER_2, "_HidePlayerFastAttack" );

    npc.SetEvent( CRITTER_EVENT_IDLE,        "_Idle" );
    npc.SetEvent( CRITTER_EVENT_MESSAGE,     "_OnMessage" );
    npc.SetEvent( CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin" );
    npc.SetEvent( CRITTER_EVENT_SMTH_DEAD,   "_Death" );
     npc.SetEvent(CRITTER_EVENT_DEAD,        "_MyDeath");
    npc.SetEvent( CRITTER_EVENT_RESPAWN,     "_Respawn" );
    npc.SetEvent( CRITTER_EVENT_ATTACKED,    "_Attacked" );
}

void _MobInit1( Critter& npc, bool firstTime )
{
    npc.ModeBase[ MODE_NO_HOME ] = 0;

    uint16 locPid = npc.GetMap().GetLocation().GetProtoId();
    if( LOCATION_IS_CITY( locPid ) )
        // npc.StatBase[ST_REPLICATION_TIME]= 6 * 60 * __TimeMultiplier; // 6 real hours
        npc.StatBase[ ST_REPLICATION_TIME ] = = -1;
    else
        npc.StatBase[ ST_REPLICATION_TIME ] = -1;      // Newer

    ResetVars( npc );

    npc.ShowCritterDist1 = 20;
	npc.ParamBase[ ST_TEAM_ID ] = 17;
    npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_1, "_ShowPlayer" );
    npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER, "_HidePlayer" );    // отсутствие "_1" это не ошибка, так надо.
	//npc.SetFavoriteItem( SLOT_HAND1, 299 ); 

    // дистанция мнгновенной атаки
//	npc.ShowCritterDist2=1;
    npc.SetEvent( CRITTER_EVENT_SHOW_CRITTER_2, "_ShowPlayerFastAttack" );
    npc.SetEvent( CRITTER_EVENT_HIDE_CRITTER_2, "_HidePlayerFastAttack" );

    npc.SetEvent( CRITTER_EVENT_IDLE,        "_Idle" );
    npc.SetEvent( CRITTER_EVENT_MESSAGE,     "_OnMessage1" );
    npc.SetEvent( CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin1" );
    //npc.SetEvent( CRITTER_EVENT_SMTH_DEAD,   "_Death" );
    // npc.SetEvent(CRITTER_EVENT_DEAD,        "_MyDeath");
    npc.SetEvent( CRITTER_EVENT_ATTACKED,    "_Attacked" );
}

void ActivateMobScript( Map& map ) // Export
{
    Critter@[] critters;
    for( uint i = 0, j = Pids_BestialMobs.length(); i < j; i++ )
        map.GetCritters( Pids_BestialMobs[ i ], FIND_ALL | FIND_ONLY_NPC, critters );

    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetScriptId() == 0 && ( critters[ i ].Stat[ ST_TEAM_ID ] == 0 || ( critters[ i ].Stat[ ST_TEAM_ID ] >= 24 && critters[ i ].Stat[ ST_TEAM_ID ] <= 33 ) ) )
            critters[ i ].SetScript( "_MobInit" );
    }
}

void ResetVars( Critter& npc )
{
    npc.VarAttacked = 0;
    npc.VarFury = 0;
    npc.VarFear = 0;
    if( not ( npc.Stat[ ST_TEAM_ID ] == 0 || npc.Stat[ ST_TEAM_ID ] == 33 ) )
        npc.VarMaxFear = GetMyTeamCount( npc ) * 80 / 100;
    else
        npc.VarMaxFear = 10;
}

// Try go to home position
void TryGoHome( Critter& npc )
{
    if( npc.VarFury < MAX_FURY && npc.IsLife() )
    {
        uint   mapId = 0;
        uint16 homeX = 0;
        uint16 homeY = 0;
        uint8  dir = 0;
        npc.GetHomePos( mapId, homeX, homeY, dir );
        if( npc.GetMapId() == mapId && GetDistantion( homeX, homeY, npc.HexX, npc.HexY ) > DISTANCE_GO_HOME )
        {
            npc.DropPlanes();
            AddWalkPlane( npc, 0, homeX, homeY, dir, false, 0 );
        }
    }
}

// убегаем от когото
void AddPlaneEscape( Critter& npc, Critter& fromRunning )
{
    // TMP:
    TryGoHome( npc );
    // нужно взять угол от атакующего и бежать в противоположном направлении
    // причем нужно еще делать проверку на дистанцию
}

// собрать нпц по номеру группы
uint GetCrittersByTeam( Map& map, uint x, uint y, uint radius, int team )
{
    uint count = 0;
    Critter@[] critters;
    for( uint i = 0, j = map.GetCrittersHex( x, y, radius, FIND_LIFE | FIND_ONLY_NPC, critters ); i < j; i++ )
        if( critters[ i ].Stat[ ST_TEAM_ID ] == team )
            count++;
    return count;
}

uint GetMyTeamCount( Critter& npc )
{
    return GetCrittersByTeam( npc.GetMap(), npc.HexX, npc.HexY, DISTANCE_GROUP_RADIUS, npc.Stat[ ST_TEAM_ID ] );
}

// CRITTER_EVENT_SMTH_DEAD
// Когда криттер в области видимости умирает. См. CRITTER_EVENT_DEAD.
void _Death( Critter& npc, Critter& fromCrit, Critter@ killer )
{
    if( not valid( killer ) )
        return;
    if( npc.Stat[ ST_TEAM_ID ] == 0 || npc.Stat[ ST_TEAM_ID ] == 33 )
        return;

    if( npc.Stat[ ST_TEAM_ID ] == fromCrit.Stat[ ST_TEAM_ID ] )
    {
        // если убили когото из своей команды то пугаемся
        npc.VarFear++;
        if( npc.VarFear > npc.VarMaxFear )
        {
            // если слишком страшно то убегаем
            npc.DropPlanes();
            npc.EraseEnemyFromStack( killer.Id );
            AddPlaneEscape( npc, killer );
        }
    }
    else if( npc.Stat[ ST_TEAM_ID ] == killer.Stat[ ST_TEAM_ID ] )
    {
        // если ктото из своей команды убивает то поднимаем боевой дух (уменьшаем страх)
        npc.VarFear -= 2;
    }
}

// CRITTER_EVENT_DEAD
void _MyDeath( Critter& npc, Critter@ killer )
{
    npc.ClearEnemyStack();
	npc.AddTimeEvent ("cte_rotten", 0, CTE_ROTTEN, 0);
	
	//ChangeMonsterCount( npc, false );
    //ReduseWildByWildness( npc );
    //ChangeWildness(npc.WorldX/10, npc.WorldY/10, -5);
}

uint cte_rotten (Critter& cr, int identifier, uint& rate ) 
{
	if( cr.StatBase[ST_BODY_TYPE] == BT_ROBOT ) //Роботы лежат вечно.
		return 0;
	
	rate++;
	
	bool isPlant = cr.StatBase[ST_BODY_TYPE] == BT_PLANT;

	cr.StatBase[ ST_CURRENT_HP ]--;
	if( cr.Stat[ ST_CURRENT_HP ] < __DeadHitPoints - cr.Stat[ ST_MAX_LIFE ]  ) //Превращается в останки.
	{
		if( !isPlant )
		{
			Item@ bones;
			Map@ map = cr.GetMap();
			if( valid(map) )
				@bones = map.AddItem( cr.HexX, cr.HexY, Random( PID_BLOOD_BONES_1, PID_BLOOD_BONES_3 ), 1 );
			if( valid( bones) )
			{
				uint[] data = { bones.Id, rate };
				CreateTimeEvent( __FullSecond + REAL_SECOND( 60 ), "e_rotten_bones", data, true );
			}
		}
		DeleteNpc( cr );
		return 0;
	}
	if( cr.Stat[ ST_CURRENT_HP ] < __DeadHitPoints && !isPlant )
	{
		Map@ map = cr.GetMap();
		if( valid(map) )
			map.SetText( cr.HexX, cr.HexY, COLOR_LGRAY, ":запах " + ( rate < 10 ? "крови" : "разложения" ) + ":" );
	}
	return REAL_SECOND( cr.Stat[ ST_MAX_LIFE ] ); //Чем крупней, тем дольше гниёт.
}

uint e_rotten_bones( uint[] @ values )
{
	if( !valid(values) || values.length() != 2 || values[0] == 0 )return 0;
	Item@ bones = GetItem( values[0] );
	if( !valid(bones) )return 0;
	
	values[1]++;
	
	bones.Val0 += Random( 1, 3 );
	if( bones.Val0 > 10 )
		DeleteItem( bones );
	
	Map@ map = GetMap( bones.MapId );
	if( valid(map) && bones.Accessory == ACCESSORY_HEX )
		map.SetText( bones.HexX, bones.HexY, COLOR_LGRAY, ":запах " + ( values[1] < 10 ? "крови" : "разложения" ) + ":" );
	
	return REAL_MINUTE( Random( 5, 15 ) );
}


// CRITTER_EVENT_RESPAWN
void _Respawn( Critter& npc )
{
    // ResetVars(npc);
    DeleteNpc( npc );
}

// CRITTER_EVENT_SHOW_CRITTER
// Появился новый криттер в поле зрения.
void _ShowPlayer( Critter& npc, Critter& player )
{
	Critter@ target = ::GetCritter( player.Id );
    if( not player.IsPlayer() /* && player.StatBase[ST_BODY_TYPE] > 4*/ )
        return;

    if( npc.StatBase[ ST_BASE_CRTYPE ] == player.StatBase[ ST_BASE_CRTYPE ] )
        return;

    //npc.Say( SAY_EMOTE, "!!!" );
	
	if( npc.VarFear > npc.VarMaxFear )
    {
        // если испуганы то игнорим и убегаем
        if( npc.IsNoPlanes() )
            AddPlaneEscape( npc, player );
    }
    else
    {
        if( player.Param[ QST_GAMEMODE ] != GAME_ARCADE )
		npc.SendMessage( MSG_GROUP_ATTACK, target.Id, MESSAGE_TO_WHO_SEES_ME );
            AddAttackPlane( npc, 10, player );
    }
}

void _ShowPlayer1( Critter& npc, Critter& player )
{
    /*if( not player.IsPlayer() /* && player.StatBase[ST_BODY_TYPE] > 4 )
        return;*/

    if( npc.StatBase[ ST_BASE_CRTYPE ] == player.StatBase[ ST_BASE_CRTYPE ] )
        return;

    if( npc.VarFear > npc.VarMaxFear )
    {
        // если испуганы то игнорим и убегаем
        if( npc.IsNoPlanes() )
            AddPlaneEscape( npc, player );
    }
    else
    {
        if( player.Param[ QST_GAMEMODE ] != GAME_ARCADE )
            AddAttackPlane( npc, 10, player );
    }
}

// CRITTER_EVENT_HIDE_CRITTER
// Пропал криттер с поля зрения.
void _HidePlayer( Critter& npc, Critter& player )
{
    if( not player.IsPlayer() )
        return;
	
	//npc.Say( SAY_EMOTE, "???" );
	
    if( npc.VarFury < MAX_FURY )
    {
        npc.EraseEnemyFromStack( player.Id );
        EraseAttackPlane( npc, player );
    }
}

// CRITTER_EVENT_SHOW_CRITTER
// Появился новый криттер в поле зрения.
void _ShowPlayerFastAttack( Critter& npc, Critter& player )
{
    if( not player.IsPlayer() )
        return;
    AddAttackPlane( npc, AI_PLANE_ATTACK_PRIORITY + 1, player );
}

// CRITTER_EVENT_HIDE_CRITTER
// Пропал криттер с поля зрения.
void _HidePlayerFastAttack( Critter& npc, Critter& player )
{
    if( not player.IsPlayer() )
        return;
    EraseAttackPlane( npc, player );
}

// CRITTER_EVENT_MESSAGE
// Пришло сообщение отправленное с помощью Critter::SendMessage.
void _OnMessage( Critter& npc, Critter& fromCrit, int message, int value )
{
    if( npc.IsPlayer() )
        return;
    if( not npc.IsLife() )
        return;
    if( npc.Stat[ ST_TEAM_ID ] == 0 )
        return;                               // 0 группа не групируеться
    if( npc.Stat[ ST_TEAM_ID ] == 33 )
        return;                               // 33 группа не групируеться
    if( npc.Stat[ ST_TEAM_ID ] != fromCrit.Stat[ ST_TEAM_ID ] )
        return;                               // ктото не из нашей группы

    if( fromCrit.IsPlayer() )
    {
        AddAttackPlane( npc, 10, fromCrit );
    }

    if( message == MSG_GROUP_ATTACK )
    {
        Critter@ target = ::GetCritter( value );
        if( not valid( target ) )
            return;
        if( ::GetCrittersDistantion( npc, fromCrit ) > DISTANCE_GROUP_RADIUS )
            return;
        AddAttackPlane( npc, 0, target );
    }
    else if( message == MSG_GROUP_FURY )
    {
        npc.VarFury++;
    }
}

void _OnMessage1( Critter& npc, Critter& fromCrit, int message, int value )
{
    if( npc.IsPlayer() )
        return;
    if( not npc.IsLife() )
        return;
    if( npc.Stat[ ST_TEAM_ID ] == 0 )
        return;                               // 0 группа не групируеться
    if( npc.Stat[ ST_TEAM_ID ] == 33 )
        return;                               // 33 группа не групируеться
    if( npc.Stat[ ST_TEAM_ID ] != fromCrit.Stat[ ST_TEAM_ID ] )
        return;                               // ктото не из нашей группы

    if( fromCrit.IsPlayer() )
    {
        AddAttackPlane( npc, 10, fromCrit );
    }

    if( message == MSG_GROUP_ATTACK )
    {
        Critter@ target = ::GetCritter( value );
        if( not valid( target ) )
            return;
        if( ::GetCrittersDistantion( npc, fromCrit ) > 70 )
            return;
        AddAttackPlane( npc, 0, target );
    }
    else if( message == MSG_GROUP_FURY )
    {
        npc.VarFury++;
    }
}

// CRITTER_EVENT_IDLE
// Простой, вызывается каждые __CritterIdleTick секунд, для изменения времени вызывайте Critter::Wait в функции.
void _Idle( Critter& npc )
{
	uint   mapId = 0;
	uint16 homeX = 0;
	uint16 homeY = 0;
	uint8  dir = 0;
	npc.GetHomePos( mapId, homeX, homeY, dir );
	
	if( npc.GetMapId() != mapId ) return; //Если не на домашней карте - не рыпаемся.
	uint dist = GetDistantion( homeX, homeY, npc.HexX, npc.HexY );

	if( dist > 4 ) //Топаем к гнезду, если загулялись.
	{
		npc.DropPlanes();
		AddWalkPlane( npc, 0, homeX, homeY, dir, false, 0 );
	}
    else npc.MoveRandom(); //Шароёбимся по родной лощине.
}

void _BossIdle( Critter& npc )
{
	Map @ map = npc.GetMap();
	if( map.GetData( 0 ) <= 0 ) return; // не бродить без игроков на карте

	if( Random(0,9) == 0 )
	{
    uint16 HomeHx = npc.HexX + Random(-20,20);
    uint16 HomeHy = npc.HexY + Random(-20,20);	
	if( not map.IsHexPassed( HomeHx, HomeHy ) || map.GetPathLength( npc, HomeHx, HomeHy, 0 ) > 50 || GetDistantion( HomeHx, HomeHy, npc.HexX, npc.HexY ) <= DISTANCE_GO_HOME ) return;
	
	npc.SetHomePos( HomeHx, HomeHy, Random(0, 5) );
	TryGoHome(npc);
	//Log("leaderpatrol");
	if(npc.StatBase[ST_VAR2]!=0)
		{
		uint[] minions = {npc.StatBase[ST_VAR2], npc.StatBase[ST_VAR3], npc.StatBase[ST_VAR4], npc.StatBase[ST_VAR5]};
		for(uint i=0,ii=minions.length();i<ii;i++)
			{
			if (minions[i]==0 || !valid(GetCritter(5000000 + minions[i])))
				{
				if(i<ii-1)
					{
					minions[i]=minions[i+1];
					minions[i+1]=0;
					}
				else minions[i]=0;
				}
			if (minions[i]==0) continue;
			Critter@ minion = GetCritter(5000000 + minions[i]);
			if (!valid(minion) || minion.IsKnockout() || minion.IsDead()) continue;
			else
				{
				if (5000000 + minion.StatBase[ST_VAR1]!=npc.Id)
					{
					if(i<ii-1)
						{
						minions[i]=minions[i+1];
						minions[i+1]=0;
						}
					else minions[i]=0;
					}
				else
					{
					minion.SetHomePos(HomeHx + Random(-5-i,5+i), HomeHy + Random(-5-i, 5+i), Random(0, 5));
					TryGoHome(minion);
					}
				}
			}
		npc.StatBase[ST_VAR2]=minions[0];
		npc.StatBase[ST_VAR3]=minions[1];
		npc.StatBase[ST_VAR4]=minions[2];
		npc.StatBase[ST_VAR5]=minions[3];
		}
	}
}

// CRITTER_EVENT_PLANE_BEGIN
// Когда движок создает план для Нпц. Вызывается и для потомков основного плана в том числе.
// int reason указывает причину начала плана (см. Plane begin/wait/end reasons в _defines.fos).
int _PlaneBegin( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    if( plane.Type == AI_PLANE_ATTACK )
    {
        Critter@ target = ::GetCritter( plane.Attack_TargId );
        if( not valid( target ) )
            return PLANE_RUN_GLOBAL;

        if( target.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] )
            return PLANE_DISCARD;                                                         // не атакуем всех из своей команды

        if( reason == REASON_FOUND_IN_ENEMY_STACK )
        {
            uint distantion = ::GetCrittersDistantion( npc, target );
            if( distantion <= DISTANCE_ATTACK )
            {
                // если противник подошел достаточно близко, то разрешаем атаку
                // анализ на дальность
                uint pathLength = npc.GetMap().GetPathLength( npc, target.HexX, target.HexY, 1 );
                // если пройти нельзя, то не идем
                if( pathLength == 0 )
                    return PLANE_DISCARD;
                // если слишком далеко, то не идем
                if( pathLength > distantion * 3 )
                    return PLANE_DISCARD;
                // зовем друзей
                npc.SendMessage( MSG_GROUP_ATTACK, target.Id, MESSAGE_TO_WHO_SEES_ME );
                return PLANE_KEEP;
            }
            else
            {
                // иначе запрещаем атаку
                return PLANE_DISCARD;
            }
        }
    }
    return PLANE_RUN_GLOBAL;
}

int _PlaneBegin1( Critter& npc, NpcPlane& plane, int reason, Critter@ someCr, Item@ someItem )
{
    if( plane.Type == AI_PLANE_ATTACK )
    {
        Critter@ target = ::GetCritter( plane.Attack_TargId );
        if( not valid( target ) )
            return PLANE_RUN_GLOBAL;

        if( target.Stat[ ST_TEAM_ID ] == npc.Stat[ ST_TEAM_ID ] )
            return PLANE_DISCARD;        // не атакуем всех из своей команды
		

        if( reason == REASON_FOUND_IN_ENEMY_STACK )
        {
            uint distantion = ::GetCrittersDistantion( npc, target );
            if( distantion <= 20 )
            {
                // если противник подошел достаточно близко, то разрешаем атаку
                // анализ на дальность
                uint pathLength = npc.GetMap().GetPathLength( npc, target.HexX, target.HexY, 1 );
                // если пройти нельзя, то не идем
                if( pathLength == 0 )
                    return PLANE_DISCARD;
                // если слишком далеко, то не идем
                if( pathLength > distantion * 9 )
                    return PLANE_DISCARD;
                // зовем друзей
                npc.SendMessage( MSG_GROUP_ATTACK, target.Id, MESSAGE_TO_WHO_SEES_ME );
                return PLANE_KEEP;
            }
            else
            {
                // иначе запрещаем атаку
                return PLANE_DISCARD;
            }
        }
    }
    return PLANE_RUN_GLOBAL;
}

// CRITTER_EVENT_ATTACKED
bool _Attacked( Critter& npc, Critter& attacker )
{
    npc.VarAttacked = attacker.Id;
    npc.VarFury++;     // злимся
    // друзья тоже зляться!
    npc.SendMessage( MSG_GROUP_FURY, attacker.Id, MESSAGE_TO_WHO_SEES_ME );
    // зовем друзей
    npc.SendMessage( MSG_GROUP_ATTACK, attacker.Id, MESSAGE_TO_WHO_SEES_ME );
//	AddAttackPlane(npc, 0, attacker);

    if( npc.VarFear <= npc.VarMaxFear && npc.Stat[ ST_CURRENT_HP ] < npc.Stat[ ST_MAX_LIFE ] / 5 )
        npc.VarFear = npc.VarMaxFear + 1;
    if( npc.VarFear > npc.VarMaxFear )
    {
        npc.ErasePlane( AI_PLANE_ATTACK, true );
        AddPlaneEscape( npc, attacker );
    }
    return true;     // Handle attacked processing
}

void _BossMobInit(Critter& npc, bool firstTime)
{
	npc.ModeBase[ MODE_NO_HOME ] = 1;
	npc.StatBase[ ST_REPLICATION_TIME ] = __FullSecond + REAL_HOUR( 2 );

	ResetVars(npc);

	npc.ShowCritterDist1 = DISTANCE_ATTACK;
	npc.SetEvent(CRITTER_EVENT_SHOW_CRITTER_1, "_ShowPlayer");
	npc.SetEvent(CRITTER_EVENT_HIDE_CRITTER  , "_HidePlayer");// отсутствие "_1" это не ошибка, так надо.

	npc.SetEvent(CRITTER_EVENT_IDLE,        "_BossIdle");
	npc.SetEvent(CRITTER_EVENT_MESSAGE,     "_OnMessage");
	npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin");
	npc.SetEvent(CRITTER_EVENT_SMTH_DEAD,   "_Death");
	npc.SetEvent(CRITTER_EVENT_DEAD,        "_BossMyDeath");
	npc.SetEvent(CRITTER_EVENT_ATTACKED,    "_Attacked");
    npc.SetEvent(CRITTER_EVENT_RESPAWN,     "_Respawn" );	

	npc.StatBase[ST_VAR1] = npc.Id - 5000000;
}

void _MinionMobInit(Critter& npc, bool firstTime)
{
	npc.ModeBase[MODE_NO_HOME] = 1;
	npc.StatBase[ ST_REPLICATION_TIME ] = __FullSecond + REAL_HOUR( 2 );

	npc.ShowCritterDist1 = DISTANCE_ATTACK;
	npc.SetEvent(CRITTER_EVENT_SHOW_CRITTER_1, "_ShowPlayer");
	npc.SetEvent(CRITTER_EVENT_HIDE_CRITTER  , "_HidePlayer");// отсутствие "_1" это не ошибка, так надо.

	npc.SetEvent(CRITTER_EVENT_IDLE,        "_Idle");
	npc.SetEvent(CRITTER_EVENT_MESSAGE,     "_OnMessage");
	npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN, "_PlaneBegin");
	npc.SetEvent(CRITTER_EVENT_SMTH_DEAD,   "_Death");
	npc.SetEvent(CRITTER_EVENT_DEAD,        "_MinionMyDeath");
	npc.SetEvent(CRITTER_EVENT_ATTACKED,    "_Attacked");
    npc.SetEvent(CRITTER_EVENT_RESPAWN,     "_Respawn" );	

	if (npc.StatBase[ST_VAR1]==0 || !valid(GetCritter( 5000000 + npc.StatBase[ST_VAR1]))) npc.AddTimeEvent( "cte_findboss",Random(10,100), 0 );
	ResetVars(npc);	
}

uint cte_findboss (Critter& npc, int identifier, uint& rate)
{
	Critter@[] critters;
	
	uint8 BossRADIUS = 10;
	
	if( npc.PerkBase[ PE_SILENT_RUNNING ] == 1 ) npc.GetMap().GetCrittersHex( npc.HexX, npc.HexY, BossRADIUS, FIND_LIFE | FIND_ONLY_NPC, critters);
	else npc.GetMap().GetCritters( npc.GetProtoId(), FIND_LIFE|FIND_ONLY_NPC, critters );
	bool noBoss = true;
	for(uint16 i = 0, j = critters.length(); i < j; i++)
		{
		if ( npc.GetProtoId() != critters[i].GetProtoId() ) continue;
		if ( npc.PerkBase[ PE_SILENT_RUNNING ] != 1 || npc.GetMap().GetPathLength( npc, critters[i].HexX, critters[i].HexY, 0 ) > 40 ) continue;
		int CrId = critters[i].Id - 5000000;
		int NpcId = npc.Id - 5000000;
		if( critters[i].StatBase[ST_VAR1] == CrId )
			{
			if (critters[i].StatBase[ST_VAR2]==0) {critters[i].StatBase[ST_VAR2]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR3]==0) {critters[i].StatBase[ST_VAR3]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR4]==0) {critters[i].StatBase[ST_VAR4]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR5]==0) {critters[i].StatBase[ST_VAR5]=NpcId; noBoss = false;}
			else if (critters[i].StatBase[ST_VAR5]==0) {critters[i].StatBase[ST_VAR5]=NpcId; noBoss = false;}
			
			if(!noBoss)
				{
				npc.StatBase[ST_VAR1] = CrId;
				npc.StatBase[ ST_TEAM_ID ] = critters[ i ].StatBase[ ST_TEAM_ID ];
				//Log("foundBoss");
				break;
				}
			}
		}
	if (noBoss)	npc.SetScript("_BossMobInit");
	return 0;
}

// CRITTER_EVENT_DEAD
void _MinionMyDeath( Critter& npc, Critter@ killer )
{
    ChangeMonsterCount( npc, false );
    npc.ClearEnemyStack();     // моб забывает своих обидчиков
}

void _BossMyDeath(Critter& npc, Critter@ killer)
{
	ChangeMonsterCount(npc, false);
	npc.ClearEnemyStack(); // моб забывает своих обидчиков

	if(npc.StatBase[ST_VAR2]!=0)
		{
		uint[] minions = {npc.StatBase[ST_VAR2], npc.StatBase[ST_VAR3], npc.StatBase[ST_VAR4], npc.StatBase[ST_VAR5]};
		for(uint i=0,ii=minions.length();i<ii;i++)
			{
			if (minions[i]==0 || !valid(GetCritter(5000000 + minions[i])))
				{
				if(i<ii-1)
					{
					minions[i]=minions[i+1];
					minions[i+1]=0;
					}
				else minions[i]=0;
				}
			}
		if (minions[0]==0) return;
		Critter@ minion = GetCritter(minions[0]);
		if (!valid(minion)) return;
		minion.StatBase[ST_VAR1]=minion.Id - 5000000;
		minion.StatBase[ST_VAR2]=minions[1];
		minion.StatBase[ST_VAR3]=minions[2];
		minion.StatBase[ST_VAR4]=minions[3];
		minion.StatBase[ST_VAR5]=0;
		if (minion.IsDead())
			{
			_BossMyDeath(minion, killer);
			return;
			}
		minion.SetScript("_BossMobInit");
		for(uint i=0,ii=minions.length();i<ii;i++)
			{
			Critter@ minion_t = GetCritter(5000000 + minions[i]);
			if (valid(minion_t)) minion_t.StatBase[ST_VAR1]=minion.Id - 5000000;
			}
		}
}

uint16[] DefaultPidsOrder = {   NPC_PID_RegularRat, NPC_PID_Mantis, NPC_PID_Ant, NPC_PID_SporePlant, 
								NPC_PID_Brahmin, NPC_PID_WildDog, NPC_PID_WildDog /*wolfes*/, 
								NPC_PID_RegularPigRat, NPC_PID_Molerat, NPC_PID_SmallSilverGecko,
								NPC_PID_GoldenGecko, NPC_PID_FireGecko, NPC_PID_SmallRadscorpion,
								NPC_PID_LargeRadscorpion, NPC_PID_SmallRadscorpion /*black scorp*/,
								NPC_PID_Deathclaw, NPC_PID_MirelurkWeak, NPC_PID_Alien, NPC_PID_Alien /*mother alien*/,
								NPC_PID_Floater, NPC_PID_Centaur, NPC_PID_BanditMale /*tribal*/, 
								0 /*not implemented!*/, 0 /*not implemented!*/, NPC_PID_BanditMale /*raider*/
							};
							
uint16 NewPidToDefault(uint16 pid)
{
	if( pid < 1000 ) return pid; //Функция преобразует лишь новые пиды, не трогая старые.
	uint16 	start = 1000, 
			size = 30,
			resultPidNumber = ( pid - start ) / 30;
	if( resultPidNumber >= 0 && resultPidNumber < DefaultPidsOrder.length() )
		//Если в таблице 0 - тогда возвращает тот же пид.
		return ( DefaultPidsOrder[ resultPidNumber ] == 0 ? pid : DefaultPidsOrder[ resultPidNumber ] ); 
	else 
		return pid; //Функция преобразует лишь новые пиды, не трогая старые.
}

void _InitSkinningKnife( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_InitSkinningUse" );
}

bool e_InitSkinningUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	if( onCritter.StatBase[ ST_CURRENT_HP ] > 0 )
		return false;
	
	if( cr.GetTimeEvents( CTE_SKINNING, null, null, null ) > 0 || cr.TimeoutBase[ TO_BATTLE ] > __FullSecond )
	{
		cr.Say( SAY_NETMSG, "Вы итак заняты." );
		return false;
	}
	
	if( cr.Karma[ KARMA_BERSERKER ] == 0 && valid(onCritter) && onCritter.IsPlayer() )
	{
		cr.Say( SAY_NETMSG, "Вам не хочется издеваться над трупом." );
		return false;
	}

	cr.ParamBase[ CR_HEXX ] = cr.HexX;
	cr.ParamBase[ CR_HEXY ] = cr.HexY;
	cr.ParamBase[ CR_VAL0 ] = ( valid(onCritter) ? onCritter.Id : 0 );

	cr.AddTimeEvent ( "cte_skinning", 0, CTE_SKINNING, 0 );
	return true;
}

uint cte_skinning( Critter& cr, int identifier, uint& rate )
{
	if( cr.HexX != cr.ParamBase[ CR_HEXX ] || cr.HexY != cr.ParamBase[ CR_HEXY ] || cr.TimeoutBase[ TO_BATTLE ] > __FullSecond )
	{
		cr.Say( SAY_NETMSG, "Вы отвлеклись от процесса свежевания." );
		return 0;
	}
	
	Critter@ onCritter = ( cr.ParamBase[ CR_VAL0 ] > 0 ? GetCritter( cr.ParamBase[ CR_VAL0 ] ) : null );
	if( !valid(onCritter) ) { 
		cr.Say( SAY_NETMSG, "Туша стала непригодна." );
		return 0; 
	}
	
	onCritter.ParamBase[ CR_VAL0 ] += cr.Skill[ SK_OUTDOORSMAN ] / 10; //Туша хранит в себе прогресс свежевания.
	
	if( onCritter.ParamBase[ CR_VAL0 ] < onCritter.Stat[ ST_MAX_LIFE ] )
	{
		uint dir = GetDirection ( cr.HexX, cr.HexY, onCritter.HexX, onCritter.HexY );
		cr.SetDir( dir );
		if( cr.CrType != 99 ) //Т.к. нет времени ковырять паки анимаций Гориса, поставил заглушку.
		{
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_SWING_1H, null, false, true );
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			if( Random( 0, 1 ) == 0 ) cr.Animate( 0, ANIM2_USE, null, false, true );
		}
		uint time = cr.StatBase[ ST_AGILITY ] / 2;
		time = Random( CLAMP( 5 - time, 1, 10 ), 5 ); //Т.е. рандом от (11-ЛОВ/2) до 5 секунд
		cr.Say( SAY_NETMSG, "Вы разделываете тушу." );
		return REAL_SECOND( time );
	}
	
	bool skinned = false;
    uint16 Add1 = 0;
	uint16 Add2 = 0;
	uint16 Add3 = 0;
	uint8  Sum1 = 0;
	uint8  Sum2 = 0;
	uint8  Sum3 = 0;
	uint16 PAdd1 = 0;
	uint16 PAdd2 = 0;
	uint16 PAdd3 = 0;
	uint8  PSum1 = 0;
	uint8  PSum2 = 0;
	uint8  PSum3 = 0;
	uint8 Exp1 = 0;
	uint8 Exp2 = 0;
	uint8 Exp3 = 0;
	string Str1 = "Из этого ничего не вышло.";
	string Str2 = "Из этого ничего не вышло.";
	string Str3 = "Из этого ничего не вышло.";
	int result = ( Random( 80, 120) * cr.Skill[SK_OUTDOORSMAN] ) / 100; //Т.е. +-20%
	
    // if( onCritter.IsDead() && onCritter.IsNpc() )
    if( onCritter.StatBase[ ST_CURRENT_HP ] < 0 && onCritter.IsNpc() ) //Можно свежевать тяжело раненных, но ещё не умирающих мобов.
    {
		Item @ darts = onCritter.GetItem(PID_DARTS_LOW, -1 );
        if( valid(darts) ) 
		{ 
			MoveItem( darts, darts.GetCount(), cr ); 
			cr.Say( SAY_NETMSG, "Вы достали дротики." ); 
		}

        if( onCritter.Stat[ ST_DESEASE ] != 0 )
        {
            cr.Say( SAY_NETMSG, "Уже освежован." );
            return 0;
        }
        
		uint16 npcPid = onCritter.GetProtoId();
		if( npcPid > 1000 ) npcPid = NewPidToDefault( npcPid );
		if( npcPid == 10 ) npcPid = NPC_PID_Brahmin; //Дефолтные брамины.		
		
        switch( npcPid )
        {
			case NPC_PID_RegularRat:
				Add1=PID_RAT_MEAT; 
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=1;
				Exp1 = 5;
				Str1= "Вы бездарно разделываете бедную крысу.";	
				Add2=PID_RAT_MEAT;
				Sum2=1;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=2;
				Exp2 = 10;
				Str2= "Вы разделываете бедную крысу.";
				Add3=PID_RAT_MEAT;
				Sum3=1;
				PAdd3=PID_MOUSE_SKIN;
				PSum3=1;
				Exp3 = 15; Str3= "Вы умело разделываете бедную крысу.";
			break;
			
			case NPC_PID_Mantis:
			case NPC_PID_Ant:
				Add1=PID_RAD_MEAT;
				Sum1=0;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы не смогли ни сохранить панцирь, ни достать мяса.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=0;
				Exp2 = 10;
				Str2= "Вы достали мясо, но при этом сломали панцирь.";
				Add3=PID_RAD_MEAT;
				Sum3=1;
				PAdd3=PID_MANTIS_SHELL;
				PSum3=1;
				Exp3 = 15; Str3= "Вы сняли панцирь и добрались до мяса.";	
            break;
			
			case NPC_PID_RegularPigRat:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=1;
				Exp1 = 5; 
				Str1= "В процессе добычи мяса вы исполосали кожу животного.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=2;
				Exp2 = 10;
				Str2= "Вам удалось сохранить кожу животного и достать мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_CRAFT_L_RAGS;
				PSum3=3;
				Exp3 = 15; Str3= "Вы вырезали самые мясистые места туши, повредив шкуры.";
            break;
			
			case NPC_PID_Molerat:
			case NPC_PID_MutatedMolerat:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_MOLERAT_STOMATCH;
				PSum1=0;
				Exp1 = 5; 
				Str1= "В процессе добычи мяса вы повредили желудок кротокрыса.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_MOLERAT_STOMATCH;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы вырезали желудок кротокрыса и немного мяса с ним.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_MOLERAT_STOMATCH;
				PSum3=1;
				Exp3 = 15; Str3= "Вы вырезали желудок кротокрыса и немало мяса.";
            break;
			
			case NPC_PID_SmallSilverGecko:
				Add1=PID_GECKO_MEAT;
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=2;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=2;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=3;
				Exp2 = 10;
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=2;
				PAdd3=PID_GECKO_PELT;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
            break;
			
			case NPC_PID_GoldenGecko:
				Add1=PID_GECKO_MEAT;
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=2;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=2;
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=3;
				Exp2 = 10; 
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=2;
				PAdd3=PID_GOLDEN_GECKO_PELT;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
            break;
			
			case NPC_PID_WildDog:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=1;
				Exp1 = 5; 
				Str1= "Вы разделываете тушку пса.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(1,2);
				PAdd2=PID_CRAFT_L_RAGS;
				PSum2=Random(1,2);
				Exp2 = 10; 
				Str2= "Вы не особо умело разделали животное.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_CRAFT_L_RAGS;
				PSum3=Random(2,3);
				Exp3 = 15; Str3= "Вы удачно разделали пса.";
            break;
			
			case NPC_PID_SmallRadscorpion:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы достали немного мяса из тела скорпиона.";
				Add2=PID_RAD_MEAT;
				Sum2=1;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=2;
				Exp2 = 10; 
				Str2= "Отломав кусок панциря вы добрались до мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_SCORPION_TAIL;
				PSum3=1;
				Exp3 = 15; Str3= "Вы умело лишили мертвого скорпиона его жала.";
            break;
			
			case NPC_PID_LargeRadscorpion:
				Add1=PID_RAD_MEAT;
				Sum1=2;
				PAdd1=PID_MANTIS_SHELL;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы достали немного мяса из тела скорпиона.";
				Add2=PID_RAD_MEAT;
				Sum2=2;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=2;
				Exp2 = 10;
				Str2= "Отломав кусок панциря вы добрались до мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=3;
				PAdd3=PID_SCORPION_TAIL;
				PSum3=1;
				Exp3 = 15; Str3= "Вы умело лишили мертвого скорпиона его жала.";
            break;
			
			case NPC_PID_Brahmin:
				Add1=PID_MEAT;
				Sum1=5;
				PAdd1=PID_CRAFT_L_HIDE;
				PSum1=Random(0,2);
				Exp1 = 5; 
				Str1= "Вы исполосали ножом всю шкуру.";
				Add2=PID_MEAT;
				Sum2=Random(5,8);
				PAdd2=PID_CRAFT_L_HIDE;
				PSum2=Random(1,3);
				Exp2 = 10; 
				Str2= "Вы разделали брамина не так хорошо как хотелось бы.";
				Add3=PID_MEAT;
				Sum3=10;
				PAdd3=PID_BRAHMIN_SKIN;
				PSum3=1;
				Exp3 = 15; Str3= "Вы лишили тушу брамина мяса и шкуры.";
            break;
			
			case NPC_PID_SporePlant:
				_CritAddItem( cr, PID_PLANT_SPIKE, 4 );
				_CritAddItem( cr, PID_MUTATED_FRUIT, 1 );
				skinned = true;
            break;
			
			case NPC_PID_Alien:
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_MUTATED_GLAND;
				PSum1=Random(0,1);
				Exp1 = 5; 
				Str1= "Вы небрежно распотрошили мутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(3,4);
				PAdd2=PID_MUTATED_GLAND;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы извлекаете железу твари.";
				Add3=PID_RAD_MEAT;
				Sum3=Random(4,5);
				PAdd3=PID_MUTATED_GLAND;
				PSum3=1;
				Exp3 = 15; Str3= "Вы извлекаете железу твари.";	
			break;
			
			case NPC_PID_SmDeathclaw:
			case NPC_PID_Deathclaw:
			case NPC_PID_ToughDeathclaw:
				Add1=PID_RAD_MEAT;
				Sum1=2;
				PAdd1=PID_DEATHCLAW_CLAW_1;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы распотрошили тушу.";
				Add2=PID_RAD_MEAT;
				Sum2=3;
				PAdd2=PID_DEATHCLAW_CLAW_1;
				PSum2=Random(0,1);
				Exp2 = 10;
				Str2= "Вы усердно поработали ножом над тушей.";
				Add3=PID_RAD_MEAT;
				Sum3=4;
				PAdd3=PID_DEATHCLAW_CLAW_1;
				PSum3=1;
				Exp3 = 15; Str3= "Вы вырезали все, что посчитали возможным.";
            break;
			
			case NPC_PID_FireGecko:
				Add1=PID_GECKO_MEAT;
				Sum1=2;
				PAdd1=PID_CRAFT_L_RAGS;
				PSum1=4;
				Exp1 = 5; 
				Str1= "Ради мяса вы порезали тушу гекко.";
				Add2=PID_GECKO_MEAT;
				Sum2=3;
				PAdd2=PID_CRAFT_L_HIDE;
				PSum2=2;
				Exp2 = 10;
				Str2= "Вы не особо умело разделываете гекко.";
				Add3=PID_GECKO_MEAT;
				Sum3=3;
				PAdd3=PID_FIRE_GECKO_PELT;
				PSum3=1;
				Exp3 = 15; Str3= "Вы аккуратно сняли шкуру с гекко, не забыв про мясо.";
            break;
			
			case NPC_PID_Centaur:
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_MUTATED_GLAND;
				PSum1=Random(0,1);
				Exp1 = 5; 
				Str1= "Вы небрежно распотрошили мутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(3,4);
				PAdd2=PID_MUTATED_GLAND;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы извлекаете железу твари.";
				Add3=PID_RAD_MEAT;
				Sum3=Random(4,5);
				PAdd3=PID_MUTATED_GLAND;
				PSum3=1;
				Exp3 = 15; Str3= "Вы извлекаете железу твари.";
            break;
			
			case NPC_PID_Floater:
				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_MUTATED_GLAND;
				PSum1=Random(0,1);
				Exp1 = 5; 
				Str1= "Вы небрежно распотрошили мутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=Random(3,4);
				PAdd2=PID_MUTATED_GLAND;
				PSum2=1;
				Exp2 = 10; 
				Str2== "Вы извлекаете железу твари.";
				Add3=PID_RAD_MEAT;
				Sum3=Random(4,5);
				PAdd3=PID_MUTATED_GLAND;
				PSum3=1;
				Exp3 = 15; Str3= "Вы извлекаете железу твари.";
            break;
			
			case NPC_PID_MirelurkWeak:
				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_MIRELUK_SHELL;
				PSum1=0;
				Exp1 = 5;
				Str1= "Разбив панцирь, вы вырезали немного мяса.";
				Add2=PID_RAD_MEAT;
				Sum2=2;
				PAdd2=PID_MANTIS_SHELL;
				PSum2=2;
				Exp2 = 10; 
				Str2= "Вы сломали панцирь в попытках его оторвать от тела болотника.";
				Add3=PID_RAD_MEAT;
				Sum3=2;
				PAdd3=PID_MIRELUK_SHELL;
				PSum3=1;
				Exp3 = 15; Str3= "Вы успешно срываете панцирь с болотника.";
			break;
			
			case NPC_PID_BanditFemale:		
			case NPC_PID_RaiderFemale:  
			case NPC_PID_ToughFemaleThug:
			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{
				if( onCritter.IsDead() )
					onCritter.ToLife();
				onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

				Add1=PID_MEAT;
				Sum1=1;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы отрезали самую вкусную часть умирающего человека.";
				Add2=PID_MEAT;
				Sum2=2;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_MEAT;
				Sum3=2;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			}
			break;
		
			case NPC_PID_BanditMale:                           
			case NPC_PID_MauraderMale:            
			case NPC_PID_RaiderMale:              
			case NPC_PID_MaleSlaver:               
			case NPC_PID_MaleSlaver2:              
			case NPC_PID_ToughMaleThug:                     
			case NPC_PID_MaleTrapper:                                                                                     
			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{
				if( onCritter.IsDead() )
					onCritter.ToLife();
				onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

				Add1=PID_MEAT;
				Sum1=1;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы отрезали самую вкусную часть умирающего человека.";
				Add2=PID_MEAT;
				Sum2=2;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_MEAT;
				Sum3=2;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			}
			break;
			
			case NPC_PID_GreenGhoul:               
			case NPC_PID_WhiteGhoul:
			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{
				if( onCritter.IsDead() )
					onCritter.ToLife();
				onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

				Add1=PID_RAD_MEAT;
				Sum1=1;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы с радостью распотрошили гуля.";
				Add2=PID_RAD_MEAT;
				Sum2=2;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=0;
				Exp2 = 10;
				Str2= "Вы вырезали как можно больше мяса.";
				Add3=PID_RAD_MEAT;
				Sum3=3;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=0;
				Exp3 = 15; Str3= "С тела гуля получилось мясное ассорти, на запах отвратное.";
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			}
			break;
		
			case NPC_PID_Supermutant: 
			if( cr.Karma[ KARMA_BERSERKER ] !=0 ) 
			{
				if( onCritter.IsDead() )
					onCritter.ToLife();
				onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

				Add1=PID_RAD_MEAT;
				Sum1=3;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5;
				Str1= "Вы отрезали самую вкусную часть умирающего супермутанта.";
				Add2=PID_RAD_MEAT;
				Sum2=5;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10;
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_RAD_MEAT;
				Sum3=6;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
			}
			else 
			{
				cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
				return 0;
			}
			break;
		}
	}
	else if( onCritter.IsDead() && !onCritter.IsNpc() )
	{
		if( onCritter.Stat[ ST_DESEASE ] != 0 )
		{
			cr.Say( SAY_NETMSG, "Уже освежован." );
			return 0;
		}
		if(cr.Karma[ KARMA_BERSERKER ] != 0)
		{
				if( onCritter.IsDead() )
					onCritter.ToLife();
				onCritter.ToDead( ANIM2_DEAD_BLOODY_SINGLE, cr );

				Add1=PID_MEAT;
				Sum1=3;
				PAdd1=PID_PLAYERS_EAR;
				PSum1=0;
				Exp1 = 5; 
				Str1= "Вы отрезали самую вкусную часть умирающего.";
				Add2=PID_MEAT;
				Sum2=4;
				PAdd2=PID_PLAYERS_EAR;
				PSum2=1;
				Exp2 = 10; 
				Str2= "Вы вырезали как можно больше мяса и взяли ухо как трофей.";
				Add3=PID_MEAT;
				Sum3=5;
				PAdd3=PID_PLAYERS_EAR;
				PSum3=2;
				Exp3 = 15; Str3= "Вы вырезали самое вкусное и отрезали уши умершего.";
		}
		else
		{
			cr.Say(SAY_NETMSG, "Вам не хочется издеваться над трупом.");
			return 0;
		}
	}
	
	if( result > 150 )
	{
		if( Sum3 > 0 )
			_CritAddItem(cr,Add3,Sum3);
		cr.Say( SAY_NETMSG, Str3 );
		cr.StatBase[ ST_EXPERIENCE ] += Exp3;
		skinned = true;
		//if( cr.Perk[PE_GECKO_SKINNING] != 0 && PSum3 > 0)		
		if( PSum3 > 0)		
			_CritAddItem(cr,PAdd3,PSum3);
	}
	else if( result > 100 )
	{
		if( Sum2 > 0 )
			_CritAddItem(cr,Add2,Sum2);
		cr.Say( SAY_NETMSG, Str2 );
		cr.StatBase[ ST_EXPERIENCE ] += Exp2;
		skinned = true;
		//if (cr.Perk[PE_GECKO_SKINNING] !=0 && PSum2 > 0)		
		if ( PSum2 > 0)		
			_CritAddItem(cr,PAdd2,PSum2);
	}
	else if( result > 40 )
	{
		if( Sum1 > 0 )
			_CritAddItem(cr,Add1,Sum1);
		cr.Say( SAY_NETMSG, Str1 );
		cr.StatBase[ ST_EXPERIENCE ] += Exp1;
		skinned = true;
//		if (cr.Perk[PE_GECKO_SKINNING] !=0 && PSum1 > 0)		
		if ( PSum1 > 0)		
			_CritAddItem(cr,PAdd1,PSum1);
	}
	else 
	{
		cr.Say( SAY_NETMSG, "Вы задумались о своем, забыв про разделку." );
	}
			
	if( skinned )
	{
		onCritter.StatBase[ ST_KILLER_PERSON ] = cr.Id;
		onCritter.StatBase[ ST_CURRENT_HP ] += __DeadHitPoints; //ХП падает ниже некуда, скорей сгнивают останки.
		if( onCritter.IsDead() == false && onCritter.IsPlayer() == false )
		{
			if( onCritter.StatBase[ ST_CURRENT_HP ] > 0 )
			{
				cr.Say( SAY_NETMSG, "Жертва слишком сильно брыкается, у вас не вышло её разделать." );
				return 0;
			}
			else
			{
				cr.StatBase[ST_EXPERIENCE] += onCritter.Stat[ST_KILL_EXPERIENCE];
			}
		}
		onCritter.StatBase[ ST_DESEASE ] = 1;

		if( onCritter.GetTimeEvents( CTE_ROTTEN, null, null, null ) < 1 )
			onCritter.AddTimeEvent( "cte_rotten", 0, CTE_ROTTEN, 0 );
	}
    return 0;
}


