#ifndef HEAL
#define HEAL

#include "_utils.fos"
#include "heal_h.fos"
#include "food_h.fos"
#include "waterworks_h.fos"
#include "combat_h.fos"
#include "drugs_h.fos"
#include "critter_status_h.fos"
#include "speed_h.fos"
#include "poison_h.fos"

void StartMenuDOC( Critter& healer, Critter& target )
{
	OpenMenu( healer, "DOC", MenuDOC( target ) );
}	

enum MenuDOC_stage
{
	tool = 1,
	antiseptik = 2,
	anestetik = 3,
	processing = 4
};

enum MenuDOC_tool
{
	none = 0,
	blade = 1,  
	clips = 2,
	multitool = 3,
	needle = 4
};

enum MenuDOC_antiseptik
{
	none = 0,
	booze = 1,
	spirit = 2,
	antiseptik = 3
};

enum MenuDOC_anestetik
{
	none = 0,
	booze = 1,
	spirit = 2,
	anestetik = 3
};

enum MenuCripple_stage
{
	main = 0,
	tool = 1
};

enum MenuCripple_tools
{
	none = 0,
	splint = 1,
	handmade = 2
};

class MenuDOC: CenteredMenuHandler 
{	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	string state;
	
	MenuDOC( Critter& target )
	{
		@this.target = @target;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) )
		{
			if( menu.Button( success ) )
			{
				return true;
			}
		}
		else
		{ 
			menu.Button( failed );
		}
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
	
		state = target.Stat[ ST_CURRENT_HP ] > 0 ? "Pulse normal" : "Weak pulse";

		if( damages.length() != damage_states.length() )
		{
			testInfo( cr, "damages.length("+damages.length()+") != damage_states.length("+damage_states.length()+")" );
			return false;
		}
		
		bool hasDamages = false;
		for( uint i = 0, l = damages.length(); i < l; i++ )
		{
			if( target.DamageBase[damages[i]] != 0 )
			{
				state += ", " + damage_states[i]; 
				hasDamages = true;
			}
		}
		
		if( cr.Stat[ST_POISONING_LEVEL] > 0 )
		{
			state += ", signs of poisoning";
			hasDamages = true;
		}
		
		if( cr.Stat[ST_RADIATION_LEVEL] > 0 )
		{
			state += ", signs of radiation sickness";
			hasDamages = true;
		}
		
		if( cr.Stat[ST_BLEED] > 0 )
		{
			state += ", bleeding";
			hasDamages = true;
		}
		
		state += ".";
		
		bool knife = ( _CritCountItem( cr, PID_KNIFE ) > 0 || _CritCountItem( cr, PID_COMBAT_KNIFE ) > 0 );

		if( FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) )
		{
			state += "\n" + "there is a bullet or a shard is in the wound, that requires to be removed before anything else is done.";
			if ( menu.Button( "Removal" ) )
			{
				OpenMenu( cr, "BulletOver", MenuDOC_Bullet( target ) );
				return false;
			}
			return true;
		}

		if( FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
		{
			state += "\n" + "Heavy wound that requires to be closed.";
			if ( menu.Button( "Surgery" ) )
			{
				OpenMenu( cr, "HeavyDamage", MenuDOC_Heavy( target ) );
				return false;
			}
			return true;
		}
			
		if( hasDamages && menu.Button( "Traumas" ) )
		{
			OpenMenu( cr, "Cripple", MenuDOC_Cripple( target ) );
			return false;
		}

		state += "\n" + "There is nothing requiring a doctor.";
		return true;
	}

	string@ Description( Critter& cr ) 
	{
		return state;
	}
}

class MenuDOC_Bullet: CenteredMenuHandler 
{	
	int stage;
	
	int tool;
	int antiseptik;
	int anestetik;
	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	MenuDOC_Bullet( Critter& target )
	{
		@this.target = @target;
		
		this.stage = MenuDOC_stage::tool;
		
		this.tool = MenuDOC_tool::none;
		this.antiseptik = MenuDOC_antiseptik::none;
		this.anestetik 	= MenuDOC_anestetik::none;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) ) {
			if( menu.Button( success ) ) {
				return true;
			}
		} else { menu.Button( failed );
		}
		
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
		
		string info = "Test info:\n"
					+ "Doctor #" + cr.Id 			+ "\n"
					+ "Patient #" + target.Id		+ "\n"
					+ "Stage #" + stage				+ "\n"
					+ "Antiseptik #" + antiseptik	+ "\n"
					+ "Anestetik #" + anestetik		+ "\n"

				;

		testInfo( cr, info );
		
		switch( stage )
		{
			case(MenuDOC_stage::tool):
			{
				if( check( PID_MEDCLIP, "tongs", "no tongs" ) )
				{
					tool  = MenuDOC_tool::clips;
					stage = MenuDOC_stage::antiseptik;	
				}
				
				if( check( PID_MULTI_TOOL, "multitool", "no multitool" ) )
				{
					tool  = MenuDOC_tool::multitool;
					stage = MenuDOC_stage::antiseptik;	
				}

				if( HasBlade( cr ) )
				{
					if( menu.Button( "pluck out" ) )
					{
						tool  = MenuDOC_tool::blade;
						stage = MenuDOC_stage::antiseptik;	
					}
				}
				else
				{
					menu.Button( "no blade" );
				}
				
				if( menu.Button( "Medical check" ) )
				{
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
			}
			return true;
			
			case(MenuDOC_stage::antiseptik):
			{
				
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					antiseptik  = MenuDOC_antiseptik::booze;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					antiseptik  = MenuDOC_antiseptik::spirit;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_ANTISEPTIC, "use antiseptik", "no antiseptik" ) )
				{
					antiseptik  = MenuDOC_antiseptik::antiseptik;
					stage 		= MenuDOC_stage::anestetik;	
				}

				if( menu.Button( "without disinfecting" ) )
				{
					antiseptik  = MenuDOC_antiseptik::none;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::tool;	
				}
			}
			return true;
			
			case(MenuDOC_stage::anestetik):
			{
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					anestetik   = MenuDOC_anestetik::booze;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					anestetik   = MenuDOC_anestetik::spirit;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_ANESTETIC, "use anastetic", "no anastetic" ) )
				{
					anestetik   = MenuDOC_anestetik::anestetik;
					stage 		= MenuDOC_stage::processing;	
				}

				if( menu.Button( "no painkillers" ) )
				{
					anestetik   = MenuDOC_anestetik::none;
					stage 		= MenuDOC_stage::processing;	
				}
				
				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::antiseptik;	
				}
			}
			return true;
			
			case(MenuDOC_stage::processing):
			{
				if( menu.Button( "Begin" ) )
				{
					if( cr.Timeout[ TO_SK_DOCTOR ] > 0 )
					{
						stage 		= MenuDOC_stage::tool;
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_TIRED );
						return true;
					}
					
					uint16 skill = cr.Skill[ SK_DOCTOR ];
					string skill_info = "DOC base [" + skill + "] ";
					
					int damage = 0;
					string damage_info = "Taken damage: ";
					
					switch( tool )
					{
						case(MenuDOC_tool::clips):
						{
							Item@ item_tool = getItem( cr, PID_MEDCLIP );
							if( !valid( item_tool ) )
							{
								tool = MenuDOC_tool::none;
							}
							else
							{
								skill += 100;
								skill_info += " + clips [100]";
							}						
						}
						break;

						case(MenuDOC_tool::multitool):
						{
							Item@ item_tool = getItem( cr, PID_MULTI_TOOL );
							if( !valid( item_tool ) )
							{
								tool = MenuDOC_tool::none;
							}
							else
							{
								skill += 0;
								skill_info += " + multitool [0]";

								int rng = Random( 5, 15 );
								damage += rng;
								damage_info += " + multitool [" + rng + "]";
							}						
						}
						break;

						case(MenuDOC_tool::blade):
						{
							if(  HasBlade( cr ) )
							{
								skill -= 100;
								skill_info += " - blades [100]";
								
								int rng = Random( 15, 30 );
								damage += rng;
								damage_info += " + blades [" + rng + "]";
							}						
						}
						break;
					}
					
					switch( antiseptik )
					{
						case(MenuDOC_antiseptik::booze):
						{
							Item@ item_antiseptik = getItem( cr, PID_ROT_GUT_PRT );
							if( !valid( item_antiseptik ) )
							{
								antiseptik = MenuDOC_antiseptik::none;
							}
							else
							{
								SpillOut( item_antiseptik );
								
								skill += 0;
								skill_info += " + booze [0]";
								
								damage += 0;
							}
						}
						break;
						
						case(MenuDOC_antiseptik::spirit):
						{
							Item@ item_antiseptik = getItem( cr, PID_SPIRIT_PRT );
							if( !valid( item_antiseptik ) )
							{
								antiseptik = MenuDOC_antiseptik::none;
							}
							else
							{
								SpillOut( item_antiseptik );
								
								skill += 15;
								skill_info += " + spirit [15]";
								
								damage += 0;
							}
						}
						break;
						
						case(MenuDOC_antiseptik::antiseptik):
						{
							Item@ item_antiseptik = getItem( cr, PID_ANTISEPTIC );
							if( !valid( item_antiseptik ) )
							{
								antiseptik = MenuDOC_antiseptik::none;
							}
							else
							{
								skill += 30;
								skill_info += " + antiseptik [30]";
								
								int rng = Random( 5, 10 );
								damage -= rng;
								damage_info += " - antiseptik [" + rng + "]";

								_SubItem( item_antiseptik, 1 );
								cr.AddItem( PID_PHIAL, 1 );
							}
						}
						break;
						
						case(MenuDOC_antiseptik::none):
						{
							skill -= 30;
							skill_info += " - no antiseptik [30]";
								
							int rng = Random( 5, 10 );
							damage += rng;
							damage_info += " + no antiseptik [" + rng + "]";

							cr.ParamBase[ CR_DIRTINESS ] += Random( 5, 10 );
						}
						break;
						
					}
					
					switch( anestetik )
					{
						case(MenuDOC_anestetik::booze):
						{
							Item@ item_anestetik = getItem( cr, PID_ROT_GUT_PRT );
							if( !valid( item_anestetik ) )
							{
								anestetik = MenuDOC_anestetik::none;
							}
							else
							{
								SpillOut( item_anestetik );
								
								skill += 15;
								skill_info += " + booze [15]";
								
								damage += 0;
							}
						}
						break;
						
						case(MenuDOC_anestetik::spirit):
						{
							Item@ item_anestetik = getItem( cr, PID_SPIRIT_PRT );
							if( !valid( item_anestetik ) )
							{
								anestetik = MenuDOC_anestetik::none;
							}
							else
							{
								SpillOut( item_anestetik );
								
								skill += 30;
								skill_info += " + spirit [30]";
								
								int rng = Random( 5, 20 );
								damage -= rng;
								damage_info += " - spirit [" + rng + "]";
							}
						}
						break;
						
						case(MenuDOC_anestetik::anestetik):
						{
							Item@ item_anestetik = getItem( cr, PID_ANESTETIC );
							if( !valid( item_anestetik ) )
							{
								anestetik = MenuDOC_anestetik::none;
							}
							else 
							{
								skill += 60;
								skill_info += " + anestetik [60]";
								
								int rng = Random( 15, 30 );
								damage -= rng;
								damage_info += " - anestetik [" + rng + "]";

								_SubItem( item_anestetik, 1 );
								cr.AddItem( PID_PHIAL, 1 );
							}
						}
						break;
						
						case(MenuDOC_anestetik::none):
						{
							skill += 0;
							skill_info += " + no anestetik [0]";
								
							damage += 0;
						}
						break;
						
					}

					target.StatBase[ ST_CURRENT_HP ] -= damage;
					
					testInfo( cr, skill_info + " = " + skill + "." );
					testInfo( cr, damage_info + " = " + damage + "." );

					int luck = cr.Stat[ST_LUCK];
					int chances = ( skill + rollLuck( luck ) * HEALING_LUCK_DEPENDENCY );
					testInfo( cr,
						"skill [" + skill + "]" +
						" + rollLuck( luck[" + luck + "] )[" + rollLuck( luck ) + "]" + 
						" * HEALING_LUCK_DEPENDENCY [" + HEALING_LUCK_DEPENDENCY + "]" +
						"{" + chances + "}" +
							" > " +
						"Random( 0, 100 * HEALING_DIFFICULTY[" + HEALING_DIFFICULTY + "] )" +
						"\n\nChances are: " + float( chances / HEALING_DIFFICULTY ) + "%." +
						""
					);
					
					if( HealingProcessSucceed( skill, cr.Stat[ST_LUCK] ) )
					{
						ChangeStatus( target, CR_STATUS_BULLET_OVER, 0, false );
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_BULLET_SUCCESS );
					}
					else
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_BULLET_FAILED );
					}
					cr.TimeoutBase[ TO_SK_DOCTOR ] = DOCTOR_TIMEOUT( player );
					
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}

				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::anestetik;	
				}
			}
			return true;
		}
		
		return true;
	}

	string@ Description( Critter& cr ) 
	{
		switch( stage )
		{
			case(MenuDOC_stage::tool):
				return "Choosen tool:";
				
			case(MenuDOC_stage::antiseptik):
				return "Applied disenfection:"; 
			
			case(MenuDOC_stage::anestetik):
				return "Applied anastetic:"; 
			
			case(MenuDOC_stage::processing):
				return "You are ready to perform extraction of an alien object from the patient."; 
		}
		
		return "[UNKNOWN STATE #" + stage + "]";
	}
}

class MenuDOC_Heavy: CenteredMenuHandler 
{	
	int stage;
	
	int tool;
	int antiseptik;
	int anestetik;
	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	MenuDOC_Heavy( Critter& target )
	{
		@this.target = @target;
		
		this.stage 		= MenuDOC_stage::tool;
		
		this.tool 		= MenuDOC_tool::none;
		this.antiseptik = MenuDOC_antiseptik::none;
		this.anestetik 	= MenuDOC_anestetik::none;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) )
		{
			if( menu.Button( success ) )
			{
				return true;
			}
		}
		else
		{
			menu.Button( failed );
		}
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
		
		string info = "Test info:\n"
					+ "Doctor #" + cr.Id 			+ "\n"
					+ "Patient #" + target.Id		+ "\n"
					+ "stage #" + stage				+ "\n"
					+ "antiseptik #" + antiseptik	+ "\n"
					+ "anestetik #" + anestetik		+ "\n"

				;
					
		testInfo( cr, info );
		
		switch( stage )
		{
			case(MenuDOC_stage::tool):
			{
				if( check( PID_MEDNEEDLE, "stich", "nothing to stich with" ) )
				{
					tool  = MenuDOC_tool::needle;
					stage = MenuDOC_stage::antiseptik;	
				}		

				if( HasBlade( cr ) )
				{
					if( menu.Button( "burn" ) )
					{
						tool  = MenuDOC_tool::blade;
						stage = MenuDOC_stage::antiseptik;	
					}
				}
				else menu.Button( "nothing to burn with" );
				
				if( menu.Button( "Medical check" ) )
				{
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
			}
			return true;
			
			case(MenuDOC_stage::antiseptik):
			{
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					antiseptik  = MenuDOC_antiseptik::booze;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					antiseptik  = MenuDOC_antiseptik::spirit;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( check( PID_ANTISEPTIC, "use antiseptik", "no antiseptik" ) )
				{
					antiseptik  = MenuDOC_antiseptik::antiseptik;
					stage 		= MenuDOC_stage::anestetik;	
				}

				if( menu.Button( "no disinfecting" ) ) 
				{
					antiseptik  = MenuDOC_antiseptik::none;
					stage 		= MenuDOC_stage::anestetik;	
				}
				
				if( menu.Button( "Return" ) )
					stage 		= MenuDOC_stage::tool;	
				
			}
			return true;
			
			case(MenuDOC_stage::anestetik):
			{
				if( check( PID_ROT_GUT_PRT, "use rot gut", "no rot gut" ) )
				{
					anestetik   = MenuDOC_anestetik::booze;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_SPIRIT_PRT, "use spirit", "no spirit" ) )
				{
					anestetik   = MenuDOC_anestetik::spirit;
					stage 	    = MenuDOC_stage::processing;	
				}
				
				if( check( PID_ANESTETIC, "use antiseptik", "no antiseptik" ) )
				{
					anestetik   = MenuDOC_anestetik::anestetik;
					stage 		= MenuDOC_stage::processing;	
				}

				if( menu.Button( "no painkillers" ) ) 
				{
					anestetik   = MenuDOC_anestetik::none;
					stage 		= MenuDOC_stage::processing;	
				}
				
				if( menu.Button( "Return" ) )
				{
					stage 		= MenuDOC_stage::antiseptik;	
				}
			}
			return true;
			
			case(MenuDOC_stage::processing):
			{
				if( menu.Button( "Begin" ) )
				{
					if( cr.Timeout[ TO_SK_DOCTOR ] > 0 )
					{
						stage 		= MenuDOC_stage::tool;
						
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_TIRED );
						return true;
					}
					
					uint16 skill = cr.Skill[ SK_DOCTOR ];
					string skill_info = "DOC base [" + skill + "] ";
					
					int damage = 0;
					string damage_info = "Taken damage: ";
					uint action_info;
					
					switch( tool )
					{
						case(MenuDOC_tool::needle):
						{
							Item@ needle = getItem( cr, PID_MEDNEEDLE );
							Item@ thread = getItem( cr, PID_MEDTHREAD );
							if( !valid( needle ) || !valid( thread ) )
							{
								tool = MenuDOC_tool::none;
								stage 		= MenuDOC_stage::tool;
								
								cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_NEED_NEEDLE );
								return true;
							}
							else
							{
								skill += 100;
								skill_info += " + needle [100]";
								
								int rng = Random( 5, 10 );
								damage += rng;
								damage_info += " + needle [" + rng + "]";
								
								action_info = STR_DOCTOR_STICHED_WOUND;

								_SubItem( thread, 1 );
							}						
						}
						break;

						case(MenuDOC_tool::blade):
						{
							if( HasBlade( cr ) && hasItems( cr, heatSources ) )
							{
								skill -= 100;
								skill_info += " - blades [100]";
								
								int rng = Random( 15, 30 );
								damage += rng;
								damage_info += " + blades [" + rng + "]";

								action_info = STR_DOCTOR_BURNED_WOUND;
							}
							else
							{
								tool = MenuDOC_tool::none;
								stage 		= MenuDOC_stage::tool;
								
								cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_NEED_FIRE );
								return true;
							}
						}
						break;
					}
					
					switch( antiseptik )
					{
						case(MenuDOC_antiseptik::booze):
						{
							Item@ item_antiseptik = getItem( cr, PID_ROT_GUT_PRT );
							if( !valid( item_antiseptik ) )
								antiseptik = MenuDOC_antiseptik::none;
							else
							{
								SpillOut( item_antiseptik );
								
								skill += 0;
								skill_info += " + booze [0]";
								
								damage += 0;
							}
						}
						break;
						
						case(MenuDOC_antiseptik::spirit):
						{
							Item@ item_antiseptik = getItem( cr, PID_SPIRIT_PRT );
							if( !valid( item_antiseptik ) )
								antiseptik = MenuDOC_antiseptik::none;
							else
							{
								SpillOut( item_antiseptik );
								
								skill += 15;
								skill_info += " + spirit [15]";
								
								damage += 0;
							}
						}
						break;
						
						case(MenuDOC_antiseptik::antiseptik):
						{
							Item@ item_antiseptik = getItem( cr, PID_ANTISEPTIC );
							if( !valid( item_antiseptik ) )
								antiseptik = MenuDOC_antiseptik::none;
							else
							{
								skill += 30;
								skill_info += " + antiseptik [30]";
								
								int rng = Random( 5, 10 );
								damage -= rng;
								damage_info += " - antiseptik [" + rng + "]";

								_SubItem( item_antiseptik, 1 );
								cr.AddItem( PID_PHIAL, 1 );
							}
						}
						break;
						
						case(MenuDOC_antiseptik::none):
						{
							skill -= 30;
							skill_info += " - no antiseptik [30]";
								
							int rng = Random( 5, 10 );
							damage += rng;
							damage_info += " + no antiseptik [" + rng + "]";

							cr.ParamBase[ CR_DIRTINESS ] += Random( 5, 10 );
						}
						break;
						
					}
					
					switch( anestetik )
					{
						case(MenuDOC_anestetik::booze):
						{
							Item@ item_anestetik = getItem( cr, PID_ROT_GUT_PRT );
							if( !valid( item_anestetik ) )
								anestetik = MenuDOC_anestetik::none;
							else
							{
								ApplyFoodEffects( target, item_anestetik );
								
								SpillOut( item_anestetik );
								
								skill += 15;
								skill_info += " + booze [15]";
								
								damage += 0;
							}
						}
						break;
						
						case(MenuDOC_anestetik::spirit):
						{
							Item@ item_anestetik = getItem( cr, PID_SPIRIT_PRT );
							if( !valid( item_anestetik ) )
								anestetik = MenuDOC_anestetik::none;
							else
							{
								ApplyFoodEffects( target, item_anestetik );
								
								SpillOut( item_anestetik );
								
								skill += 30;
								skill_info += " + spirit [30]";
								
								int rng = Random( 5, 20 );
								damage -= rng;
								damage_info += " - spirit [" + rng + "]";
							}
						}
						break;
						
						case(MenuDOC_anestetik::anestetik):
						{
							Item@ item_anestetik = getItem( cr, PID_ANESTETIC );
							if( !valid( item_anestetik ) )
								anestetik = MenuDOC_anestetik::none;
							else
							{
								skill += 60;
								skill_info += " + anestetik [60]";
								
								int rng = Random( 15, 30 );
								damage -= rng;
								damage_info += " - anestetik [" + rng + "]";

								_SubItem( item_anestetik, 1 );
								cr.AddItem( PID_PHIAL, 1 );
							}
						}
						break;
						
						case(MenuDOC_anestetik::none):
						{
							skill += 0;
							skill_info += " + no anestetik [0]";
								
							damage += 0;
						}
						break;
						
					}

					target.StatBase[ ST_CURRENT_HP ] -= damage;
					
					testInfo( cr, skill_info + " = " + skill + "." );
					testInfo( cr, damage_info + " = " + damage + "." );

					int luck = cr.Stat[ST_LUCK];
					int chances = ( skill + rollLuck( luck ) * HEALING_LUCK_DEPENDENCY );
					testInfo( cr,
						"skill [" + skill + "]" +
						" + rollLuck( luck[" + luck + "] )[" + rollLuck( luck ) + "]" + 
						" * HEALING_LUCK_DEPENDENCY [" + HEALING_LUCK_DEPENDENCY + "]" +
						"{" + chances + "}" +
							" > " +
						"Random( 0, 100 * HEALING_DIFFICULTY[" + HEALING_DIFFICULTY + "] )" +
						"\n\nChances are: " + float( chances / HEALING_DIFFICULTY ) + "%." +
						""
					);
					
					if( HealingProcessSucceed( skill, cr.Stat[ST_LUCK] ) )
					{
						ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, false );
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_NEED_FIRE );
					}
					else 
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_SURGERY_FAILED );

					cr.TimeoutBase[ TO_SK_DOCTOR ] = DOCTOR_TIMEOUT( player );
					
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
				
				if( menu.Button( "Return" ) )
					stage 		= MenuDOC_stage::anestetik;	
			}
			return true;
		}
		
		return true;
	}

	string@ Description( Critter& cr ) 
	{
		switch( stage )
		{
			case(MenuDOC_stage::tool):
				return "Choosen tool:";
				
			case(MenuDOC_stage::antiseptik):
				return "Applied disenfection:"; 
			
			case(MenuDOC_stage::anestetik):
				return "Applied anastetic:"; 
			
			case(MenuDOC_stage::processing):
				return "You are ready to perform surgery on an open wound."; 
		}
		
		return "[UNKNOWN STATE #" + stage + "]";
	}
}

class MenuDOC_Cripple: CenteredMenuHandler 
{	
	Critter@ cr;
	Critter@ target;
	iDialogBox@ menu;
	
	int stage;
	uint limb;
	string description;
	
	MenuDOC_Cripple( Critter& target )
	{
		this.stage = MenuCripple_stage::main;
		@this.target = @target;
	}

	bool check( uint pid, string success, string failed )
	{
		if( hasItem( cr, pid ) )
		{
			if( menu.Button( success ) )
			{
				return true;
			}
		}
		else
		{
			menu.Button( failed );
		}
		return false;
	}
	
	bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
		@this.cr = @cr;
		@this.menu = @menu;
		description = "";
		
		string info = "Test info:\n"
					+ "Doctor #" + cr.Id 			+ "\n"
					+ "Patient #" + target.Id		+ "\n"
				;
					
		testInfo( cr, info );
		
		switch( stage )
		{
			case( MenuCripple_stage::main ):
			{
				for( uint i = 0, l = damages.length(); i < l; i++ )
				{
					if( target.DamageBase[damages[i]] != 0 && menu.Button(damage_states[i]) )
					{
						stage = MenuCripple_stage::tool;
						limb = damages[i];
						return true;
					}
				}

				if( menu.Button("Return") )
				{
					OpenMenu( cr, "DOC", MenuDOC( target ) );
					return false;
				}
			}
			return true;
			
			case(MenuCripple_stage::tool):
			{
				uint[] rates;
				uint[] ids;
				uint8 countTimes = target.GetTimeEvents( CTE_DOC, ids, null, rates );
				for( uint8 i = 0; i < countTimes; i++ )
				{
					if( rates[i] == limb )
					{
						description += "This part is already being healed.\n";
						
						if( menu.Button( "Remove " + ( limb == DAMAGE_EYE ? "bandage" : "brace" ) ) )
						{
							target.EraseTimeEvent( ids[i] );
							stage = MenuCripple_stage::main;
							limb = 0;
						}

						if( menu.Button( "Return" ) )
						{
							stage = MenuCripple_stage::main;
							limb = 0;
						}

						return true;
					}
				}
				
				if( target.DamageBase[ limb ] == 0 )
				{
					description += "This part does not require healing.\n";
					
					if( menu.Button("Return") )
					{
						stage = MenuCripple_stage::main;
						limb = 0;
					}
					
					return true;
				}
				
				switch( limb )
				{
					case(DAMAGE_EYE):
					{
						if( check( PID_CRAFT_L_RAGS, "Use a patch", "No patch" ) )
						{
							Item@ bandage = getItem( cr, PID_CRAFT_L_RAGS );
							if( !valid( bandage ) ) return true;
							
							_SubItem( bandage, 1 );

							int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
							target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
							cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_EYE_PATCHED );
							
							testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);
							
							stage = MenuCripple_stage::main;
							limb = 0;
							
							return true;
						}

						if( check( PID_BANDAGE, "Use bandage", "No bandage" ) )
						{
							Item@ bandage = getItem( cr, PID_BANDAGE );
							if( !valid( bandage ) ) return true;
							
							_SubItem( bandage, 1 );

							int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] * 2 - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
							target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
							cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_EYE_BANDAGED);

							testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] * 2 ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);
							
							stage = MenuCripple_stage::main;
							limb = 0;

							return true;
						}
						
					}						
					return true;
					
					case( DAMAGE_RIGHT_ARM ):
					case( DAMAGE_LEFT_ARM ):
					case( DAMAGE_RIGHT_LEG ):
					case( DAMAGE_LEFT_LEG ):
					{
						if( hasItem( cr, PID_ROPE ) && hasItems( cr, makeshift_splints ) )
						{
							if( menu.Button( "Improvised brace" ) )
							{
								Item@ rope = getItem( cr, PID_ROPE );
								if( !valid( rope ) )
								{
									return true;
								}
								
								Item@[] splints = getItems( cr, makeshift_splints );
								if( splints.length() == 0 )
								{
									return true;
								}
								
								Item@ splint = splints[ Random( 0, splints.length() - 1 ) ];
								if( !valid( splint ) )
								{
									return true;
								}

								_SubItem( splint, 1 );
								_SubItem( rope, 1 );								

								int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
								target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
								cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_IMPROVISED_BRACE );
								
								testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);

								stage = MenuCripple_stage::main;
								limb = 0;
								
								return true;
							}
						}
						else
						{
							if( menu.Button( "Nothing to brace with" ) )
							{
								cr.SayMsg( SAY_NETMSG,  TEXTMSG_TEXT, STR_DOCTOR_NO_BRACE );
								return true;
							}
						}

						if( check( PID_MEDSPLINT, "Apply brace", "No brace" ) )
						{
							Item@ splint = getItem( cr, PID_MEDSPLINT );
							if( !valid( splint ) ) return true;
							
							_SubItem( splint, 1 );

							int docTime = MAX_LIMB_HEALING_TIME - cr.Skill[ SK_DOCTOR ] * 2 - target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY;
							target.AddTimeEvent( "cte_Doc", REAL_MINUTE( CLAMP( docTime, 5, MAX_LIMB_HEALING_TIME ) ), CTE_DOC, limb );
							cr.SayMsg( SAY_NETMSG,  TEXTMSG_TEXT, STR_DOCTOR_MEDICAL_BRACE );

							testInfo( cr, "Time: " + MAX_LIMB_HEALING_TIME + " - " + ( cr.Skill[ SK_DOCTOR ] * 2 ) + " - " + ( target.Stat[ ST_ENDURANCE ] * HEALING_ENDURANCE_DEPENDENCY ) + " = " + docTime	);
							
							stage = MenuCripple_stage::main;
							limb = 0;

							return true;
						}
						
						if( menu.Button( "Return" ) )
						{
							stage = MenuCripple_stage::main;
							limb = 0;

							return true;
						}
					}				
					return true;
				}
			}
			return true;
		}
		return true;
	}

	string@ Description( Critter& cr ) 
	{
		switch( stage )
		{
			case(MenuCripple_stage::main):
				return description + "Chose your action:";
				
			case(MenuCripple_stage::tool):
				return description + "Choose healing method:"; 
		}
		
		return "[UNKNOWN STATE #" + stage + "]";
	}
}

bool ProccessDoctorSkill( Critter& cr, Critter& targetCr, bool alreadyAllowed )
{
	targetCr.StatBase[ST_VAR0] = cr.Id;
	cr.StatBase[ST_VAR0] = targetCr.Id;
	
	if(targetCr.Id != cr.Id && !targetCr.IsKnockout() && targetCr.Stat[ST_CURRENT_HP] > 0 && !alreadyAllowed && targetCr.IsPlayer ())
	{
		targetCr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_SelectAction" );
		targetCr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_BEING_EXAMINED_PROMPT );
		targetCr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_AGREE_EXAMINATION );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_BEING_EXAMINED );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WAITING_FOR_PATIENT );
	}
	else
	{
		answer_SelectAction(targetCr, 0, "");
	}
	
	return true;
}

void answer_SelectAction(Critter& targetCr, uint answerI, string& answerS)
{
	Critter@ cr = GetCritter( targetCr.StatBase[ST_VAR0] );
	if( !valid( cr ) )
	{
		return;
	}
	StartMenuDOC( cr, targetCr );
}

uint cte_Doc( Critter& cr, int identifier, uint& rate )
{
    cr.DamageBase[ rate ] = 0;
	
	uint[] effects =
	{
		STR_DOCTOR_EYE_HEALED,
		STR_DOCTOR_RIGHT_ARM_HEALED,
		STR_DOCTOR_LEFT_ARM_HEALED,
		STR_DOCTOR_RIGHT_LEG_HEALED,
		STR_DOCTOR_LEFT_LEG_HEALED		
	};
	
	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, effects[ rate - DAMAGE_EYE ] );
	ChangeCritterSpeed(cr);
	
    return 0;
}

/*bool UseBandage( Critter& cr, Critter& targetCr, uint16 sk )
{
	uint rate = 0;
	
	Map@ map = cr.GetMap();
	map.PlaySound( "bandage.ogg", cr.HexX, cr.HexY, 2 );
	
	rate = 1.0f + targetCr.Stat[ST_MAX_LIFE] * sk / 750.0f;
    targetCr.AddTimeEvent( "cte_Heal", 0, CTE_HEAL, rate );

    ChangeStatus( targetCr, CR_STATUS_BLEED, sk * 0.5, false );

    if( targetCr.Id != cr.Id ) {
		targetCr.Say( SAY_NETMSG, "Вам наложили повязки.");
	}
	
	targetCr.ParamBase[ CR_DIRTINESS ] += targetCr.StatBase[ ST_BLEED ];
	targetCr.StatBase[ ST_BLEED ] /= 8.0f;
	
	if ( valid (cr) ) {
		if( cr.IsPlayer() ) {
			cr.Say( SAY_NETMSG, "Вы наложили повязку." );	
			cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );
			cr.AddScore( SCORE_DOCTOR, 1 );
		}
	}
    return true;
}*/

uint cte_Heal( Critter& cr, int identifier, uint& rate )
{
    int heal = cr.Stat[ST_HEALING_RATE];
    if( heal < 1 ) heal = 3;
    if( heal > int(rate) ) heal = rate;
	if( heal <= 0 ) return 0;
    
	cr.StatBase[ST_CURRENT_HP] += heal;
    
	cr.Say( SAY_NETMSG, "Вы восстановили " + heal + " жизней." );

	testInfo( cr, "Healed " + heal + " , rate = " + rate );
	
    int result = int(rate) - heal;
	if( result < 0 || cr.Stat[ ST_CURRENT_HP ] >= cr.Stat[ ST_MAX_LIFE ] )
	{
		cr.Say( SAY_NETMSG, "Кажется, от повязки больше нет проку." );
		return 0;
    }
		
	rate = uint(result);

    ChangeCritterSpeed( cr );
	
    return REAL_SECOND( 60 );
}

bool HealingProcessSucceed( Critter@ cr, int skill )
{
	if( !valid( cr ) )
	{
		return false;
	}

	return HealingProcessSucceed( skill, cr.Stat[ST_LUCK] );
}

bool HealingProcessSucceed( int skill, int luck )
{
	int bug_check_1 = skill + rollLuck( luck ) * HEALING_LUCK_DEPENDENCY; 
	int bug_check_2 = Random( 0, 100 * HEALING_DIFFICULTY ); 

	Log("checkie beckie > " + bug_check_1);
	Log("checkie beckie > " + bug_check_2);

	if( bug_check_1 > 15000 ) {
		return false;
	}

	if ( bug_check_1 < 0 || bug_check_2 < 0 ) {
		return false;
	}

	if( bug_check_1 > bug_check_2 ) {
		return true;
	}
	return false;
}

class HealingItem
{
	uint16 pid;
	uint8 instant_heal;
	uint8 value_heal;
	uint8 value_overdose;
	uint msg;
	bool ResurectItem;
	string SoundName;
	
	HealingItem( uint16 pid, uint8 instant_heal, uint8 value_heal, uint8 value_overdose, uint msg, bool ResurectItem, string SoundName )
	{
        this.pid = pid;
		this.instant_heal = instant_heal;
		this.value_heal = value_heal;
		this.value_overdose = value_overdose;
		this.msg = msg;
		this.ResurectItem = ResurectItem;
		this.SoundName = SoundName;
	}
}

class HealingItemCollection
{
	HealingItem@[] healingItems;
	HealingItemCollection()
	{
	}
	
	HealingItemCollection@ healingItem( uint16 pid, uint8 instant_heal, uint8 value_heal, uint8 value_overdose, uint msg, bool ResurectItem, string SoundName ) 
	{
		this.healingItems.insertLast( HealingItem( pid, instant_heal, value_heal, value_overdose, msg, ResurectItem, SoundName ) );
		return this;
	}
	
	HealingItem@ get_by_pid( uint16 pid ) 
	{
		for( uint i = 0, len = this.healingItems.length(); i < len; i++ )
		{
			if( this.healingItems[i].pid == pid )
			{
				return this.healingItems[i];
			}
		}
		return null;
	}
}

HealingItemCollection@ healingItems = HealingItemCollection()
//					    Pid         instant_heal,	value_heal,		value_overdose,	 			msg, 			 ResurectItem,			SoundName
	.healingItem( PID_TRAUMATIN,		100,			60,				75,				STR_EMOTE_INJECT_STIM, 		true,	 		 "Stimpack.ogg" 	)
	.healingItem( PID_SUPER_STIMPAK,	60,				100,			75,				STR_EMOTE_INJECT_SS, 		true,	 		 "Stimpack.ogg" 	)
	.healingItem( PID_STIMPAK,			30,				50,				30,				STR_EMOTE_INJECT_STIM, 		true,			 "Stimpack.ogg" 	)
	.healingItem( PID_HEALING_POWDER,	20,				30,				40,				STR_EMOTE_APPLY_HP, 	   	false,	  		 "powder_use.ogg"	);
	
HealingItem@ GetHealingItem( Item@ item ) 
{
    uint16 Pid = item.GetProtoId();
    return healingItems.get_by_pid( Pid );
}	

void UseHealingItem( Critter& cr, Critter& targetCr, Item& item )
{
	if( valid( item ) )
	{
		HealingItem@ usedItem = GetHealingItem( item );
		
		if( valid( usedItem ) )
		{
			if( targetCr.IsDead() && usedItem.ResurectItem )
			{
				TryResurect( cr, targetCr );
			}
			else
			{
				cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );
				proccessHealItem( targetCr, usedItem );
			}
		}
		
		if( usedItem.pid != PID_HEALING_POWDER )
		{
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
		}
		uint lineNumber = cr.Id == targetCr.Id ? usedItem.msg : usedItem.msg + 1;
		
		cr.SayMsg( SAY_EMOTE, TEXTMSG_COMBAT, lineNumber );
		
		Map@ map = cr.GetMap();
		if( valid( map ) )
		{
			PlayGenericSound( map, cr.HexX, cr.HexY, usedItem.SoundName, 5 );
		}
		
		_SubItem( item, 1 );
	}
}

void proccessHealItem( Critter& cr, HealingItem& usedItem )
{
	uint traitMul = 1;
	uint traitDiv = 1;
	
	if( cr.Trait[TRAIT_CHEM_RELIANT] != 0 )
	{
		traitMul = 13;
		traitDiv = 10;
	}
	
	if( cr.Trait[TRAIT_CHEM_RESISTANT] != 0 )
	{
		traitMul = 7;
		traitDiv = 10;
	}
	
	if( cr.ParamBase[ ST_GLOBAL_OVERDOSE ] < 100 )
	{
		cr.StatBase[ ST_CURRENT_HP ] += usedItem.instant_heal * traitMul / traitDiv;
		int healedAmount = usedItem.value_heal * traitMul / traitDiv;
		cr.AddTimeEvent( "cte_quickheal", 0, CTE_QUICKHEAL, healedAmount );
	}
	
	if( cr.Trait[TRAIT_FAST_METABOLISM] != 0 )
	{
		traitMul += 3;
		traitDiv = 10;
	}
		
	cr.ParamBase[ ST_GLOBAL_OVERDOSE ] += ( usedItem.value_overdose * traitMul / traitDiv );
	
	if( cr.ParamBase[ ST_GLOBAL_OVERDOSE ] > 100 && cr.IsPlayer() )
	{
		cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 100, cr.HexX, cr.HexY );
		int poisonAmount = ( usedItem.value_overdose * ( 100 - cr.Stat[ ST_POISON_RESISTANCE ] ) ) / 100;
		AffectPoison( cr, poisonAmount );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_HEALING_OVERDOSE );
	}

	if( cr.StatBase[ ST_GLOBAL_OVERDOSE ] > 0 && cr.GetTimeEvents( CTE_GLOBAL_OVERDOSE, null, null, null ) < 1 ) 
	{
		cr.AddTimeEvent( "gameplay@cte_Global_Overdose", REAL_SECOND( 0 ), CTE_GLOBAL_OVERDOSE, 0 );
	}
}

uint cte_quickheal( Critter& cr, int identifier, uint& rate ) 
{
	int heal = 5;
	if( heal > int( rate ) )
	{
		heal = rate;
	}
	bool isHealed = true;

	cr.StatBase[ ST_CURRENT_HP ] += heal;
	int16 aidTime = 5;
	
	rate -= heal;

	ChangeCritterSpeed (cr);
	
	bool repeat = true;
	if( rate <= 0 )
	{
		repeat = false;
	}
	return repeat ? aidTime : 0;
}

void TryResurect( Critter& cr, Critter& targetCr )
{
	if( targetCr.Stat[ST_MAX_LIFE] > 50 )
	{
		
		Map@ map = targetCr.GetMap();
		
		if( targetCr.ParamBase[ CR_DEATH_STAGE ] >= 50 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WASTED_ITEM );
			return;
		}
		
		for( int dx = -1; dx < 1; dx++ )
		{
			for( int dy = -1; dy < 1; dy++ )
			{
				if( map.IsHexPassed( targetCr.HexX + dx, targetCr.HexY + dy ) )
				{
					targetCr.TransitToHex( targetCr.HexX + dx, targetCr.HexY + dy, targetCr.Dir );
					break;
				}
			}
		}
		targetCr.ToLife();
		targetCr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, targetCr.HexX, targetCr.HexY );
		targetCr.StatBase[ ST_CURRENT_HP ] = __DeadHitPoints + 1;
		targetCr.StatBase[ST_MAX_LIFE] -= 30;
		if( targetCr.IsPlayer() )
		{
			targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_RESURECTION_SUCCESS );
		}
	}
	else
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_ITEM_WONT_HELP );		
	}
}

class MenuFirstAid: CenteredMenuHandler
{
    uint map_id;
	uint targetCr_id;
	
    MenuFirstAid( Map& map, Critter& targetCr )
	{
        map_id = map.Id;
		targetCr_id = targetCr.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
		Critter@ targetCr = GetCritter( targetCr_id );
		
        if( !valid( map ) || !valid( targetCr) )
		{
            return false;
        }
		
		if( hasItem( cr, PID_HEALING_POWDER, -1 ) && menu.Button( "Healing Powder" ) )
		{
			Item@ item = getItem( cr, PID_HEALING_POWDER, -1 );
			cr.Action( ACTION_USE_ITEM, 2, item );
			UseHealingItem( cr, targetCr, item );
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			return false;
		}
		
		if( hasItem( cr, PID_STIMPAK, -1 ) && menu.Button( "Stimpack" ) )
		{
			Item@ item = getItem( cr, PID_STIMPAK, -1 );
			cr.Action( ACTION_USE_ITEM, 2, item );
			UseHealingItem( cr, targetCr, item );
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			return false;
		}
		
		if( hasItem( cr, PID_SUPER_STIMPAK, -1 ) && menu.Button( "Superstim" ) )
		{
			Item@ item = getItem( cr, PID_SUPER_STIMPAK, -1 );
			cr.Action( ACTION_USE_ITEM, 2, item );
			UseHealingItem( cr, targetCr, item );
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			return false;
		}
		
		if( hasItem( cr, PID_TRAUMATIN, -1 ) && menu.Button( "Traumatin" ) )
		{
			Item@ item = getItem( cr, PID_TRAUMATIN, -1 );
			cr.Action( ACTION_USE_ITEM, 2, item );
			UseHealingItem( cr, targetCr, item );
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			return false;
		}
		
		if( hasItem( cr, PID_ANTIDOTE, -1 ) && menu.Button( "Antidote" ) )
		{
			Item@ item = getItem( cr, PID_ANTIDOTE, -1 );
			cr.Action( ACTION_USE_ITEM, 2, item );
			if( targetCr_id == cr.Id )
			{
				cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_MED_ITEM_CONSUMED, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
				UseDrug( cr, item );
			}
			else
			{
				cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_MED_ITEM_USED_ON, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
				UseDrugOn( cr, targetCr, item );
			}
			cr.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
			return false;
		}
		
		if( targetCr.Stat[ ST_BLEED ] > 0 )
		{	//temp
			if( hasItem( cr, PID_CRAFT_L_RAGS, -1 ) && menu.Button( "Rags" ) )
			{
				uint msgStr = targetCr_id == cr.Id ? STR_EMOTE_BANDAGES_SELF : STR_EMOTE_BANDAGES_TERGET;
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, msgStr );
				targetCr.StatBase[ ST_BLEED ] /= 4;
				cr.DeleteItem( PID_CRAFT_L_RAGS, 1 );
				PlayGenericSound( map, cr.HexX, cr.HexY, "bandage.ogg", 6 );
				return false;
			}
			//temp
			if( hasItem( cr, PID_BANDAGE, -1 ) && menu.Button( "Bandage" ) )
			{
				uint msgStr = targetCr_id == cr.Id ? STR_EMOTE_BANDAGES_SELF : STR_EMOTE_BANDAGES_TERGET;
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, msgStr );
				targetCr.StatBase[ ST_BLEED ] /= 6;
				cr.DeleteItem( PID_BANDAGE, 1 );
				PlayGenericSound( map, cr.HexX, cr.HexY, "bandage.ogg", 6 );
				return false;
			}
		}

		return true;
    }
	
    string@ Description( Critter& cr )
	{
		string info = "First aid menu:";
		return info;
    }
	
    string@ ButtonCancel()
	{
        return ButtonDecorator( "Hide menu", null );
    }
}

void StartMenuFirstAid( Critter& cr, Critter& targetCr )
{
    Map@ map = cr.GetMap();
    if( map is null )
	{
        return;
    }

    iMenuHandler@ handler = MenuFirstAid( map, targetCr );
    iDialogBox@ menu = OpenMenu( cr, "", handler );
}

bool AskFirstAid( Critter& cr, Critter& targetCr, bool alreadyAllowed )
{
	targetCr.StatBase[ST_VAR0] = cr.Id;
	cr.StatBase[ST_VAR0] = targetCr.Id;
	
	if( targetCr.Id != cr.Id && !targetCr.IsKnockout() && targetCr.Stat[ST_CURRENT_HP] > 0 && !alreadyAllowed && targetCr.IsPlayer () )
	{
		targetCr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_SelectFAAction" );
		targetCr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_BEING_EXAMINED_PROMPT );
		targetCr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_AGREE_EXAMINATION );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_BEING_EXAMINED );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WAITING_FOR_PATIENT );
	}
	else
	{
		answer_SelectFAAction( targetCr, 0, "" );
	}
	
	return true;
}

void answer_SelectFAAction( Critter& targetCr, uint answerI, string& answerS )
{
	Critter@ cr = GetCritter( targetCr.StatBase[ST_VAR0] );
	if( !valid( cr ) ) 
	{
		return;
	}
	
	uint16 hx = cr.HexX, hy = cr.HexY;
	uint16 tx = targetCr.HexX, ty = targetCr.HexY;
	
	if( GetDistantion( hx, hy, tx, ty ) > 1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PATIENT_TOO_FAR );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_TOO_FAR );
		return;
	}
	StartMenuFirstAid( cr, targetCr );
}

bool AskHealingItem( Critter& cr, Critter& targetCr, Item& item, bool alreadyAllowed )
{
	targetCr.StatBase[ST_VAR0] = cr.Id;
	cr.StatBase[ST_VAR0] = targetCr.Id;
	cr.StatBase[ST_VAR1] = item.Id;
	
	if( targetCr.Id != cr.Id && !targetCr.IsKnockout() && targetCr.Stat[ST_CURRENT_HP] > 0 && !alreadyAllowed && targetCr.IsPlayer () )
	{
		targetCr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_UseHealingItem" );
		targetCr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_TEXT, STR_MED_ITEM_USED_PROMPT, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
		targetCr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_TEXT, STR_AGREE_EXAMINATION );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MED_ITEM_USED, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WAITING_FOR_PATIENT);
	}
	else
	{
		answer_SelectFAAction( targetCr, 0, "" );
	}
	
	return true;
}

void answer_UseHealingItem( Critter& targetCr, uint answerI, string& answerS )
{
	Critter@ cr = GetCritter( targetCr.StatBase[ST_VAR0] );
	Item@ item = GetItem( cr.StatBase[ST_VAR1] );
	if( !valid( cr ) ) 
	{
		return;
	}
	
	uint16 hx = cr.HexX, hy = cr.HexY;
	uint16 tx = targetCr.HexX, ty = targetCr.HexY;
	
	if( GetDistantion( hx, hy, tx, ty ) > 1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PATIENT_TOO_FAR );
		targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOCTOR_TOO_FAR );
		return;
	}
	
	UseHealingItem( cr, targetCr, item );
}

#endif // HEAL