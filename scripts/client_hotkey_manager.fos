#ifndef CLIENT_HOTKEY_MANAGER
#define CLIENT_HOTKEY_MANAGER

#include "_utils.fos"
#include "client_hotkey_manager.fosh"
#include "config_parser_h.fos"

import void HotkeysInit() from "client_hotkey_bind";

// Some shitty stub to call anything, don't know if that's really needed - APAMk2
void StubOnKeyStateCallback(int state, int[] args)
{
	return;
}

class KeyState
{
    uint8 Key = 0;
    bool IsDown = false;

	KeyState(uint8 newKey, bool newDown)
	{
		this.Key = newKey;
		this.IsDown = newDown;
	}

	KeyState(uint8 newKey)
	{
		this.Key = newKey;
		this.IsDown = false;
	}
}

class Hotkey 
{
	string Name;
	KeyState@[] Keys;
	int[] Args;
	HotkeyOnKeyState@ Callback;

	Hotkey(string name, uint8[] keys, HotkeyOnKeyState@ callback)
	{
		this.Name = name;
        for(uint i = 0, len = keys.length(); i < len; i++)
		{
            Keys.insertLast(KeyState(keys[i], false));
        }
		@Callback = callback;
    }

	Hotkey(string name, uint8[] keys, HotkeyOnKeyState@ callback, int[] args)
	{
		this.Name = name;
        for(uint i = 0, len = keys.length(); i < len; i++)
		{
            Keys.insertLast(KeyState(keys[i], false));
        }
		this.Args = args;
		@Callback = callback;
    }

	bool HasKey(uint8 key)
	{
        for(uint i = 0; i < Keys.length(); i++) 
		{
            if (Keys[i].Key == key)
                return true;
        }

        return false;
    }
	void MarkKeyDown(uint8 key)
	{
        for(uint i = 0; i < Keys.length(); i++) 
		{
            if (Keys[i].Key == key)
                Keys[i].IsDown = true;
        }
    }
	void MarkKeyUp(uint8 key)
	{
        for(uint i = 0; i < Keys.length(); i++) 
		{
            if (Keys[i].Key == key)
                Keys[i].IsDown = false;
        }
    }
	void Reset()
	{
        for(uint i = 0; i < Keys.length(); i++)
            Keys[i].IsDown = false;
    }
	bool IsFulfilled()
	{
        for(uint i = 0; i < Keys.length(); i++) 
		{
            if (!Keys[i].IsDown)
                return false;
        }

        return true;
    }

	void Rebind(uint8[] keys)
	{
		Keys.resize(0);
		for(uint i = 0, len = keys.length(); i < len; i++)
		{
            Keys.insertLast(KeyState(keys[i], false));
        }
	}
}

class HotkeyGroup
{
	string Name;
	dictionary Hotkeys;
	bool Enabled = false;

	HotkeyGroup(string name, bool enabled = false)
	{
		this.Name = name;
		this.Enabled = enabled;
	}

	void AddHotkey(string name, uint8[] keys, HotkeyOnKeyState@ callback, int[] args)
	{
		Hotkeys.set(name, Hotkey(name, keys, callback, args));
	}

	void InvokeCallbacks(uint8 callbackType)
	{
		string@[] hotkeyNames;
		Hotkeys.keys(hotkeyNames);
		for (uint i = 0, len = hotkeyNames.length(); i < len; i++)
		{
			Hotkey@ currHotkey;
			Hotkeys.get(hotkeyNames[i], @currHotkey);
			if(!valid(currHotkey)) continue;
			if (currHotkey.IsFulfilled())
			{
				Message("Invoking " + Name + ":" + hotkeyNames[i]);
				currHotkey.Callback( callbackType, currHotkey.Args );
			}
		}
	}
	
	void OnKeyStateChange(uint8 key, bool pressed)
	{
		string@[] hotkeyNames;
		Hotkeys.keys(hotkeyNames);
		
		if (pressed)
		{
			for (uint i = 0, len = hotkeyNames.length(); i < len; i++)
			{
				Hotkey@ currHotkey;
				Hotkeys.get(hotkeyNames[i], @currHotkey);
				if(!valid(currHotkey)) continue;
				if (currHotkey.HasKey(key))
				{
					currHotkey.MarkKeyDown(key);
				}
				else
				{
					currHotkey.Reset();
				}

				if((!currHotkey.HasKey(DIK_LSHIFT) || currHotkey.HasKey(DIK_RSHIFT)) && __shiftDown)
					currHotkey.Reset();
				
				if((!currHotkey.HasKey(DIK_LMENU) || currHotkey.HasKey(DIK_RMENU)) && __altDown)
					currHotkey.Reset();
				
				if((!currHotkey.HasKey(DIK_LCONTROL) || currHotkey.HasKey(DIK_RCONTROL)) && __ctrlDown)
					currHotkey.Reset();
			}

			InvokeCallbacks(KEY_PRESS);
		}
		else
		{
			for (uint i = 0, len = hotkeyNames.length(); i < len; i++)
			{
				Hotkey@ currHotkey;
				Hotkeys.get(hotkeyNames[i], @currHotkey);
				if(!valid(currHotkey)) continue;
				if (currHotkey.HasKey(key))
				{
					if (currHotkey.IsFulfilled())
					{
						currHotkey.Callback( KEY_RELEASE, currHotkey.Args );
					}
					currHotkey.MarkKeyUp(key);	
				}
			}
		}
	}
}

dictionary HotkeyGroups;
dictionary KeyStrToValList;

void HotkeyMngr_AddHotkey(string groupName, string name, uint8[] keys, HotkeyOnKeyState@ callback, int[] args)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(groupName, @currGroup);
	if(!valid(currGroup))
	{
		Log("Can't add hotkey [" + name + "] to [" + groupName + "] group. Reason: GROUP_NOT_EXISTS");
		return;
	}
	
    currGroup.AddHotkey(name, keys, callback, args);
}

void HotkeyMngr_AddHotkey(string groupName, string name, uint8 key, HotkeyOnKeyState@ callback, int[] args)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(groupName, @currGroup);
	if(!valid(currGroup))
	{
		Log("Can't add hotkey [" + name + "] to [" + groupName + "] group. Reason: GROUP_NOT_EXISTS");
		return;
	}
	
	uint8[] keys = {key};
    currGroup.AddHotkey(name, keys, callback, args);
}

void HotkeyMngr_AddHotkey(string groupName, string name, uint8[] keys, HotkeyOnKeyState@ callback)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(groupName, @currGroup);
	if(!valid(currGroup))
	{
		Log("Can't add hotkey [" + name + "] to [" + groupName + "] group. Reason: GROUP_NOT_EXISTS");
		return;
	}
	
	currGroup.AddHotkey(name, keys, callback, array<int>());
}

void HotkeyMngr_AddHotkey(string groupName, string name, uint8 key, HotkeyOnKeyState@ callback)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(groupName, @currGroup);
	if(!valid(currGroup))
	{
		Log("Can't add hotkey [" + name + "] to [" + groupName + "] group. Reason: GROUP_NOT_EXISTS");
		return;
	}

	uint8[] keys = {key};
    currGroup.AddHotkey(name, keys, callback, array<int>());
}

uint8 KeyStrToVal(string keyStr)
{
	uint8 result = 0;
	KeyStrToValList.get(keyStr, result);
	return result;
}

void ParseConfig()
{
	iConfig@ config = CreateConfig();
	if( !config.Parse( "hotkeys.cfg", true ) )
	{
		Message("Cant load hotkeys cfg!");
		return;
	}
	
	string@[] groupNames;
    HotkeyGroups.keys(groupNames);
	for (uint groupInd = 0, groupLen = groupNames.length(); groupInd < groupLen; groupInd++)
	{
		HotkeyGroup@ currGroup;
		HotkeyGroups.get(groupNames[groupInd], @currGroup);
		if(!valid(currGroup))
		{
			Log("Invalid group called [" + groupNames[groupInd] + "]!");
			continue;
		}
		iSection@[]@ sects = config.GetSections( currGroup.Name );
		if(!valid(sects)) 
		{
			Log("There's no sections called [" + currGroup.Name + "] in hotkeys.cfg!");
			continue;
		}

		for (uint sectInd = 0, sectsLen = sects.length(); sectInd < sectsLen; sectInd++)
		{
			iSection@ sect = sects[sectInd];
			if(!valid(sect))
			{
				Log("Invalid section called [" + currGroup.Name + "] in hotkeys.cfg!");
				continue;
			}

			string@[] hotkeyNames;
			currGroup.Hotkeys.keys(hotkeyNames);
			for (uint i = 0, len = hotkeyNames.length(); i < len; i++)
			{
				Hotkey@ currHotkey;
				currGroup.Hotkeys.get(hotkeyNames[i], @currHotkey);
				if(!valid(currHotkey))
				{
					Log("Can't find key [" + hotkeyNames[i] + "] in " + currGroup.Name + "!");
					continue;
				}

				string hotkeyVal = sect.GetKey( hotkeyNames[i] ).GetVal();
				if(hotkeyVal.length() <= 0) continue;

				uint8[] keyVals;
				string@[] keyStrs = splitEx( hotkeyVal, " " );
				for(uint j = 0, jlen = keyStrs.length(); j < jlen; j++)
				{
					uint8 convertedVal = KeyStrToVal(keyStrs[j]);
					keyVals.insertLast(convertedVal);
				}

				if(keyVals.length() > 0)
				{
					currHotkey.Rebind(keyVals);
				}
			}
		}
	}
}

void HotkeyMngr_Init()
{
	HotkeysInit();
	KeyStrToValList.set("DIK_ESCAPE", uint8(DIK_ESCAPE));
	KeyStrToValList.set("DIK_1", uint8(DIK_1));
	KeyStrToValList.set("DIK_2", uint8(DIK_2));
	KeyStrToValList.set("DIK_3", uint8(DIK_3));
	KeyStrToValList.set("DIK_4", uint8(DIK_4));
	KeyStrToValList.set("DIK_5", uint8(DIK_5));
	KeyStrToValList.set("DIK_6", uint8(DIK_6));
	KeyStrToValList.set("DIK_7", uint8(DIK_7));
	KeyStrToValList.set("DIK_8", uint8(DIK_8));
	KeyStrToValList.set("DIK_9", uint8(DIK_9));
	KeyStrToValList.set("DIK_0", uint8(DIK_0));
	KeyStrToValList.set("DIK_MINUS", uint8(DIK_MINUS));
	KeyStrToValList.set("DIK_EQUALS", uint8(DIK_EQUALS));
	KeyStrToValList.set("DIK_BACK", uint8(DIK_BACK));
	KeyStrToValList.set("DIK_TAB", uint8(DIK_TAB));
	KeyStrToValList.set("DIK_Q", uint8(DIK_Q));
	KeyStrToValList.set("DIK_W", uint8(DIK_W));
	KeyStrToValList.set("DIK_E", uint8(DIK_E));
	KeyStrToValList.set("DIK_R", uint8(DIK_R));
	KeyStrToValList.set("DIK_T", uint8(DIK_T));
	KeyStrToValList.set("DIK_Y", uint8(DIK_Y));
	KeyStrToValList.set("DIK_U", uint8(DIK_U));
	KeyStrToValList.set("DIK_I", uint8(DIK_I));
	KeyStrToValList.set("DIK_O", uint8(DIK_O));
	KeyStrToValList.set("DIK_P", uint8(DIK_P));
	KeyStrToValList.set("DIK_LBRACKET", uint8(DIK_LBRACKET));
	KeyStrToValList.set("DIK_RBRACKET", uint8(DIK_RBRACKET));
	KeyStrToValList.set("DIK_RETURN", uint8(DIK_RETURN));
	KeyStrToValList.set("DIK_LCONTROL", uint8(DIK_LCONTROL));
	KeyStrToValList.set("DIK_A", uint8(DIK_A));
	KeyStrToValList.set("DIK_S", uint8(DIK_S));
	KeyStrToValList.set("DIK_D", uint8(DIK_D));
	KeyStrToValList.set("DIK_F", uint8(DIK_F));
	KeyStrToValList.set("DIK_G", uint8(DIK_G));
	KeyStrToValList.set("DIK_H", uint8(DIK_H));
	KeyStrToValList.set("DIK_J", uint8(DIK_J));
	KeyStrToValList.set("DIK_K", uint8(DIK_K));
	KeyStrToValList.set("DIK_L", uint8(DIK_L));
	KeyStrToValList.set("DIK_SEMICOLON", uint8(DIK_SEMICOLON));
	KeyStrToValList.set("DIK_APOSTROPHE", uint8(DIK_APOSTROPHE));
	KeyStrToValList.set("DIK_GRAVE", uint8(DIK_GRAVE));
	KeyStrToValList.set("DIK_LSHIFT", uint8(DIK_LSHIFT));
	KeyStrToValList.set("DIK_BACKSLASH", uint8(DIK_BACKSLASH));
	KeyStrToValList.set("DIK_Z", uint8(DIK_Z));
	KeyStrToValList.set("DIK_X", uint8(DIK_X));
	KeyStrToValList.set("DIK_C", uint8(DIK_C));
	KeyStrToValList.set("DIK_V", uint8(DIK_V));
	KeyStrToValList.set("DIK_B", uint8(DIK_B));
	KeyStrToValList.set("DIK_N", uint8(DIK_N));
	KeyStrToValList.set("DIK_M", uint8(DIK_M));
	KeyStrToValList.set("DIK_COMMA", uint8(DIK_COMMA));
	KeyStrToValList.set("DIK_PERIOD", uint8(DIK_PERIOD));
	KeyStrToValList.set("DIK_SLASH", uint8(DIK_SLASH));
	KeyStrToValList.set("DIK_RSHIFT", uint8(DIK_RSHIFT));
	KeyStrToValList.set("DIK_MULTIPLY", uint8(DIK_MULTIPLY));
	KeyStrToValList.set("DIK_LMENU", uint8(DIK_LMENU));
	KeyStrToValList.set("DIK_SPACE", uint8(DIK_SPACE));
	KeyStrToValList.set("DIK_CAPITAL", uint8(DIK_CAPITAL));
	KeyStrToValList.set("DIK_F1", uint8(DIK_F1));
	KeyStrToValList.set("DIK_F2", uint8(DIK_F2));
	KeyStrToValList.set("DIK_F3", uint8(DIK_F3));
	KeyStrToValList.set("DIK_F4", uint8(DIK_F4));
	KeyStrToValList.set("DIK_F5", uint8(DIK_F5));
	KeyStrToValList.set("DIK_F6", uint8(DIK_F6));
	KeyStrToValList.set("DIK_F7", uint8(DIK_F7));
	KeyStrToValList.set("DIK_F8", uint8(DIK_F8));
	KeyStrToValList.set("DIK_F9", uint8(DIK_F9));
	KeyStrToValList.set("DIK_F10", uint8(DIK_F10));
	KeyStrToValList.set("DIK_NUMLOCK", uint8(DIK_NUMLOCK));
	KeyStrToValList.set("DIK_SCROLL", uint8(DIK_SCROLL));
	KeyStrToValList.set("DIK_NUMPAD7", uint8(DIK_NUMPAD7));
	KeyStrToValList.set("DIK_NUMPAD8", uint8(DIK_NUMPAD8));
	KeyStrToValList.set("DIK_NUMPAD9", uint8(DIK_NUMPAD9));
	KeyStrToValList.set("DIK_SUBTRACT", uint8(DIK_SUBTRACT));
	KeyStrToValList.set("DIK_NUMPAD4", uint8(DIK_NUMPAD4));
	KeyStrToValList.set("DIK_NUMPAD5", uint8(DIK_NUMPAD5));
	KeyStrToValList.set("DIK_NUMPAD6", uint8(DIK_NUMPAD6));
	KeyStrToValList.set("DIK_ADD", uint8(DIK_ADD));
	KeyStrToValList.set("DIK_NUMPAD1", uint8(DIK_NUMPAD1));
	KeyStrToValList.set("DIK_NUMPAD2", uint8(DIK_NUMPAD2));
	KeyStrToValList.set("DIK_NUMPAD3", uint8(DIK_NUMPAD3));
	KeyStrToValList.set("DIK_NUMPAD0", uint8(DIK_NUMPAD0));
	KeyStrToValList.set("DIK_DECIMAL", uint8(DIK_DECIMAL));
	KeyStrToValList.set("DIK_F11", uint8(DIK_F11));
	KeyStrToValList.set("DIK_F12", uint8(DIK_F12));
	KeyStrToValList.set("DIK_NUMPADENTER", uint8(DIK_NUMPADENTER));
	KeyStrToValList.set("DIK_RCONTROL", uint8(DIK_RCONTROL));
	KeyStrToValList.set("DIK_DIVIDE", uint8(DIK_DIVIDE));
	KeyStrToValList.set("DIK_SYSRQ", uint8(DIK_SYSRQ));
	KeyStrToValList.set("DIK_RMENU", uint8(DIK_RMENU));
	KeyStrToValList.set("DIK_PAUSE", uint8(DIK_PAUSE));
	KeyStrToValList.set("DIK_HOME", uint8(DIK_HOME));
	KeyStrToValList.set("DIK_UP", uint8(DIK_UP));
	KeyStrToValList.set("DIK_PRIOR", uint8(DIK_PRIOR));
	KeyStrToValList.set("DIK_LEFT", uint8(DIK_LEFT));
	KeyStrToValList.set("DIK_RIGHT", uint8(DIK_RIGHT));
	KeyStrToValList.set("DIK_END", uint8(DIK_END));
	KeyStrToValList.set("DIK_DOWN", uint8(DIK_DOWN));
	KeyStrToValList.set("DIK_NEXT", uint8(DIK_NEXT));
	KeyStrToValList.set("DIK_INSERT", uint8(DIK_INSERT));
	KeyStrToValList.set("DIK_DELETE", uint8(DIK_DELETE));
	KeyStrToValList.set("DIK_LWIN", uint8(DIK_LWIN));
	KeyStrToValList.set("DIK_RWIN", uint8(DIK_RWIN));
	ParseConfig();
}

void HotkeyMngr_OnKeyStateChange(uint8 key, bool pressed)
{
	string@[] groupNames;
    HotkeyGroups.keys(groupNames);
	for (uint groupInd = 0, groupLen = groupNames.length(); groupInd < groupLen; groupInd++)
	{
		HotkeyGroup@ currGroup;
		HotkeyGroups.get(groupNames[groupInd], @currGroup);
		if(!valid(currGroup)) continue;

		if(!currGroup.Enabled) continue;

		currGroup.OnKeyStateChange(key, pressed);
	}
}

void HotkeyMngr_Tick()
{
	string@[] groupNames;
    HotkeyGroups.keys(groupNames);
	for (uint groupInd = 0, groupLen = groupNames.length(); groupInd < groupLen; groupInd++)
	{
		HotkeyGroup@ currGroup;
		HotkeyGroups.get(groupNames[groupInd], @currGroup);
		if(!valid(currGroup)) continue;

		if(!currGroup.Enabled) continue;

		currGroup.InvokeCallbacks(KEY_HOLD);
	}
}

void HotkeyMngr_AddGroup(string name, bool enabled = false)
{
	HotkeyGroups.set(name, HotkeyGroup(name, enabled));
}

void HotkeyMngr_SetGroupState(string name, bool enabled)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(name, @currGroup);

	if(!valid(currGroup)) return;

	Message("Changed group " + name + " state to " + (enabled ? "true" : "false"));
	currGroup.Enabled = enabled;
}

void HotkeyMngr_RebindKey(string groupName, string name, uint8[] keys)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(groupName, @currGroup);
	if(!valid(currGroup)) return;
	
	Hotkey@ currHotkey;
	currGroup.Hotkeys.get(name, @currHotkey);
	if(!valid(currHotkey)) return;
	
    currHotkey.Rebind(keys);
}

void HotkeyMngr_RebindKey(string groupName, string name, uint8 key)
{
	HotkeyGroup@ currGroup;
	HotkeyGroups.get(groupName, @currGroup);
	if(!valid(currGroup)) return;
	
	Hotkey@ currHotkey;
	currGroup.Hotkeys.get(name, @currHotkey);
	if(!valid(currHotkey)) return;
	
	uint8[] keys = {key};
    currHotkey.Rebind(keys);
}

#endif // CLIENT_HOTKEY_MANAGER