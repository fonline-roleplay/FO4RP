                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

class Entire
{
	int Number;
	uint16 HexX;
	uint16 HexY;
}

uint ParseEntires(Map&map,Entire[]&entires,int number)
{
	uint oldCount=entires.length();
	uint count=map.CountEntire(number);
	entires.resize(oldCount+count);
	
	for(uint i=0;i<count;i++)
	{
		Entire@ent=entires[oldCount+i];
		if(map.GetEntireCoords(number,i,ent.HexX,ent.HexY)==false)
		return 0;
		ent.Number=number;
	}
	
	return count;
}

bool GetEntireFreeHex(Map&map,int number,uint16&hx,uint16&hy)
{
	uint count=map.CountEntire(number); 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy)&&map.IsHexPassed(hx,hy))
		return true;
	}
	
	if(hx==0||hy==0||hx>=map.GetWidth()-1||hy>=map.GetHeight()-1)
	return false; 
	
	for(uint i=0;i<count;i++)
	{
		if(map.GetEntireCoords(number,i,hx,hy))
		{
			for(int x=-1;x<=1;x++)
			{
				for(int y=-1;y<=1;y++)
				{
					if(x==0&&y==0)
					continue;
					
					if(__MapHexagonal)
					{
						if((hx%2)==1&&((x==-1&&y==1)||(x==1&&y==1)))
						continue;
						if((hx%2)==0&&((x==-1&&y==-1)||(x==1&&y==-1)))
						continue;
					}
					
					if(map.IsHexPassed(hx+x,hy+y))
					{
						hx+=x;
						hy+=y;
						return true;
					}
				}
			}
		}
	}
	return false;
}

bool GetNearEntire(Map&map,int number,uint16&hx,uint16&hy)
{
	uint16 hxBase=hx;
	uint16 hyBase=hy;
	
	Entire[]entires;
	uint count=ParseEntires(map,entires,number);
	if(count==0)
	return false;
	
	hx=entires[0].HexX;
	hy=entires[0].HexY;
	for(uint i=1;i<count;i++)
	{
		Entire@ent=entires[i];
		if(GetDistantion(hxBase,hyBase,ent.HexX,ent.HexY)<GetDistantion(hxBase,hyBase,hx,hy))
		{
			hx=ent.HexX;
			hy=ent.HexY;
		}
	}
	
	return true;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

const uint16[]Pids_AllWeapon={(300),(122),(8),(22),(18),(404),(241),(313),(398),(388),(394),(10),(287),(299),(23),(405),(143),(351),(403),(500),(161),(162),(261),(353),(392),(94),(385),(242),(268),(354),(9),(296),(283),(352),(391),(332),(11),(400),(13),(12),(389),(395),(350),(355),(387),(16),(402),(390),(118),(401),(28),(120),(24),(406),(15),(233),(396),(397),(16),(402),(390),(118),(401),(28),(120),(24),(406),(15),(233),(396),(397),(159),(25),(26),(27),(79),(205),(365),(45),(19),(423),(426),(486),(4),(236),(517),(383),(319),(522),(7),(280),(320),(5),(20),(384),(6),(386),(115),(160),(399),(116),(292),(293),(496),(497),(235),(21),(234),(407)};
const uint16[]Pids_WeaponSmallGuns={(300),(122),(8),(22),(18),(404),(241),(313),(398),(388),(394),(10),(287),(299),(23),(405),(143),(351),(403),(500),(161),(162),(261),(353),(392),(94),(385),(242),(268),(354),(9),(296),(283),(352),(391),(332)};
const uint16[]Pids_WeaponPistols={(300),(122),(8),(22),(18),(404),(241),(313),(398),(388),(394)};
const uint16[]Pids_WeaponRifles={(10),(287),(299),(23),(405),(143),(351),(403),(500),(161),(162),(261),(353),(392)};
const uint16[]Pids_WeaponShotguns={(94),(385),(242),(268),(354)};
const uint16[]Pids_WeaponPistolMachineGun={(9),(296),(283),(352),(391),(332)};
const uint16[]Pids_WeaponBigGuns={(11),(400),(13),(12),(389),(395),(350),(355),(387)};
const uint16[]Pids_WeaponEnergo={(16),(402),(118),(401),(28),(120),(24),(406),(15),(233),(396),(397)};
const uint16[]Pids_WeaponLaser={(16),(402),(118),(401),(28),(120)};
const uint16[]Pids_WeaponPlasma={(24),(406),(15),(233)};
const uint16[]Pids_WeaponPulse={(396),(397)};
const uint16[]Pids_WeaponThrowing={(159),(25),(26),(27),(79),(205),(365),(45),(19),(423),(426),(486)};
const uint16[]Pids_WeaponGrenade={(159),(25),(26),(27)};
const uint16[]Pids_WeaponThrowingOther={(79),(205),(365),(45),(19),(423),(426),(486)};
const uint16[]Pids_WeaponMelee={(4),(236),(517),(383),(319),(522),(7),(280),(320),(5),(20),(384),(6),(386),(115),(160),(399),(116)};
const uint16[]Pids_WeaponCutting={(4),(236),(517),(383),(319),(522)};
const uint16[]Pids_WeaponPricking={(7),(280),(320)};
const uint16[]Pids_WeaponShock={(5),(20),(384),(6),(386),(115)};
const uint16[]Pids_WeaponElectric={(160),(399),(116)};
const uint16[]Pids_WeaponUnarmed={(292),(293),(496),(497),(235),(21),(234),(407)};
const uint16[]Pids_WeaponSpecial={(270),(393),(371),(372),(427),(489),(498),(290),(291),(518),(520),(530),(531),(421),(390)};

const uint16[]Pids_AllArmor={(74),(1),(379),(265),(2),(380),(240),(17),(381),(239),(3),(232),(348),(349),(113),(524)};
const uint16[]Pids_ArmorLight={(74),(1),(379),(265)};
const uint16[]Pids_ArmorMedium={(2),(380),(240),(17),(381),(239)};
const uint16[]Pids_ArmorHeavy={(3),(232),(348),(349)};
const uint16[]Pids_ArmorRobes={(113)};
const uint16[]Pids_ArmorSpecial={(524)};

const uint16[]Pids_AllAmmo={(359),(35),(36),(363),(360),(121),(29),(30),(33),(31),(111),(357),(34),(95),(358),(14),(37),(32),(382),(38),(39),(163),(361),(362)};
const uint16[]Pids_Ammo={(359),(35),(36),(363),(360),(121),(29),(30),(33),(31),(111),(357),(34),(95),(358)};
const uint16[]Pids_AmmoOther={(14),(37),(32),(382),(38),(39),(163),(361),(362)};
const uint16[]Pids_AmmoSpecial={(274)};

const uint16[]Pids_AllDrugs={(40),(48),(49),(109),(144),(260),(273),(525),(106),(124),(125),(310),(311),(469),(53),(87),(110),(259),(71),(81),(103),(378),(424)};
const uint16[]Pids_DrugsPreparations={(40),(48),(49),(109),(144),(260),(273),(525)};
const uint16[]Pids_DrugsAlcohol={(106),(124),(125),(310),(311),(469)};
const uint16[]Pids_Drugs={(53),(87),(110),(259)};
const uint16[]Pids_DrugsOther={(71),(81),(103),(378)};
const uint16[]Pids_DrugsSpecial={(334),(473),(480),(481),(482),(424)};

const uint16[]Pids_MiscExplosions={(51),(85),(544)};
const uint16[]Pids_MiscActiveExplosions={(206),(209),(545),(222)};
const uint16[]Pids_MiscPartsBasic={(98),(92),(127),(271),(272),(276),(277),(278),(284),(285),(286),(318),(416),(542),(532),(534),(475),(535),(536),(537),(538),(50),(449),(539),(541)};
const uint16[]Pids_MiscPartsSelfSpecial={(89),(222),(229),(307),(419),(454),(364),(422),(479),(488)};
const uint16[]Pids_MiscPartsSpecial={(55),(253),(254),(258),(269),(356),(377)};
const uint16[]Pids_MiscPartsBody={(114),(251),(281),(282),(321),(322),(323),(324),(429),(484),(485),(507)};
const uint16[]Pids_MiscAllTools={(75),(77),(84),(308),(410),(411),(412),(47),(91),(408),(409),(428),(440),(289),(297),(543)};
const uint16[]Pids_MiscToolsTech={(75),(77),(84),(308),(410),(411),(412)};
const uint16[]Pids_MiscToolsMediacal={(47),(91),(408),(409),(428),(440)};
const uint16[]Pids_MiscToolsOther={(289),(297),(543)};
const uint16[]Pids_MiscToolsSpecial={(52),(54),(59)};
const uint16[]Pids_MiscOther={(101),(117),(126),(226),(227),(262),(295),(314),(315),(316),(317),(325),(326),(436),(437)};                                                                                                                                                                                                                                                                                                                                                                                                 

import void GM_MobInit(Critter&npc)from"mob";
import void GM_MobBossInit(Critter&npc)from"mob";
import void GM_MobMinionInit(Critter&npc)from"mob";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import void GM_InitCommonGuard(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)from"guards"; 

uint attackTarget=0; 

void AdvancedSpawnNPC(Critter&player,int type,int weapon,int AI_type,string@param3,int[]@param4)
{
	if(!(@player!=null))
	return;
	Map@map=player.GetMap();
	AdvancedSpawn(player,map,type,weapon,AI_type,param4[0],param4[1]);
}

void _OnDeadEvent(Critter&dead,Critter@killer)
{
	
	dead.AddTimeEvent("cte_deleteCorpse",40*60,0);
	
}

uint cte_deleteCorpse(Critter&dead,int identifier,uint&rate)
{
	
	DeleteNpc(dead);
	return 0;
}

void stopMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param0*10,ii=10+param0*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		
		if((@player!=null)&&(@controlled!=null)&&!controlled.IsPlayer())
		{
			controlled.ErasePlane(-1,true);
			controlled.ClearEnemyStack();
			controlled.EraseTimeEvents(9);
			controlled.SetDir(GetDirection(controlled.HexX,controlled.HexY,param1,param2));
		}
	}
}

void controlMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	player.RunClientScript("client_gui@_SetControlCritters",param0,0,0,null,null);
	Critter@target=GetCritter(param0);
	if((@target!=null))target.ParamBase[(800)]=player.Id;
}

void moveMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param0*10,ii=10+param0*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		
		if((@player!=null)&&(@controlled!=null)&&controlled.IsNpc())
		{
			controlled.ModeBase[(517)]=1;
			controlled.ErasePlane(-1,true);
			AddWalkPlane(controlled,1,param1,param2,GetDirection(controlled.HexX,controlled.HexY,param1,param2),(param3!=null),0);
			if(param0==0)
			controlled.ClearEnemyStack();
		}
	}
}

void attackMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	Critter@target=GetCritter(param0);
	
	for(uint i=param2*10,ii=10+param2*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@player!=null)&&(@controlled!=null)&&(@target!=null)&&controlled.IsNpc())
		{
			controlled.ModeBase[(517)]=1;
			controlled.ErasePlane(-1,true);
			AddAttackPlane(controlled,0,target,__RunOnCombat);
			controlled.AddEnemyInStack(target.Id);
		}
	}
}

void assaultMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	Critter@[]players,guards;
	Critter@target=GetCritter(param0);
	Map@map=player.GetMap();
	
	for(uint i=param2*10,ii=10+param2*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@player!=null)&&(@controlled!=null)&&(@target!=null)&&controlled.IsNpc()&&map.GetCritters(0,(0x03)|(0x10),players)>0)
		{
			controlled.StatBase[(97)]=(128);
			for(uint j=0,jj=players.length();j<jj;j++)
			{
				if(players[j].StatBase[(97)]!=controlled.StatBase[(97)])
				{
					AddAttackPlane(controlled,0,players[j],__RunOnCombat);
					controlled.AddEnemyInStack(players[j].Id);
				}
			}
		}
	}
}

void deleteMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param2*10,ii=10+(param2*10);i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@player!=null)&&(@controlled!=null)&&controlled.IsNpc()&&controlled.Stat[(104)]==0)
		DeleteNpc(controlled);
	}
}

void HomeMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param2*10,ii=10+(param2*10);i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@player!=null)&&(@controlled!=null)&&controlled.IsNpc())
		{
			controlled.SetHomePos(controlled.HexX,controlled.HexY,player.Dir);
			controlled.ModeBase[(517)]=0;
			controlled.SetDir(player.Dir);
		}
	}
} 

void MobHome(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	Critter@target=GetCritter(param0);
	target.ModeBase[(517)]=0;
}

void chaseMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	Critter@target=GetCritter(param0);
	
	for(uint i=param2*10,ii=10+param2*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@player!=null)&&(@controlled!=null)&&(@target!=null)&&controlled.IsNpc())
		{
			controlled.ErasePlane(-1,true);
			controlled.ModeBase[(517)]=1;
			controlled.StatBase[(188)]=target.Id;
			controlled.AddTimeEvent("follow",30,9);
		}
	}
}

void GatherMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param2*10,ii=10+param2*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@player!=null)&&(@controlled!=null))
		{
			Map@map=player.GetMap();
			if(not(@map!=null))
			return;
			uint8 temp_dir=Random(0,5);
			
			for(uint i=0;i<6;i++)
			{
				uint16 hexX=player.HexX,hexY=player.HexY;
				map.MoveHexByDir(hexX,hexY,(temp_dir+i)%6,1+param1);
				if(not map.IsHexPassed(hexX,hexY))
				continue;
				controlled.TransitToMap(map.Id,hexX,hexY,0);
				break;
			}
		}
	}
}

uint follow(Critter&cr,int master,uint&rate)
{
	int8 y=0;
	cr.ClearEnemyStack();
	Critter@daddy=GetCritter(cr.Stat[(188)]);
	Map@daddymap=null;
	Map@crmap=cr.GetMap();
	if((@daddy!=null))
	@daddymap=daddy.GetMap();
	else
	return 0;
	cr.ErasePlane(-1,true);
	
	if((!(@daddymap!=null))&&((@crmap!=null)))
	{
		cr.TransitToGlobalGroup(daddy.Id);
	}
	else if(((@daddymap!=null))&&((@crmap!=null))&&(daddymap.Id==crmap.Id))
	{
		AddWalkPlane(cr,0,daddy.HexX,daddy.HexY,GetDirection(cr.HexX,cr.HexY,daddy.HexX,daddy.HexY),false,1);
	}
	else if(((@daddymap!=null))&&((@crmap!=null))&&(crmap.Id!=daddymap.Id))
	{
		uint8 findPos=1;
		while(findPos<=10)
		{
			if(daddymap.IsHexPassed(daddy.HexX+findPos,daddy.HexY+findPos))
			{
				cr.TransitToMap(daddymap.Id,daddy.HexX+findPos,daddy.HexY+findPos,Random(0,5));
				findPos=10;
			}
			findPos++;
		}
	}
	return 30;
}

void AdvancedSpawn(Critter&player,Map&map,int type,int weapon,int AI_type,uint16 hexX,uint16 hexY)
{
	if(type==0)
	{
		player.Say((11)," #spawn [тип] [оружие] [AI]");
		player.Say((11),"Тип:");
		player.Say((11),"1 - крыса");
		player.Say((11),"2 - мантис");
		player.Say((11),"3 -  муравей");
		player.Say((11),"4 -  свинокрыс");
		player.Say((11),"5 -  кротокрыс");
		player.Say((11),"6 -  большой кротокрыс");
		player.Say((11),"7 -  гекко");
		player.Say((11),"8 -  золотой гекко");
		player.Say((11),"9 -  собака");
		player.Say((11),"10 -  малый скорпион");
		player.Say((11),"11 -  большой скорпион");
		player.Say((11),"12 -  брамин");
		player.Say((11),"13 -  чужой");
		player.Say((11),"14 -  малый коготь");
		player.Say((11),"15 -  большой коготь");
		player.Say((11),"16 -  кентавр");
		player.Say((11),"17 -  летун");
		player.Say((11),"18 -  огнегекко");
		player.Say((11),"19 -  кентавр2");
		player.Say((11),"20 -  каннибал");
		player.Say((11),"21 -  каннибал ж");
		player.Say((11),"22 -  рейдер");
		player.Say((11),"23 -  рейдер ж");
		player.Say((11),"24 -  работорг");
		player.Say((11),"25 -  работорг ж");
		player.Say((11),"26 -  мародер");
		player.Say((11),"27 -  мародер ж");
		player.Say((11),"28 -  гуль");
		player.Say((11),"29 -  супермутант");
		player.Say((11),"30 -  раб");
		player.Say((11),"31 -  раб ж");
		player.Say((11),"32 -  мальчик");
		player.Say((11),"33 -  девочка");
		player.Say((11),"34 -  путешественник");
		player.Say((11),"35 -  путешественница");
		player.Say((11),"Оружие:");
		player.Say((11),"1-без оружия");
		player.Say((11),"1-нож");
		player.Say((11),"2-кастет");
		player.Say((11),"3-копье");
		player.Say((11),"10-лоу револьвер");
		player.Say((11),"14-самопал винт.");
		player.Say((11),"18-лоу смг");
		player.Say((11),"19-большая пушка");
		player.Say((11),"20 - 10мм");
		player.Say((11),"21 -  маузер");
		player.Say((11),"22 -  дисерт игл");
		player.Say((11),"23 -  охотка");
		player.Say((11),"AI:");
		player.Say((11),"0-контроль");
		player.Say((11),"1-моб");
		player.Say((11),"2-гарнизонМодока");
		player.Say((11),"3-нейтрал");
		player.Say((11),"4-моб-Лидер");
		player.Say((11),"5-моб-миньон");
		return;
	}
	int NPC1=(310)+type;
	if(type>=36)
	NPC1=type;
	Critter@cr=map.AddNpc(NPC1,hexX,hexY,Random(0,5),null,null,null);
	if((@cr!=null))
	{
		cr.SetEvent((2),"_OnDeadEvent");
		cr.StatBase[(105)]=207;
		cr.StatBase[(107)]=(1);
		cr.StatBase[(106)]=30;
		cr.StatBase[(84)]=__FullSecond+((2)*__TimeMultiplier*3600);
		cr.ModeBase[(517)]=0;
		cr.ModeBase[(522)]=1;
		if(type>=20)
		{
			int weapon2;
			switch(weapon)
			{
				case 0:
				weapon2=0;
				break;
				case 1:
				weapon2=(1418);
				break;
				case 2:
				weapon2=(1417);
				break;
				case 3:
				weapon2=(1043);
				break;
				case 4:
				weapon2=(4);
				break;
				case 5:
				weapon2=(1420);
				break;
				case 6:
				weapon2=(20);
				break;
				case 7:
				weapon2=(7);
				break;
				case 8:
				weapon2=(383);
				break;
				case 9:
				weapon2=(319);
				break;
				case 10:
				weapon2=(1406);
				break;
				case 11:
				weapon2=(1407);
				break;
				case 12:
				weapon2=(1405);
				break;
				case 13:
				weapon2=(1408);
				break;
				case 14:
				weapon2=(299);
				break;
				case 15:
				weapon2=(300);
				break;
				case 16:
				weapon2=(1403);
				break;
				case 17:
				weapon2=(1412);
				break;
				case 18:
				weapon2=(1402);
				break;
				case 19:
				weapon2=(1410);
				break;
				case 20:
				weapon2=(8);
				break;
				case 21:
				weapon2=(122);
				break;
				case 22:
				weapon2=(18);
				break;
				case 23:
				weapon2=(10);
				break;
			}
			if(weapon>23)
			cr.AddItem(weapon,1);
			else if(weapon2>0)
			cr.AddItem(weapon2,1);
		}
		if(AI_type==0&&(@player!=null))
		{
			controlMob(player,cr.Id,0,0,null,null);
		}
		else if(AI_type==1)
		{
			GM_MobInit(cr);
		}
		else if(AI_type==2)
		{
			Critter@[]players,guards;
			Map@map=player.GetMap();
			if((@player!=null)&&(@cr!=null)&&map.GetCritters(0,(0x03)|(0x10),players)>0)
			{
				cr.StatBase[(97)]=(128);
				for(uint j=0,jj=players.length();j<jj;j++)
				{
					if(players[j].StatBase[(97)]!=cr.StatBase[(97)])
					{
						AddAttackPlane(cr,0,players[j],__RunOnCombat);
						cr.AddEnemyInStack(players[j].Id);
					}
				}
			}
		}
		else if(AI_type==3&&(@player!=null))
		{
			GM_InitCommonGuard(player,cr.Id,0,0,null,null);
		}
		else if(AI_type==4)
		{
			GM_MobBossInit(cr);
		}
		else if(AI_type==5)
		{
			GM_MobMinionInit(cr);
		}
	}
}                                                                                    

