                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                       

import void AffectRadiation(Critter&cr,int value)from"radiation";
import void ApplyMutation(Critter&cr)from"morphes";
import void _MobInit(Critter&npc,bool firstTime)from"mob";
import void FlushScreen(Critter&cr,uint fromColor,uint toColor,uint timeMs)from"effects";
import void GM_MobInit(Critter&npc)from"mob";     

void Radiate(Critter&player,int param0,int param1,int param2)
{
	Critter@target=null;
	if(param0==0)
	@target=player;
	else
	@target=GetCritter(param0);
	AffectRadiation(target,param1);
}

void Mutate(Critter&player,int param0,int param1,int param2)
{
	Critter@target=null;
	if(param0==0)
	@target=player;
	else
	@target=GetCritter(param0);
	ApplyMutation(target);
}

void ViewPlanes(Critter&player,int param0,int param1,int param2)
{
	if(param0==0)
	param0=20;
	
	Map@map=player.GetMap();
	if(not(@map!=null))
	return;
	
	Critter@[]critters;
	uint count=0;
	if(param1==0)
	count=map.GetCrittersHex(player.HexX,player.HexY,param0,(0x0F)|(0x20),critters);
	else
	{
		Critter@cr=GetCritter(param1);
		if(not(@cr!=null))
		return;
		critters.resize(1);
		@critters[0]=cr;
	}
	
	for(uint i=0;i<count;i++)
	{
		NpcPlane@[]p;
		uint pcount=critters[i].GetPlanes(p);
		for(uint j=0;j<pcount;j++)
		{
			uint[]param={critters[i].Id,p[j].Type,p[j].Priority};
			switch(p[j].Type)
			{
				case(0):
				param.resize(5);
				param[3]=p[j].Misc_WaitSecond;
				param[4]=p[j].Misc_ScriptId;
				break;
				case(1):
				param.resize(5);
				param[3]=p[j].Attack_TargId;
				param[4]=p[j].Attack_MinHp;
				break;
				case(2):
				param.resize(8);
				param[3]=p[j].Walk_HexX;
				param[4]=p[j].Walk_HexY;
				param[5]=p[j].Walk_Dir;
				if(p[j].Run)
				param[6]=1;
				else
				param[6]=0;
				param[7]=p[j].Walk_Cut;
				break;
				case(3):
				param.resize(6);
				param[3]=p[j].Pick_HexX;
				param[4]=p[j].Pick_HexY;
				param[5]=p[j].Pick_Pid;
				break;
			}
			CreateTimeEvent(__FullSecond+60+j,"e_ViewPlanes",param,false);
		}
	}
}

uint e_ViewPlanes(uint[]@values)
{
	Critter@crit=GetCritter(values[0]);
	if(not(@crit!=null))
	return 0;
	
	string msg="error";
	switch(values[1])
	{
		case(0):
		msg="<<MISC>> Prior="+values[2];
		msg+=" WaitMinute="+values[3]+" ScriptId="+values[4];
		break;
		case(1):
		msg="<<ATTACK>> Prior="+values[2];
		msg+=" TargId="+values[3]+" MinHp="+values[4];
		break;
		case(2):
		msg="<<WALK>> Prior="+values[2];
		msg+=" HexX="+values[3]+" HexY="+values[4]+" Dir="+values[5];
		msg+=" Run="+values[6]+" Cut="+values[7];
		break;
		case(3):
		msg="<<PICK>> Prior="+values[2];
		msg+=" HexX="+values[3]+" HexY="+values[4]+" Pid="+values[5];
		break;
	}
	
	crit.Say((2),msg);
	return 0;
}   

import void InjureCritter(Critter&cr,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";  

void lvl(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(77)]));
}

void team(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(106)]));
}

void role(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(89)]));
}

void info(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[param0]));
}

void hp(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Stat[(72)])+"/"+""+(critters[i].Stat[(7)]));
} 

void planc(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].GetPlanes(null)));
} 

void plans(Critter&player,int param0,int param1,int param2)
{
	NpcPlane@[]planes;
	string str;
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	{
		str="";
		uint count=critters[i].GetPlanes(planes);
		for(uint j=0;j<count;j++)
		{
			switch(planes[j].Type)
			{
				case(0):
				str=str+"M ";
				break;
				case(1):
				str=str+"A ";
				break;
				case(2):
				str=str+"W ";
				break;
				case(3):
				str=str+"P ";
				break;
				case(4):
				str=str+"P ";
				break;
				case(5):
				str=str+"C ";
				break;
			}
		}
		critters[i].Say((2),str);
	}
} 

void lvli(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16)*2,(0x01)|(0x10),critters);
	for(uint i=0;i<count;i++)
	player.Say((11),GetPlayerName(critters[i].Id)+": "+""+(critters[i].Stat[(77)]));
}

void dmg(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter(param0);
	if(not(@target!=null))
	return;
	InjureCritter(target,param1,param2,0,player.Id);
}

void kill(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter(param0);
	if(not(@target!=null))
	return;
	target.Say((11),"Кара небесная поразила вас!");
	target.ToDead((param1==0?(114):param1),player);
	
}

void body(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	target.ChangeCrType(param1);
}

void anim(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	target.Animate(param1,param2,null,true,true);
}

void testmap(Critter&player,int param0,int param1,int param2)
{
	Critter@[]groups;
	groups.insertLast(@player);
	uint locid=CreateLocation(
	(param1==0?400:param1),player.WorldX,player.WorldY,groups);
	Location@loc=GetLocation(locid);
	
	if(not(@loc!=null))
	{
		player.Say((11),"Location not found");
		return;
	}
	Map@map;
	if(param0!=0)
	@map=loc.GetMap(param0);
	else
	@map=loc.GetMapByIndex(0);
	if(not(@map!=null))
	return;
	player.TransitToMap(map.Id,0);
} 

void _ctd(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	ctd(player,param0,param1,param2);
} 

void ctd(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter(param0);
	if(not(@target!=null))
	return;
	
	Critter@daddy=((param2!=0)?target:player);
	Critter@child=((param2==0)?target:player); 
	
	Map@map=daddy.GetMap();
	if(not(@map!=null))
	return;
	
	if(child.ParamBase[(703)]==(0)&&daddy.GetAccess()<=(2))
	{
		child.Say((11),"Игрок в стартовом режиме, его нельзя телепортировать.");
		return;
	} 
	
	uint8 temp_dir=Random(0,5);
	for(uint i=0;i<6;i++)
	{
		uint16 hexX=daddy.HexX,hexY=daddy.HexY;
		map.MoveHexByDir(hexX,hexY,(temp_dir+i)%6,1+param1);
		if(not map.IsHexPassed(hexX,hexY))
		continue;
		child.TransitToMap(map.Id,hexX,hexY,0);
		break;
	}
	
}

void CalmDown(Critter&player,int crId,int param1,int param2)
{
	Critter@cr=GetCritter(crId);
	if(!(@cr!=null)||cr.IsPlayer())
	{
		player.Say((11),"НПЦ не найдет");
		return;
	}
	else
	cr.ClearEnemyStack();
}

void god(Critter&player,int,int,int)
{
	for(uint i=(0);i<=(6);i++)
	player.StatBase[i]=10;
	for(uint i=(16);i<=(22);i++)
	player.StatBase[i]=100;
	for(uint i=(23);i<=(31);i++)
	player.StatBase[i]=100;
	for(uint i=(200);i<=(217);i++)
	player.SkillBase[i]=300;
	player.StatBase[(10)]=999;
	player.StatBase[(9)]=100;
	player.StatBase[(72)]=9999;
	player.StatBase[(7)]=9999;
}

void GM_god(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	for(uint i=(0);i<=(6);i++)
	player.StatBase[i]=10;
	for(uint i=(200);i<=(217);i++)
	player.SkillBase[i]=300;
	player.PerkBase[(315)]=100;
	player.PerkBase[(314)]=10;
	player.PerkBase[(316)]=1;
	player.PerkBase[(301)]=2;
	player.PerkBase[(344)]=3;
	player.StatBase[(7)]=120;
	player.StatBase[(72)]=9999;
	player.ModeBase[(510)]=1;
	player.ModeBase[(524)]=1;
	player.ModeBase[(527)]=1;
	player.ModeBase[(511)]=1;
}

void mapid(Critter&player,int,int,int)
{
	Map@map=player.GetMap();
	player.Say((11),""+(map.GetProtoId()));
}

void GM_tele(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	tele(player,param0,param1,param2);
}

void tele(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	Location@loc=GetLocationByPid((param1==0?player.GetMap().Id:param1),0);
	if(not(@loc!=null))
	{
		player.Say((11),"Location not found");
		return;
	}
	Map@map=loc.GetMapByIndex(param2);
	if(not(@map!=null))
	{
		player.Say((11),"Map index not found");
		@map=loc.GetMapByIndex(0);
		if(not(@map!=null))
		return;
	}
	
	target.SetWorldPos(loc.WorldX,loc.WorldY);
	target.TransitToMap(map.Id,0);
}

void items(Critter&player,int param0,int param1,int param2)
{
	Item@[]items;
	uint count=player.GetMap().GetItems(player.HexX,player.HexY,items);
	for(uint i=0;i<count;i++)
	player.Say((11),""+items[i].GetProtoId());
}

void id(Critter&player,int param0,int param1,int param2)
{
	Critter@[]critters;
	uint count=player.GetMap().GetCrittersHex(player.HexX,player.HexY,(16),(0x01)|(0x0F),critters);
	for(uint i=0;i<count;i++)
	critters[i].Say((2),""+(critters[i].Id));
}     

void ToMapEntire(Critter&player,int mapPid,int entire,int skip)
{
	Map@map=::GetMapByPid(mapPid,skip);
	if((@map!=null))
	{
		player.TransitToMap(map.Id,entire);
	}
	else
	{
		player.Say((11),"Карта с pid="+mapPid+" не найдена");
	}
}

void ToMap(Critter&player,int mapPid,int X,int Y)
{
	Map@map=GetMapByPid(mapPid,0);
	if((@map!=null))
	{
		player.TransitToMap(map.Id,X,Y,0);
	}
	else
	{
		player.Say((11),"Карта с pid="+mapPid+" не найдена");
	}
} 

void NpcByDialog(Critter&player,int mapPid,int dialog,int)
{
	Map@map=::GetMapByPid(mapPid,0);
	if((@map!=null))
	{
		Critter@[]npc;
		
		if(map.GetCritters(0,(0x0F)|(0x20),npc)==0)
		{
			
			player.Say((11),"не найдено нпц с таким диалогом");
			
		}
		else
		{
			uint idF=0;
			uint l=0;
			for(uint i=0;i<npc.length();i++)
			{
				if(npc[i].Stat[(104)]==dialog)
				{
					l++;
					idF=(idF==0?npc[i].Id:idF);
				}
			}
			player.Say((11),"Найдено нпц, в штуках:"+l+" Id первого:"+idF);
		}
	}
	
}

void SetReputation(Critter&cr,int crId,int num,int val)
{
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	toCr.ReputationBase[num]=val;
}

void Siren(Critter&cr,int,int,int)
{
	Map@map=cr.GetMap();
	if(!(@map!=null))
	{
		cr.Say((11),"Невозможно проиграть звук на глобальной карте");
		return;
	}
	map.PlaySound("AIRSIREN.OGG");
}

void Mirelurk(Critter&cr,int,int,int)
{
	cr.GetMap().AddNpc(487,cr.HexX-3,cr.HexY-3,0,null,null,null);
	
}         

void SetMode(Critter&cr,int id,int mode,int value)
{
	Critter@crit=GetCritter(id);
	crit.ModeBase[mode]=value;
}

void RunMapLoop(Critter&player,int ms,int param1,int param2)
{
	Map@map=player.GetMap();
	map.SetLoopTime(0,ms);
	map.SetLoopTime(1,ms+500);
	map.SetEvent((1),"e_Map_Loop_0_Run");
	map.SetEvent((2),"e_Map_Loop_1_Run"); 
	
}

void e_Map_Loop_0_Run(Map&map)
{
	map.SetLoopTime(0,3000);
	Display_Ms_Msg(map);
}

void e_Map_Loop_1_Run(Map&map)
{
	map.SetLoopTime(1,3000);
	Display_Ms_Msg(map);
}

void Display_Ms_Msg(Map&map)
{
	uint16 year=0,month=0,week=0,day=0,hour=0,minute=0,sec=0,ms=0;
	Critter@[]critArr(1);
	map.GetCritters(0,(0x0F),critArr);
	
	if(critArr.length()==0)
	Log("Не найдено криттеров");
	else
	{
		
		Critter@crt=critArr[critArr.length()-1];
		GetTime(year,month,week,day,hour,minute,sec,ms);
		crt.Say((3),"Current local second "+sec+","+ms);
	}
}

void Check_Dict_Element(Critter&player,int,int,int)
{
	dictionary dict;
	dict.set(player.Id+"|"+1,1);
	dict.set(player.Id+"|"+2,2);
	dict.set(player.Id+"|"+3,3);
	if(dict.exists(player.Id+"|*"))
	player.Say((1),"Словарь обрабатывает звездочку в ключе");
	else
	player.Say((1),"Хуй вам, словарь не обрабатывает звездочку в ключе");
}

void SetRain(Critter&player,int capacity,int param1,int param2)
{
	Map@map=player.GetMap();
	if(!(@map!=null))
	return;
	map.SetRain(capacity);
}

void GetRain(Critter&player,int param0,int param1,int param2)
{
	Map@map=player.GetMap();
	if(!(@map!=null))
	return;
	player.Say((11),"Rain power: "+map.GetRain());
}

void GetParam(Critter&player,int crId,int num,int val)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	player.Say((11)," "+toCr.Param[num]);
}

void GetParamBase(Critter&player,int crId,int num,int val)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	player.Say((11)," "+toCr.ParamBase[num]);
}

void SetParam(Critter&player,int crId,int num,int val)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	{
		toCr.ParamBase[num]=val;
		player.Say((11),"Done.");
	}
}

void GetId(Critter&player,int playerId,int param1,int param2)
{
	player.ShowScreen((0),0,"");
	player.ShowScreen((5),0,"answer_GetId");
	player.Say((39),"Введите логин персонажа.");
}

void answer_GetId(Critter&player,uint answerI,string&answerS)
{
	if(answerS.length()<3)
	return;
	
	Critter@cr=GetPlayer(answerS);
	
	if(!(@cr!=null))
	{
		player.Say((11),"Нет такого персонажа.");
		return;
	}
	
	player.Say((11),"Login: "+answerS+" Id: "+cr.Id);
}                                                              

void NetId(Critter&player,int searchRadius,int,int)
{
	Critter@[]crits;
	player.GetMap().GetCrittersHex(player.HexX,player.HexY,searchRadius,(0x0F),crits);
	player.Say((11),"my info: HexX="+player.HexX+"; HexY="+player.HexY+"; SearchRadius="+searchRadius);
	for(uint i=0;i<crits.length();i++)
	{
		player.Say((11),"Critter Pid:"+crits[i].GetProtoId()+"; Dialog:"+crits[i].Stat[(104)]+"; Id:"+crits[i].Id);
	}
	player.Say((11),"Total: "+crits.length());
}

void SetCritParam(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	{
		cr.ParamBase[param]=value;
	}
}

void GetCritParam(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	{
		player.Say((11),"Param #"+param+" val= "+cr.Param[param]);
	}
}

void ShowLocation(Critter&player,int,int,int)
{
	Map@map=player.GetMap();
	if((@map!=null))
	{
		Location@loc=map.GetLocation();
		if((@loc!=null)&&!loc.Visible)
		loc.Visible=true;
	}
}  

void GetMap(Critter&player,int param0,int param1,int param2)
{
	Map@map=player.GetMap();
	string str=map.Id;
	player.Say((11),"КАРТА - "+str);
	str=player.HexX+" "+player.HexY;
	player.Say((11),"Координаты - "+str);
	str=player.Dir;
	player.Say((11),"Направление - "+str);
}

void GetEnemyStack(Critter&player,int crId,int param1,int param2)
{
	uint[]enemyStack;
	uint x=0;
	string str;
	Critter@cr=GetCritter(crId);
	if(!(@cr!=null))
	player.Say((11),"Криттер не найдет");
	else if(cr.IsPlayer())
	player.Say((11),"Криттер не является НПЦ");
	else
	{
		cr.GetEnemyStack(enemyStack);
		player.Say((11),"Список врагов:");
		while(x<enemyStack.length())
		{
			str="";
			str+=x;
			str+=": ";
			str+=enemyStack[x];
			player.Say((11),str);
			x++;
		}
	}
	
}                                        

void deleteCritter(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	DeleteNpc(cr);
}

void rotateCritter(Critter&player,int id,int param,int value)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	{
		cr.SetHomePos(cr.HexX,cr.HexY,param);
		cr.SetDir(param);
	}
}

void changeHome(Critter&player,int id,int x,int y)
{
	Critter@cr=GetCritter(id);
	cr.SetHomePos(x,y,0);
}

void GM_tel(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if((@cr!=null))
	cr.TransitToHex(param1,param2,cr.Dir);
}

void teleportCritter(Critter&player,int id,int x,int y)
{
	Critter@cr=GetCritter(id);
	if((@cr!=null))
	cr.TransitToHex(x,y,0);
}

void getCoords(Critter&player,int id,int x,int y)
{
	Critter@cr=GetCritter(id);
	player.Say((11),"X = "+cr.HexX+" Y = "+cr.HexY);
}

void GM_lock(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Map@map=player.GetMap();
	Item@item=map.GetItem(param0);
	if((@item!=null))
	lock(player,param0,param1,param2);
}

void lock(Critter&player,int itemId,int complexity,int lockId)
{
	Map@map=player.GetMap();
	Item@item=map.GetItem(itemId);
	if((@item!=null))
	{
		item.LockerCondition=(0x02);
		item.LockerComplexity=complexity;
		item.LockerId=lockId;
		item.Update();
		Item@key=player.AddItem((82),1);
		if((@key!=null))
		key.LockerId=lockId;
		key.Update();
	}
}

void unlock(Critter&player,int itemId,int param,int param2)
{
	Map@map=player.GetMap();
	Item@item=map.GetItem(itemId);
	
	if((@item!=null))
	{
		item.LockerCondition=(0x01);
		item.LockerComplexity=0;
		item.LockerId=0;
		item.Update();
	}
}

void cleanEnemyStacks(Critter&player,int,int,int)
{
	Map@map=player.GetMap();
	Critter@[]crits;
	uint crCount=map.GetCritters(0,(0x01),crits);
	for(uint i=0;i<crCount;++i)
	{
		if(crits[i].IsNpc())
		{
			crits[i].ClearEnemyStack();
			crits[i].DropPlanes();
		}
	}
} 

void SetSkin(Critter&player,int param0,int param1,int param2)
{
	Critter@target=GetCritter((param0==0?player.Id:param0));
	if(not(@target!=null))
	return;
	if(target.ChangeCrType(param1))
	target.StatBase[(112)]=param1;
}

void CreateLoc(Critter&player,int param0,int param1,int param2)
{
	CreateLocation(param0,param1,param2,null);
}

void DeleteLoc(Critter&player,int param0,int param1,int param2)
{
	Location@loc=GetLocationByPid(param0,0);
	DeleteLocation(loc.Id);
}

void getMapId(Critter&cr,int param0,int param1,int param2)
{
	Map@map=cr.GetMap();
	if(!(@map!=null))
	return;
	string msg=map.Id;
	
	Location@loc=map.GetLocation();
	if(!(@loc!=null))
	{
		msg+="loc err";
	}
	else
	{
		msg+=" "+loc.Id;
	}
	cr.Say((11),msg);
	
}

void setcoolarmor(Critter&cr,int p0,int p1,int p2)
{
	if(p1==0)
	{
		cr.Say((11),"invalid armor pid (second parameter)");
		return;
	}
	;
	Critter@target=GetCritter((p0==0?cr.Id:p0));
	Item@armor=target.GetItem(p1,(0));
	if(!(@armor!=null))
	{
		cr.Say((11),"armor !valid");
		return;
	}
	armor.Val1=target.Id;
	armor.Val2=target.StatBase[(112)];
	cr.Say((11),"BaseCrTypeTarget "+armor.Val2);
	armor.SetScript("debug@_CoolArmor");
	armor.Update();
} 

void _CoolArmor(Item&armor,bool firstTime)
{
	if(firstTime)
	{
		armor.SetEvent((6),"e_ArmorMove");
	}
}

void e_ArmorMove(Item&item,Critter&cr,uint8 fromSlot)
{
	string msg=fromSlot+" "+item.CritSlot;
	cr.Say((11),msg);
	if(item.Val1!=cr.Id)
	return;
	if((item.CritSlot==(1)||item.CritSlot==(1))&&fromSlot==(0))
	{
		cr.ChangeCrType(3);
		cr.MoveItem(item.Id,item.GetCount(),(3));
		cr.Action((2),(3),item);
		cr.Action((23),0,null);
		item.Update();
	}
}

import uint GetAllPlayers(Critter@[]&crs)from"manager";

void GetAllPl(Critter&cr,int p0,int p1,int p2)
{
	Critter@[]crs;
	string msg;
	GetAllPlayers(crs);
	if(crs.length()>0)
	{
		msg=crs.length();
		cr.Say((11),msg);
	}
}

void delItem(Critter&cr,int p0,int p1,int p2)
{
	if(p0!=1)
	{
		Item@item=cr.GetMap().GetItem(p1);
		if(!(@item!=null))
		return;
		DeleteItem(item);
	}
	else
	{
		Item@[]items;
		cr.GetMap().GetItems(p1,items);
		if(items.length()>0)
		{
			DeleteItems(items);
		}
	}
}

void setblankscript(Critter&cr,int p0,int p1,int p2)
{
	Item@item=GetItem(p0);
	if(!(@item!=null))
	return;
	item.SetScript("");
}

void spawnmob(Critter&cr,int p0,int p1,int p2)
{
	uint16 hexX=0,hexY=0;
	Critter@[]crs;
	Critter@mob;
	Map@map=cr.GetMap();
	map.GetEntireCoords(p2,0,hexX,hexY);
	map.GetCritters(0,(0x01),crs);
	for(uint8 i=0;i<p1;i++)
	{
		@mob=map.AddNpc(p0,hexX+Random(-5,5),hexY+Random(-5,5),Random(0,5),null,null,null);
		mob.AddEnemyInStack(cr.Id);
	}
}

void delmob(Critter&cr,int p0,int p1,int p2)
{
	Critter@[]crs;
	Map@map=cr.GetMap();
	p1=(p1==0?(0x04):(0x0F));
	map.GetCritters(p0,p1,crs);
	for(uint16 i=0;i<crs.length();i++)
	{
		DeleteNpc(crs[i]);
	}
}

void getadmin(Critter&cr,int p0,int p1,int p2)
{
	Critter@[]crs;
	string msg;
	GetAllPlayers(crs);
	for(uint8 i=0;i<crs.length();i++)
	{
		if(crs[i].GetAccess()>=(1))
		{
			msg+="player "+GetPlayerName(crs[i].Id)+" id "+crs[i].Id+" access "+crs[i].GetAccess()+"\n";
		}
	}
	cr.Say((11),msg);
}

void getAllPls(Critter&cr,int p1,int p2,int p3)
{               
	
	Critter@[]crs;
	GetAllPlayers(crs);
	for(uint i=0;i<crs.length();i++)
	{
		if(crs[i]is null)
		continue;
		cr.Say((11)," i "+i+" id= "+crs[i].Id+" access "+crs[i].GetAccess());
	}    
	
} 

void openDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@item=GetItem(uint(p1));
	if(item is null)
	return;
	
	item.LockerOpen();
}

void closeDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@item=GetItem(uint(p1));
	if(item is null)
	return;
	
	item.LockerClose();
}

void BlockHex(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	map.BlockHex(cr.HexX+p1,cr.HexY+p2,p3!=0);
}

void UnblockHex(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	map.UnblockHex(cr.HexX+p1,cr.HexY+p2);
}

void noopenDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@door=GetItem(uint(p1));
	if(door is null)
	return;
	if(p2==0)
	(door.LockerCondition=(door.LockerCondition)|((0x10)));
	else
	(door.LockerCondition=((door.LockerCondition)&(~((0x10)))));
}

void clearDoor(Critter&cr,int p1,int p2,int p3)
{
	Item@door=GetItem(uint(p1));
	if(door is null)
	return;
	
	door.LockerClose();
	
	door.LockerCondition=0;
	door.LockerId=0;
	door.LockerComplexity=0;
	door.Val0=0;
	door.Val1=0;
}

void di(Critter&cr,int p1,int p2,int p3)
{
	Item@item=GetItem(uint(p1));
	if(item is null)
	return;
	
	DeleteItem(item);
}

void setScale(Critter&cr,int p1,int p2,int p3)
{
	cr.ParamBase[(116)]=p1;
}

void knock(Critter&player,int id,int param1,int param2)
{
	Critter@cr=GetCritter(id);
	cr.Say((6),"теряет сознание");
	cr.ToKnockout(((true)?(82):(83)),((true)?(86):(87)),((true)?(88):(89)),100,cr.HexX,cr.HexY);
}

import void ApplyGhoul(Critter&cr)from"morphes";

void makeGhoul(Critter&cr,int p1,int p2,int p3)
{
	Critter@target=GetCritter(p1!=0?p1:cr.Id);
	if(@target==null)
	{
		cr.Say((11),"something wrong");
		return;
	}
	ApplyGhoul(target);
}

void AddMine(Critter&cr,int,int,int)
{
	Item@item=cr.GetMap().AddItem(cr.HexX+1,cr.HexY+1,(545),1);
	item.SetScript("_MineInit");
}

void _MineInit(Item&item,bool firstTime)
{
	item.TrapValue=150;
	(item.Flags=(item.Flags)|((0x00020000)));
	item.SetEvent((7),"explode@_MineWalk");
	item.Update();
}       

void liststats(Critter&cr,int p0,int p1,int)
{
	Critter@target=GetCritter((p0==0?cr.Id:p0));
	for(uint16 i=(0);i<(199);i++)
	{
		cr.Say((11),"id "+target.Id+" stat "+i+" "+target.Stat[i]);
	}
	
	for(uint16 i=(__SkillBegin);i<(__SkillEnd);i++)
	{
		cr.Say((11),"id "+target.Id+" skill "+i+" "+target.Skill[i]);
	}
}

void HideAllMaps(Critter&cr,int,int,int)
{
	Critter@[]crs;
	uint crLen=GetAllPlayers(crs);
	
	Location@[]locations;
	uint len=GetAllLocations(0,locations);
	
	for(uint i=0;i<len;i++)
	{
		Location@loc=locations[i];
		if(loc is null)
		continue;
		
		if(loc.Visible)
		{
			loc.Visible=false;
			Log("Скрыта локация "+loc.Id);
		}
		
		loc.GeckVisible=false;
		
		for(uint k=0;k<crLen;k++)
		{
			if(crs[k].UnsetKnownLoc(true,loc.Id))
			Log("Стерта для "+crs[k].Id);
		}
	}
}

void GM_setcodedoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	setcodedoor(player,param0,param1,param2);
}

void setcodedoor(Critter&cr,int p0,int p1,int p3)
{
	Item@item=GetItem(p0);
	if(@item==null)
	return;
	
	item.Val0=4;
	item.Val1=p1+1;
	item.Val4=p3!=0?p3:Random(pow(10,item.Val1),pow(10,(item.Val1+1))-1);
	cr.Say((11),"code "+item.Val4);
	item.LockerComplexity=Random(50,200);
	(item.LockerCondition=(item.LockerCondition)|((0x20)));
	item.Update();
}

void Flushblack(Critter&player,int p0,int p1,int p3,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(p0);
	FlushScreen(cr,((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),((uint((0xFF<<24)|(((0)&0xFF)<<16)|(((0)&0xFF)<<8)|((0)&0xFF)))),p1);
}

void GiveItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	cr.AddItem(param1,1);
}

void GM_mobinit(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	cr.StatBase[(106)]=33;
	GM_MobInit(cr);
}

void GM_GetParam(Critter&player,int crId,int param1,int param2,string@param3,int[]@param4)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	player.Say((11)," "+toCr.Param[param1]);
}

void GM_SetParam(Critter&player,int crId,int param1,int param2,string@param3,int[]@param4)
{
	if(crId==0)
	crId=player.Id;
	Critter@toCr=GetCritter(crId);
	if((@toCr!=null))
	{
		toCr.ParamBase[param1]=param2;
		player.Say((11),"Done.");
	}
}

void GM_liststats(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@target=GetCritter(param0);
	for(uint16 i=(0);i<(199);i++)
	{
		player.Say((11),"id "+target.Id+" stat "+i+" "+target.Stat[i]);
	}
	
	for(uint16 i=(__SkillBegin);i<(__SkillEnd);i++)
	{
		player.Say((11),"id "+target.Id+" skill "+i+" "+target.Skill[i]);
	}
}

void GM_openDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(uint(param0));
	if(item is null)
	return;
	
	item.LockerOpen();
}

void GM_closeDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(uint(param0));
	if(item is null)
	return;
	
	item.LockerClose();
}

void GM_noopenDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@door=GetItem(uint(param0));
	if(door is null)
	return;
	if(param1==0)
	(door.LockerCondition=(door.LockerCondition)|((0x10)));
	else
	(door.LockerCondition=((door.LockerCondition)&(~((0x10)))));
}

void GM_clearDoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@door=GetItem(uint(param0));
	if(door is null)
	return;
	
	door.LockerClose();
	
	door.LockerCondition=0;
	door.LockerId=0;
	door.LockerComplexity=0;
	door.Val0=0;
	door.Val1=0;
}

void GM_deleteCritter(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if((@cr!=null))
	DeleteNpc(cr);
}

void GM_delItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=player.GetMap().GetItem(param0);
	if(!(@item!=null))
	return;
	DeleteItem(item);
}

void GM_brokeItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(param0);
	if(!(@item!=null))
	return;
	item.Deterioration=param1;
	player.Say((11),"предмет "+item.Id+" сломан на "+param1);
	item.Update();
}

void viewarcadepop(Critter&cr,int clear,int,int)
{
	GameVar@firegeckoNow=GetGlobalVar((9952));
	GameVar@alienNow=GetGlobalVar((9951));
	GameVar@deathclawNow=GetGlobalVar((9950));
	GameVar@flocentNow=GetGlobalVar((9953));
	GameVar@clawNow=GetGlobalVar((9955));
	GameVar@clawKidNow=GetGlobalVar((9954));
	
	GameVar@firegecko=GetGlobalVar((9941));
	GameVar@alien=GetGlobalVar((9940));
	GameVar@deathclaw=GetGlobalVar((9939));
	GameVar@flocent=GetGlobalVar((9942));
	
	if(clear>0)
	{
		firegeckoNow.opAssign(0);
		alienNow.opAssign(0);
		deathclawNow.opAssign(0);
		clawNow.opAssign(0);
		clawKidNow.opAssign(0);
		flocentNow.opAssign(0);
	}
	
	cr.Say((11),"firegecko : "+firegeckoNow.GetValue()+"\nalien : "+alienNow.GetValue()+"\ndeathclaw : "+deathclawNow.GetValue()+"\nclaw : "+clawNow.GetValue()+"\nclawkid :"+clawKidNow.GetValue()+"\nflocent : "+flocentNow.GetValue());
	cr.Say((11),"\neggs\nfiregecko : "+firegecko.GetValue()+"\nalien : "+alien.GetValue()+"\ndeathclaw : "+deathclaw.GetValue()+"\nflocent : "+flocent.GetValue());
}

void testcte(Critter&cr,int p0,int p1,int)
{
	for(uint8 i=0;i<=p1;i++)
	{
		cr.AddTimeEvent("cte_test",p0+Random(p0,p0*3),(39),i);
	}
}

uint cte_test(Critter&cr,int identifier,uint&rate)
{
	cr.Say((11),"test cte "+rate);
	return 0;
}

void itemsetval(Critter&cr,int p0,int p1,int p3)
{
	Item@item=GetItem(p0);
	if(@item==null)
	return;
	switch(p1)
	{
		case 0:
		item.Val0=p3;
		break;
		case 1:
		item.Val1=p3;
		break;
		case 3:
		item.Val2=p3;
		break;
		case 4:
		item.Val4=p3;
		break;
		case 5:
		item.Val5=p3;
		break;
		case 6:
		item.Val6=p3;
		break;
		case 7:
		item.Val7=p3;
		break;
		
		default:
		break;
	}
	
}

void itemgetval(Critter&cr,int p0,int p1,int p3)
{
	Item@item=GetItem(p0);
	if(@item==null)
	return;
	string msg=""+item.Val0+"\n"+
	item.Val1+"\n"+
	item.Val2+"\n"+
	item.Val3+"\n"+
	item.Val4+"\n"+
	item.Val5+"\n"+
	item.Val6+"\n"+
	item.Val7+"\n"+
	item.Val8+"\n"+
	item.Val9;
	
	cr.Say((11),msg);
	
}             

void GM_GiveAll(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	Item@[]items;
	if(param1==0)
	{
		cr.GetItems((0),items);
		cr.GetItems((1),items);
		cr.GetItems((2),items);
		MoveItems(items,player);
		cr.Say((11),"Вещи переданы вам от криттера "+cr.Id);
	}
	else if(param1==1)
	{
		player.GetItems((0),items);
		player.GetItems((1),items);
		player.GetItems((2),items);
		MoveItems(items,cr);
		cr.Say((11),"Вещи переданы криттеру "+player.Id);
	}
	else if(param1==2)
	{
		cr.GetItems((0),items);
		cr.GetItems((1),items);
		cr.GetItems((2),items);
		DeleteItems(items);
		cr.Say((11),"Удалены вещи у криттера "+player.Id);
	}
}

void Clone(Critter&player,int param0,int param1,int param2)
{
	Critter@cr=GetCritter(param0);
	if(!(@cr!=null))
	return;
	if(param1==1)
	{
		for(uint i=0;i<=565;i++)
		{
			cr.ParamBase[i]=player.Param[i];
		}
		player.Say((11),"Вы присвоили свои параметры персонажу "+cr.Id);
	}
	else if(param1==0)
	{
		for(uint i=0;i<=565;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		player.Say((11),"Вам присвоенны параметры персонажа "+cr.Id);
	}
}

void GM_Clone(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if((@cr!=null))
	{
		for(uint i=0;i<=80;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		for(uint i=200;i<=207;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		for(uint i=209;i<=217;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		
		for(uint i=260;i<=278;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		for(uint i=300;i<=439;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		for(uint i=470;i<=476;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		for(uint i=480;i<=498;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		for(uint i=550;i<=565;i++)
		{
			player.ParamBase[i]=cr.Param[i];
		}
		player.Say((11),"Вам присвоенны параметры персонажа "+cr.Id);
		player.Say((11),"Сник цели равен "+cr.Param[208]);
	}
}

import void _TraderInit(Critter&trader,bool firstTime)from"trader";

void GM_TraderInit(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@cr=GetCritter(param0);
	if(!(@cr!=null))
	return;
	_TraderInit(cr,true);
}

void setautodoor(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@door=GetItem(param0);
	if(door is null)
	return;
	uint16 x=0;
	uint16 y=0;
	Map@map=door.GetMapPosition(x,y);
	uint16 x0=x;
	uint16 y0=y;
	for(uint8 i=0;i<6;i++)
	{
		map.MoveHexByDir(x,y,i,1);
		if(param1!=2)
		{
			Item@pedal=map.AddItem(x,y,(1544),1);
			pedal.Val1=door.Id;
			pedal.Val2=param1;
		}
		else
		{
			Item@pedal=map.GetItem(x,y,(1544));
			if((@pedal!=null))
			DeleteItem(pedal);
		}
		x=x0;
		y=y0;
	}
}

void setjukebox(Critter&cr,int id,int,int)
{
	Item@item=GetItem(id);
	if(@item==null||item.GetType()!=(8))
	return;
	item.SetScript("jukebox@_JukeboxInit");
}

void GM_GetItem(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(param0);
	if(!(@item!=null))
	return;
	MoveItem(item,0,player);
}       

void chagecell(Critter&cr,int x,int y,int)
{
	cr.StatBase[(720)]=x;
	cr.StatBase[(721)]=y;
}

import void arcadehiveinsert(Critter&cr,uint16 x,uint16 y,uint8 type)from"arcade_menu";
import void arcadehivelist(Critter&cr)from"arcade_menu";
import void arcadehiveclear(Critter&cr)from"arcade_menu";
import void arcadehivedelone(Critter&cr,uint8 index)from"arcade_menu";

void arcadehiveadd(Critter&cr,int x,int y,int type)
{
	arcadehiveinsert(cr,x,y,type);
}

void arcadehivelist(Critter&cr,int,int,int)
{
	arcadehivelist(cr);
}

void arcadehiveclear(Critter&cr,int,int,int)
{
	arcadehiveclear(cr);
}

void arcadehivedel(Critter&cr,int index,int,int)
{
	arcadehivedelone(cr,index);
}

import void ShowInputBoxScreen(Critter&cr,string funcName,uint16 textLength,uint8 flags)from"main";

void testbox(Critter&cr,int p0,int,int)
{
	uint8 flags=0;
	(flags=(flags)|((0x00000001)));
	ShowInputBoxScreen(cr,"debug@unsafe_test_inputbox#mywindow",p0,flags);
}

void unsafe_test_inputbox(Critter&cr,int skill,int p1,int p2,string@message,int[]@p4)
{
	cr.Say((1),"message "+message);
}

import void DropWild()from"globalmap_group";

void dropwild(Critter&cr,int,int,int)
{
	DropWild();
}

void setworld(Critter&cr,int id,int x,int y)
{
	Critter@target=GetCritter(id>0?id:cr.Id);
	if(target is null)
	return;
	
	target.SetWorldPos(x,y);
}

void additemsrndpic(Critter&cr,int id,int x,int y)
{
	Map@map=cr.GetMap();
	if(map is null)
	{
		cr.Say((11),"map");
		return;
	}
	
	for(uint8 i=0;i<x;++i)
	{
		Item@item=map.AddItem(cr.HexX+(Random(-10,10)),cr.HexY+(Random(-10,10)),2004,1);
		if(item is null)
		continue;                    
		
		uint hash=GetStrHash("art\\scenery\\corpse1.png"); 
		
		item.SetMapPic(hash);
		
		cr.Say((11),"add "+hash);
	}
	
}

void delsatmobs(Critter&cr,int id,int x,int y)
{
	for(uint8 i=id;i<x;++i)
	{
		Location@loc=GetLocationByPid(i,0);
		if(loc is null)
		continue;
		
		Map@map=loc.GetMapByIndex(0);
		if(map is null)
		continue;
		
		Critter@[]crs;
		map.GetCritters(0,(0x0F)|(0x20),crs);
		Log("delete len "+crs.length());
		for(uint16 ii=0,jj=crs.length();ii<jj;++ii)
		{
			if(crs[ii]is null)
			continue;
			
			Log("delete "+ii);
			DeleteNpc(crs[ii]);
		}
	}
}

void itemrndpic(Critter&cr,int id,int x,int y)
{
	Item@item=GetItem(id);
	if(item is null)
	return;
	
	uint hash=GetStrHash("art\\scenery\\corpse1.png");
	item.SetMapPic(hash);
}

void addplant(Critter&cr,int id,int x,int y)
{
	Item@item=cr.AddItem(id,1);
	if(item is null)
	return;
	
	item.Val3=x;
	item.SetScript("plant@_InitPlant");
	
}

void evilplant(Critter&cr,int id,int,int)
{
	cr.GetMap().AddNpc(id,cr.HexX-3,cr.HexY-3,0,null,null,"mob@_MobInit");
	
}

void droptime(Critter&cr,int id,int,int)
{
	for(uint i=(__TimeoutBegin);i<(__TimeoutEnd);i++)
	{
		cr.TimeoutBase[i]=0;
	}
}

void addtime(Critter&cr,int id,int,int)
{
	uint time=cr.TimeoutBase[(241)];
	if(time>__FullSecond)
	{
		time+=((10)*__TimeMultiplier);
	}
	else
	{
		time=__FullSecond+((1)*__TimeMultiplier*60);
	}
	
	cr.TimeoutBase[(241)]=time;
}
import uint GetTile(Map&map,uint16 hexX,uint16 hexY,uint8 layer)from"qmap";
void gettile(Critter&cr,int id,int,int)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	uint hash=map.GetTile(((cr.HexX)>>1),((cr.HexY)>>1));
	cr.Say((11),"tile hash\n* "+hash);
	
}

void gettiles(Critter&cr,int id,int,int)
{
	uint hash0=GetStrHash("art/tiles/road02.frm"),
	hash1=GetStrHash("road02.frm");
	cr.Say((11),"tile hash\n* "+hash0+"\ntile hash\n* "+hash1);
}

void varset(Critter&cr,int id,int x,int)
{
	GameVar@isStored=GetLocalVar((10000),id);
	
	int val=isStored.GetValue();
	
	cr.Say((11),""+val);
	
	if(x>0)
	{
		uint8 temp=Random(1,100);
		
		isStored.opAssign(temp);
	}
}               

import void ActivateMobScript(Map&map)from"mob";

void testmob(Critter&cr,int id,int val,int)
{
	ActivateMobScript(cr.GetMap());
}  

void spawnsateng(Critter&cr,int id,int val,int)
{
	Location@loc;
	Item@item;
	for(uint8 i=13;i<25;++i)
	{
		@loc=GetLocation(i);
		if(loc is null)
		continue;
		
		Map@map=loc.GetMapByIndex(0);
		if(map is null)
		continue;
		
		Item@[]conts;
		map.GetItemsByType((8),conts);
		
		uint16 len=conts.length(); 
		
		for(uint16 ii=0;ii<2;++ii)
		{
			
			@item=conts[Random(0,len-1)];
			
			if(!(item is null))
			{
				item.AddItem((39),Random(1,3),0);
				Log("SPAWN "+item.HexX+":"+item.HexY);
			}
		}
	}
}

void testscreen(Critter&cr,int,int,int){
	cr.ShowScreen((2),2,"answer_test");
	cr.Say((18),"Вас устраивает ваша зарплата?");
	cr.Say((19+(0)),"Да");
	cr.Say((19+(1)),"Нет");
}

void answer_test(Critter&cr,uint answerI,string&answerS)
{
	string msg="";
	if(answerI>0){
		msg="Правда чтоли?";
	}else{
		msg="ВРешь!";
	}
	
	cr.Say((11),msg);
}