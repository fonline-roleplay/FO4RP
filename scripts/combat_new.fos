//Это старая версия, просто нужно было залить рабочий код, поэтому просто взял её из последних "рабочих" бэкапов.

class newCombat
{
	int point;
	uint yyy;
	uint8 use;
	uint8 aim;
	Item@ realWeapon;
	Map@ map;
	int wpnMaxDist;
	int skillNum;
	uint8 weaponSubtype;
	bool isRanged;
	bool isUnarmed;
	bool isHthAttack;
	uint16 ammoRound;
	bool wpnIsRemoved;
	uint16 hx;
	uint16 hy;
	uint16 tx;
	uint16 ty;
	uint16 weapPid;
	uint16 ammoPid;
	bool isBurst;
	int dmgType;
	bool isGrenade;
	bool isFlamethrower;
	bool isShotgun;
	bool isRocket;
	bool eyeDamage;
	bool crIsPlayer;
	bool isHit;
	bool isCritical;
	bool fullParry;
	bool hitRandomly;
	bool isSneak;
	bool useNormal;
	bool useHex;
	uint critfailFlags;
	int weaponPerk;
	Critter@ normalTarget;
	Critter@ realTarget;
	CombatRes[] results;
	int acmod;
	int skillVal;

	
	Critter@ cr;
	Critter@ target;
	ProtoItem@ weapon;
	uint8 weaponMode;
	ProtoItem@ ammo;
	uint16 hexX;
	uint16 hexY;
	
	newCombat( Critter& cr, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY )
	{

		@this.cr = @cr;
		@this.target = @target;
		@this.weapon = @weapon;
		@this.ammo = @ammo;
		
		this.weaponMode = weaponMode;
		this.hexX = hexX;
		this.hexY = hexY;
		
		//Old combat logic:
		init( cr, target, weapon, weaponMode, ammo, hexX, hexY );

		prepare();
		getBaseToHit();
		getRealTohit();
		Evasion();
		marginRoll();
		commenceAttack();
		effects();
	}
	
	void init( Critter& cr, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY )
	{
		int point = 0;
		
		if( !valid( target ) && hexX == 0 && hexY == 0 )
			return;

		uint yyy = 0;

		use = _WeaponModeUse( weaponMode );
		aim = _WeaponModeAim( weaponMode );
		@realWeapon = _CritGetItemHand( cr );
		@map = cr.GetMap();
		wpnMaxDist = _WeaponMaxDist( weapon, use );
		skillNum = _WeaponSkill( weapon, use );

		if( weapon.ProtoId == PID_FLARE_GUN && weaponMode == 1 )
		{
			FlareGunUse( cr, realWeapon );
			return;
		}

		if( skillNum == SK_THROWING )
			wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), cr.Stat[ ST_STRENGTH ] ) );

		weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );

		isRanged = ( weaponSubtype == WS_THROWING || weaponSubtype == WS_GUN );
		isUnarmed = weapon.Weapon_IsUnarmed;
		isHthAttack = ( weaponSubtype == WS_MELEE || weaponSubtype == WS_UNARMED );
		ammoRound = _WeaponRound( weapon, use );
		wpnIsRemoved = _WeaponRemove( weapon, use );
		hx = cr.HexX;
		hy = cr.HexY;
		tx = ( valid( target ) ) ? target.HexX : hexX;
		ty = ( valid( target ) ) ? target.HexY : hexY;
		weapPid = weapon.ProtoId;
		ammoPid = 0;
		if( valid( ammo ) )
			ammoPid = ammo.ProtoId;
		isBurst = ( ammoRound > 1 );
		if( isBurst )
			aim = HIT_LOCATION_UNCALLED;
		dmgType = _WeaponDmgType( weapon, use );

		isGrenade = weaponSubtype == WS_THROWING && ( dmgType == DAMAGE_PLASMA || dmgType == DAMAGE_EMP || dmgType == DAMAGE_EXPLODE || dmgType == DAMAGE_FIRE ); 

		isFlamethrower = ( ( aim == HIT_LOCATION_NONE || aim == HIT_LOCATION_TORSO || aim == HIT_LOCATION_UNCALLED ) &&
			( ammoPid == PID_FLAMETHROWER_FUEL || ammoPid == PID_FLAMETHROWER_FUEL_MK_II || weapPid == PID_FIRE_GECKO_FLAME_WEAPON ) );

		isShotgun = false;
		if( ammoPid == PID_SHOTGUN_SHELLS || ammoPid == PID_12g_LOW )
			isShotgun = true;
			
		isRocket = ( ammoPid == PID_EXPLOSIVE_ROCKET ) || ( ammoPid == PID_ROCKET_AP ) || ( ammoPid == PID_ROBO_ROCKET_AMMO ) || ( ammoPid == PID_GRENADELAUNCHER_AMMO );

		eyeDamage = cr.Damage[ DAMAGE_EYE ] != 0;

		crIsPlayer = cr.IsPlayer();
		isHit = false;
		isCritical = false;
		fullParry = false; 
		hitRandomly = false;

		isSneak = false;
		useNormal = false; 
		useHex = false;  

		critfailFlags = 0;
		weaponPerk = weapon.Weapon_Perk;

		acmod = 0; 
		skillVal = getFullSkill( cr, target, skillNum, weaponSubtype );
	}
	
	void prepare()
	{
		if( !map.IsTurnBased() && map.IsTurnBasedAvailability() )
			map.BeginTurnBased( cr );

		if( cr.Mode[ MODE_HIDE ] != 0 && !( weaponSubtype == WS_THROWING && dmgType == DAMAGE_NORMAL && valid( target ) && !cr.IsSeenBy( target ) ) )
		{
			if( !cr.IsPlayer() || cr.GetAccess() == ACCESS_CLIENT )
				cr.ModeBase[ MODE_HIDE ] = 0;
			isSneak = true;
		}

		cr.SetDir( GetDirection( hx, hy, tx, ty ) );

		if( aim == HIT_LOCATION_EYES && valid( cr ) && valid( target ) && (( cr.Dir + 3 ) % 6 != target.Dir ) )	
			aim = HIT_LOCATION_HEAD;

		if(  ( dmgType != DAMAGE_FIRE && dmgType != DAMAGE_EXPLODE ) && //..не €вл€ющихс€ атаками взрывом и огнЄм..
			( aim == HIT_LOCATION_NONE || cr.Param[ QST_GAMEMODE ] == GAME_ARCADE ) //..неприцельные или атаки аркад
			|| ( cr.Trait[ TRAIT_FAST_SHOT ] != 0 && Random( 0, 2 ) != 0 ) //ј так же 66% атак "фастшотеров"
			&& valid( cr ) && valid( target ) )
		{
			aim = RandomAim();
		}

		if( valid( target ) )
		{
			if( cr.Timeout[ TO_BATTLE ] == 0 )
				cr.StatBase[ ST_BLOCK ] = 0;

			if( target.Timeout[ TO_BATTLE ] == 0 )
			{
				if( target.StatBase[ ST_SEQUENCE ] < ( cr.StatBase[ ST_SEQUENCE ] + Random( -15, 15 ) ) )
					target.StatBase[ ST_BLOCK ] = 0;
				else //TODO: ќтображение перехода в состо€ни€ блока через parameters change -> Stat[ST_BLOCK]
					target.StatBase[ ST_BLOCK ] = 1;
			}

			if( target.GetProtoId() != NPC_PID_Ball && weapPid != PID_BALL )
			{
				setTimeout( cr, TO_BATTLE, ( cr.IsPlayer() ? __TimeoutBattle : __TimeoutBattle / 2 ) );
				setTimeout( target, TO_BATTLE, ( cr.IsPlayer() ? __TimeoutBattle : __TimeoutBattle / 10 ) );
			}
		}
		else setTimeout( cr, TO_BATTLE, __TimeoutBattle / 2 );

		setTimeout( cr, TO_SNEAK, SNEAK_TIMEOUT( cr ) );
		setTimeout( target, TO_SNEAK, SNEAK_TIMEOUT( target ) );

		if( !crIsPlayer )
			AI_TrySayCombatText( cr, COMBAT_TEXT_ATTACK );

		if( valid( target ) && ( ( target.GetProtoId() != NPC_PID_Ball ) && ( weapPid != PID_BALL ) && weapPid != PID_GM_PISTOL ) )
				target.EventAttacked( cr );
	}

	int baseToHit;
	int dist;
	AttackStruct attack;
	
	void getBaseToHit()
	{
		baseToHit = skillVal - cr.ParamBase[ ST_PARALYSIS_LEVEL ] * 3;
		
		inform( cr, target, "baseToHit= "+ baseToHit );//TODO: —делать информативней, и включаемым-выключаемым.
		
		if( eyeDamage )
			baseToHit -= 25;
		
		if( !isUnarmed )
		{
			if( cr.Trait[ TRAIT_ONE_HANDER ] != 0 )
				baseToHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

			int handlingStrength = cr.Stat[ ST_STRENGTH ];
			int reqStrength = weapon.Weapon_MinStrength;
			
			if( handlingStrength < reqStrength )
				baseToHit -= ( reqStrength - handlingStrength ) * 20;

			if( weaponPerk == WEAPON_PERK_ACCURATE )
				baseToHit += 20;
		}

		dist = GetDistantion( hx, hy, valid( target ) ? target.HexX : hexX, valid( target ) ? target.HexY : hexY );

		// main attack structure
		@attack.Attacker = cr;
		@attack.RealWeapon = realWeapon;
		attack.WeaponPid = weapon.ProtoId;
		attack.Hx = hx;
		attack.Hy = hy;
		attack.Aim = aim;
		attack.IsBurst = isBurst;
		attack.BloodyMess = cr.Trait[ TRAIT_BLOODY_MESS ] != 0;
		attack.CombatMessage = true;
		attack.scoreUnarmed = ( weaponSubtype == WS_UNARMED );
		attack.WeaponPerk = ( isUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weaponPerk;
		attack.WeaponSubtype = weaponSubtype;
		attack.DmgMin = _WeaponDmgMin( weapon, use );
		attack.DmgMax = _WeaponDmgMax( weapon, use );
		attack.DmgType = dmgType;
		attack.BonusDmg = 0;
		attack.DmgMul = 2;
		@attack.Ammo = ammo;

		if( isHthAttack )
		{
			attack.DmgMax += cr.Stat[ ST_MELEE_DAMAGE ];
			attack.DmgMin += cr.Stat[ ST_MELEE_DAMAGE ];
		}
		if( weaponSubtype == WS_THROWING )
		{
			attack.DmgMax += cr.Stat[ ST_MELEE_DAMAGE ] / 2;
			attack.DmgMin += cr.Stat[ ST_MELEE_DAMAGE ] / 2;
		}
		// if( weaponSubtype == WS_GUN )
			// attack.BonusDmg += cr.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;
			
		// Ammo
		if( valid( ammo ) )
		{
			attack.DRMod = ammo.Ammo_DrMod;
			attack.DMMod = ammo.Ammo_DmgMult;
			attack.DDMod = ammo.Ammo_DmgDiv;
			if( attack.DMMod == 0 )
				attack.DMMod = 1;
			if( attack.DDMod == 0 )
				attack.DDMod = 1;
		}

		if( valid( target ) )
			attack.TargetId = target.Id;
	}
	
	int toHit;
	int acc;
	int accloss;
	int perception;
	int sharpshooter;
	int distmod2;
	
	void getRealTohit()
	{
		// here we're deciding the real toHit;
		toHit = baseToHit;
		toHit -= isHthAttack ? ( GetHitAim( aim ) / 2 ) : GetHitAim( aim );

		// range considerations, we're storing everything for a later use
		int distmod1 = 2;   // used for initial weapon bonus
		distmod2 = 0;   // minimal distance

		if( weaponPerk == WEAPON_PERK_LONG_RANGE ) //перки
			distmod1 = 4;
		else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
		{
			distmod1 = 5;
			distmod2 = 8;
		}

		perception = cr.Stat[ ST_PERCEPTION ];
		acc = dist;
		accloss = ( crIsPlayer ? ( perception - 2 ) * distmod1 : ( perception * distmod1 ) );
		sharpshooter = 0;
		//int sharpshooter = 2 * cr.Perk[ PE_SHARPSHOOTER ];

		if( !isHthAttack )
		{
			if( dist < distmod2 )
				acc += distmod2;
			else
				acc -= accloss;
			if( -2 * perception > acc )
				acc = -2 * perception;
			acc -= sharpshooter;
			if( acc > 0 && eyeDamage )
				acc *= 3;
			acc *= -4;
			toHit += acc;
			int blockers = map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null );
			if( valid( target ) && !target.IsKnockout() )
				blockers--;                                                // binyan - Hex attack - added
			toHit -= 10 * blockers;
		}

		inform( cr, target, "ToHitAfterMods= "+ toHit );//TODO: —делать информативней, и включаемым-выключаемым.
	}
	
	void Evasion()
	{
		if( valid( target ) ) // binyan - Hex attack - added
		{
			acmod = target.Stat[ ST_ARMOR_CLASS ];
			if( valid( ammo ) )
				acmod += ammo.Ammo_AcMod;
			if( acmod > 0 )
				toHit -= acmod;
			
			inform( cr, target, "ToHitAfterAC= "+ toHit );//TODO: —делать информативней, и включаемым-выключаемым.
			// //////////////////begin  ErlKing  Aiming ////////////////////
			// now we block attacks with arms:
			if( valid( cr ) && valid( target ) && ( ( cr.Dir + 3 ) % 6 == target.Dir || ( cr.Dir + 4 ) % 6 == target.Dir || ( cr.Dir + 2 ) % 6 == target.Dir ) &&
				( target.StatBase[ ST_BLOCK ] >= 1 ) && ( target.DamageBase[ DAMAGE_RIGHT_ARM ] != 1 ) && ( target.DamageBase[ DAMAGE_LEFT_ARM ] != 1 ) &&
				( target.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( cr.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) &&
				attack.DmgType != DAMAGE_FIRE && attack.DmgType != DAMAGE_EXPLODE )                                                                 // WTF?!
			{
				if( !target.IsDead() || !target.IsKnockout() )
				{
					uint8 dist = GetDistantion( cr.HexX, cr.HexY, target.HexX, target.HexY );
					Item@ hand1 = target.GetItem( 0, SLOT_HAND1 );
					Item@ hand2 = target.GetItem( 0, SLOT_HAND2 );
					Item@ hand3 = target.GetItem( 0, SLOT_ARMOR );

					int   itemweigh1 = 0;
					int   itemweigh2 = 0;
					int   itemweigh3 = 0;
					int   aimpenalty = 0;

					if( valid( hand1 ) )
						itemweigh1 = hand1.Proto.Weight;
					if( valid( hand2 ) )
						itemweigh2 = hand2.Proto.Weight;
					if( valid( hand3 ) )
						itemweigh3 = hand3.Proto.Weight;


					if( dist > 4 && cr.Stat[ ST_BLOCK ] == 2 )
						cr.StatBase[ ST_BLOCK ] = 0;
					if( aim == HIT_LOCATION_HEAD && cr.Stat[ ST_BLOCK ] != 2 )
						aimpenalty = 50;

					uint16   h_x = target.HexX, h_y = target.HexY;
					map.MoveHexByDir( h_x, h_y, ( cr.Dir + 3 ) % 6, 1 );
					Critter@ poor_guy = map.GetCritter( h_x, h_y );

					if( !( map.IsHexPassed( h_x, h_y ) ) && dist >= 2 && ( Random( 0, 80 ) + aimpenalty - skillVal - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 >= 0 ) )  //”крытие
					{
						target.Say( SAY_EMOTE_ON_HEAD, "укрылс€" );
						skillVal = skillVal - Random( 100, 200 + aimpenalty - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 );
					}

					if( valid( poor_guy ) && ( !poor_guy.IsDead() || !poor_guy.IsKnockout() ) && dist >= 2 && ( Random( 0, 80 ) + aimpenalty - skillVal - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 >= 0 ) )
					{
						target.Say( SAY_EMOTE_ON_HEAD, "укрылс€ за" );
						skillVal = skillVal - Random( 100, 200 + aimpenalty - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001  );
					}
					
					if( ( dist <= 1 || isHthAttack ) && ( Random( 1, 200 ) - (cr.Stat[ST_LUCK]-5)*5 + aimpenalty * 2 - skillVal + target.Skill[ SK_MELEE_WEAPONS ] + target.Skill[ SK_UNARMED ] - ( itemweigh1 + itemweigh2 ) * 0.01 >= 100 ) )
					{
						target.Say( SAY_EMOTE_ON_HEAD, "блок" );
						skillVal = skillVal - Random( 30, 50 + aimpenalty + target.Skill[ SK_UNARMED ] * 0.2 - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 );

						if( isHthAttack )
							attack.DmgMul -= 0.5;
						if( Random( 0, 2 ) == 0 || ( ( aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES ) && Random( 0, 1 ) == 0 ) )
						{
							target.StatBase[ ST_BLOCK ] = 2;
							target.Say( SAY_EMOTE_ON_HEAD, "жесткий блок" );
						}

						if( Random( 0, 1 ) == 0 )
						{
							aim = HIT_LOCATION_LEFT_ARM;
						}
						else
						{
							aim = HIT_LOCATION_RIGHT_ARM;
						}
					}
				}
			}

			if( valid(target) && target.IsBusy() )
			{
				if( ( cr.Dir + 3 ) % 6 == target.Dir )
					toHit += 20;
				else if( ( cr.Dir ) % 6 != target.Dir )
				{
					toHit -= acmod / 2;
					if( aim == HIT_LOCATION_HEAD )
						toHit -= acmod / 2;
				}
			}

			if( aim == HIT_LOCATION_HEAD )
				toHit *= 0.5;
			else if( aim == HIT_LOCATION_LEFT_ARM || aim == HIT_LOCATION_RIGHT_ARM || aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG )
				toHit *= 0.7;

			if( cr.Stat[ ST_BLOCK ] == 2 )
			{
				cr.StatBase[ ST_BLOCK ] = 0;
				toHit += 30;
			}

			if( Random( 0, 2 ) < 1 && cr.Stat[ ST_BLOCK ] == 1 )
				cr.StatBase[ ST_BLOCK ] = 0;

			if (cr.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0) cr.EraseTimeEvents( CTE_SLOWRELOAD );
			
			if(valid(target))
			{
				if( target.IsKnockout() )
					toHit += 40;
				if( target.GetMultihex() > 0 )
					toHit += 15;
			}
		}
		
		inform( cr, target, "ToHitAfterErlTweaks= "+ toHit );//TODO: —делать информативней, и включаемым-выключаемым.

		toHit += (cr.Stat [ST_LUCK]-5)*3;
		toHit = CLAMP( toHit, 0, 95 );
		
		bool psiShield = false;
		if (valid (target)) {
			psiShield = (target.GetTimeEvents (CTE_PSI_SHIELD, null, null, null) > 0);
			if (dmgType == DAMAGE_NORMAL && psiShield) {
				int psiRoll = Random (0, 99);
				int psiShieldChance = (target.Skill [SK_SPEECH] / 4) + target.Stat [ST_LUCK] + target.Stat [ST_INTELLECT];
				psiShieldChance = CLAMP (psiShieldChance, 5, 95);
				if (psiRoll < psiShieldChance) {
					target.Say (SAY_EMOTE, "јтака отражаетс€");
					toHit = 0;
				}
			}
		}
		
		if ( valid( target) && target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) //
		{
			toHit = 0;
			target.TimeoutBase[TO_BATTLE] = __FullSecond + REAL_SECOND( 10 );
			fullParry = true;
		}		
	}

	int margin;
	
	void marginRoll()
	{
		margin = toHit - Random( 1, 100 );

		inform( cr, target, "ToHitRoll= "+ margin );//TODO: —делать информативней, и включаемым-выключаемым.
		
		if( margin < 0 )
		{
			if( cr.Mode[ MODE_INVULNERABLE ] == 0 )
			{
				isCritical = ( (( -margin ) / 10) >= Random( 1, 100 ) );

				if( !isCritical )
					isCritical = Random( 1, 10 ) == 1 //10%
						&& ( cr.Trait[ TRAIT_JINXED ] != 0 || ( valid( target ) && target.Trait[ TRAIT_JINXED ] != 0 ) ); //someone is jinxed
							// ( cr.Trait[ TRAIT_JINXED ] != 0 || cr.Perk[ PE_JINXED_II ] != 0 ) || 
							// ( valid( target ) && ( target.Trait[ TRAIT_JINXED ] != 0 || target.Perk[ PE_JINXED_II ] != 0 ) ) 
				
				if( isCritical )
				{
					int roll = Random( 1, 100 ) - 5 * ( cr.Stat[ ST_LUCK ] - 5 );
					if( roll <= 20 )
						roll = 0;
					else if( roll <= 50 )
						roll = 1;
					else if( roll <= 75 )
						roll = 2;
					else if( roll <= 95 )
						roll = 3;
					else
						roll = 4;

					critfailFlags = CriticalFailureTable[ 5 * weapon.Weapon_CriticalFailture + roll ];
					if( critfailFlags == 0 )
						isCritical = false;
					hitRandomly = FLAG( critfailFlags, MF_HIT_RANDOMLY );
				}
			}
		}
		else     // if hit
		{
			isHit = true;
			
			isCritical = ( cr.Stat[ ST_CRITICAL_CHANCE ] + margin*0.1 ) * ( valid( target ) ? ( ( 100 - ( target.Stat[ ST_LUCK ] + target.Stat[ ST_ARMOR_CLASS ] ) ) * 0.01 ) : 0 ) >= Random( 1, 100 );
		}

		if( hitRandomly && valid( target ) )
		{
			Critter@ randomTarget = ChooseRandomTarget( map, cr, target, wpnMaxDist );
			if( @randomTarget != null )
			{
				@realTarget = randomTarget;
				tx = realTarget.HexX;
				ty = realTarget.HexY;
				attack.Aim = HIT_LOCATION_UNCALLED;
				realTarget.ModeBase[ MODE_HIDE ] = 0;         // done here to allow combat notifications later
				NotifyOops( cr, target, realTarget, results );
			}
		}
		else
			@realTarget = target;
	}
	
	void commenceAttack()
	{ //Код дорабатывается в "local branch" на рабочем столе.
		bool isArm = ( attack.WeaponPid == 1000 ) || ( attack.WeaponPid == 1001 ) || ( attack.WeaponPid == 1002 ) || ( attack.WeaponPid == 1003 ) || ( attack.WeaponPid == 1010 ) || ( attack.WeaponPid == 1011 ) || ( attack.WeaponPid == 1012 );
		if( valid( target ) && ( ( target.GetProtoId() == NPC_PID_Ball ) && ( isArm ) ) )
		{
			e_BallIntoInven( target, cr, true );
			return;
		}

		if(cr.Anim2Life == ANIM2_WINDUP)
			cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);

		cr.Action(ACTION_USE_WEAPON, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | (((!isHit && isCritical && !hitRandomly) ? 1 : 0) << 8) | (aim << 4) | use, realWeapon);

		cr.Action( ACTION_USE_WEAPON, ( ( ( !isHit && isCritical && !hitRandomly ) ? 1 : 0 ) << 8 ) | ( aim << 4 ) | use, realWeapon );

		bool changedTarget = ( hitRandomly && ( @realTarget != null ) );

		if( !isHit && isCritical && ( !hitRandomly  || @realTarget == null ) )
		{
			CriticalFailure( cr, weapon, use, ammo, critfailFlags, results );
			return;
		}

		bool criticalHit = isHit && isCritical;

		if( isHthAttack )                                                                                                                                // UNARMED AND MELEE ATTACK
		{
			if( isHit )
			{
				int crDir = cr.Dir;
				int tDir  = valid( realTarget) ? realTarget.Dir : cr.Dir;
				// if( isSneak && cr.Perk[ PE_SILENT_DEATH ] != 0 && ( crDir == tDir || ( ( crDir + 1 ) % 6 ) == tDir || ( ( crDir + 5 ) % 6 ) == tDir ) )
					// attack.DmgMul *= 2;
				if( valid( realTarget) )
					ApplyDamage( attack, realTarget, 1, criticalHit, true, results );
			}
			else
			{
				if( changedTarget )
				{
					if( valid( realTarget ) )
						ApplyDamage( attack, realTarget, 1, false, false, results );
				}
				else
					NotifyMiss( cr, results );
			}
		}
		else if( ( weaponSubtype == WS_GUN ) && !isBurst && !isRocket && !isFlamethrower && !isShotgun )
		{

			if( isHit || changedTarget )
			{
				if( valid( realTarget ) )
					ApplyDamage( attack, realTarget, 1, criticalHit, !changedTarget, results );
			}
			else         // standard miss here
			{
				Critter@[] critsLine;
				attack.Aim = HIT_LOCATION_UNCALLED;
				baseToHit += GetHitAim( aim );
				map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine );
				int  bl = 0;
				bool anyHit = false;
				for( int i = 0, j = critsLine.length(); ( i < j ) && !anyHit; i++ )
				{
					if( valid( realTarget ) && critsLine[ i ].Id == realTarget.Id )
					{
						bl++;
						continue;
					}                                                                       // skip the primary target

					// adjust tohit
					dist = GetDistantion( hx, hy, critsLine[ i ].HexX, critsLine[ i ].HexY );
					acc = dist;
					toHit = baseToHit;
					if( dist < distmod2 )
						acc += distmod2;
					else
						acc -= accloss;
					if( -2 * perception > acc )
						acc = -2 * perception;
					acc -= sharpshooter;
					if( acc > 0 && eyeDamage )
						acc *= 3;
					acc *= -4;
					toHit += acc;
					acmod = critsLine[ i ].Stat[ ST_ARMOR_CLASS ];
					if( valid( ammo ) )
						acmod += ammo.Ammo_AcMod;
					if( acmod > 0 )
						toHit -= acmod;
					toHit -= 10 * bl;
					if( critsLine[ i ].IsKnockout() )
						toHit += 40;
					else
						bl++;
					if( critsLine[ i ].GetMultihex() > 0 )
						toHit += 15;
					toHit = CLAMP( toHit, 5, 95 );
					toHit /= 3;               // after clamp
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					if( Random( 1, 100 ) <= toHit )
					{
						if( valid( target ) )
							NotifyOops( cr, target, critsLine[ i ], results );
						@normalTarget = critsLine[ i ];
						useNormal = true;
						ApplyDamage( attack, normalTarget, 1, false, false, results );
						anyHit = true;
					}
				}
				if( !anyHit )
					NotifyMiss( cr, results );
			}
			// }//end of split if
		}
		else if( isFlamethrower || isShotgun )
		{
			// adjust toHit if random hit
			if( changedTarget )
			{
				dist = GetDistantion( hx, hy, tx, ty );
				acc = dist;
				toHit = baseToHit;
				if( dist < distmod2 )
					acc += distmod2;
				else
					acc -= accloss;
				if( -2 * perception > acc )
					acc = -2 * perception;
				acc -= sharpshooter;
				if( acc > 0 && eyeDamage )
					acc *= 3;
				acc *= -4;
				toHit += acc;
				acmod = valid( realTarget ) ? realTarget.Stat[ ST_ARMOR_CLASS ] : 0;
				if( valid( ammo ) )
					acmod += ammo.Ammo_AcMod;
				if( acmod > 0 )
					toHit -= acmod;
				if( valid( realTarget ) && realTarget.IsKnockout() )
					toHit += 40;
				if( valid( realTarget ) && realTarget.GetMultihex() > 0 )
					toHit += 15;
				int blockers = map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null );
				if( valid( realTarget ) && !realTarget.IsKnockout() )
					blockers--;
				toHit -= 10 * blockers;
				toHit = CLAMP( toHit, 5, 95 );
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
			}

			// critical hit bonus, toHit can be increased over 100
			if( criticalHit )
				toHit += 20;

			// proceed with the flame attack
			Critter@[] critsHit( 0 );
			uint[]     critsHitBullets( 0 );
			int len_ = 0;

			if( Random( 1, 100 ) <= toHit && valid( realTarget ) )
			{
				critsHit.resize( 1 );
				@critsHit[ 0 ] = realTarget;
				critsHitBullets.resize( 1 );
				critsHitBullets[ 0 ] += 1;
				len_++;
			}

			Critter@[] lineCentral;
			map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral );
			int  bl;

			bool threeLines;
			if( lineCentral.length() > 0 )
				threeLines = ( GetDistantion( hx, hy, lineCentral[ 0 ].HexX, lineCentral[ 0 ].HexY ) > 1 ); // target not adjacent and weapon not shotgun
			else
				threeLines = ( GetDistantion( hx, hy, tx, ty ) > 1 ); // target not adjacent and weapon not shotgun
			// already shot: MAX(rounds/6,1);

			for( int lineCount = 0, lineMax = ( threeLines ? 1 : 3 ); lineCount < lineMax; lineCount++ )
			{

				// lineCentral
				bl = 0;           // zero blockers
				for( int i = 0, j = lineCentral.length(); i < j; i++ )
				{
					// adjust tohit
					toHit = baseToHit - 10 * bl;
					dist = GetDistantion( hx, hy, lineCentral[ i ].HexX, lineCentral[ i ].HexY );
					acc = dist;
					if( dist < distmod2 )
						acc += distmod2;
					else
						acc -= accloss;
					if( -2 * perception > acc )
						acc = -2 * perception;
					acc -= sharpshooter;
					if( acc > 0 && eyeDamage )
						acc *= 3;
					acc *= -4;
					toHit += acc;
					acmod = lineCentral[ i ].Stat[ ST_ARMOR_CLASS ];
					if( valid( ammo ) )
						acmod += ammo.Ammo_AcMod;
					if( acmod > 0 )
						toHit -= acmod;
					if( lineCentral[ i ].IsKnockout() )
						toHit += 40;
					else
						bl++;
					if( lineCentral[ i ].GetMultihex() > 0 )
						toHit += 15;
					toHit = CLAMP( toHit, 5, 95 );
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					if( Random( 1, 100 ) <= toHit )
					{
						int crIndex = FindCritterInArray( critsHit, lineCentral[ i ] );
						if( crIndex == -1 )
						{
							critsHit.resize( len_ + 1 );
							@critsHit[ len_ ] = lineCentral[ i ];
							critsHitBullets.resize( len_ + 1 );
							crIndex = len_;
							len_++;
						}
						critsHitBullets[ crIndex ] += 1;
					}
				}
				// lineCentral end
			}

			if( threeLines )
			{
				// rounds for the left stack
				// real left

				uint8  leftDir = GetOffsetDir( hx, hy, tx, ty, 89.0f );
				uint16 sx = hx;
				uint16 sy = hy;
				uint16 ex = tx;
				uint16 ey = ty;

				map.MoveHexByDir( sx, sy, leftDir, 1 );
				map.MoveHexByDir( ex, ey, leftDir, 1 );

				Critter@[] lineLeft;
				map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft );
				int leftStart = 0;
				int leftLen = lineLeft.length();
				while( ( leftStart < leftLen ) && ( GetDistantion( hx, hy, lineLeft[ leftStart ].HexX, lineLeft[ leftStart ].HexY ) ) < 3 )
					leftStart++;

				for( int i = leftStart, j = leftLen; i < j; i++ )
				{
					// adjust tohit
					dist = GetDistantion( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY );
					bl = map.GetCrittersPath( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
					toHit = baseToHit - 10 * bl;
					acc = dist;
					if( dist < distmod2 )
						acc += distmod2;
					else
						acc -= accloss;
					if( -2 * perception > acc )
						acc = -2 * perception;
					acc -= sharpshooter;
					if( acc > 0 && eyeDamage )
						acc *= 3;
					acc *= -4;
					toHit += acc;
					acmod = lineLeft[ i ].Stat[ ST_ARMOR_CLASS ];
					if( valid( ammo ) )
						acmod += ammo.Ammo_AcMod;
					if( acmod > 0 )
						toHit -= acmod;
					if( lineLeft[ i ].IsKnockout() )
						toHit += 40;
					if( lineLeft[ i ].GetMultihex() > 0 )
						toHit += 15;
					toHit = CLAMP( toHit, 5, 95 );
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					if( Random( 1, 100 ) <= toHit )
					{
						int crIndex = FindCritterInArray( critsHit, lineLeft[ i ] );
						if( crIndex == -1 )
						{
							critsHit.resize( len_ + 1 );
							@critsHit[ len_ ] = lineLeft[ i ];
							critsHitBullets.resize( len_ + 1 );
							crIndex = len_;
							len_++;
						}
						critsHitBullets[ crIndex ] += 1;
					}
				}             // left line

				uint8 rightDir = GetOffsetDir( hx, hy, tx, ty, -89.0f );
				sx = hx;
				sy = hy;
				ex = tx;
				ey = ty;

				map.MoveHexByDir( sx, sy, rightDir, 1 );
				map.MoveHexByDir( ex, ey, rightDir, 1 );

				Critter@[] lineRight;
				map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight );
				int rightStart = 0;
				int rightLen = lineRight.length();
				while( ( rightStart < rightLen ) && ( GetDistantion( hx, hy, lineRight[ rightStart ].HexX, lineRight[ rightStart ].HexY ) ) < 3 )
					rightStart++;
				for( int i = rightStart, j = rightLen; i < j; i++ )
				{
					// adjust tohit
					dist = GetDistantion( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY );
					bl = map.GetCrittersPath( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
					toHit = baseToHit - 10 * bl;
					acc = dist;
					if( dist < distmod2 )
						acc += distmod2;
					else
						acc -= accloss;
					if( -2 * perception > acc )
						acc = -2 * perception;
					acc -= sharpshooter;
					if( acc > 0 && eyeDamage )
						acc *= 3;
					acc *= -4;
					toHit += acc;
					acmod = lineRight[ i ].Stat[ ST_ARMOR_CLASS ];
					if( valid( ammo ) )
						acmod += ammo.Ammo_AcMod;
					if( acmod > 0 )
						toHit -= acmod;
					if( lineRight[ i ].IsKnockout() )
						toHit += 40;
					if( lineRight[ i ].GetMultihex() > 0 )
						toHit += 15;
					toHit = CLAMP( toHit, 5, 95 );
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					if( Random( 1, 100 ) <= toHit )
					{
						int crIndex = FindCritterInArray( critsHit, lineRight[ i ] );
						if( crIndex == -1 )
						{
							critsHit.resize( len_ + 1 );
							@critsHit[ len_ ] = lineRight[ i ];
							critsHitBullets.resize( len_ + 1 );
							crIndex = len_;
							len_++;
						}
						critsHitBullets[ crIndex ] += 1;
					}
				}             // right line
			}

			//WTF
			uint main_aim = attack.Aim;
			for( int i = 0, j = critsHit.length(); i < j; i++ )
			{
				if( valid( realTarget ) && critsHit[i].Id == realTarget.Id )
				{
					ApplyDamage( attack, critsHit[ i ], 1, ( valid( realTarget ) && realTarget.Id == critsHit[ i ].Id ) && criticalHit, ( cr.IsPlayer() && !changedTarget ) || ( cr.IsNpc() && critsHit[ i ].Id == target.Id ), results );
					continue; //¬ кого целились - так и попадаем, остальным достаЄтс€ на орехи по рандому..
				}
				
				AttackStruct _attack;
				uint dist_a = GetCrittersDistantion ( cr, critsHit[i] );
				if( isShotgun && dist_a > 7 ) //—лишком больша€ дистанци€, попадание считаетс€ "обобщЄнным", без уточнени€ части тела.
					attack.Aim = HIT_LOCATION_NONE;
				else //ѕопадание приходитс€ в какую-либо часть тела.
					attack.Aim = RandomAim();
					
				_attack = AttackStruct( attack );
				
				ApplyDamage( _attack, critsHit[ i ], 1, ( valid( realTarget ) && realTarget.Id == critsHit[ i ].Id ) && criticalHit, ( cr.IsPlayer() && !changedTarget ) || ( cr.IsNpc() && critsHit[ i ].Id == target.Id ), results );
			}

			if( !changedTarget && !attack.TargetHit )
				NotifyMiss( cr, results );
		}
		else if( ( weaponSubtype == WS_GUN ) && isBurst )  // BURST FIRE
		{
			// adjust toHit if random hit
			if( changedTarget )
			{
				dist = GetDistantion( hx, hy, tx, ty );
				acc = dist;
				toHit = baseToHit;
				if( dist < distmod2 )
					acc += distmod2;
				else
					acc -= accloss;
				if( -2 * perception > acc )
					acc = -2 * perception;
				acc -= sharpshooter;
				if( acc > 0 && eyeDamage )
					acc *= 3;
				acc *= -4;
				toHit += acc;
				acmod = valid( realTarget ) ? realTarget.Stat[ ST_ARMOR_CLASS ] : 0;
				if( valid( ammo ) )
					acmod += ammo.Ammo_AcMod;
				if( acmod > 0 )
					toHit -= acmod;
				if( valid( realTarget ) && realTarget.IsKnockout() )
					toHit += 40;
				if( valid( realTarget ) && realTarget.GetMultihex() > 0 )
					toHit += 15;
				int blockers = map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null );
				if( valid( realTarget ) && !realTarget.IsKnockout() )
					blockers--;
				toHit -= 10 * blockers;
				toHit = CLAMP( toHit, 5, 95 );
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
			}

			// critical hit bonus, toHit can be increased over 100
			if( criticalHit )
				toHit += 20;

			// proceed with the burst attack
			int rounds = ammoRound;
			if( valid( realWeapon ) && realWeapon.AmmoCount < rounds )
				rounds = realWeapon.AmmoCount;
			Critter@[] critsHit( 0 );
			uint[]     critsHitBullets( 0 );

			int len_ = 0;
			int volleyRounds = MAX( ( rounds / 6 ), 1 );

			int curRounds = 0;
			for( int i = 0; i < volleyRounds; i++ )
			{
				if( (i+1)*Random( 1, 100 ) <= toHit )
					curRounds++;
			}
			if( curRounds != 0 && valid( realTarget ) )
			{
				critsHit.resize( 1 );
				critsHitBullets.resize( 1 );
				@critsHit[ 0 ] = realTarget;
				critsHitBullets[ 0 ] = curRounds;
				len_++;
			}
			volleyRounds -= curRounds;

			Critter@[] lineCentral;
			map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral );

			int bl = 0;
			curRounds = 0;
			for( int i = 0, j = lineCentral.length(); ( i < j ) && ( volleyRounds > 0 ); i++ )
			{
				if( valid( realTarget ) && lineCentral[ i ].Id == realTarget.Id )
				{
					bl++;
					continue;
				}                                                                       // skip the primary target, but add blocker
				// adjust tohit
				toHit = baseToHit - 10 * bl;
				dist = GetDistantion( hx, hy, lineCentral[ i ].HexX, lineCentral[ i ].HexY );
				acc = dist;
				if( dist < distmod2 )
					acc += distmod2;
				else
					acc -= accloss;
				if( -2 * perception > acc )
					acc = -2 * perception;
				acc -= sharpshooter;
				if( acc > 0 && eyeDamage )
					acc *= 3;
				acc *= -4;
				toHit += acc;
				acmod = lineCentral[ i ].Stat[ ST_ARMOR_CLASS ];
				if( valid( ammo ) )
					acmod += ammo.Ammo_AcMod;
				if( acmod > 0 )
					toHit -= acmod;
				toHit = CLAMP( toHit, 5, 95 );
				if( lineCentral[ i ].IsKnockout() )
					toHit += 40;
				else
					bl++;
				if( lineCentral[ i ].GetMultihex() > 0 )
					toHit += 15;
				for( curRounds = 0; curRounds < volleyRounds;)
				{
					if( (curRounds+1)*Random( 1, 100 ) <= toHit )
						curRounds++;
					else
						break;
				}
				volleyRounds -= curRounds;
				if( curRounds > 0 )
				{
					int crIndex = FindCritterInArray( critsHit, lineCentral[ i ] );
					if( crIndex == -1 )
					{
						critsHit.resize( len_ + 1 );
						@critsHit[ len_ ] = lineCentral[ i ];
						critsHitBullets.resize( len_ + 1 );
						critsHitBullets[ len_ ] = 0;
						crIndex = len_;
						len_++;
					}
					critsHitBullets[ crIndex ] += curRounds;
				}
			}

			
			// now we're shooting the rest of the bullets (=rounds-MAX(1,rounds/6))
			bool threeLines = false;
			if( lineCentral.length() > 0 && valid( lineCentral[0] ) )
				threeLines = ( GetDistantion( hx, hy, lineCentral[ 0 ].HexX, lineCentral[ 0 ].HexY ) > 1 ) && ( ammoRound > 3 ); // target not adjacent and weapon not shotgun
			else
				threeLines = ( GetDistantion( hx, hy, tx, ty ) > 1 ) && ( ammoRound > 3 ); // target not adjacent and weapon not shotgun
			
			// already shot: MAX(rounds/6,1);

			for( int lineCount = 0, lineMax = ( threeLines ? 1 : 3 ); lineCount < lineMax; lineCount++ )
			{
				// rounds for central stack

				if( lineCount == 0 )
				{
					volleyRounds = rounds - ( ( ( rounds + 1 ) / 3 ) + ( rounds / 3 ) ); // second central, always
					volleyRounds -= MAX( rounds / 6, 1 );
				}
				else
				{
					if( lineCount == 1 )
						volleyRounds = ( rounds + 1 ) / 3;             // left line
					else
						volleyRounds = rounds / 3;                     // right line
				}

				if( volleyRounds == 0 )
					continue;     // end this

				// lineCentral
				bl = 0;           // zero blockers
				for( int i = 0, j = lineCentral.length(); ( i < j ) && ( volleyRounds > 0 ); i++ )
				{
					// adjust tohit
					toHit = baseToHit - 10 * bl;
					dist = GetDistantion( hx, hy, lineCentral[ i ].HexX, lineCentral[ i ].HexY );
					acc = dist;
					if( dist < distmod2 )
						acc += distmod2;
					else
						acc -= accloss;
					if( -2 * perception > acc )
						acc = -2 * perception;
					acc -= sharpshooter;
					if( acc > 0 && eyeDamage )
						acc *= 3;
					acc *= -4;
					toHit += acc;
					acmod = lineCentral[ i ].Stat[ ST_ARMOR_CLASS ];
					if( valid( ammo ) )
						acmod += ammo.Ammo_AcMod;
					if( acmod > 0 )
						toHit -= acmod;
					if( lineCentral[ i ].IsKnockout() )
						toHit += 40;
					if( lineCentral[ i ].GetMultihex() > 0 )
						toHit += 15;
					
					toHit = CLAMP( toHit, 5, 95 );
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					bl++;
					for( curRounds = 0; curRounds < volleyRounds;)
					{
						if( (curRounds+1)*Random( 1, 100 ) <= toHit )
							curRounds++;
						else
							break;
					}
					volleyRounds -= curRounds;
					if( curRounds > 0 )
					{
						int crIndex = FindCritterInArray( critsHit, lineCentral[ i ] );
						if( crIndex == -1 )
						{
							critsHit.resize( len_ + 1 );
							@critsHit[ len_ ] = lineCentral[ i ];
							critsHitBullets.resize( len_ + 1 );
							critsHitBullets[ len_ ] = 0;
							crIndex = len_;
							len_++;
						}
						critsHitBullets[ crIndex ] += curRounds;
					}
				}
				// lineCentral end
			}

			if( threeLines )
			{
				// rounds for the left stack
				volleyRounds = ( rounds + 1 ) / 3;

				if( volleyRounds > 0 )          // real left
				{
					uint8  leftDir = GetOffsetDir( hx, hy, tx, ty, 89.0f );
					uint16 sx = hx;
					uint16 sy = hy;
					uint16 ex = tx;
					uint16 ey = ty;

					map.MoveHexByDir( sx, sy, leftDir, 1 );
					map.MoveHexByDir( ex, ey, leftDir, 1 );

					Critter@[] lineLeft;
					map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft );
					int leftStart = 0;
					int leftLen = lineLeft.length();
					while( ( leftStart < leftLen ) && ( GetDistantion( hx, hy, lineLeft[ leftStart ].HexX, lineLeft[ leftStart ].HexY ) ) < 3 )
						leftStart++;

					for( int i = leftStart, j = leftLen; ( i < j ) && ( volleyRounds > 0 ); i++ )
					{
						// adjust tohit
						dist = GetDistantion( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY );
						bl = map.GetCrittersPath( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
						toHit = baseToHit - 10 * bl;
						acc = dist;
						if( dist < distmod2 )
							acc += distmod2;
						else
							acc -= accloss;
						if( -2 * perception > acc )
							acc = -2 * perception;
						acc -= sharpshooter;
						if( acc > 0 && eyeDamage )
							acc *= 3;
						acc *= -4;
						toHit += acc;
						acmod = lineLeft[ i ].Stat[ ST_ARMOR_CLASS ];
						if( valid( ammo ) )
							acmod += ammo.Ammo_AcMod;
						if( acmod > 0 )
							toHit -= acmod;
						if( lineLeft[ i ].IsKnockout() )
							toHit += 40;
						if( lineLeft[ i ].GetMultihex() > 0 )
							toHit += 15;
							
						toHit = CLAMP( toHit, 5, 95 );
						if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
							toHit = 0;
						
						for( curRounds = 0; curRounds < volleyRounds;)
						{
							if( (curRounds+1)*Random( 1, 100 ) <= toHit )
								curRounds++;
							else
								break;
						}
						volleyRounds -= curRounds;
						if( curRounds > 0 )
						{
							int crIndex = FindCritterInArray( critsHit, lineLeft[ i ] );
							if( crIndex == -1 )
							{
								critsHit.resize( len_ + 1 );
								@critsHit[ len_ ] = lineLeft[ i ];
								critsHitBullets.resize( len_ + 1 );
								critsHitBullets[ len_ ] = 0;
								crIndex = len_;
								len_++;
							}
							critsHitBullets[ crIndex ] += curRounds;
						}
					}
				}             // left line


				// rounds for the right stack
				volleyRounds = ( rounds ) / 3;

				if( volleyRounds > 0 )
				{
					uint8  rightDir = GetOffsetDir( hx, hy, tx, ty, -89.0f );

					uint16 sx = hx;
					uint16 sy = hy;
					uint16 ex = tx;
					uint16 ey = ty;

					map.MoveHexByDir( sx, sy, rightDir, 1 );
					map.MoveHexByDir( ex, ey, rightDir, 1 );

					Critter@[] lineRight;
					map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight );
					int rightStart = 0;
					int rightLen = lineRight.length();
					while( ( rightStart < rightLen ) && ( GetDistantion( hx, hy, lineRight[ rightStart ].HexX, lineRight[ rightStart ].HexY ) ) < 3 )
						rightStart++;
					for( int i = rightStart, j = rightLen; ( i < j ) && ( volleyRounds > 0 ); i++ )
					{
						// adjust tohit
						dist = GetDistantion( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY );
						bl = map.GetCrittersPath( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
						toHit = baseToHit - 10 * bl;
						acc = dist;
						if( dist < distmod2 )
							acc += distmod2;
						else
							acc -= accloss;
						if( -2 * perception > acc )
							acc = -2 * perception;
						acc -= sharpshooter;
						if( acc > 0 && eyeDamage )
							acc *= 3;
						acc *= -4;
						toHit += acc;
						acmod = lineRight[ i ].Stat[ ST_ARMOR_CLASS ];
						if( valid( ammo ) )
							acmod += ammo.Ammo_AcMod;
						if( acmod > 0 )
							toHit -= acmod;
						if( lineRight[ i ].IsKnockout() )
							toHit += 40;
						if( lineRight[ i ].GetMultihex() > 0 )
							toHit += 15;
						toHit = CLAMP( toHit, 5, 95 );
						if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
							toHit = 0;
						for( curRounds = 0; curRounds < volleyRounds;)
						{
							if( (curRounds+1)*Random( 1, 100 ) <= toHit )
								curRounds++;
							else
								break;
						}
						volleyRounds -= curRounds;
						if( curRounds > 0 )
						{
							int crIndex = FindCritterInArray( critsHit, lineRight[ i ] );
							if( crIndex == -1 )
							{
								critsHit.resize( len_ + 1 );
								@critsHit[ len_ ] = lineRight[ i ];
								critsHitBullets.resize( len_ + 1 );
								critsHitBullets[ len_ ] = 0;
								crIndex = len_;
								len_++;
							}
							critsHitBullets[ crIndex ] += curRounds;
						}
					}
				}             // right line
			}

			for( int i = 0, j = len_; i < j; i++ )
				ApplyDamage( attack, critsHit[ i ], critsHitBullets [i], ( valid( realTarget ) && realTarget.Id == critsHit[ i ].Id ) && criticalHit, ( cr.IsPlayer() && !changedTarget ) || ( cr.IsNpc() && critsHit[ i ].Id == target.Id ), results );

			if( !changedTarget && !attack.TargetHit )
				NotifyMiss( cr, results );
		}                                                       // burst attack
		else if( isRocket || ( weaponSubtype == WS_THROWING ) ) // ROCKETS, THROWING
		{
			bool exploding = isRocket || isGrenade;

			if( isHit || changedTarget )
			{
				if( exploding )
					CommenceExplosion( attack, map, tx, ty, realTarget, weapPid, criticalHit, valid( realTarget ) ? realTarget.Id : 0, isRocket, results );
				else if( valid( realTarget ) )          // binyan - Hex attack - added
					ApplyDamage( attack, realTarget, 1, criticalHit, !changedTarget, results );
			}
			else
			{
				// miss with missiles
				attack.Aim = HIT_LOCATION_UNCALLED;
				baseToHit += GetHitAim( aim );

				if( weaponSubtype == WS_THROWING )
					sharpshooter = 0;
				uint16 bx = 0;
				uint16 by = 0;
				uint16 pbx = 0;
				uint16 pby = 0;


				Critter@[] critsLine;
				map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine, pbx, pby, bx, by );

				int  bl = 0;
				bool anyHit = false;
				for( int i = 0, j = critsLine.length(); ( i < j ) && !anyHit; i++ )
				{
					if( valid( realTarget ) && critsLine[ i ].Id == realTarget.Id )
					{
						bl++;
						continue;
					}                                                                                            // skip the primary target // binyan - Hex attack - added
					// adjust tohit
					dist = GetDistantion( hx, hy, critsLine[ i ].HexX, critsLine[ i ].HexY );
					acc = dist;
					toHit = baseToHit;
					if( dist < distmod2 )
						acc += distmod2;
					else
						acc -= accloss;
					if( -2 * perception > acc )
						acc = -2 * perception;
					acc -= sharpshooter;
					if( acc > 0 && eyeDamage )
						acc *= 3;
					acc *= -4;
					toHit += acc;
					acmod = critsLine[ i ].Stat[ ST_ARMOR_CLASS ];
					if( valid( ammo ) )
						acmod += ammo.Ammo_AcMod;
					if( acmod > 0 )
						toHit -= acmod;
					toHit -= 10 * bl;
					if( critsLine[ i ].IsKnockout() )
						toHit += 40;
					else
						bl++;
					if( critsLine[ i ].GetMultihex() > 0 )
						toHit += 15;
					toHit = CLAMP( toHit, 5, 95 );
					toHit /= 3;               // after clamp
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					if( Random( 1, 100 ) <= toHit )
					{
						tx = critsLine[ i ].HexX;
						ty = critsLine[ i ].HexY;
						@normalTarget = critsLine[ i ];
						anyHit = true;
					}
				}

				if( anyHit )
				{
					if( valid( target ) )
						NotifyOops( cr, target, normalTarget, results );
					useNormal = true;
					if( weapPid != PID_BALL )                                                                                                                    // binyan - учитывем м€ч
					{
						if( exploding )
							CommenceExplosion( attack, map, tx, ty, normalTarget, weapPid, false, valid( realTarget ) ? realTarget.Id : 0, isRocket, results );  // binyan - Hex attack - added
						else
							ApplyDamage( attack, normalTarget, 1, false, false, results );
					}
				}
				else
				{
					useHex = true;
					NotifyMiss( cr, results );
					if( isGrenade || weapPid == PID_BALL )           // binyan - при промахе расчитываем отклонение от траектори и дл€ м€ча в том числе.
					{
						// binyan - Hex attack - added
						tx = valid( realTarget ) ? realTarget.HexX : hexX;
						ty = valid( realTarget ) ? realTarget.HexY : hexY;
						// /////////////////////////////////////
						int newdist = GetDistantion( hx, hy, tx, ty ) + 1;
						map.MoveHexByDir( tx, ty, Random( 0, 5 ), Random( 1, newdist / 2 ) );
						newdist = GetDistantion( hx, hy, tx, ty );
						map.GetCrittersPath( hx, hy, tx, ty, 0.0f, newdist, FIND_LIFE, null, tx, ty, bx, by );
					}
					else
					{
						if( isRocket )
						{
							tx = bx;
							ty = by;
						}
						else
						{
							tx = pbx;
							ty = pby;
						}
					}

					if( exploding )
						CommenceExplosion( attack, map, tx, ty, null, weapPid, false, valid( realTarget ) ? realTarget.Id : 0, isRocket, results );  // binyan - Hex attack - added

				}
			}                                                                                                                                        // miss
																																					 // binyan - Ѕросок м€ча////////////////////////////////////////////////////////////
			if( weapPid == PID_BALL )
			{
				e_ConvertBallToCrit( cr, realWeapon, tx, ty );
				FlushResults( results );           // ”ведомление о промахе в случае оного.
				return;
			}
		}
		else
			cr.Say( SAY_NETMSG, "Combat error: weapon PID=" + weapPid + " not handled, please send bug report." );
	}

	
	
	void effects()
	{
		FlushResults( results );

		if( !isGrenade && !isHthAttack )
			hearshot( cr, weapon, weaponMode );
		
		if( _WeaponEffect( weapon, use ) != 0 )
		{
			string sfx = "";
			switch( dmgType )
			{
				case( DAMAGE_NORMAL ): 
					if( weaponSubtype == WS_THROWING )
						sfx = "стук"; 
					if( weaponSubtype == WS_GUN )
						sfx = "стук"; 
					if( valid( realTarget ) )
						sfx = "удар";
					break;
				case( DAMAGE_LASER ): sfx = "шипение"; break;
				case( DAMAGE_FIRE ): sfx = "треск"; break;
				case( DAMAGE_PLASMA ): sfx = "щипение"; break;
				case( DAMAGE_ELECTR ): sfx = "треск"; break;
				case( DAMAGE_EMP ): sfx = "треск"; break;
				//case( DAMAGE_EXPLODE ): sfx = ""; break;
			}
			if( isGrenade ) sfx = "стук";
			
			if( sfx.length() > 0 )
				map.SetText( tx - 1, ty - 1, COLOR_SAND, "|0xFF828a96 :" + sfx + ":" );

			if( useHex || not valid( realTarget ) )                                          
				map.RunFlyEffect( _WeaponEffect( weapon, use ), cr, null, hx, hy, tx, ty );
			else
				map.RunFlyEffect( _WeaponEffect( weapon, use ), cr, ( useNormal ? normalTarget : realTarget ), hx, hy, tx, ty );
		}

		if( ammoRound > 0 && valid( realWeapon ) && cr.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
		{
			if( realWeapon.AmmoCount <= ammoRound )
				realWeapon.AmmoCount = 0;
			else
				realWeapon.AmmoCount -= ammoRound;

			uint[] ammo_shells_normal = { 
				PID_5MM_JHP, PID_5MM_AP, PID_7_62MM_AMMO, PID_9MM_AMMO, PID_9MM_BALL, PID_10MM_JHP, PID_10MM_AP, PID_14MM_AP, PID_44_MAGNUM_JHP, PID_44_FMJ_MAGNUM, PID_45_CALIBER_AMMO, PID_223_FMJ, PID_SHOTGUN_SHELLS, PID_2MM_EC_AMMO, PID_NEED_CART_POISON, PID_NEED_CART_NT 
			};
			bool isNormal = ammo_shells_normal.find( attack.Ammo.ProtoId ) != -1;

			uint[] ammo_shells_poor = {
				PID_10mm_LOW, PID_044mag_LOW, PID_14mm_LOW, PID_12g_LOW, PID_223_LOW
			};
			bool isLow = ammo_shells_poor.find( attack.Ammo.ProtoId ) != -1;

			for( uint i = 0; i < ammoRound; i++ )
				if( ( isNormal && Random(0,3)!=0 ) || ( isLow && Random(0,2)==0 ) )
					map.AddItem( cr.HexX + Random( -1, 1 ), cr.HexY + Random( -1, 1 ), PID_gilza, 1 );

			realWeapon.Update();
		}

		if( valid( realWeapon ) )
		{
			if( realWeapon.IsDeteriorable() && crIsPlayer )       
			{
				if( realWeapon.GetProtoId() != PID_CLAW_EXT && realWeapon.GetProtoId() != PID_FIREBREATH )
				{
					int wearCount = Random( 50, 100 ) - (cr.Stat [ST_LUCK]-5)*5;
					if( attack.WeaponPid == PID_DRUM_GUN_LOW || attack.WeaponPid == PID_REV_RIFLE_LOW || attack.WeaponPid == PID_BIGGUN_LOW || attack.WeaponPid == PID_SMOKE_GUN_LOW || attack.WeaponPid == PID_AUTOGUN_LOW )
						wearCount += Random( 50, 150 );
					if( ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_10mm_LOW ) || ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_14mm_LOW ) || ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_12g_LOW ) || ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_223_LOW ) )
						wearCount += Random( 10, 20 );
					if( skillVal < 100 )
						wearCount += Random( 25, 75 );
					if( Random( 0, 20 ) == 20 )
					{
						if( cr.IsPlayer() )
							cr.Say( SAY_NETMSG, "¬ оружии что-то непри€тно щЄлкнуло." );
						wearCount += Random( 100, 200 );
					}
					DeteriorateItem( cr, realWeapon, wearCount / 3 );
				}
				
				//  нокбэк себе и ломание конечностей:
				if( realWeapon.GetProtoId() == PID_ONEHAND_ROCKET_LAUNCHER )
				{
					if( ( Random( 0, 5 ) + cr.Stat[ ST_ENDURANCE ] + cr.Stat[ ST_STRENGTH ] ) < 15 )
					{
						if( !cr.IsDead() || !cr.IsKnockout() )
						{
							cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 150, cr.HexX, cr.HexY );
							switch( Random( 0, 1 ) )
							{
							case 0:
								if( cr.DamageBase[ DAMAGE_LEFT_ARM ] != 1 )
									cr.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
								break;                                                                                                             
							case 1:
								if( cr.DamageBase[ DAMAGE_RIGHT_ARM ] != 1 )
									cr.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
								break;                                                                                 
							default:
								break;
							}
						}
					}
				}
			}

			if( wpnIsRemoved && cr.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
			{ //TODO: ѕеремещение метательного оружи€ к цели/месту попадани€.
				bool placeOnHex = ( skillNum == SK_THROWING && !( isGrenade || weapPid == PID_ALGAE ) );
				if( realWeapon.IsStackable() )
				{
					if( placeOnHex )
						map.AddItem( tx, ty, weapPid, 1 );

					if( realWeapon.GetCount() > 1 )
						realWeapon.SetCount( realWeapon.GetCount() - 1 );
					else
						DeleteItem( realWeapon );
				}
				else
					MoveItem( realWeapon, 0, map, tx, ty );
			}
		}

		if( !attack.TargetHit && valid( target ) )
		{
			if( !target.IsPlayer() )
				AI_TrySayCombatText( target, COMBAT_TEXT_MISS );
			target.Action( ACTION_DODGE, 0, null );                                                                   
		}
	}
}