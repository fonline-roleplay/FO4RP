                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

const uint8 BIT_STILL_ISBEER=0x01;
const uint8 BIT_STILL_UPRATED=0x02;     

import void ExplodeEx(Map&map,uint16 hexX,uint16 hexY,uint16 effectPid,uint effectRadius,uint damage,uint damageType,uint damageRadius,uint ownerId)from"explode";             

bool IsStill(Item@item)
{
	if(not(@item!=null))
	return false;
	uint16 pid=item.GetProtoId();
	return pid==(810)||pid==(811)||
	pid==(812)||pid==(813)||
	pid==(814)||pid==(815);
} 

bool UseStill(Critter@cr,Item@still,int skill,Item@item)   

{
	if(not(@cr!=null))
	{
		Log("Critter is not valid.");
		return false;
	}
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return false;
	}
	if(not ChkParam(still))
	Log("ChkParam return FALSE.");
	bool isBeer=GetParam_isBeer(still);
	bool uprated=GetParam_uprated(still);
	int8 condition=still.Val2;
	uint16 pid=0;
	if((@item!=null))
	pid=item.GetProtoId();     
	
	if((skill==-1)&&(not(@item!=null)))
	switch(condition)
	{
		case(0):
		cr.SayMsg((11),(0),1500);
		return true;
		case(1):
		cr.SayMsg((11),(0),1501);
		return true;
		case(2):
		cr.SayMsg((11),(0),1502);
		return true;
		case(3):
		if(isBeer)
		cr.SayMsg((11),(0),1503);
		else
		cr.SayMsg((11),(0),1504);
		return true;
	}
	;
	
	if(pid==(542)&&condition==(3))
	{
		
		uint32 itemCount=item.GetCount();
		uint8 productCount;
		if(isBeer)
		productCount=(50)+(10);
		else
		productCount=(40)+(20);
		if(itemCount<productCount)
		{
			cr.SayMsg((11),(0),1507);
			return true;
		}
		
		if(isBeer)
		productCount=(50)+Random(0,(10)+(cr.Stat[(6)]-4)*(3));
		else
		productCount=(40)+Random(0,(20)+(cr.Stat[(6)]-4)*(3));
		
		if(productCount>itemCount)
		productCount=itemCount;
		
		if(not ChgCond(still,isBeer,uprated,(1)))
		{
			Log("ChgCond return FALSE.");
			return false;
		}
		if(not cr.DeleteItem((542),productCount))
		Log("DeleteItem fail.");
		uint16 pid_product;
		uint16 msgNum;
		if(isBeer)
		{
			pid_product=(124);
			msgNum=1505;
		}
		else
		{
			pid_product=(125);
			msgNum=1506;
		}
		if(not(@cr.AddItem(pid_product,productCount)!=null))
		{
			Log("cr.AddItem fail.");
			return false;
		}
		cr.SayMsg((11),(0),msgNum);
		
		GameVar@totalProductCount=GetLocalVar((4700),cr.Id);
		if(not(@totalProductCount!=null))
		{
			Log("LVAR_manufact_alco_productcount is not valid.");
			return true;
		}       
		
		return true;
	} 
	
	if(pid==(286))
	switch(condition)
	{
		case(0):
		cr.SayMsg((11),(0),1508);
		return true;
		case(2):
		cr.SayMsg((11),(0),1513);
		return true;
		case(3):
		if(isBeer)
		cr.SayMsg((11),(0),1514);
		else
		cr.SayMsg((11),(0),1515);
		return true;
		case(1):
		{
			
			uint32 itemCount=item.GetCount();
			uint8 itemCount_Need;
			if(isBeer)
			itemCount_Need=(2);
			else
			itemCount_Need=(3);
			if(not uprated)
			itemCount_Need*=(2);
			if(itemCount<itemCount_Need)
			{
				cr.SayMsg((11),(0),1509);
				return true;
			}
			
			if(cr.Skill[(212)]<(51))
			{
				cr.SayMsg((11),(0),1510);
				return true;
			}
			
			uint32 timeWorking;
			if(isBeer)
			timeWorking=(24);
			else
			timeWorking=(12);
			timeWorking*=60;
			
			timeWorking+=Random(-60,60);      
			
			still.Val3=CreateTimeEvent(__FullSecond+timeWorking*60,"e_WorkingComplete",still.Id,true);
			if(still.Val3==0)
			{
				Log("Time event WorkingComplete create fail, LastError = "+GetLastError()+".");
				return false;
			}
			
			if(not ChgCond(still,isBeer,uprated,(2)))
			{
				Log("ChgCond return FALSE");
				return false;
			}
			if(not cr.DeleteItem((286),itemCount_Need))
			Log("DeleteItem fail.");
			if(isBeer)
			cr.SayMsg((11),(0),1511);
			else
			cr.SayMsg((11),(0),1512);
			
			return true;
		}
	} 
	
	if(condition!=(0)&&
	(pid==(6)||pid==(115)||pid==(20)||pid==(386)||pid==(543)))
	{
		
		if(still.Val3!=0)
		{
			EraseTimeEvent(still.Val3);
			still.Val3=0;
		}
		
		uint32 TimeToDownrate=(16)*24*60;      
		
		if(uprated)
		{
			still.Val3=CreateTimeEvent(__FullSecond+TimeToDownrate*60,"e_DownrateAtBroken",still.Id,true);
			if(still.Val3==0)
			Log("Time event DownrateAtBroken create fail, LastError = "+GetLastError()+".");
		}
		
		if(not ChgCond(still,isBeer,uprated,(0)))
		{
			Log("ChgCond return FALSE.");
			return false;
		}
		if(isBeer)
		cr.SayMsg((11),(0),1516);
		else
		cr.SayMsg((11),(0),1517);
		
		if(condition==(2)&&((40)-cr.Stat[(6)])>Random(0,99))
		{
			
			uint16 hexX=0;
			uint16 hexY=0;
			Map@map=still.GetMapPosition(hexX,hexY);
			if(not(@map!=null))
			Log("Map is not valid.");
			uint8 damage=Random((40),(80));
			cr.SayMsg((11),(0),1518);
			
			bool damageEye=cr.Damage[(502)]==0;
			damageEye=damageEye&&not
			((@cr.GetItem((3),(3))!=null)||(@cr.GetItem((232),(3))!=null)||
			(@cr.GetItem((348),(3))!=null)||(@cr.GetItem((349),(3))!=null));
			if(damageEye&&(20)>Random(0,99))
			{
				cr.SayMsg((11),(0),1519);
				cr.DamageBase[(502)]=1;
			}
			
			if((@map!=null))
			ExplodeEx(map,hexX,hexY,(4011),0,damage,(3),1,0);  
			
		}
		
		return true;
	}
	; 
	
	if(condition==(0)&&(skill==(213)||pid==(75)||pid==(308)))
	{
		
		if(cr.Skill[(213)]<(51))
		return false;
		
		if(cr.Timeout[(232)]>0)
		{
			cr.SayMsg((11),(3),(3401));
			return true;
		}
		
		if(skill==(213))
		{
			cr.SayMsg((11),(0),1521);
			return true;
		}
		
		if(cr.CountItem((475))<(4))
		{
			cr.SayMsg((11),(0),1520);
			return true;
		}
		
		uint16 repairSkill=cr.Skill[(213)];
		if(pid==(308))
		repairSkill+=15;
		
		uint8 repairChance=0;
		if(repairSkill>=(70))
		repairChance=((((repairSkill-(70)+1)*3)>(95))?(95):((((repairSkill-(70)+1)*3)<(0))?(0):((repairSkill-(70)+1)*3)));
		
		if(repairChance>Random(0,99))
		{ 
			
			if(still.Val3!=0)
			{
				EraseTimeEvent(still.Val3);
				still.Val3=0;
			}
			if(not ChgCond(still,isBeer,uprated,(1)))
			{
				Log("ChgCond return FALSE.");
				return false;
			}
			if(not cr.DeleteItem((475),(4)))
			Log("DeleteItem fail.");
			cr.TimeoutBase[(232)]=(__FullSecond+((20)*__TimeMultiplier));
			cr.SayMsg((11),(0),1522);
			
			GameVar@totalRepairCount=GetLocalVar((4701),cr.Id);
			if(not(@totalRepairCount!=null))
			{
				Log("LVAR_manufact_alco_repaircount is not valid.");
				return true;
			}
			uint8 totalRepairCount_value=totalRepairCount.GetValue();
			if(totalRepairCount_value<5)
			{
				uint16 exp=2;
				switch(totalRepairCount_value)
				{
					case 0:
					exp=(400);
					break;
					case 1:
					exp=(400)/2;
					break;
					default:
					for(int ___i=1,___j=exp;___i<totalRepairCount_value;___i++)
					exp*=___j;
					exp=(400)/exp;
				}
				cr.StatBase[(76)]+=exp;
				totalRepairCount=totalRepairCount_value+1;
			}
			
			return true;
		}
		
		if(not cr.DeleteItem((475),Random(1,(2))))
		Log("DeleteItem fail.");
		cr.TimeoutBase[(232)]=(__FullSecond+((20)*__TimeMultiplier));
		cr.SayMsg((11),(0),1523);
		
		return true;
	} 
	
	if(condition==(1)&&(skill==(212)||pid==(384)))
	{
		
		if(uprated)
		return false;
		
		if(cr.Skill[(212)]<(51))
		return false;
		
		if(cr.Timeout[(233)]>0)
		{
			cr.SayMsg((11),(3),(3401));
			return true;
		}
		
		if(pid!=(384))
		{
			cr.SayMsg((11),(0),1524);
			return true;
		}
		
		if(cr.Skill[(213)]<(41))
		{
			if(not ChgCond(still,isBeer,false,(0)))
			{
				Log("ChgCond return FALSE.");
				return false;
			}
			if(not cr.DeleteItem((384),1))
			Log("DeleteItem fail.");
			cr.TimeoutBase[(233)]=(__FullSecond+((20)*__TimeMultiplier));
			cr.SayMsg((11),(0),1525);
			
			return true;
		}
		
		if(cr.Skill[(212)]<(80))
		{
			
			if(cr.Skill[(212)]<=((80)+(51))/2)
			{
				if(not ChgCond(still,isBeer,false,(0)))
				{
					Log("ChgCond return FALSE.");
					return false;
				}
				cr.SayMsg((11),(0),1526);
				
			}
			else
			cr.SayMsg((11),(0),1527);
			cr.TimeoutBase[(233)]=(__FullSecond+((20)*__TimeMultiplier));
			
			return true;
		}
		
		uint8 uprateChance=0;
		if(cr.Skill[(212)]>=(80))
		uprateChance=((((cr.Skill[(212)]-(80)+1)*4)>(95))?(95):((((cr.Skill[(212)]-(80)+1)*4)<(0))?(0):((cr.Skill[(212)]-(80)+1)*4)));
		
		if(uprateChance>Random(0,99))
		{
			
			if(not ChgCond(still,isBeer,true,(1)))
			{
				Log("ChgCond return FALSE");
				return false;
			}
			if(isBeer)
			cr.SayMsg((11),(0),1528);
			else
			cr.SayMsg((11),(0),1529);
			cr.TimeoutBase[(233)]=(__FullSecond+((20)*__TimeMultiplier));
			
			GameVar@totalUprateCount=GetLocalVar((4702),cr.Id);
			if(not(@totalUprateCount!=null))
			{
				Log("LVAR_manufact_alco_upratecount is not valid.");
				return true;
			}
			uint8 totalUprateCount_value=totalUprateCount.GetValue();
			if(totalUprateCount_value<3)
			{
				uint16 exp=2;
				switch(totalUprateCount_value)
				{
					case 0:
					exp=(600);
					break;
					case 1:
					exp=(600)/2;
					break;
					default:
					for(int ___i=1,___j=exp;___i<totalUprateCount_value;___i++)
					exp*=___j;
					exp=(600)/exp;
				}
				cr.StatBase[(76)]+=exp;
				totalUprateCount=totalUprateCount_value+1;
			}
			
			return true;
		}
		
		cr.SayMsg((11),(0),1530);
		cr.TimeoutBase[(233)]=(__FullSecond+((20)*__TimeMultiplier));
		
		return true;
	}
	
	return false;
}       

bool ChgCond(Item@still,bool isBeer,bool uprated,int8 condition)
{ 
	
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return false;
	}
	
	uint16 pid_stillOld=still.GetProtoId();
	uint16 pid_stillNew;
	switch(condition)
	{
		case(0):
		if(isBeer)
		pid_stillNew=(810);
		else
		pid_stillNew=(811);
		break;
		case(2):
		if(isBeer)
		pid_stillNew=(813);
		else
		pid_stillNew=(815);
		break;
		default:
		if(isBeer)
		pid_stillNew=(812);
		else
		pid_stillNew=(814);
	}
	;
	
	if(pid_stillNew!=pid_stillOld)
	if(not still.ChangeProto(pid_stillNew))
	Log("ChangeProto fail (WARNING).");
	
	SetParam(still,isBeer,uprated);
	still.Val2=condition;
	if(not ChkParam(still))
	Log("ChkParam return FALSE.");
	return true;
} 

bool GetParam_isBeer(Item@still)
{
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return false;
	}
	return(still.Val1&BIT_STILL_ISBEER)!=0;
}
bool GetParam_uprated(Item@still)
{
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return false;
	}
	return(still.Val1&BIT_STILL_UPRATED)!=0;
} 

void SetParam(Item@still,bool isBeer,bool uprated)
{
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return;
	}
	if(isBeer)
	still.Val1|=BIT_STILL_ISBEER;
	else
	still.Val1&=~BIT_STILL_ISBEER;
	if(uprated)
	still.Val1|=BIT_STILL_UPRATED;
	else
	still.Val1&=~BIT_STILL_UPRATED;
	return;
} 

bool ChkParam(Item@still)

{
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return false;
	}
	if(still.Val2!=(0)&&still.Val2!=(1)&&
	still.Val2!=(2)&&still.Val2!=(3))
	{
		still.Val2=(0);
		Log("Incorrect condition.");
	}
	bool isBeer=GetParam_isBeer(still);
	bool uprated=GetParam_uprated(still);
	bool ok=true;
	
	switch(still.GetProtoId())
	{
		case(810):
		
		if(still.Val2!=(0))
		{
			still.Val2=(0);
			ok=false;
		}
		
		if(not isBeer)
		{
			isBeer=true;
			ok=false;
		}
		
		if(uprated&&still.Val3==0)
		{
			ok=false;
			Log("Event for STILL_BROKEN is not exist.");
			still.Val3=CreateTimeEvent(__FullSecond+(16)*24*60*60,"e_DownrateAtBroken",still.Id,true);
			if(still.Val3==0)
			{
				Log("Time event DownrateAtBroken create fail, LastError = "+GetLastError()+".");
				if(not ChgCond(still,isBeer,false,(0)))
				Log("ChgCond return FALSE.");
			}
		}
		
		else if(not uprated&&still.Val3!=0)
		{
			ok=false;
			EraseTimeEvent(still.Val3);
			still.Val3=0;
			Log("Incorrect event for PID_STILL_B_BROKEN.");
		}
		break;
		case(811):
		
		if(still.Val2!=(0))
		{
			still.Val2=(0);
			ok=false;
		}
		
		if(isBeer)
		{
			isBeer=false;
			ok=false;
		}
		
		if(uprated&&still.Val3==0)
		{
			ok=false;
			Log("Event for STILL_BROKEN is not exist.");
			still.Val3=CreateTimeEvent(__FullSecond+(16)*24*60*60,"e_DownrateAtBroken",still.Id,true);
			if(still.Val3==0)
			{
				Log("Time event DownrateAtBroken create fail, LastError = "+GetLastError()+".");
				if(not ChgCond(still,isBeer,false,(0)))
				Log("ChgCond return FALSE.");
			}
		}
		
		else if(not uprated&&still.Val3!=0)
		{
			ok=false;
			EraseTimeEvent(still.Val3);
			still.Val3=0;
			Log("Incorrect event for PID_STILL_S_BROKEN.");
		}
		break;
		case(812):
		
		if(not isBeer)
		{
			isBeer=true;
			ok=false;
		}
		
		if(still.Val2!=(1)&&still.Val2!=(3))
		{
			still.Val2=(1);
			ok=false;
		}
		
		if(still.Val3!=0)
		{
			ok=false;
			EraseTimeEvent(still.Val3);
			still.Val3=0;
			Log("Incorrect event for PID_STILL_B.");
		}
		break;
		case(814):
		
		if(isBeer)
		{
			isBeer=false;
			ok=false;
		}
		
		if(still.Val2!=(1)&&still.Val2!=(3))
		{
			still.Val2=(1);
			ok=false;
		}
		
		if(still.Val3!=0)
		{
			ok=false;
			EraseTimeEvent(still.Val3);
			still.Val3=0;
			Log("Incorrect event for PID_STILL_S.");
		}
		break;
		case(813):
		
		if(not isBeer)
		{
			isBeer=true;
			ok=false;
		}
		
		if(still.Val2!=(2))
		{
			still.Val2=(2);
			ok=false;
		}
		
		if(still.Val3==0)
		{
			ok=false;
			Log("Event for STILL_B_ACTIVE is not exist.");
			still.Val3=CreateTimeEvent(__FullSecond+(24)*60+1,"e_WorkingComplete",still.Id,true);
			if(still.Val3==0)
			{
				Log("Time event WorkingComplete create fail, LastError = "+GetLastError()+".");
				if(not ChgCond(still,isBeer,uprated,(1)))
				Log("ChgCond return FALSE.");
			}
		}
		break;
		case(815):
		
		if(isBeer)
		{
			isBeer=false;
			ok=false;
		}
		
		if(still.Val2!=(2))
		{
			still.Val2=(2);
			ok=false;
		}
		
		if(still.Val3==0)
		{
			ok=false;
			Log("Event for STILL_S_ACTIVE is not exist.");
			still.Val3=CreateTimeEvent(__FullSecond+(12)*60+1,"e_WorkingComplete",still.Id,true);
			if(still.Val3==0)
			{
				Log("Time event WorkingComplete create fail, LastError = , "+GetLastError()+".");
				if(not ChgCond(still,isBeer,uprated,(1)))
				Log("ChgCond return FALSE.");
			}
		}
		break;
		default:
		Log("Unknown pid = "+still.GetProtoId()+".");
		return false;
	}
	if(not ok)
	SetParam(still,isBeer,uprated);
	return ok;
}     

uint e_DownrateAtBroken(uint[]@values)
{
	Item@still=GetItem(values[0]);
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return 0;
	}
	;
	still.Val3=0;
	if(still.Val2!=(0))
	{
		Log("Incorrect condition.");
		return 0;
	}
	if(not ChgCond(still,GetParam_isBeer(still),false,(0)))
	Log("ChgCond return FALSE.");
	return 0;
} 

uint e_WorkingComplete(uint[]@values)
{
	Item@still=GetItem(values[0]);
	if(not(@still!=null))
	{
		Log("Item (still) is not valid.");
		return 0;
	}
	;
	still.Val3=0;
	if(still.Val2!=(2))
	{
		Log("Incorrect condition.");
		return 0;
	}
	if(not ChgCond(still,GetParam_isBeer(still),GetParam_uprated(still),(3)))
	Log("ChgCond return FALSE.");
	return 0;
}    

bool s_GrainContainer(Critter@cr,Scenery@sc,int skill,Item@item)
{
	if((@item!=null))
	return false;
	else if(skill==-1)
	cr.SayMsg((11),(0),1560);
	else
	return false;
	return true;
}
bool s_BrewTank(Critter@cr,Scenery@sc,int skill,Item@item)
{
	if(not(@item!=null)&&skill==(212)&&cr.Skill[(212)]>4)
	cr.SayMsg((11),(0),1561);
	return true;
}
