                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

bool AddMiscPlane(Critter&npc,uint priority,uint waitSecond,string@funcName)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(0);
	plane.Priority=(priority==0?(10):priority);
	plane.Misc_WaitSecond=waitSecond;
	if((@funcName!=null)&&not plane.Misc_SetScript(funcName))
	{
		Log("Set script <"+funcName+"> fail");
		return false;
	}
	return npc.AddPlane(plane);
}

bool AddWalkPlane(Critter&npc,uint entire,uint cut,bool run)
{
	uint16 hX=0,hY=0;
	Map@map=npc.GetMap();
	if((@map!=null)&&map.GetEntireCoords(entire,0,hX,hY))
	{
		return AddWalkPlane(npc,0,hX,hY,6,run,cut);
	}
	return false;
}

bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)
{
	if(not npc.IsCanWalk())
	return false;
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(2);
	plane.Priority=(priority==0?(20):priority);
	plane.Walk_HexX=hexX;
	plane.Walk_HexY=hexY;
	plane.Walk_Dir=dir;
	plane.Run=run;
	plane.Walk_Cut=cut;
	return npc.AddPlane(plane);
}

bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)
{
	if(not npc.IsCanWalk())
	return false;
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(2);
	plane.Priority=(priority==0?(20):priority);
	plane.Identifier=identifier;
	plane.IdentifierExt=identifierExt;
	plane.Walk_HexX=hexX;
	plane.Walk_HexY=hexY;
	plane.Walk_Dir=dir;
	plane.Run=run;
	plane.Walk_Cut=cut;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexY=target.HexY;
	plane.Attack_LastHexX=target.HexX;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId,bool run)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=__DeadHitPoints;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,Critter&target,int minHp,bool run)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddAttackPlane(Critter&npc,uint priority,uint critId,int minHp,bool run)
{
	Critter@target=GetCritter(critId);
	if(not(@target!=null))
	{
		Log("Target not found.");
		return false;
	}
	
	NpcPlane@plane=CreatePlane();
	plane.Type=(1);
	plane.Priority=(priority==0?(50):priority);
	plane.Attack_TargId=target.Id;
	plane.Attack_MinHp=minHp;
	plane.Attack_IsGag=false;
	plane.Attack_GagHexX=0;
	plane.Attack_GagHexY=0;
	plane.Attack_LastHexX=target.HexX;
	plane.Attack_LastHexY=target.HexY;
	plane.Run=run;
	return npc.AddPlane(plane);
}

bool AddPickPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint16 protoId,uint useItemId,bool toOpen)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(3);
	plane.Priority=(priority==0?(35):priority);
	plane.Pick_HexX=hexX;
	plane.Pick_HexY=hexY;
	plane.Pick_Pid=protoId;
	plane.Pick_UseItemId=useItemId;
	plane.Pick_ToOpen=toOpen;
	plane.Run=false;
	return npc.AddPlane(plane);
}

bool AddPickPlane(Critter&npc,uint priority,Item@item,uint useItemId,bool toOpen)
{
	NpcPlane@plane=CreatePlane();
	plane.Type=(3);
	plane.Priority=(priority==0?(35):priority);
	plane.Pick_HexX=item.HexX;
	plane.Pick_HexY=item.HexY;
	plane.Pick_Pid=item.GetProtoId();
	plane.Pick_UseItemId=useItemId;
	plane.Pick_ToOpen=toOpen;
	plane.Run=false;
	return npc.AddPlane(plane);
}

uint EraseAttackPlane(Critter&npc,Critter&target)
{
	return EraseAttackPlane(npc,target.Id);
}

uint EraseAttackPlane(Critter&npc,uint critId)
{
	NpcPlane@[]planes;
	uint count=npc.GetPlanes(planes);
	if(count==0)
	return 0;
	
	uint erased=0;
	for(uint i=0;i<count;i++)
	{
		if(planes[i].Attack_TargId==critId&&npc.ErasePlane(i-erased))
		erased++;
	}
	
	return erased;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

class CIMP
{
	bool Destroible;
	
	uint16 TileGroup;
	
	uint16 HexX;
	uint16 HexY;
	uint Hash;
	
	Item@Object;
	
	CIMP()
	{
		@Object=null;
		
		HexX=0;
		HexY=0;
		Hash=0;
		
		Destroible=false;
	}
	
	CIMP(uint hash,Item&item,bool destroible)
	{
		Hash=hash;
		@Object=item;
		
		Destroible=destroible;
		
		if(SetPic())
		{
			HexX=Object.HexX;
			HexY=Object.HexY;
		}
	}
	
	CIMP(uint hash,Map&map)
	{
		Spawn(map);
		SetPic(hash);
	}
	
	bool Spawn(Map&map)
	{
		uint16 hexX=0,hexY=0,tempX=0,tempY=0;
		uint hash=0;
		
		map.GetEntireCoords(255,0,hexX,hexY);
		
		tempX=hexX;
		tempY=hexY;
		
		uint count=0;
		bool condition=false;
		
		if(!tileInited)
		{
			InitTiles();
		}
		
		do
		{
			hexX=Random(tempX+1,tempX+(150)-1);
			hexY=Random(tempY+1,tempY+(150)-1);  
			
			hash=map.GetTile(((hexX)>>1),((hexY)>>1));
			
			for(uint i=1;i<=32;++i)
			{
				if((((TileGroup)&(pow(2,i)))!=0))
				{
					condition=IsTileAvalible(hash,i);
					if(condition)
					{
						Log("cond");
						break;
					}
				}
			}
			
			count++;  
			
		}
		while(!map.IsHexPassed(hexX,hexY));
		
		@Object=map.AddItem(hexX,hexY,(904),1);
		
		if(!(Object is null))
		{
			Object.SetEvent((4),"cimp@e_SkillImp");
		}   
		
		HexX=hexX;
		HexY=hexY;
		
		return(!(Object is null));
	}
	
	private bool SetMapPic(uint hash)
	{
		if(Object is null)
		return false;
		
		Object.SetMapPic(hash);
		Object.Update();
		return true;
	}
	
	bool SetPic()
	{
		return SetMapPic(Hash);
	}
	
	bool SetPic(uint hash)
	{
		return SetMapPic(hash);
		
	}  
	
	Item@GetObject()
	{
		return@Object;
	}   
	
}

bool e_SkillImp(Item&item,Critter&cr,int skill)
{
	
	if(skill==(-3))
	{
		Item@[]items;
		item.GetItems(-1,items);
		if(items.length()==1)
		{
			DeleteItem(item);
			return true;
		}
	}
	return false;
}

class CLO:CIMP
{
	
	int RechLevel;
	uint16 GroupType;
	
	RespawnedItemGroup@Group;
	
	CLO()
	{
		Destroible=false;
		RechLevel=0;
		GroupType=uint16(-1);
		@Group=null;
	}
	
	CLO(uint16 groupType,int rechLvl,bool destroible)
	{
		Destroible=false;
		RechLevel=rechLvl;
		GroupType=groupType;
		
		@Group=GetItemGroup(GroupType);
		TileGroup=Group.TileGroup;
		Destroible=destroible;  
		
		if(Group is null)
		Log("NULL!!"); 
		
	}
	
	bool SpawnInto()
	{
		if(Group is null||Object is null)
		{
			Log("NULL!!");
			return false;
		}
		
		Map@map=GetMap(Object.MapId);
		if(map is null)
		{
			return false;
		}
		else
		{
			if(Group.MapProtos.find(map.GetProtoId())==-1)
			{
				
				DeleteItem(Object);
				return false;
			}
		}
		
		int len=RechLevel;
		
		if(RechLevel==-1)
		len=Group.Length();
		
		for(uint16 i=0;i<len;++i)
		{
			uint8 chance=Random(0,95);
			uint16 index=(RechLevel!=-1?Random(0,Group.Length()-1):i);
			
			if(Group.RespItems[index].Chance<chance)
			continue;
			
			uint8 count=0;
			uint16 pid=0;
			
			Group.GetItem(index,pid,count);  
			
			if(GetObject()is null)
			{
				Log("NULL!!OBJ");
				return false;
			}
			count=(RechLevel!=-1?Random(1,count):count);
			Object.AddItem(pid,count,0);
		}
		
		return true;
		
	}
	
	bool SpawnMap(Map&map)
	{
		return Spawn(map);
		
	}
	
	bool Add(Map&map)
	{
		return Spawn(map)&&SetPic(GetLOHash(GroupType))&&SpawnInto();
		
	}
}

class RespawnedItem
{
	uint8 Chance;
	uint8 Count;
	uint16 Pid;
	
	RespawnedItem()
	{
		Chance=0;
		Count=0;
		Pid=0;
	}
	
	RespawnedItem(uint16 pid,uint8 chance,uint8 count)
	{
		Chance=chance;
		Count=count;
		Pid=pid;
	} 
	
}

class RespawnedItemGroup
{
	RespawnedItem[]RespItems;
	uint[]MapProtos;
	uint TileGroup;
	
	RespawnedItemGroup()
	{
		RespItems.resize(0);
	}
	
	uint16 Length()
	{
		return RespItems.length();
	}
	
	bool GetItem(uint16 index,uint16&pid,uint8&count)
	{
		if(index>=RespItems.length())
		return false;
		
		pid=RespItems[index].Pid;
		count=RespItems[index].Count;
		
		return true;
	}
}                                                                                          

class GroupRock:RespawnedItemGroup
{
	GroupRock()
	{
		
		RespItems.insertLast(RespawnedItem((19),50,5));
		RespItems.insertLast(RespawnedItem((536),3,1));
		RespItems.insertLast(RespawnedItem((537),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
	}
} 

class GroupAnimalCorpse:RespawnedItemGroup
{
	GroupAnimalCorpse()
	{
		
		RespItems.insertLast(RespawnedItem((539),1,2));
		RespItems.insertLast(RespawnedItem((1440),3,3));
		RespItems.insertLast(RespawnedItem((449),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
	}
} 

class GroupSmallTrash:RespawnedItemGroup
{
	GroupSmallTrash()
	{
		
		RespItems.insertLast(RespawnedItem((439),3,5));
		RespItems.insertLast(RespawnedItem((98),3,2));
		RespItems.insertLast(RespawnedItem((532),2,5));
		RespItems.insertLast(RespawnedItem((542),2,5));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),1,2));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupTrash:RespawnedItemGroup
{
	GroupTrash()
	{
		
		RespItems.insertLast(RespawnedItem((439),3,2));
		RespItems.insertLast(RespawnedItem((98),3,1));
		RespItems.insertLast(RespawnedItem((532),5,2));
		RespItems.insertLast(RespawnedItem((542),4,2));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),2,1));
		RespItems.insertLast(RespawnedItem((227),1,1));
		RespItems.insertLast(RespawnedItem((226),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
} 

class GroupSleeper:RespawnedItemGroup
{
	GroupSleeper()
	{
		
		RespItems.insertLast(RespawnedItem((572),5,3));
		RespItems.insertLast(RespawnedItem((40),1,1));
		RespItems.insertLast(RespawnedItem((48),1,1));
		RespItems.insertLast(RespawnedItem((259),1,1));
		RespItems.insertLast(RespawnedItem((4),1,1));
		RespItems.insertLast(RespawnedItem((314),1,1));
		RespItems.insertLast(RespawnedItem((315),1,1));
		RespItems.insertLast(RespawnedItem((316),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupBox:RespawnedItemGroup
{
	GroupBox()
	{
		
		RespItems.insertLast(RespawnedItem((227),3,1));
		RespItems.insertLast(RespawnedItem((226),3,1));
		RespItems.insertLast(RespawnedItem((79),1,1));
		RespItems.insertLast(RespawnedItem((98),3,3));
		RespItems.insertLast(RespawnedItem((475),1,2)); 
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}  

class GroupMetalTrash:RespawnedItemGroup
{
	GroupMetalTrash()
	{ 
		
		RespItems.insertLast(RespawnedItem((297),3,1));
		RespItems.insertLast(RespawnedItem((475),3,1));
		RespItems.insertLast(RespawnedItem((1475),3,1));
		RespItems.insertLast(RespawnedItem((538),3,1));
		RespItems.insertLast(RespawnedItem((50),3,1));
		RespItems.insertLast(RespawnedItem((1508),3,1));
		RespItems.insertLast(RespawnedItem((1502),3,1));
		RespItems.insertLast(RespawnedItem((1504),3,1));
		RespItems.insertLast(RespawnedItem((1505),3,1));
		RespItems.insertLast(RespawnedItem((1509),3,1));
		RespItems.insertLast(RespawnedItem((1510),3,1));
		RespItems.insertLast(RespawnedItem((1507),3,1));
		RespItems.insertLast(RespawnedItem((1506),3,1));
		RespItems.insertLast(RespawnedItem((1503),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupNewspMachine:RespawnedItemGroup
{
	GroupNewspMachine()
	{
		
		RespItems.insertLast(RespawnedItem((41),3,2));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=4;
	}
}

class GroupBottleBox:RespawnedItemGroup
{
	GroupBottleBox()
	{
		
		RespItems.insertLast(RespawnedItem((532),10,2));
		RespItems.insertLast(RespawnedItem((542),15,3));
		RespItems.insertLast(RespawnedItem((124),2,3));
		RespItems.insertLast(RespawnedItem((125),2,3));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupPlant:RespawnedItemGroup
{
	GroupPlant()
	{ 
		
		RespItems.insertLast(RespawnedItem((271),100,2));
		RespItems.insertLast(RespawnedItem((272),100,3));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupCorpse:RespawnedItemGroup
{
	GroupCorpse()
	{
		
		RespItems.insertLast(RespawnedItem((4),1,1));
		RespItems.insertLast(RespawnedItem((532),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupEvilMinds:RespawnedItemGroup
{
	GroupEvilMinds()
	{
		RespItems.insertLast(RespawnedItem((349),100,1));
		
		RespItems.insertLast(RespawnedItem((401),100,1));
		RespItems.insertLast(RespawnedItem((1036),100,1));
		RespItems.insertLast(RespawnedItem((405),100,1));
		
		RespItems.insertLast(RespawnedItem((35),100,10));
		RespItems.insertLast(RespawnedItem((1035),100,24));
		RespItems.insertLast(RespawnedItem((39),100,100));
		
	}
} 

uint GetLOHash(uint16 groupType)
{
	string temp="art\\scenery\\";
	string[]tempAdd;
	switch(groupType)
	{                            
		
		case(100):
		tempAdd.insertLast("locker5.frm");
		break;
		
		case(10):
		tempAdd.insertLast("dead01.frm");
		tempAdd.insertLast("dead02.frm");
		tempAdd.insertLast("dead03.frm");
		tempAdd.insertLast("dead04.frm");
		tempAdd.insertLast("v13bones.frm");
		tempAdd.insertLast("bone01.frm");
		tempAdd.insertLast("bone03.frm");
		break;
		
		case(9): 
		
		tempAdd.insertLast("weed06.frm");
		tempAdd.insertLast("weed07.frm");
		break;
		
		case(8):
		tempAdd.insertLast("crate01.frm");
		tempAdd.insertLast("crate02.frm");
		tempAdd.insertLast("crate03.frm");
		break;
		
		case(7):
		tempAdd.insertLast("mailbx.frm");
		tempAdd.insertLast("newsp1.frm");
		tempAdd.insertLast("newsp2.frm");
		tempAdd.insertLast("newsp3.frm");
		tempAdd.insertLast("newsp4.frm");
		tempAdd.insertLast("newsp5.frm");
		tempAdd.insertLast("newsp6.frm");
		tempAdd.insertLast("novbud1.frm");
		tempAdd.insertLast("novbud2.frm");
		break;
		
		case(6):
		tempAdd.insertLast("junk1.frm");
		tempAdd.insertLast("junk2.frm");
		tempAdd.insertLast("junk3.frm");
		tempAdd.insertLast("junk4.frm");
		tempAdd.insertLast("junk5.frm");
		break;
		
		case(5):
		tempAdd.insertLast("boxes1.frm");
		tempAdd.insertLast("boxes2.frm");
		tempAdd.insertLast("boxes3.frm");
		tempAdd.insertLast("boxes4.frm");
		tempAdd.insertLast("njunk5.frm");
		tempAdd.insertLast("njunk6.frm");
		tempAdd.insertLast("boxes02.frm");
		tempAdd.insertLast("boxes03.frm");
		tempAdd.insertLast("boxes04.frm");
		break;
		
		case(4):
		tempAdd.insertLast("bed1.frm");
		tempAdd.insertLast("bed2.frm");
		tempAdd.insertLast("bed3.frm");
		tempAdd.insertLast("bed4.frm");
		tempAdd.insertLast("bed5.frm");
		tempAdd.insertLast("bed6.frm");
		tempAdd.insertLast("bed7.frm");
		tempAdd.insertLast("bed8.frm");
		break;
		
		case(3):
		tempAdd.insertLast("trashcn.frm");
		tempAdd.insertLast("kont1.frm");
		tempAdd.insertLast("kontsmet.frm");
		tempAdd.insertLast("weed05.frm");
		break;
		
		case(2):
		tempAdd.insertLast("weed06.frm");
		tempAdd.insertLast("weed07.frm");
		tempAdd.insertLast("weed08.frm");
		tempAdd.insertLast("weed09.frm");
		tempAdd.insertLast("weed15.frm");
		tempAdd.insertLast("weed16.frm");
		tempAdd.insertLast("weed17.frm");
		tempAdd.insertLast("trash1.frm");
		tempAdd.insertLast("trash2.frm");
		tempAdd.insertLast("trash3.frm");
		break;
		
		case(1):
		tempAdd.insertLast("bone05.frm");
		tempAdd.insertLast("bone04.frm");
		tempAdd.insertLast("bone02.frm");
		break;
		
		case(0):
		tempAdd.insertLast("rock01.frm");
		tempAdd.insertLast("rock02.frm");
		tempAdd.insertLast("rock04.frm");
		tempAdd.insertLast("rock05.frm");
		tempAdd.insertLast("rock09.frm");
		tempAdd.insertLast("rock10.frm");
		tempAdd.insertLast("rubble1.frm");
		tempAdd.insertLast("drock1.frm");
		tempAdd.insertLast("drock2.frm");
		tempAdd.insertLast("drock3.frm");
		tempAdd.insertLast("drock4.frm");
		tempAdd.insertLast("drock8.frm");
		break;
		
		default:
		break;
	}
	
	temp+=tempAdd[Random(0,tempAdd.length()-1)]; 
	
	return GetStrHash(temp);
} 

RespawnedItemGroup@GetItemGroup(uint16 groupType)
{
	RespawnedItemGroup@temp;
	switch(groupType)
	{    
		
		case(100):
		@temp=GroupEvilMinds();
		break;
		
		case(10):
		@temp=GroupCorpse();
		break;
		case(9):
		@temp=GroupPlant();
		break;
		case(8):
		@temp=GroupBottleBox();
		break;
		case(7):
		@temp=GroupNewspMachine();
		break;
		case(6):
		@temp=GroupMetalTrash();
		break;
		case(5):
		@temp=GroupBox();
		break;
		case(4):
		@temp=GroupSleeper();
		break;
		case(3):
		@temp=GroupTrash();
		break;
		case(2):
		@temp=GroupSmallTrash();
		break;
		case(1):
		@temp=GroupAnimalCorpse();
		break;
		case(0):
		@temp=GroupRock();
		break;
		default:
		@temp=null;
		break;
	}
	
	if(temp is null)
	Log("NULL!!!");
	
	return@temp;
}

bool tileInited=false;

uint[][]tileGroups((8));

void InitTiles()
{ 
	
	uint[]@data=tileGroups[(1)];
	
	data.resize(0);            
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"road0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=10;i<=43;++i)
	{
		string temp=("art/tiles/")+"road"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(3)];
	data.resize(0);
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"curb0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=1;i<=5;++i)
	{
		string temp=("art/tiles/")+"road0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(2)];
	data.resize(0);
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg100"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg200"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=1;++i)
	{
		string temp=("art/tiles/")+"edg300"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=8;++i)
	{
		string temp=("art/tiles/")+"edg400"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=8;++i)
	{
		string temp=("art/tiles/")+"edg500"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=9;++i)
	{
		string temp=("art/tiles/")+"edg600"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=1;++i)
	{
		string temp=("art/tiles/")+"edg601"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg700"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=4;++i)
	{
		string temp=("art/tiles/")+"eds00"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(6)];
	data.resize(0);  
	
	data.insertLast(GetStrHash(("art/tiles/")+"cav4008"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4009"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4010"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4011"+(".frm"))); 
	
	@data=tileGroups[(7)];
	data.resize(0);
	
	for(uint8 i=1;i<=6;++i)
	{
		for(uint8 j=1;j<=7;++j)
		{
			string temp=("art/tiles/")+"bld_floor_"+i+"_"+j+(".png");
			data.insertLast(GetStrHash(temp));
		}
	}
	
	for(uint8 i=1;i<=5;++i)
	{
		string temp=("art/tiles/")+"bld_floor_7_"+i+(".png");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=3;i<=5;++i)
	{
		string temp=("art/tiles/")+"bld_floor_8_"+i+(".png");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(5)];
	data.resize(0);
	
	for(uint8 i=0;i<=9;++i)
	{
		string temp=("art/tiles/")+"cav100"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"cav200"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=5;++i)
	{
		string temp=("art/tiles/")+"cav300"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=7;++i)
	{
		string temp=("art/tiles/")+"cav400"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(4)];
	data.resize(0);
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"brick0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=10;i<=13;++i)
	{
		string temp=("art/tiles/")+"brick"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	tileInited=true;     
	
}                               

bool IsTileAvalible(uint hash,uint8 group)
{
	uint[]@data=tileGroups[group];
	
	for(uint16 i=0,j=data.length();i<j;++i)
	{
		
		if(data[i]==hash)
		{
			Log("hash "+data[i]+":"+hash);
			return true;
		}
	}
	
	return false;
}

bool IsTileGround(uint hash)
{
	return IsTileAvalible(hash,(6));
}  

import void ActivateMobScript(Map&map)from"mob";
import void SetDeterioration(Item&item,int wearProcent)from"repair";                                          

uint8 timeNum=0;   

uint8 CheckNpcAi(uint16 crType)
{
	uint8 retn=0;
	switch(crType)
	{
		case 5:
		retn=(8);
		break;
		case 9:
		retn=(21);
		break;
		case 11:
		retn=(7);
		break;
		case 80:
		retn=(26);
		break;
		case 83:
		retn=(26);
		break;
		case 85:
		retn=(10);
		break;
		case 113:
		retn=(7);
		break;
		case 117:
		retn=(7);
		break;
		case 119:
		retn=(47);
		break;
		case 177:
		retn=(132);
		break;
		case 249:
		retn=(133);
		break;
		default:
		retn=0;
		break;
	}
	return retn;
} 

void TeleportNpcToMap(Critter&npc)
{    
	
}

void runmobspawn(Critter&player,int param0,int param1,int param2)
{
	Map@map=player.GetMap();
	AddCritter(map);
}

void runitemspawn(Critter&player,int param0,int param1,int param2)
{
	Map@map=player.GetMap();
	FillContainer(map);
}

void ChangeBrokeAndAmmo(Item&item)
{
	if(item.IsDeteriorable())
	{
		SetDeterioration(item,Random(30,90));
		if(item.AmmoCount>0)
		{
			item.AmmoCount=0;
		}
	}
}

void testspawn(Critter&cr,int,int,int)
{
	_MapInit(cr.GetMap(),true);
}

void _MapInit(Map&map,bool firstTime)
{   
	
}

uint e_SpawnStuff(uint[]@values)
{
	
	Map@map=GetMap(values[0]);
	if(!(@map!=null))
	return 0;
	FillContainer(map);
	SpawnLO(map);
	
	EraseTimeEvent(map.GetData((1)));
	timeNum=CreateTimeEvent(__FullSecond+(60*60*2*__TimeMultiplier),"e_SpawnStuff",values,false);
	map.SetData((1),timeNum);
	timeNum=0;
	return 0;
}

string msg;

void FillContainer(Map&map)
{
	Item@[]containers;
	uint16 itemPid=0;
	map.GetItemsByType((8),containers);
	if((@containers!=null)&&containers.length()!=0)
	{
		Item@item;
		for(uint16 i=0;i<containers.length();i++)
		{
			Item@[]contBag;
			
			if(containers[i]is null)
			continue;
			if(containers[i].GetProtoId()==(904))
			{
				DeleteItem(containers[i]);
				continue;
			}
			
			containers[i].GetItems((0),contBag);
			if((@contBag!=null)&&contBag.length()==0)
			{
				itemPid=Random(0,(sutterGroup.length()/3)-1);
				if(sutterGroup[itemPid*3]>Random(0,9))
				{
					@item=containers[i].AddItem(sutterGroup[itemPid*3+2],Random(1,sutterGroup[itemPid*3+1]),(0));
					i+=Random(0,Random(1,4));
				}
				if((@item!=null))ChangeBrokeAndAmmo(item);
			}
		}
	}
}                                                                                                                                                                                                                                 

bool critters_inited=false;

uint16[][]CritterInfo(((32)+1)*(3));

bool CritterInfoInit()
{
	
	uint16[]@data0;
	uint16[]@data1;
	uint16[]@data2;
	
	uint16[]pids(0);
	uint16[]count(0);
	uint16[]spawns(0);   
	
	for(uint16 i=0;i<(32);++i)
	{
		pids.insertLast((310)+i);
		count.insertLast(6);
		spawns.insertLast((200)+i);
	} 
	
	for(uint8 i=0;i<(32);i++)
	{
		
		@data0=CritterInfo[i*(3)+(1)]; 
		
		@data1=CritterInfo[i*(3)+(2)]; 
		
		@data2=CritterInfo[i*(3)+(3)]; 
		
		for(uint16 i=0;i<(32);++i)
		{
			data0.insertLast((310)+i);
			data1.insertLast((200)+i);
			data2.insertLast(6);
		}
		
	}  
	
	critters_inited=true;
	
	return true;
	
}           

void AddCritter(Map&map)
{
	
	if(!critters_inited)
	CritterInfoInit();
	
	if(map.GetProtoId()<(60)||map.GetProtoId()>(91))
	return;
	
	uint16 index=(map.GetProtoId()-(60));
	
	uint16[]@pids=CritterInfo[index*(3)+(1)];
	uint16[]@counts=CritterInfo[index*(3)+(3)];
	uint16[]@spawns=CritterInfo[index*(3)+(2)];  
	
	if(pids.length()!=counts.length()||pids.length()!=spawns.length()||spawns.length()!=counts.length())
	{
		Log("len error");
		return;
	}
	
	uint16[]max_count={GetLocalVar((310),map.Id).GetValue(),
		GetLocalVar((311),map.Id).GetValue(),
		GetLocalVar((312),map.Id).GetValue(),
		GetLocalVar((313),map.Id).GetValue(),
		GetLocalVar((314),map.Id).GetValue(),
		GetLocalVar((315),map.Id).GetValue(),
		GetLocalVar((316),map.Id).GetValue(),
		GetLocalVar((317),map.Id).GetValue(),
		GetLocalVar((318),map.Id).GetValue(),
		GetLocalVar((319),map.Id).GetValue(),
		GetLocalVar((320),map.Id).GetValue(),
		GetLocalVar((321),map.Id).GetValue(),
		GetLocalVar((322),map.Id).GetValue(),
		GetLocalVar((323),map.Id).GetValue(),
		GetLocalVar((324),map.Id).GetValue(),
		GetLocalVar((325),map.Id).GetValue(),
		GetLocalVar((326),map.Id).GetValue(),
		GetLocalVar((327),map.Id).GetValue(),
		GetLocalVar((328),map.Id).GetValue(),
		GetLocalVar((329),map.Id).GetValue(),
		GetLocalVar((330),map.Id).GetValue(),
		GetLocalVar((335),map.Id).GetValue(),
		GetLocalVar((336),map.Id).GetValue(),
		GetLocalVar((337),map.Id).GetValue(),
		GetLocalVar((338),map.Id).GetValue(),
		GetLocalVar((339),map.Id).GetValue(),
		GetLocalVar((340),map.Id).GetValue(),
		GetLocalVar((341),map.Id).GetValue(),
		GetLocalVar((342),map.Id).GetValue(),
		GetLocalVar((343),map.Id).GetValue(),
		GetLocalVar((344),map.Id).GetValue(),
		GetLocalVar((345),map.Id).GetValue(),
		GetLocalVar((346),map.Id).GetValue(),
		GetLocalVar((347),map.Id).GetValue(),
		GetLocalVar((348),map.Id).GetValue(),
		GetLocalVar((349),map.Id).GetValue()};
	
	for(uint8 i=0,j=pids.length();i<j;++i)
	{
		uint8 jj=map.CountEntire(spawns[i]);
		uint8 entNum=spawns[i];
		uint16 pid=pids[i];
		uint16 cur_count=map.GetCritters(pid,(0x03)|(0x20),null);
		
		if(cur_count>=max_count[i])continue;
		
		uint8 teamId=Random(24,33);
		
		for(uint8 ii=0;ii<jj;++ii)
		{
			
			uint16 hexX=0,hexY=0,tempX=0,tempY=0;
			
			map.GetEntireCoords(entNum,ii,hexX,hexY);
			
			tempX=hexX;
			tempY=hexY;
			
			uint8 count=counts[i];
			
			for(uint8 iii=0;iii<count;++iii)
			{
				
				while(!map.IsHexPassed(tempX,tempY))
				{
					tempX=hexX+Random(-10,10);
					tempY=hexY+Random(-10,10);
					
				}
				;
				
				if(cur_count<max_count[i])
				{
					Critter@npc=map.AddNpc(pid,tempX,tempY,Random(0,5),null,null,"mob@_MobInit");
					cur_count++;
					
					if(npc is null)
					continue;
					
					npc.StatBase[(105)]=CheckNpcAi(npc.CrType);
					npc.StatBase[(106)]=teamId;
				} 
				
			}
		}
	}
}                                  

const uint16[]critterTypes_20=
{
	80,
	83
};

const uint8[]critterPopul_20=
{
	10,
	10
};

const uint8[]critterSpawn_20=
{
	52,
	151
};   

const uint16[]critterTypes_101=
{
	5,
	9,
	11,
	85,
	113,
	117,
	119,
	246,
	249
};

const uint8[]critterPopul_101=
{
	20,
	20,
	40,
	5,
	20,
	7,
	5,
	5,
	5
};

const uint8[]critterSpawn_101=
{
	34,
	30,
	31,
	38,
	32,
	33,
	37,
	35,
	36
};

const uint16[]sutterGroup=
{  
	
	10,1,(79),
	10,2,(19),
	10,5,(79),
	10,5,(19),
	10,5,(365),
	1,1,(40),
	1,1,(49),
	5,1,(469),
	10,50,(519),
	7,1,(4),
	4,2,(127),
	10,9,(572),
	3,1,(276),
	10,1,(277),
	10,2,(278),
	10,2,(416),
	10,2,(542),
	8,3,(532),
	10,10,(534),
	9,3,(475),
	8,3,(536),
	7,2,(537),
	7,1,(538),
	5,1,(50),
	1,1,(449),
	4,1,(541),
	1,1,(289),
	3,1,(297),
	2,1,(543),
	3,1,(101),
	4,1,(300),
	10,10,(1430),
	7,10,(1431),
	3,12,(1432),
	5,15,(1433),
	3,10,(1434),
	1,1,(1435),
	10,7,(1436),
	1,1,(1437),
	10,1,(1440),
	10,1,(1423),
	8,1,(1425),
	5,1,(1426),
	1,1,(1427),
	10,1,(1420),
	1,1,(1406),
	1,1,(1407),
	3,1,(1473),
	6,1,(1474),
	2,1,(1475),
	5,1,(1477),
	5,2,(1478),
	6,3,(1490),
	8,1,(1502),
	5,1,(1503),
	4,1,(1504),
	8,1,(1505),
	1,1,(1506),
	4,1,(1507),
	7,1,(1508),
	9,1,(1509),
	4,1,(1510),
	3,1,(1511),
	3,1,(1512),
	1,1,(1513),
	1,1,(1516),
	4,1,(1517),
	7,1,(1519),
	2,1,(1548),
	1,1,(1322),
	6,3,(273),
	1,1,(318),
	5,2,(1321),
	1,1,(1323),
	1,1,(1324),
	2,1,(1325),
	4,1,(1326),
	1,1,(1320)
};

void additemsrndpic(Critter&cr,int id,int x,int y)
{
	Map@map=cr.GetMap();
	if(map is null)
	{
		cr.Say((11),"map");
		return;
	}
	
	for(uint8 i=0;i<x;++i)
	{
		Item@item=map.AddItem(cr.HexX+(Random(-10,10)),cr.HexY+(Random(-10,10)),2004,1);
		if(item is null)
		continue;                    
		
		uint hash=GetStrHash("art\\scenery\\corpse1.png"); 
		
		item.SetMapPic(hash);
		
		cr.Say((11),"add "+hash);
	}
	
}  

void setpic(Critter&cr,int id,int x,int y)
{
	Item@item=GetItem(id);
	if(item is null)
	return;
	string temp="art\\scenery\\";
	temp+="boxes3.frm";
	item.SetMapPic(GetLOHash((3)));
	item.Update();
}

void itemrndpic(Critter&cr,int id,int x,int y)
{     
	
	CLO@clo=CLO((3),100,false);
	Map@map=cr.GetMap();
	if(clo is null)
	{
		cr.Say((11),"clo null");
	}
	if(map is null)
	{
		cr.Say((11),"map null");
	}
	
	string msg_="fail.";
	
	if(clo.Add(map))
	{
		msg_=("succesfull "+clo.HexX+":"+clo.HexY+"\n clo : "+clo.Hash);
		
		if(!cr.TransitToHex(clo.HexX,clo.HexY,1))
		{
			cr.ShowContainer(cr,clo.Object,0);
		}
	}
	
	cr.Say((11),msg_);
}
void forcespawn(Critter&cr,int id,int x,int y)
{
	Map@map=(id<=0?cr.GetMap():GetMap(id));
	if(map is null)
	{
		cr.Say((11),"null map");
		return;
	}
	if(x>0)
	{
		FillContainer(map);
	}
	SpawnLO(map);
}   

bool SpawnLO(Map&map)
{
	int rechLvl=(1000);
	for(uint16 i=0;i<(100);++i)
	{
		uint8 temp=Random(1,99);
		rechLvl-=temp;
		if(rechLvl>0)
		{
			CLO@clo=CLO(Random(0,(11)-1),temp,false);
			
			if(clo is null)
			{
				Log("clo null");
			}
			
			clo.Add(map); 
			
		}
		
	}
	return true;
}

bool SpawnItemCell(uint mapId)
{
	Map@map=GetMap(mapId);
	if(!(map is null))
	{
		FillContainer(map);
		SpawnLO(map);
		return true;
	}
	
	return false;
}
