                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

import bool AddAttackPlane(Critter&npc,uint priority,Critter&target)from"npc_planes";                                                            

uint[][]PositionDirs=
{
	{0},
	
	{1,4,3,2,1,0,5,2,3,4,5,0,1},
	{1,5,0,1,2,3,4,1,0,5,4,3,2},
	{1,4,2},
	{1,5,1},
	{2,1,2,4,5},
	{2,1,2,4,5}
};                                                                                                                                                                                                                        

class CCheck
{
	uint Type;
	uint Index;
	uint8 Operator;
	int Value;
	
	CCheck()
	{
		Type=0;
		Index=0;
		Operator=0;
		Value=0;
	}
	
	void Set(uint type,uint index,uint8 operator,int value)
	{
		Type=type;
		Index=index;
		Operator=operator;
		Value=value;
	}
}

class CEncounterObject
{
	uint ObjectType;
	uint16 Pid;
	uint DialogId;
	string ScriptName;
	uint DistanceLength;
	CEncounterObject@[]Childs;
	CCheck[]Checks;
	
	uint RatioValue;
	bool IsDead;
	
	uint Minimum;
	uint Maximum;
	uint InvSlot;
	
	CEncounterObject()
	{
		ObjectType=0;
		Pid=0;
		DialogId=0;
		ScriptName="";
		DistanceLength=0;
		RatioValue=0;
		IsDead=false;
		Minimum=0;
		Maximum=0;
		InvSlot=0;
	}
	
	CEncounterObject@NewCheck(uint type,uint index,uint8 operator,int value)
	{
		Checks.grow(1);
		Checks.last().Set(type,index,operator,value);
		return this;
	}
	
	CEncounterObject@Dialog(uint dialog)
	{
		DialogId=dialog;
		return this;
	}
	CEncounterObject@Script(string&script)
	{
		ScriptName=script;
		return this;
	}
	CEncounterObject@Distance(uint distance)
	{
		DistanceLength=distance;
		return this;
	}
	CEncounterObject@CheckRandom(int value)
	{
		NewCheck((0),0,0,value);
		return this;
	}
	CEncounterObject@CheckParam(uint index,uint8 operator,int value)
	{
		NewCheck((1),index,operator,value);
		return this;
	}
	CEncounterObject@CheckParamAny(uint index,uint8 operator,int value)
	{
		NewCheck((6),index,operator,value);
		return this;
	}
	CEncounterObject@CheckLVar(uint index,uint8 operator,int value)
	{
		NewCheck((2),index,operator,value);
		return this;
	}
	CEncounterObject@CheckLVarAny(uint index,uint8 operator,int value)
	{
		NewCheck((5),index,operator,value);
		return this;
	}
	CEncounterObject@CheckGVar(uint index,uint8 operator,int value)
	{
		NewCheck((3),index,operator,value);
		return this;
	}
	CEncounterObject@CheckHour(uint8 operator,int value)
	{
		NewCheck((4),0,operator,value);
		return this;
	}
	CEncounterObject@Ratio(uint ratio)
	{
		RatioValue=ratio;
		return this;
	}
	CEncounterObject@Dead(bool dead)
	{
		IsDead=dead;
		return this;
	}
	CEncounterObject@Slot(uint slot)
	{
		InvSlot=slot;
		return this;
	}
	
	CEncounterObject@AddItem(uint16 pid,uint min,uint max,uint slot)
	{
		CEncounterObject new_child;
		Childs.insertLast(@new_child);
		new_child.Pid=pid;
		new_child.Minimum=min;
		new_child.Maximum=max;
		new_child.InvSlot=slot;
		return this;
	}
}

class CEncounterGroup
{
	uint TeamNum;
	uint Position;
	uint Spacing;
	uint Distance;
	CEncounterObject[]Objects;
	
	CEncounterGroup()
	{
		TeamNum=0;
		Position=0;
		Spacing=0;
		Distance=0;
	}
	
	CEncounterObject@NewObject()
	{
		Objects.grow(1);
		return Objects.last();
	}
	
	CEncounterObject@AddCritter(uint16 pid)
	{
		CEncounterObject@obj=NewObject();
		obj.ObjectType=(1);
		obj.Pid=pid;
		return obj;
	}
	
	CEncounterObject@AddItem(uint16 pid)
	{
		CEncounterObject@obj=NewObject();
		obj.ObjectType=(2);
		obj.Pid=pid;
		return obj;
	}
}

class CEncounter
{
	uint Chance;
	uint StrNum;
	uint16 LocPid;
	bool IsSpecial;
	uint[]Groups;
	uint[]RatioMin;
	uint[]RatioMax;
	uint[]Actions;
	CCheck[]Checks;
	
	CEncounter()
	{
		Chance=0;
		StrNum=0;
		LocPid=0;
		IsSpecial=false;
	}
	
	CEncounter@AddGroup(uint group,uint ratioMin,uint ratioMax)
	{
		Groups.grow(1);
		RatioMin.grow(1);
		RatioMax.grow(1);
		Groups.last()=group;
		RatioMin.last()=ratioMin;
		RatioMax.last()=ratioMax;
		return this;
	}
	
	CEncounter@Fighting(uint fromGroup,uint toGroup)
	{
		Actions.insertLast(fromGroup);
		Actions.insertLast(toGroup);
		Actions.insertLast((1));
		return this;
	}
	
	CEncounter@NewCheck(uint type,uint index,uint8 operator,int value)
	{
		Checks.grow(1);
		Checks.last().Set(type,index,operator,value);
		return this;
	}
	
	CEncounter@LocationPid(uint16 locationPid)
	{
		LocPid=locationPid;
		return this;
	}
	CEncounter@Special(bool special)
	{
		IsSpecial=special;
		return this;
	}
	CEncounter@CheckRandom(int value)
	{
		NewCheck((0),0,0,value);
		return this;
	}
	CEncounter@CheckParam(uint index,uint8 operator,int value)
	{
		NewCheck((1),index,operator,value);
		return this;
	}
	CEncounter@CheckParamAny(uint index,uint8 operator,int value)
	{
		NewCheck((6),index,operator,value);
		return this;
	}
	CEncounter@CheckLVar(uint index,uint8 operator,int value)
	{
		NewCheck((2),index,operator,value);
		return this;
	}
	CEncounter@CheckLVarAny(uint index,uint8 operator,int value)
	{
		NewCheck((5),index,operator,value);
		return this;
	}
	CEncounter@CheckGVar(uint index,uint8 operator,int value)
	{
		NewCheck((3),index,operator,value);
		return this;
	}
	CEncounter@CheckHour(uint8 operator,int value)
	{
		NewCheck((4),0,operator,value);
		return this;
	}
	CEncounter@AssignLVar(uint index,uint8 operator,int value)
	{
		NewCheck((10),index,operator,value);
		return this;
	}
}

class CEncounterTable
{
	uint16[]LocationPids;
	CEncounter[]Encounters;
	
	void AddLocationPid(uint16 locationPid)
	{
		LocationPids.insertLast(locationPid);
	}
	
	CEncounter@AddEncounter(uint chance,uint strNum)
	{
		Encounters.grow(1);
		Encounters.last().Chance=chance;
		Encounters.last().StrNum=strNum;
		return@Encounters.last();
	}
}

class CZone
{
	int Difficulty;
	uint Terrain;
	uint Fill;
	uint MorningChance;
	uint AfternoonChance;
	uint NightChance;
	CEncounterTable@Table;
	
	CZone()
	{
		Difficulty=0;
		Terrain=0;
		Fill=0;
		MorningChance=0;
		AfternoonChance=0;
		NightChance=0;
		@Table=null;
	}
}

CEncounterGroup[]EncounterGroups((114));
CEncounterTable[]EncounterTables((96));
CZone[]Worldmap((7)*(12));    

void SetZone(uint zx,uint zy,uint table,int difficulty,uint terrain,uint fill,uint morningChance,uint afternoonChance,uint nightChance)
{
	CZone@zone=Worldmap[zy*(7)+zx];
	@zone.Table=EncounterTables[table];
	zone.Difficulty=difficulty;
	zone.Terrain=terrain;
	zone.Fill=fill;
	zone.MorningChance=morningChance;
	zone.AfternoonChance=afternoonChance;
	zone.NightChance=nightChance;
}

void SetZone(uint zx,uint zy,uint table,int difficulty,uint terrain,uint fill,uint chance)
{
	SetZone(zx,zy,table,difficulty,terrain,fill,chance,chance,chance);
}    

void AddTableToAllTables(CEncounterTable&globalTable)
{
	for(uint i=0;i<(96);i++)
	{
		CEncounterTable@table=EncounterTables[i];
		
		for(uint j=0;j<globalTable.LocationPids.length();j++)
		{
			table.LocationPids.grow(1);
			table.LocationPids.last()=globalTable.LocationPids[j];
		}
		
		for(uint j=0;j<globalTable.Encounters.length();j++)
		{
			table.Encounters.grow(1);
			table.Encounters.last()=globalTable.Encounters[j];
		}
	}
}    

bool CheckCompare(int val1,uint8 operator,int val2)
{
	if(operator==62)
	return val1>val2;
	if(operator==60)
	return val1<val2;
	if(operator==61)
	return val1==val2;
	Log("Unknown operator.");
	return false;
}

void CheckAssignVar(GameVar&val1,uint8 operator,int val2)
{
	if(operator==61)
	val1=val2;
	else if(operator==43)
	val1+=val2;
	else if(operator==45)
	val1-=val2;
	else if(operator==42)
	val1*=val2;
	else if(operator==47)
	val1/=val2;
	else
	Log("Unknown operator.");
}

bool CheckChecks(CCheck[]&checks,Critter@[]&critters)
{
	for(int i=0,j=checks.length();i<j;i++)
	{
		CCheck@check=checks[i];
		switch(check.Type)
		{
			case(0):
			if(Random(1,100)>check.Value)
			return false;
			break;
			case(4):
			if(not CheckCompare(__Hour,check.Operator,check.Value))
			return false;
			break;
			case(1):
			for(uint i=0,j=critters.length();i<j;i++)
			if(not CheckCompare(critters[i].Param[check.Index],check.Operator,check.Value))
			return false;
			break;
			case(2):
			
			for(uint i=0,j=critters.length();i<j;i++)
			{
				GameVar@lvar=GetLocalVar(check.Index,critters[i].Id);
				if(not(@lvar!=null))
				{
					
					return false;
				}
				
				if(not CheckCompare(lvar.GetValue(),check.Operator,check.Value))
				return false;
			}
			break;
			case(3):
			{
				GameVar@gvar=GetGlobalVar(check.Index);
				if(not(@gvar!=null))
				{
					
					return false;
				}
				if(not CheckCompare(gvar.GetValue(),check.Operator,check.Value))
				return false;
			}
			break;
			default:
			continue;
		}
	}
	return true;
}

void AssignChecks(CCheck[]&checks,Critter@[]&critters)
{
	for(int i=0,j=checks.length();i<j;i++)
	{
		CCheck@check=checks[i];
		if(check.Type==(10))
		{
			for(uint i=0,j=critters.length();i<j;i++)
			{
				GameVar@lvar=GetLocalVar(check.Index,critters[i].Id);
				CheckAssignVar(lvar,check.Operator,check.Value);
			}
		}
	}
}     

class CFoundedEncounter
{
	uint Index;
	uint16[]LocationPids;
	CEncounter@Encounter;
	bool IsGenerated;
	uint FullSecond;
	uint PositionX;
	uint PositionY;
	uint OwnerId;
	bool OwnerGroup;
	bool TurnBased;
	uint LocationId;
	uint16 StartHexX;
	uint16 StartHexY;
	bool[]DirBusy;
	uint AskChance;
	
	CFoundedEncounter()
	{
		Index=0;
		@Encounter=null;
		IsGenerated=false;
		FullSecond=0;
		PositionX=0;
		PositionY=0;
		OwnerId=0;
		OwnerGroup=false;
		TurnBased=false;
		LocationId=0;
		StartHexX=0;
		StartHexY=0;
		DirBusy.resize(6);
	}
}

CFoundedEncounter[]FoundedEncounters(1000);
uint FoundedEncountersLastIndex=0;

CFoundedEncounter@CreateFoundedEncounter(uint x,uint y,CEncounter@encounter,uint16[]&locationPids,uint ownerId,bool ownerGroup)
{
	for(int i=0,j=FoundedEncounters.length();i<j;i++)
	{
		CFoundedEncounter@ge=FoundedEncounters[i];
		if(ge.Index==0)
		{
			FoundedEncountersLastIndex++;
			ge.Index=FoundedEncountersLastIndex;
			ge.LocationPids=locationPids;
			@ge.Encounter=encounter;
			ge.IsGenerated=false;
			ge.FullSecond=__FullSecond;
			ge.PositionX=x;
			ge.PositionY=y;
			ge.OwnerId=ownerId;
			ge.OwnerGroup=ownerGroup;
			ge.LocationId=0;
			for(uint k=0;k<6;k++)
			ge.DirBusy[k]=false;
			return ge;
		}
	} 
	
	FoundedEncounters.resize(FoundedEncounters.length()*2);
	return CreateFoundedEncounter(x,y,encounter,locationPids,ownerId,ownerGroup);
}

CFoundedEncounter@GetFoundedEncounter(uint index)
{
	for(int i=0,j=FoundedEncounters.length();i<j;i++)
	{
		CFoundedEncounter@ge=FoundedEncounters[i];
		if(ge.Index==index)
		return ge;
	}
	return null;
}

bool CheckFoundedEncounter(uint index)
{
	return(GetFoundedEncounter(index)!is null);
}

CFoundedEncounter@GetNearFoundedEncounter(Critter@[]@group,uint x,uint y,uint radius)
{
	int combatMode=group[0].Mode[(516)];
	for(int i=0,j=FoundedEncounters.length();i<j;i++)
	{
		CFoundedEncounter@ge=FoundedEncounters[i];
		if(ge.Index==0)
		continue; 
		
		if(__FullSecond-ge.FullSecond<(((10)*__TimeMultiplier*3600))&&ge.IsGenerated&&
		(not(@ge.Encounter!=null)||(not ge.Encounter.IsSpecial&&CheckChecks(ge.Encounter.Checks,group)))&&
		
		(ge.PositionX/10==x/10&&ge.PositionY/10==y/10)&&
		group[0].Id!=ge.OwnerId&&
		(@GetLocation(ge.LocationId)!=null))
		{
			return ge;
		}
	}
	return null;
}

uint GetFreeDir(bool[]&dirBysy)
{
	
	uint dir=Random(0,5);
	if(not dirBysy[dir])
	{
		dirBysy[dir]=true;
		return dir;
	} 
	
	for(uint i=0;i<6;i++)
	{
		if(not dirBysy[i])
		{
			dirBysy[i]=true;
			return i;
		}
	} 
	
	return Random(0,5);
}

void RotatePosition(uint toDir,uint[]&positionsDirs)
{
	for(uint i=1,j=positionsDirs.length();i<j;i++)
	{
		positionsDirs[i]+=toDir;
		if(positionsDirs[i]>5)
		positionsDirs[i]-=6;
	}
}

void MovePositionPoint(Map&map,uint16&pointX,uint16&pointY,uint[]&positionDirs,uint pathIndex,uint count,uint spacing)
{
	uint steps=positionDirs[0];
	uint pathLen=(positionDirs.length()-1)/2;
	count*=steps;
	count%=pathLen;
	if(steps>1)
	{
		for(uint i=0;i<spacing;i++)
		{
			for(uint j=0;j<steps;j++)
			{
				uint dir=positionDirs[1+pathLen*pathIndex+count+j];
				map.MoveHexByDir(pointX,pointY,dir,1);
			}
		}
	}
	else
	{
		uint dir=positionDirs[1+pathLen*pathIndex+count];
		map.MoveHexByDir(pointX,pointY,dir,spacing);
	}
}

void ParseEncounterObject(CEncounterObject@obj,Map@map,uint16 posX,uint16 posY,uint8 reversDir,Critter@[]&crittersGrouop,uint teamId)
{
	if(obj.ObjectType==(1))
	{
		if(not map.IsHexPassed(posX,posY))
		return;
		
		int[]items;
		if(obj.Childs.length()>0)
		{
			for(uint i=0,j=obj.Childs.length();i<j;i++)
			{
				CEncounterObject@child=obj.Childs[i];
				uint count=Random(child.Minimum,child.Maximum);
				if(count>0)
				{
					items.insertLast(child.Pid);
					items.insertLast(count);
					items.insertLast(child.InvSlot);
				}
			}
		}
		
		int[]params={(104),obj.DialogId,(107),(1),(106),teamId,(84),-1};
		Critter@npc=map.AddNpc(obj.Pid,posX,posY,reversDir,params,items,obj.ScriptName);
		if(not(@npc!=null))
		return;
		
		if(obj.IsDead)
		{
			npc.ToDead(Random(0,1)==0?(102):(103),null);
		}
		else
		{
			crittersGrouop.insertLast(@npc);
		}
	}
	else if(obj.ObjectType==(2))
	{
		Item@item=map.AddItem(posX,posY,obj.Pid,1);
		if(not(@item!=null))
		return;
		
		if(obj.Childs.length()>0&&item.GetType()==(8))
		{
			for(uint i=0,j=obj.Childs.length();i<j;i++)
			{
				CEncounterObject@child=obj.Childs[i];
				uint count=Random(child.Minimum,child.Maximum);
				if(count>0)
				item.AddItem(child.Pid,count,0);
			}
		}
	}
	else
	{
		Log("Unknown object type<"+obj.ObjectType+">.");
	}
}

void ActionFighting(Critter@[]&npcL,Critter@[]&npcR)
{
	for(int i=0,j=npcL.length();i<j;i++)
	{
		Critter@nl=npcL[i];
		bool nlIsNpc=nl.IsNpc();
		for(int k=0,l=npcR.length();k<l;k++)
		{
			Critter@nr=npcR[k];
			if(nlIsNpc)
			{
				AddAttackPlane(nl,0,nr);
				nl.AddEnemyInStack(nr.Id);
				nl.Wait(Random(4000,5000));
			}
			if(nr.IsNpc())
			{
				AddAttackPlane(nr,0,nl);
				nr.AddEnemyInStack(nl.Id);
				nr.Wait(Random(4000,5000));
			}
		}
	}
}

Map@GenerateEncounter(CFoundedEncounter@fe,Critter@[]@critters)
{
	CEncounter@encounter=fe.Encounter;
	uint16 locPid=((@encounter!=null)?encounter.LocPid:0);
	if(locPid==0)
	locPid=fe.LocationPids[Random(0,fe.LocationPids.length()-1)];
	
	fe.LocationId=CreateLocation(locPid,fe.PositionX,fe.PositionY,null);
	if(fe.LocationId==0)
	{
		Log("CreateLocation fail, location pid<"+locPid+">.");
		return null;
	}
	
	Location@location=GetLocation(fe.LocationId);
	if(not(@location!=null))
	{
		Log("GetLocation fail.");
		return null;
	}              
	
	Map@map=location.GetMapByIndex(0);
	if(not(@map!=null))
	{
		Log("GetMapByIndex fail.");
		return null;
	}
	
	uint16 startX=0,startY=0;
	if(not map.GetEntireCoords(0,0,startX,startY))
	{
		Log("Default entire not found.");
		return null;
	}
	fe.StartHexX=startX;
	fe.StartHexY=startY;
	
	map.SetData(56,1);
	
	if(not(@encounter!=null))
	{
		fe.IsGenerated=true;
		return map;
	}
	
	Critter@leader=critters[0];
	Critter@[][]crittersGrouops(encounter.Groups.length());
	
	for(uint i=0,j=encounter.Groups.length();i<j;i++)
	{
		uint groupNum=encounter.Groups[i];
		
		if(groupNum==(uint(-1)))
		{
			Critter@[]@crGroup=crittersGrouops[i];
			crGroup.resize(critters.length());
			for(uint k=0,l=critters.length();k<l;k++)
			@crGroup[k]=critters[k];
			continue;
		}
		
		if(groupNum>=(114))
		{
			Log("Invalid group number.");
			continue;
		}
		
		CEncounterGroup@group=EncounterGroups[groupNum];
		uint ratio=Random(encounter.RatioMin[i],encounter.RatioMax[i]);
		
		uint distance=group.Distance;
		if(distance==0)
		distance=7+leader.Stat[(1)]+leader.Perk[(381)]*3;
		
		uint teamId=group.TeamNum;
		if(teamId==0)
		teamId=(24)+i;
		
		uint position=group.Position;
		uint spacing=group.Spacing;
		if(position==(1))
		spacing=leader.Stat[(1)]+leader.Perk[(381)]*3;
		
		uint[]positionDirs=PositionDirs[position];
		uint steps=positionDirs[0];
		uint dirsCount=0;
		
		uint freeDir=GetFreeDir(fe.DirBusy);
		if(freeDir!=0)
		RotatePosition(freeDir,positionDirs);
		uint reversDir=freeDir+3;
		if(reversDir>5)
		reversDir-=6; 
		
		uint16[]pointX={startX,startY};
		uint16[]pointY={startX,startY};
		if(position!=(0))
		{
			uint16 hx=pointX[0],hy=pointY[0];
			map.MoveHexByDir(pointX[0],pointY[0],freeDir,position!=(1)?distance:spacing);
			map.GetHexCoord(hx,hy,pointX[0],pointY[0],0.0f,0);
			pointX[1]=pointX[0];
			pointY[1]=pointY[0];
			MovePositionPoint(map,pointX[1],pointY[1],positionDirs,1,0,spacing);
		}
		
		for(uint k=0,l=group.Objects.length();k<l;k++)
		{
			CEncounterObject@obj=group.Objects[k];
			
			if(not CheckChecks(obj.Checks,critters))
			continue;
			
			uint otherDistance=obj.DistanceLength;
			uint count=obj.RatioValue*ratio/100;
			if(count==0)
			count=1;
			
			uint16 oldPosX=startX,oldPosY=startY;
			for(uint n=0;n<count;n++)
			{
				uint16 posX,posY;
				if(otherDistance>0||position==(0))
				{
					posX=startX+Random(-5,5);
					posY=startY+Random(-5,5);
					map.MoveHexByDir(posX,posY,freeDir,otherDistance>0?otherDistance:distance);
				}
				else
				{
					uint pathIndex=dirsCount%2;
					posX=pointX[pathIndex]+(position==(1)?Random(-3,0):0);
					posY=pointY[pathIndex]+(position==(1)?Random(-3,0):0);
					MovePositionPoint(map,pointX[pathIndex],pointY[pathIndex],positionDirs,pathIndex,dirsCount,spacing);
					dirsCount++;
				}
				
				map.GetHexCoord(oldPosX,oldPosY,posX,posY,0.0f,0);
				oldPosX=posX;
				oldPosY=posY;
				ParseEncounterObject(obj,map,posX,posY,reversDir,crittersGrouops[i],teamId);
			}
		}
	}
	
	for(uint i=0,j=encounter.Actions.length();i<j;i+=3)
	{
		uint fromGroup=encounter.Actions[i];
		uint toGroup=encounter.Actions[i+1];
		uint action=encounter.Actions[i+2];
		
		if(action==(1)&&fromGroup<crittersGrouops.length()&&toGroup<crittersGrouops.length())
		ActionFighting(crittersGrouops[fromGroup],crittersGrouops[toGroup]);
	}
	
	fe.IsGenerated=true;
	return map;
}                                 

void FindEncounter(Critter@[]&group,Item@car,uint x,uint y,uint&encounterDescriptor,bool&waitForAnswer,bool empty,int ec)
{
	encounterDescriptor=0;
	waitForAnswer=false;
	
	uint zx=x/(50);
	uint zy=y/(50);
	if(zx>=(7)||zy>=(12))
	{
		
		return;
	}
	
	CZone@zone=Worldmap[zy*(7)+zx];
	Critter@leader=group[0]; 
	
	if(empty)
	{
		CFoundedEncounter@fe=GetNearFoundedEncounter(group,x,y,(50)/10);
		if(fe is null)
		@fe=CreateFoundedEncounter(x-x%10+4,y-y%10+4,null,zone.Table.LocationPids,leader.Id,group.length()>1);
		
		if(not(@fe!=null))
		return;
		waitForAnswer=false;
		encounterDescriptor=fe.Index;
		return;
	} 
	
	CFoundedEncounter@feAlready=GetNearFoundedEncounter(group,x,y,(50)/4);
	if((@feAlready!=null))
	{
		int outdoorsman=leader.Skill[(217)]+zone.Difficulty;
		outdoorsman=(((outdoorsman)>(95))?(95):(((outdoorsman)<(6))?(6):(outdoorsman)));
		if(outdoorsman>=Random(1,100))
		{
			uint8 say=feAlready.TurnBased?(16):(15);
			if((@feAlready.Encounter!=null))
			{
				leader.SayMsg(say,(4),feAlready.OwnerGroup?(10000022):(10000021),
				"$who @msg gm "+feAlready.Encounter.StrNum+"@$player"+GetPlayerName(feAlready.OwnerId));
			}
			else
			{
				leader.SayMsg(say,(4),feAlready.OwnerGroup?(10000024):(10000023),
				"$player"+GetPlayerName(feAlready.OwnerId));
			}
			waitForAnswer=true;
			if(leader.Skill[(217)]<=95)
			leader.StatBase[(76)]+=100-leader.Skill[(217)]-zone.Difficulty;
			else
			leader.StatBase[(76)]+=5-zone.Difficulty;
		}
		
		for(uint i=0,j=group.length();i<j;i++)
		group[i].Say((41),"");
		encounterDescriptor=feAlready.Index;
		return;
	}
	
	if(leader.Param[(703)]==(3)||ec<1)
	return; 
	
	uint chance;
	if(((__Hour)>=7&&(__Hour)<=11))
	chance=zone.MorningChance;
	if(((__Hour)>=12&&(__Hour)<=21))
	chance=zone.AfternoonChance;
	else
	chance=zone.NightChance;
	if(ec>99)
	{}
	else if(uint(Random(1,100))>chance*(ec*0.01f))
	return; 
	
	int luck=0;
	for(uint i=0,j=group.length();i<j;i++)
	luck+=group[i].Stat[(6)];
	luck/=group.length();
	
	int roll=Random(0,100)+luck-5+2*leader.Perk[(342)]+leader.Perk[(348)]+leader.Perk[(346)];
	if(roll<0)
	roll=0;
	int maxRoll=0;
	
	CEncounter[]@encounters=zone.Table.Encounters;
	CEncounter@[]encountersThru(encounters.length());
	for(uint i=0,j=encounters.length();i<j;i++)
	{
		CEncounter@enc=encounters[i];
		if(CheckChecks(enc.Checks,group))
		{
			maxRoll+=enc.Chance;
			@encountersThru[i]=encounters[i];
		}
		else
		{
			@encountersThru[i]=null;
		}
	}
	
	roll=roll*maxRoll/100;
	for(uint i=0,j=encountersThru.length();i<j;i++)
	{
		CEncounter@enc=encountersThru[i];
		
		if(not(@enc!=null))
		continue;
		if(uint(roll)>enc.Chance&&i<j-1)
		{
			roll-=enc.Chance;
			continue;
		}
		
		CFoundedEncounter@fe=CreateFoundedEncounter(x-x%10+4,y-y%10+4,enc,zone.Table.LocationPids,leader.Id,group.length()>1);
		if(not(@fe!=null))
		return;
		
		int outdoorsman=leader.Skill[(217)]+zone.Difficulty;
		outdoorsman=(((outdoorsman)>(95))?(95):(((outdoorsman)<(6))?(6):(outdoorsman)));
		if(outdoorsman>=Random(1,100))
		{
			leader.SayMsg((14),(4),(10000020),"$who @msg gm "+enc.StrNum+"@");
			waitForAnswer=true;
			if(leader.Skill[(217)]<=95)
			leader.StatBase[(76)]+=100-leader.Skill[(217)]-zone.Difficulty;
			else
			leader.StatBase[(76)]+=5-zone.Difficulty;
		}
		
		for(uint i=0,j=group.length();i<j;i++)
		group[i].Say((41),"");
		encounterDescriptor=fe.Index;
		break;
	}
}

void InviteToEncounter(Critter@[]&group,Item@car,uint encounterDescriptor,int combatMode,uint&mapId,uint16&hexX,uint16&hexY,uint8&dir)
{
	mapId=0;
	
	CFoundedEncounter@fe=GetFoundedEncounter(encounterDescriptor);
	if(not(@fe!=null))
	{
		Log("GetFoundedEncounter fail.");
		return;
	}
	
	bool isGenerated=fe.IsGenerated;
	Map@map=null;
	if(isGenerated)
	{
		Location@location=GetLocation(fe.LocationId);
		if(not(@location!=null))
		{
			
			return;
		}
		
		@map=location.GetMapByIndex(0);
	}
	else
	{
		@map=GenerateEncounter(fe,group);
	}
	
	if(not(@map!=null))
	{
		Log("Map not found.");
		return;
	}
	
	if(not isGenerated&&combatMode==(2))
	{
		map.SetTurnBasedAvailability(true);
		fe.TurnBased=true;
	}
	
	Critter@leader=group[0];
	mapId=map.Id;
	hexX=fe.StartHexX;
	hexY=fe.StartHexY;
	if(isGenerated)
	{
		if((@car!=null))
		{
			
			hexX=uint16(-1);
			hexY=uint16(-1);
		}
		else
		{
			dir=GetFreeDir(fe.DirBusy);
			map.MoveHexByDir(hexX,hexY,dir,leader.Stat[(1)]+leader.Perk[(381)]*3);
			dir+=3;
			if(dir>5)
			dir-=6;
		}
	}
	else
	{
		if((@car!=null))
		{
			
			hexX=uint16(-1);
			hexY=uint16(-1);
		}
		
		dir=Random(0,5);
	}
	
	if(isGenerated||(@fe.Encounter!=null))
	{
		for(uint i=0,j=group.length();i<j;i++)
		{
			Critter@cr=group[i];
			if(not isGenerated)
			cr.SayMsg((11),(4),(10000010),"$who @msg gm "+fe.Encounter.StrNum+"@");
			else if((@fe.Encounter!=null))
			cr.SayMsg((11),(4),fe.OwnerGroup?(10000012):(10000011),"$who @msg gm "+fe.Encounter.StrNum+"@$player"+GetPlayerName(fe.OwnerId));
			else
			cr.SayMsg((11),(4),fe.OwnerGroup?(10000014):(10000013),"$player"+GetPlayerName(fe.OwnerId));
		}
	}
	if((@fe.Encounter!=null))
	AssignChecks(fe.Encounter.Checks,group);
}

uint GetGlobalMapRelief(uint x,uint y)
{ 
	
	return GetImageColor((0),x,y)&0xF;
}

void WorldmapInit()
{
	LoadImage((0),"relief_modoc.png",1,(34)); 
	
}
