#ifndef GLOBALMAP_GROUP
#define GLOBALMAP_GROUP

#include "_utils.fos"
#include "globalmap_group_h.fos"
#include "entire.fos"
#include "_cell.fos"
#include "_global_events.fos"
#include "local_population_h.fos"

import void FindEncounter( Critter@[]& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty, int ec ) from "worldmap";
import void InviteToEncounter( Critter@[]& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir ) from "worldmap";
import bool CheckFoundedEncounter( uint index ) from "worldmap";
import uint GetGlobalMapRelief( uint x, uint y ) from "worldmap";

class CellContent
{
    uint[] MapId;
    uint  Index;
    uint8 Type;
    int8  Visibility;
    uint8 Durability;

    uint[][] Critters;

    CellContent()
    {

        Index = uint( -1 );
        Type = 0;
        Visibility = 0;
        Durability = 0;

        Critters.resize( CELL_CRITTERS_MAX );
        MapId.resize( CELL_LEVEL_MAX );

        MapId[ CELL_LEVEL_DEFAULT ] = 0;
    }

    CellContent( uint mapId, uint8 type, int8 visibility )
    {
        Index = uint( -1 );
        Type = type;
        Visibility = visibility;
        Durability = 255;

        Critters.resize( CELL_CRITTERS_MAX );
        MapId.resize( CELL_LEVEL_MAX );
        MapId[ CELL_LEVEL_DEFAULT ] = mapId;
    }

    uint GetCrittersCount( int type )
    {
        if( type >= 0 )
        {
            if( type >= CELL_CRITTERS_MAX )
			{
                return 0;
			}
			
            return Critters[ type ].length();
        }
        else
        {
            uint count = 0;
            for( uint i = 0; i < CELL_CRITTERS_MAX; i++ )
            {
                count += Critters[ i ].length();
            }
            return count;
        }
    }

    uint GetCritters( Critter@[] crs, int type )
    {
        if( type >= 0 )
        {
            if( type >= CELL_CRITTERS_MAX )
			{
                return 0;
			}
			
            uint[] @ crIds = Critters[ type ];
            Critter@ cr = null;

            uint k = crs.length(), len = crIds.length();

            crs.resize( k + len );

            for( uint i = 0; i < len; i++ )
            {
                @cr = GetCritter( crIds[ i ] );
                if( cr is null )
				{
                    continue;
				}
				
                @crs[ k++ ] = cr;
            }

            crs.resize( k );

            return k;
        }
        else
        {
            uint[] @ crIds = Critters[ type ];
            Critter@ cr = null;

            uint k = crs.length(), len = 0;

            for( uint i = 0; i < CELL_CRITTERS_MAX; i++ )
            {
                len = crIds.length();
                crs.resize( k + len );

                for( uint t = 0; t < len; t++ )
                {
                    @cr = GetCritter( crIds[ t ] );
                    if( cr is null )
					{
                        continue;
					}
					
                    @crs[ k++ ] = cr;
                }

            }

            return k;
        }
    }

    bool ShiftCritter( Critter& cr, uint type, bool del )
    {
        if( type >= CELL_CRITTERS_MAX )
		{
            return false;
		}
		
        if( del )
        {
            int index = Critters[ type ].find( cr.Id );

            if( index == -1 )
			{
                return false;
			}
			
            Critters[ type ].removeAt( index );
        }
        else
        {
            Critters[ type ].insertLast( cr.Id );
        }
		
        return true;
    }

    Map@ GetMap()
    {
        return ::GetMap( MapId[ CELL_LEVEL_DEFAULT ] );
    }

    Map@ GetMap( int level )
    {
        return ::GetMap( MapId[ CELL_LEVEL_DEFAULT ] + level );
    }

}

class Cell
{
    // uint Color;
    uint8        SizeX; // pm added
    uint8        SizeY;
    uint8        ParantX;
    uint8        ParantY;
    uint16       X;
    uint16       Y;
    uint8        Wildness;
    CellContent@ Content;

    uint8        PopulationMax;
    uint16       MonsterType;
    int          MonsterCount;
    bool         IsHavePopulation;
//	uint16 CellX, CellY;

    // uint[] Groups;

    Cell()
    {
        // Color=0x33773333;
        Wildness = 50;
        SizeX = 1;         // pm added
        SizeY = 1;         // pm added
        // @Content = null;

        MonsterType = 0;
        MonsterCount = 0;
        PopulationMax = 50;
        IsHavePopulation = false;
    }

    uint8 ChangeWildness( int delta )
    {
        int wild = Wildness + delta;
        wild = CLAMP( wild, 0, 100 );
        Wildness = uint8( wild );

        return Wildness;
    }

    void DropWildness()
    {
        Wildness = 0;
        Log( "Wildness " + Wildness );
    }

    void ChangeMonsterCount( bool increase )
    {
        if( !increase )
        {
            if( MonsterCount > 0 )
			{
                MonsterCount--;
			}
		}
        else
        {
            MonsterCount++;
        }
    }

    void ChangeMonsterCount( uint8 count, bool increase )
    {
        MonsterCount += ( increase ? count : ( count - ( count * 2 ) ) );
        MonsterCount = CLAMP( MonsterCount, 0, int( PopulationMax ) );
    }

    bool SetLocation( uint16 pid )
    {
        // if(Content !is null) return;

        @Content = CellContent();
        if( Content is null )
		{
            return false;
		}
		
        uint id = CreateLocation( pid, X, Y, null );

        Location @ loc = GetLocation( id );
        if( loc is null )
		{
            return false;
		}
		
        Content.MapId[ CELL_LEVEL_DEFAULT ] = loc.GetMapByIndex( 0 ).Id;


        if( pid != 90 )
		{
            Content.Type = CELLMAP_TYPE_STATIC;
        }
		else
		{
            Content.Type = CELLMAP_TYPE_ENCOUTER;                                                            // 90 is encounter pid
		}
        return true;
    }

    int CellCreate( uint16 pid, bool force )
    {
        if( Content !is null && !force )
		{
            return -1;
		}
		
        if( !SetLocation( pid ) )
		{
            return -2;
		}
		
        return 0;
    }

    int CellCreate( uint16 pid, int wildness, int livetime, bool force )
    {
        if( Content !is null && !force )
		{
            return -1;
		}
		
        if( !SetLocation( pid ) )
		{
            return -2;
		}
		
        Wildness = wildness;
        Content.Durability = livetime;

        return 0;
    }

    int CellMove( uint16 x, uint16 y )
    {
        Cell @ target = world.GetCell( x, y );
        if( target is null /* || target.Content is null*/ )
		{
            return -1;
		}
        // @target = this;
        // @target.Content = this.Content;
        // @ = Cell();

        @target.Content = CellContent();
        target.Content.MapId = Content.MapId;
        target.Content.Durability = Content.Durability;
        target.Content.Type = Content.Type;

        @this.Content = null;


        return 0;
    }

    int CellDelete()
    {
        if( Content is null )
            return -1;
        DeleteLocation( GetMap( Content.MapId[ CELL_LEVEL_DEFAULT ] ).GetLocation().Id );
        @Content = null;



        return 0;        // CellCreate(0, Wildness, 0, true);
    }

    int CellSetSize( int x, int y )
    {

        for( uint8 i = 0; i < uint(y); ++i )
        {
            for( uint8 j = 0; j < uint(x); ++j )
            {
                Cell @ child = world.GetCell( X - j, Y + i );
                if( child is null )
                {
                    return -1;
                }

                if( child.Content is null )
                {
                    @child.Content = CellContent();
                }

                child.ParantX = X;
                child.ParantY = Y;
                child.Wildness = Wildness;

                child.Content.MapId = Content.MapId;
                child.Content.Type = Content.Type;
                child.Content.Durability = Content.Durability;

            }
        }

        return 0;
    }

    void SetMapLevel( uint[] mapId )
    {
        if( !(Content is null) )
        {
            Content.MapId = mapId;
        }
    }
}

class CellWorld : iManagerModule, iManager_map_critter_in, iManager_map_critter_out, iManager_world_save
{
    Cell[] Cells;
    uint16 CellsW;
    uint16 CellsH;
	uint16 next_cell;
	
    CellWorld()
    {
        AddStartCallback( "globalmap_group", "start" );

        CellsW = 7 * 5;
        CellsH = 12 * 5;
        next_cell = 0;
		Cells.resize( CellsW * CellsH );
        for( uint y = 0; y < CellsH; y++ )
        {
            uint cy = y * CellsW;
            for( uint x = 0; x < CellsW; x++ )
            {
                Cells[ x + cy ].X = x;
                Cells[ x + cy ].Y = y;
            }
        }
    }

    bool manager_init()
    {
        Init();

        return true;
    }

    uint GetCells( Cell@[]& cells, uint16 x, uint16 y, uint8 radius )
    {
        uint len = cells.length(),
             len2 = len;

        if( radius < 1 )
            return len;

        for( uint8 i = 1; i <= radius; i++ )
        {
            len2 += i * 8;
        }

        cells.resize( len2 );
        int x0 = x, y0 = y;

        int h = 1, g = 0, u = 0, r = 1;

        for( uint i = len; i < len2; i++ )
        {
            u = ( g / h );

            x0 += ( 1 - u ) * r;
            y0 += u * r;

            @cells[ i ] = GetCell( x0, y0 );
            g++;
            if( g >= h * 2 )
            {
                g = 0;
                h += 1;
                r *= -1;
            }
        }

        return cells.length();
    }

    Cell@ GetCell( Critter@ cr )
    {
        uint16 x = cr.WorldX / 10, y = cr.WorldY / 10;
        if( x >= CellsW || y >= CellsH )
            return null;
        return Cells[ x + y * CellsW ];
    }

    Cell@ GetCell( uint16 x, uint16 y )
    {
        if( x >= CellsW || y >= CellsH )
            return null;
        return Cells[ x + y * CellsW ];
    }

    Cell@ GetCell( uint i )
    {
        if( i >= Cells.length() )
            return null;
        return Cells[ i ];
    }

    Cell@ GetCellByMap( uint id )
    {
        for( uint16 i = 0, j = Cells.length(); i < j; ++i )
        {
            if( Cells[ i ].Content !is null && Cells[ i ].Content.MapId.find( id ) != -1 )
                return Cells[ i ];
        }

        return null;
    }

    void ShowCells( Critter& cr, Cell& cell )
    {
        int  acc = cr.IsPlayer() ? cr.GetAccess() : 0;
        bool adm = acc == ACCESS_ADMIN;

        bool showStatic = ( adm ),
             showWildness = ( adm ),
             showEncs = ( adm );

        uint8 radius = 0;
        int   vision = 0;

        if( acc == ACCESS_ADMIN )
        {
            radius = 40;
            vision = 255;
        }
        else
        {
            radius = int( cr.Param[ SK_OUTDOORSMAN ] / 100 ) + 1;
            vision = int( cr.Param[ SK_OUTDOORSMAN ] / 4 );
        }

        Cell@[] cells = { cell };

        uint len = GetCells( cells, cell.X, cell.Y, radius );

        int  precision = int( ( vision / 256.0f ) * 5 );
        precision = ( 5 - precision ) * 5;

        int[] data_color( len*2 ),
        data_number( len * 2 ),
        data_char( len * 2 );

        uint8        data_cellSize = 1;  // pm added

        uint dc = 0, dn = 0, dch = 0, wild = 0, color = 0, number = uint( -1 ), chr = uint( -1 ), r = 0, nr = 0, zx = 0, zy = 0;
        Cell@ cell0 = null;
        CellContent@ cont = null;
        int coord = 0;

        for( uint i = 0; i < len; i++ )
        {
            if( i > nr )
            {
                r++;
                nr += r * 8;
            }

            @cell0 = cells[ i ];
            if( cell0 is null )
                continue;
            zx = cell0.X;
            zy = cell0.Y;

            color = 0;
            number = uint( -1 );
            chr = uint( -1 );
            coord = int( ( zx & 0xFFFF ) | ( zy << 16 ) );

            @cont = cell0.Content;
            if( showStatic and cont !is null and ( cont.Type & 0x1F ) == CELLMAP_TYPE_STATIC and ( vision + cont.Visibility > int(r * 20) ) )
            {
                color = 0x442222DD;
                chr = 0x0011FF11 | ( uint( 'C' ) << 24 );
            }
            else if( showWildness )
            {
                wild = cell0.Wildness;

                if( wild < 45 || wild > 55 )
                {
                    color = int( wild / precision );
                    color = 0xFF * int( 1.0f - color * precision / 100.0f );
                    color = 0x44000000 | ( 0xFF - color ) << 16 | color << 8 | color;
                }
            }

            if( color != 0 )
            {
                data_color[ dc++ ] = coord;
                data_color[ dc++ ] = int(color);
            }

            if( chr != uint( -1 ) )
            {
                data_char[ dch++ ] = coord;
                data_char[ dch++ ] = int(chr);
            }

            if( showEncs && cont !is null && chr == uint( -1 ) )
            {
                number = cont.GetCrittersCount( CELL_CRITTERS_SURVIVAL );

                if( number == 0 )
                    number = uint( -1 );
            }

            if( number != uint( -1 ) )
            {
                data_number[ dn++ ] = coord;
                data_number[ dn++ ] = int(number);
            }
            /*
               if(cell0.SizeX != 1)
               {
                    data_cellSize = cell0.Size;
               }*/

        }

        // if(dc>1)
        // {
        data_color.resize( dc );
        if( cr.IsPlayer() )
			cr.RunClientScript( "client_main@_dr", 1, 0, 0, null, data_color );
        // }
        // if(dn>1)
        // {
        data_number.resize( dn );
        if( cr.IsPlayer() )
			cr.RunClientScript( "client_main@_dr", 2, 0, 0, null, data_number );
        // }
        // if(dch>1)
        // {
        data_char.resize( dch );
        if( cr.IsPlayer() )
			cr.RunClientScript( "client_main@_dr", 3, 0, 0, null, data_char );

        // pm added
        // cr.RunClientScript("client_main@_dr", 3, 0, 0, null, data_char);
        // }
    }

    // pm added
    void CreateCell( uint16 x, uint16 y, uint mapId, uint8 type, int8 visibility )
    {
        // CreateContent(world.GetCell(x*0.1, y*0.1), mapId, type, visibility);

        Cell@ cell = GetCell( x, y );
        if( !valid( cell ) )
        {
            Log( "null cell" );
            return;
        }

        @cell.Content = CellContent();
        cell.Content.MapId[ CELL_LEVEL_DEFAULT ] = mapId;
        cell.Content.Type = type;
        cell.Content.Visibility = visibility;

        cell.ParantX = cell.X;
        cell.ParantY = cell.Y;

        Map @ map = GetMap( mapId );
        if( !valid( map ) )
            return;

        map.SetData( 56, 1 );
        map.SetData( 57, 0 );
        map.SetData( 58, 0 );


        if( !valid( cell.Content ) )
            Log( "null content" );
    }

    Cell@ PassCell( Critter& cr )
    {
        Cell@ cell = GetCell( cr );
        if( cell is null )
            return null;

        int tt = ( ( int(cell.X) & 0xFFFF ) | ( int(cell.Y) << 16 ) );
        if( cr.Param[ ST_VAR6 ] != tt )
        {
            cr.ParamBase[ ST_VAR6 ] = tt;

            return cell;
        }
        return null;
    }

    void Init()
    {
        Map@[] maps;
        uint mlen = GetAllMaps( 0, maps );
        for( uint i = 0; i < mlen; i++ )
        {
            if( maps[ i ] is null )
                continue;

            Map@ map = maps[ i ];

            map.SetData( 57, 0 );
            map.SetData( 58, 0 );
        }

        Location@[] locations;
        uint llen = GetAllLocations( 0, locations );
        for( uint i = 0; i < llen; i++ )
        {
            if( locations[ i ] is null )
                continue;

            Location@ loc = locations[ i ];
			
            Map@[] maps_;
            loc.GetMaps( maps_ );

            if( maps_.length() <= 0 )
                continue;

            // Map@ map = loc.GetMapByIndex(0);
            Map@ map = maps_[ 0 ];
            if( map is null )
                continue;

            uint[] levels( CELL_LEVEL_MAX );


            for( uint8 ii = 0, jj = maps_.length(); ii < jj; ++ii )
            {
                /*Map@ tempMap = maps(ii);
                   if(tempMap is null) continue;*/

                int level = GetMapLevelByPid( maps_[ ii ].GetProtoId() );
                levels[ CELL_LEVEL_DEFAULT + level ] = maps_[ ii ].Id;

                // Log("maps "+ii+" map ID "+maps_[ii].Id+" level "+level);
            }



            uint8 type = CELLMAP_TYPE_NULL;
            int8  vis = 0;

            bool  pop = false;
            uint8 sizeX = 1, sizeY = 1;             // pm added

            if( map.GetData( 56 ) == 0 )
            {
                uint16 pid = loc.GetProtoId();
                if( LocIsCity( pid ) )
				{
                    vis = 50;
                }
				else if( LocIsHidden( pid ) )
				{
                    vis = -100;
                }
				else
				{
                    continue;
                }
				
				type = CELLMAP_TYPE_STATIC;

                pop = true;

                switch( pid )
                {
					case( LOCATION_Clinton ):
					case( LOCATION_Riverdale ):
                    case( LOCATION_en_Clinton ):
					case( LOCATION_Highway ):
					case( LOCATION_Azma_Modoc ):
					case( LOCATION_Azma_Portland ):
					case( LOCATION_blaire1_1 ):
					case( LOCATION_blaire1_2 ):
					case( LOCATION_blaire1_3 ):
					case( LOCATION_blaire2_1 ):
					case( LOCATION_blaire2_2 ):
					case( LOCATION_blaire2_3 ):
					case( LOCATION_blaire3_1 ):
					case( LOCATION_blaire3_2 ):
					case( LOCATION_blaire3_3 ):
						sizeX = 2;
						sizeY = 2;
						break;
					default:
						break;
                }
            }
            else
            {
                type = CELLMAP_TYPE_ENCOUTER;
            }

            uint8 locWorldX = int( loc.WorldX * 0.1), locWorldY = int( loc.WorldY * 0.1 );
			
            Cell@ cell = GetCell( locWorldX, locWorldY );
            if( cell is null )
			{
                continue;
			}
			
            @cell.Content = CellContent();
            cell.Content.MapId.resize( CELL_LEVEL_MAX );
            cell.Content.MapId[ CELL_LEVEL_DEFAULT ] = map.Id;
            cell.Content.Type = type;
            cell.Content.Visibility = vis;

            cell.ParantX = locWorldX;
            cell.ParantY = locWorldY;

            cell.IsHavePopulation = pop;

            cell.SetMapLevel( levels );

            // Log("x "+cell.X+" lwx "+locWorldX+" y "+cell.Y+" lwy "+locWorldY);

            if( sizeX > 1 || sizeY > 1 )
            {
                for( uint8 y = 0; y < sizeY; ++y )
                {
                    for( uint8 x = 0; x < sizeX; ++x )                   // invert right to left
                    {
                        @cell = GetCell( locWorldX - x, locWorldY + y );
                        if( cell is null )
						{
                            continue;
						}
						
                        @cell.Content = CellContent();
                        cell.Content.MapId.resize( CELL_LEVEL_MAX );
                        cell.Content.MapId[ CELL_LEVEL_DEFAULT ] = map.Id;
                        cell.Content.Type = type;
                        cell.Content.Visibility = vis;

                        cell.SizeX = sizeX;
                        cell.SizeY = sizeY;

                        cell.ParantX = locWorldX;
                        cell.ParantY = locWorldY;

                        cell.SetMapLevel( levels );

                        // Log("x "+cell.X+" lwx "+locWorldX+" y "+cell.Y+" lwy "+locWorldY);
                    }
                }
            }
        }

        if( IsAnyData( "cells_v1" ) && IsAnyData( "cells_monsters_v1" ) )
        {
            int[] cells_data,
            cells_monsters_data;
            GetAnyData( "cells_v1", cells_data );
            GetAnyData( "cells_monsters_v1", cells_monsters_data );

            uint len = cells_data.length();

            if( len <= Cells.length() )
            {
                for( uint i = 0; i < len; i++ )
                {
                    Cells[ i ].Wildness = uint8( cells_data[ i ] );

                    Cells[ i ].MonsterCount = uint8( cells_monsters_data[ i ] );
                    Cells[ i ].MonsterType = MonsterTypeTable( Cells[ i ].Wildness );               // pm added
                }
            }
        }
    }

    bool global_world_save()
    {
        uint clen = Cells.length();

        int[] cells_data( clen );
        int[] cells_monsters_data( clen );

        int dur = 0;
        Cell@ cell = null;
        CellContent@ cont = null;
        for( uint i = 0; i < clen; i++ )
        {
            if( Cells[ i ].Wildness < 100 )
			{
                Cells[ i ].Wildness += Random( 0, 5 - Cells[ i ].Wildness / 20 );
			}
			
            @cell = Cells[ i ];

            cells_data[ i ] = cell.Wildness;
            cells_monsters_data[ i ] = cell.MonsterCount;

            @cont = cell.Content;

            if( cont !is null and cont.Type == CELLMAP_TYPE_ENCOUTER )
            {
                dur = cont.Durability;
                dur += ( cont.GetCrittersCount( CELL_CRITTERS_SURVIVAL ) * 2 - 1 );
                if( dur < 1 )
                {
                    Map@ map = GetMap( cont.MapId[ CELL_LEVEL_DEFAULT ] );
                    if( map !is null )
                    {
                        Location@ loc = map.GetLocation();
                        if( loc !is null )
                        {
                            DeleteLocation( loc.Id );
                        }
                    }
                    @cell.Content = null;
                }
                else
                {
                    dur = CLAMP( dur, 1, 255 );
                    cont.Durability = uint8( dur );
                }
            }
        }

        SetAnyData( "cells_v1", cells_data );
        SetAnyData( "cells_monsters_v1", cells_monsters_data );

        return true;
    }

    bool global_map_critter_in( Map& map, Critter& cr )
    {
        cells_critter_shift( map, cr, false );
        cr.StatBase[ ST_LOCALMAP_PID ] = map.GetProtoId();
        cr.StatBase[ ST_LOCALMAP_DIR ] = -1;

        return true;
    }
    bool global_map_critter_out( Map& map, Critter& cr )
    {
        cells_critter_shift( map, cr, true );
        return true;
    }

    void cells_critter_shift( Map& map, Critter& cr, bool quit )
    {
        Cell@ cell = GetCell( cr );
        if( cell is null )
		{
            return;
        }
		
		CellContent@ cont = cell.Content;
        if( cont is null )
		{
            return;
		}
		
        if( cr.IsNpc() && cont.Type == CELLMAP_TYPE_ENCOUTER )
        {
            if( !cont.ShiftCritter( cr, CELL_CRITTERS_MOB, quit ) )
            {
                Log( "ShiftCritter mob fail" + ( quit ? ", quit." : "." ) + " Id: " + cr.Id );
            }
        }
        else if( cr.IsPlayer() && cont.MapId[ CELL_LEVEL_DEFAULT /*+level*/ ] == map.Id )
        {
            if( !cont.ShiftCritter( cr, CELL_CRITTERS_SURVIVAL, quit ) )
            {
                if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
					Log( "ShiftCritter player fail" + ( quit ? ", quit." : "." ) + " Id: " + cr.Id );
            }
        }
        else
		{
            return;
		}
		
        Location@ loc = map.GetLocation();
        if( cont.Type == CELLMAP_TYPE_ENCOUTER and loc !is null and loc.AutoGarbage )
        {
            loc.AutoGarbage = false;
        }
    }
	
	void GlobalPopulation()
    {
        uint skipped_broken = 0;
        for( uint16 i = 0, j = Cells.length(); i < j; ++i )
        {
            if( Cells[ i ] is null || !Cells[ i ].IsHavePopulation )
			{
                continue;
			}
				
            if( Cells[ i ].Content is null )
			{
                continue;
			}
			
			for( uint8 ii = 0, jj = Cells[ i ].Content.MapId.length(); ii < jj; ++ii )
            {
				if( Cells[ i ].Content.MapId[ ii ] == 0 )
				{
					skipped_broken++;
					continue;
				}
				
                Map @ map = GetMap( Cells[ i ].Content.MapId[ ii ] );
                if( !valid( map ) )
				{
                    continue;
				}
				
                AddCritter( map );
            }
        }
		if( skipped_broken > 0 )
		{
			DebugLog( "There are " + skipped_broken + " broken cells content map." );
		}
	}
}

CellWorld world;

void start()
{
    iManagerModule@  module = world;
    iManagerElement@ manager = manager_add_module( module, "CellWorld", 20 );
}

bool ChangeWildness( uint i, int delta )
{
    Cell@ cell = world.GetCell( i );
    if( cell is null )
	{
        return false;
	}
	
    cell.ChangeWildness( delta );
    return true;
}

bool ChangeWildness( uint16 x, uint16 y, int delta )
{
    Cell@ cell = world.GetCell( x, y );
    if( cell is null )
	{
        return false;
	}
			
    cell.ChangeWildness( delta );
    return true;
}

void CellInfo( Critter& cr, int p0, int p1, int p2 )
{
    Cell@ cell = null;
    if( p0 == 0 && p1 == 0 )
    {
        @cell = world.GetCell( cr );
    }
    else if( p0 > 0 && p1 > 0 )
    {
        @cell = world.GetCell( uint16( p0 ), uint16( p1 ) );
    }

    if( cell is null )
	{
        return;
	}
	
    cr.Say( SAY_NETMSG, "Cell: " + cell.X + ":" + cell.Y + " Wildness: " + cell.Wildness );
    cr.Say( SAY_NETMSG, "Population: " + cell.MonsterCount + " Type: " + cell.MonsterType );

    CellContent@ cont = cell.Content;

    if( cont is null )
	{
        return;
	}
	
    cr.Say( SAY_NETMSG, "MapId: " + cont.MapId[ CELL_LEVEL_DEFAULT ] + " Type: " + cont.Type + " Index: " + cont.Index );
    cr.Say( SAY_NETMSG, "Visibility: " + cont.Visibility + " Durability: " + cont.Durability );
    cr.Say( SAY_NETMSG, "Online: " + cont.GetCrittersCount( CELL_CRITTERS_SURVIVAL ) + "/" + cont.GetCrittersCount( CELL_CRITTERS_ADVENTURE ) + " Mobs: " + cont.GetCrittersCount( CELL_CRITTERS_MOB ) );
}

void CellMove( Critter& cr, int p0, int p1, int p2 )
{
    Cell @ cell = world.GetCell( cr );
    Cell @ targetCell = world.GetCell( p0, p1 );

    if( cell is null || targetCell is null )
	{
        return;
	}
	
    @targetCell = cell;
    @cell = Cell();
}

void ChWild( Critter& cr, int p0, int p1, int p2 )
{
    uint16 x = p0,
           y = p1;

    if( p0 == -1 && p1 == -1 )
    {
        x = cr.WorldX / 10;
        y = cr.WorldY / 10;
    }

    if( ChangeWildness( x, y, p2 ) )
	{
        Log( "Ok." );
    }
	else
	{
        Log( "Fail." );
	}
}


// //////////////////////////////////////////////////////////////////////////////////////////////////
// int processType    - see in Global map events in _defines.fos;
// Critter& cr        - who called this function, in most times is leader of group;
// Item@ car          - group car, can be null;
// float& curX, &curY - current position;
// float& toX, &toY   - destination position;
// float& speed       - speed of group, must set in GLOBAL_PROCESS_SET_MOVE,
//                      also you can type zero to stop group;
// uint encounterDescriptor - if encounterDescriptor != 0 than global_invite calls;
// bool waitForAnswer       - if waitForAnswer == false than global_invite calls after this function,
//                            else call after leader confirm invite;
void global_process( int processType, Critter& cr, Item@ car, float& curX, float& curY, float& toX, float& toY, float& speed, uint& encounterDescriptor, bool& waitForAnswer )
{
    int movementType = ( valid( car ) ? car.Proto.Car_MovementType : GM_WALK_GROUND );
    int curXi = int(curX);
    int curYi = int(curY);

    if( processType == GLOBAL_PROCESS_MOVE )
    {
        // Save current distantion to compare in the end
        float lastDist = DISTANCE( curX, curY, toX, toY );

        // Calcuate speed
        float speedPix = speed * float(__GlobalMapMoveTime) / 1000.0f;
        float speedAngle = atan2( toY - curY, toX - curX );
        float speedX = cos( speedAngle ) * speedPix;
        float speedY = sin( speedAngle ) * speedPix;

        float speedMod = 1.0f;
        if( movementType == GM_WALK_GROUND )
        {
            // Speed modifiers
            //  F   E   D   C   B   A   9    8   7    6   5    4   3    2   1    0
            // 1.5 1.4 1.3 1.2 1.1 1.0 0.95 0.9 0.85 0.8 0.75 0.7 0.65 0.6 0.55 0.0
            switch( GetGlobalMapRelief( curXi, curYi ) )
            {
            case 0x0:
                speedMod = 1.00f;
                break;
            case 0x1:
                speedMod = 0.55f;
                break;
            case 0x2:
                speedMod = 0.60f;
                break;
            case 0x3:
                speedMod = 0.65f;
                break;
            case 0x4:
                speedMod = 0.70f;
                break;
            case 0x5:
                speedMod = 0.75f;
                break;
            case 0x6:
                speedMod = 0.80f;
                break;
            case 0x7:
                speedMod = 0.85f;
                break;
            case 0x8:
                speedMod = 0.90f;
                break;
            case 0x9:
                speedMod = 0.95f;
                break;
            case 0xA:
                speedMod = 1.00f;
                break;
            case 0xB:
                speedMod = 1.10f;
                break;
            case 0xC:
                speedMod = 1.20f;
                break;
            case 0xD:
                speedMod = 1.30f;
                break;
            case 0xE:
                speedMod = 1.40f;
                break;
            case 0xF:
                speedMod = 1.50f;
                break;
            default:
                break;
            }
        }

        if( valid( car ) && speedMod != 1.0f )
        {
            float pass = float(car.Proto.Car_Passability);
            if( pass > 100.0f && speedMod < 1.0f )
			{
                speedMod += ( 1.0f - speedMod ) * ( pass - 100.0f ) / 100.0f;
            }
			else if( pass > 100.0f && speedMod > 1.0f )
			{
                speedMod -= ( speedMod - 1.0f ) * ( pass - 100.0f ) / 100.0f;
            }
			else if( pass < 100.0f && speedMod < 1.0f )
			{
                speedMod -= ( 1.0f - speedMod ) * ( 100.0f - pass ) / 100.0f;
            }
			else if( pass < 100.0f && speedMod > 1.0f )
			{
                speedMod += ( speedMod - 1.0f ) * ( 100.0f - pass ) / 100.0f;
			}
        }

        // Apply step
        curX += speedX * speedMod;
        curY += speedY * speedMod;

        int oldXi = curXi;
        int oldYi = curYi;
        curXi = int(curX);         // Round
        curYi = int(curY);         // Round

        // Check new position
        if( oldXi != curXi || oldYi != curYi )
        {
            // Check borders
            int gmWidth = __GlobalMapWidth * __GlobalMapZoneLength;
            int gmHeight = __GlobalMapHeight * __GlobalMapZoneLength;
            if( curXi < 0 || curYi < 0 || curXi >= gmWidth || curYi >= gmHeight )
            {
                if( curXi < 0 )
                    curXi = 0;
                if( curXi >= gmWidth )
                    curXi = gmWidth - 1;
                if( curYi < 0 )
                    curYi = 0;
                if( curYi >= gmHeight )
                    curYi = gmHeight - 1;

                // Stop group
                curX = float(curXi);
                curY = float(curYi);
                speed = 0.0f;
                return;
            }

            // Move from old to new and find last correct position
            int relief = GetGlobalMapRelief( oldXi, oldYi );
            int steps = MAX( ABS( curXi - oldXi ), ABS( curYi - oldYi ) );
            int newXi = oldXi;
            int newYi = oldYi;
            if( steps > 0 )
            {
                float xx = float(oldXi);
                float yy = float(oldYi);
                float oxx = float(curXi - oldXi) / float(steps);
                float oyy = float(curYi - oldYi) / float(steps);

                for( int i = 0; i < steps; i++ )
                {
                    xx += oxx;
                    yy += oyy;
                    int xxi = int(xx >= 0.0f ? xx + 0.5f : xx - 0.5f);
                    int yyi = int(yy >= 0.0f ? yy + 0.5f : yy - 0.5f);

                    if( xxi == 350 || yyi == 600 )
                        break;

                    uint relief_ = GetGlobalMapRelief( xxi, yyi );
                    if( movementType == GM_WALK_GROUND && relief != 0 && relief_ == 0 )
                        break;
                    if( movementType == GM_WALK_WATER && relief_ != 0 )
                        break;

                    newXi = xxi;
                    newYi = yyi;
                }
            }

            if( newXi != curXi || newYi != curYi )
            {
                // Stop group
                curX = float(newXi);
                curY = float(newYi);
                speed = 0.0f;
                return;
            }

            // Zone
            int oldZoneX = oldXi / __GlobalMapZoneLength;
            int oldZoneY = oldYi / __GlobalMapZoneLength;
            int curZoneX = curXi / __GlobalMapZoneLength;
            int curZoneY = curYi / __GlobalMapZoneLength;

            // Change zone
            if( oldZoneX != curZoneX || oldZoneY != curZoneY )
            {
                Critter@[] @ group = cr.GetGlobalGroup();
                ScanZone( group, curZoneX, curZoneY );
            }

            // Check for complete travelling
            float curDist = DISTANCE( curX, curY, toX, toY );
            if( curDist <= 0.01f || curDist > lastDist )
            {
                curX = toX;
                curY = toY;
                speed = 0.0f;
                return;
            }
        }

        // Car processing
        if( valid( car ) )
        {
            int fuel = car.Charge;
            uint16 deterioration = car.Deterioration;

            if( fuel <= 0 || deterioration >= car.Proto.Car_MaxDeterioration )
            {
                uint str = ( fuel <= 0 ? STR_CAR_FUEL_EMPTY : STR_CAR_BROKEN );
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, str );
                speed = 0.0f;
                return;
            }

            // Car values created for the call every 500 ms
            fuel -= car.Proto.Car_FuelConsumption * __GlobalMapMoveTime / 500;
            deterioration += car.Proto.Car_DeteriorationRate * __GlobalMapMoveTime / 500;
            if( fuel < 0 )
			{
                fuel = 0;
            }
			if( deterioration > car.Proto.Car_MaxDeterioration )
			{
                deterioration = car.Proto.Car_MaxDeterioration;
			}

            if( fuel != int(car.Charge) || deterioration != car.Deterioration )
            {
                car.Charge = fuel;
                car.Deterioration = deterioration;
                car.Update();
            }
        }

        Cell@ cell = world.PassCell( cr );

        if( cell !is null )
        {
            Critter@[] @ group = cr.GetGlobalGroup();

            // Validate charisma
            Critter@ leader = group[ 0 ];
            if( int( group.length() ) > leader.Stat[ ST_CHARISMA ] )
            {
                leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CRIT_BAD_CHARISMA );
                speed = 0.0f;                 // Stop
                return;
            }

            uint8 wild = cell.ChangeWildness( -1 );

            world.ShowCells( cr, cell );

            CellContent@ cont = cell.Content;
            if( cont is null or ( cont.Type & 0x1F ) == CELLMAP_TYPE_ENCOUTER )
            {
                if( cont !is null and cont.MapId[ CELL_LEVEL_DEFAULT ] != 0 && GetMap( cont.MapId[ CELL_LEVEL_DEFAULT ] ) !is null )
                {
                    // cont.Index=uint(-1);
                    int chance = 0;

					if( cont.GetCrittersCount( CELL_CRITTERS_MOB ) > 0 )
						chance = cr.Skill[ SK_OUTDOORSMAN ] / 2;
					else if( cont.GetCrittersCount( CELL_CRITTERS_SURVIVAL ) > 0 )
						chance = cr.Skill[ SK_OUTDOORSMAN ] / 3;
					else
						chance = -1;
                    
                    if( chance < 0 )
                    {}
                    else if( Random( 0, 100 ) > chance )
                    {
                        encounterDescriptor = uint( -1 );
                    }
                    else
                    {
                        encounterDescriptor = uint( -1 );
                        waitForAnswer = true;
                        cr.Say( SAY_ENCOUNTER_RT, "You see something near you" );
                        cr.Say( SAY_FLASH_WINDOW, "" );
                    }
                }
                else
                {
                    @cell.Content = null;

                    FindEncounter( cr.GetGlobalGroup(), car, curXi, curYi, encounterDescriptor, waitForAnswer, false, wild );
                }
            }
            else if( cont.Visibility > 0 )
			{
                ( encounterDescriptor = uint( -1 ) );
			}
		}
    }
    else if( processType == GLOBAL_PROCESS_ENTER )
    {
        // Enter to empty encounter
        /*if(movementType == GM_WALK_WATER && GetGlobalMapRelief(curXi, curYi) == 0)
           {
                // Find land
                bool landFounded = false;
                const int maxx = __GlobalMapWidth * __GlobalMapZoneLength;
                const int maxy = __GlobalMapHeight * __GlobalMapZoneLength;
                for(int ox = -1; ox <= 1; ox++)
                {
                        for(int oy = -1; oy <= 1; oy++)
                        {
                                int xx = curXi + ox;
                                int yy = curYi + oy;
                                if(xx >= 0 && xx < maxx && yy >= 0 && yy < maxy && GetGlobalMapRelief(xx, yy) != 0)
                                {
                                        FindEncounter(cr.GetGlobalGroup(), car, xx, yy, encounterDescriptor, waitForAnswer, true);
                                        ox = oy = 2; // Exit from loop
                                        landFounded = true;
                                }
                        }
                }

                if(!landFounded) FindEncounter(cr.GetGlobalGroup(), car, curXi, curYi, encounterDescriptor, waitForAnswer, true);
           }
           else
           {
                FindEncounter(cr.GetGlobalGroup(), car, curXi, curYi, encounterDescriptor, waitForAnswer, true);
           }*/

        Cell@ cell = world.GetCell( cr );
        if( cell !is null )
        {
            CellContent@ cont = cell.Content;
            if( cont is null or ( cont.Type & 0x1F ) == CELLMAP_TYPE_ENCOUTER )
            {
                if( cont !is null and cont.MapId[ CELL_LEVEL_DEFAULT ] != 0 && GetMap( cont.MapId[ CELL_LEVEL_DEFAULT ] ) !is null )
                {
                    encounterDescriptor = uint( -1 );
                    cont.Index = uint( -1 );
                }
                else
                {
                    @cell.Content = null;

                    FindEncounter( cr.GetGlobalGroup(), car, curXi, curYi, encounterDescriptor, waitForAnswer, true, 0 );
                }
            }
            else
                ( encounterDescriptor = uint( -1 ) );
        }
    }
    else if( processType == GLOBAL_PROCESS_SET_MOVE )
    {
        Critter@[] @ group = cr.GetGlobalGroup();

        // Validate charisma
        Critter@ leader = group[ 0 ];
        if( int( group.length() ) > leader.Stat[ ST_CHARISMA ] )
        {
            leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CRIT_BAD_CHARISMA );
            if( valid( car ) )
                CheckForLocationWithoutParking( cr, car, curX, curY );
            return;
        }

        // Calculate speed
        speed = GLOBAL_MAP_BASE_SPEED;
        // if(cr.GetAccess() >= ACCESS_TESTER) speed *= 20.0f; // All, exclude clients have highly speed

        if( cr.IsPlayer() && cr.GetAccess() > ACCESS_TESTER )
            speed *= 4;
        
        if( valid( car ) )
        {
            // Validate car
            uint strNum = 0;
            if( group.length() > car.Proto.Car_CrittersCapacity )
                strNum = STR_CAR_CRIT_OVERLOAD;
            else if( car.Charge == 0 )
                strNum = STR_CAR_FUEL_EMPTY;
            else if( car.Deterioration >= car.Proto.Car_MaxDeterioration )
                strNum = STR_CAR_BROKEN;
            if( strNum != 0 )
            {
                leader.SayMsg( SAY_NETMSG, TEXTMSG_GAME, strNum );
                speed = 0.0f;
                CheckForLocationWithoutParking( cr, car, curX, curY );
                return;
            }

            speed = car.Proto.Car_Speed * GLOBAL_MAP_BASE_SPEED / 20.0f;

            // Find near water for boats
            // In radius of one zone (left, top, right, bottom)
            if( car.Proto.Car_MovementType == GM_WALK_WATER )
            {
                if( GetGlobalMapRelief( curXi, curYi ) != 0 )
                {
                    const int   maxx = __GlobalMapWidth * __GlobalMapZoneLength;
                    const int   maxy = __GlobalMapHeight * __GlobalMapZoneLength;
                    const int[] ox = { -1,  0, 1, 0 };
                    const int[] oy = { 0, -1, 0, 1 };
                    for( int i = 1, ii = __GlobalMapZoneLength; i <= ii; i++ )
                    {
                        for( int j = 0; j < 4; j++ )
                        {
                            int xx = curXi + ox[ j ] * i;
                            int yy = curYi + oy[ j ] * i;
                            if( xx >= 0 && xx < maxx && yy >= 0 && yy < maxy && GetGlobalMapRelief( xx, yy ) == 0 )
                            {
                                curX = float(xx);
                                curY = float(yy);
                                // Exit from loop
                                j = 4;
                                i = ii;
                            }
                        }
                    }
                }
            }
        }
    }
    else if( processType == GLOBAL_PROCESS_START_FAST || processType == GLOBAL_PROCESS_STOPPED )
    {
        Cell@ cell = world.GetCell( cr );
        if( cell !is null )
            world.ShowCells( cr, cell );
    }
    else if( processType == GLOBAL_PROCESS_NPC_IDLE )
    {
        // Critter& cr - is npc who call idle
        // Process npc group on global map
        if( curX == toX && curY == toY )       // Stopped
        {
            // If you want enter to location under group than type
            // encounterDescriptor = uint(-1);
            // waitForAnswer = false;
        }
    }
    else if( processType == GLOBAL_PROCESS_KICK )
    {
        if( GetGlobalMapRelief( curXi, curYi ) == 0 )
        {
            // Say to leader
            Critter@[] @ group = cr.GetGlobalGroup();
            group[ 0 ].SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CANT_KICK_ON_WATER );
            return;
        }

        cr.LeaveGlobalGroup();
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on invite to encaunter.
// If mapId != 0 than group enter to it.
void global_invite( Critter& leader, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir )
{
    // Enter to map under group
    /*if(encounterDescriptor == uint(-1))
       {
            Location@[] locations;
            if(GetLocations(leader.WorldX, leader.WorldY, 0, locations) != 0)
            {
                    Location@ loc = locations[0];
                    Map@ map = loc.GetMapByIndex(0);
                    if(valid(map) && map.GetEntireCoords(0, 0, hexX, hexY))
                    {
                            mapId = map.Id;
                            dir = 0xFF;
                    }
            }
            return;

       // Find encounter
       InviteToEncounter(leader.GetGlobalGroup(), car, encounterDescriptor, combatMode, mapId, hexX, hexY, dir);
     */

    Cell@ cell = world.GetCell( leader );
    if( cell is null )
        return;

    CellContent@ cont = cell.Content;

    if( encounterDescriptor != uint( -1 ) && cont is null )
    {
        @cell.Content = CellContent();
        @cont = cell.Content;
        cont.Type |= CELLMAP_TYPE_ENCOUTER;
        cont.Durability = 5;
    }

	if( !valid( cont ) )
	{
		return;
	}

    uint8 type = ( cont.Type & 0x1f );

    if( type == CELLMAP_TYPE_ENCOUTER )
    {
        if( cont.MapId[ CELL_LEVEL_DEFAULT ] != 0 )
        {
            Map@ map = GetMap( cont.MapId[ CELL_LEVEL_DEFAULT ] );
            if( map !is null and map.GetEntireCoords( 0, 0, hexX, hexY, dir ) )
            {
                GetEnterHexFromGlobal( leader, cell, hexX, hexY );
                cont.Index = uint( -1 );
                mapId = map.Id;
            }
        }
        else
        {
            GetEnterHexFromGlobal( leader, cell, hexX, hexY );

            InviteToEncounter( leader.GetGlobalGroup(), car, encounterDescriptor, COMBAT_MODE_REAL_TIME /*combatMode*/, mapId, hexX, hexY, dir );
            cont.Index = encounterDescriptor;
            cont.MapId[ CELL_LEVEL_DEFAULT ] = mapId;
        }
    }
    else if( type == CELLMAP_TYPE_STATIC )
    {
        if( encounterDescriptor != uint( -1 ) )
		{
            Log( "stat, encounterDescriptor WTF?!" );
		}
		
        Map@ map = GetMap( cont.MapId[ CELL_LEVEL_DEFAULT ] );
        if( map !is null and map.GetEntireCoords( 0, 0, hexX, hexY, dir ) )
        {
            // pm added
            GetEnterHexFromGlobal( leader, cell, hexX, hexY );
            cont.Index = uint( -1 );
            mapId = map.Id;
        }
    }

}

void ScanZone( Critter@[]& group, int zx, int zy )
{
    uint[] locIds1, locIds2;
    bool locIds2Founded = false;

    GetZoneLocationIds( zx, zy, 1, locIds1 );

    for( uint i = 0; i < group.length(); i++ )
    {
        Critter@ cr = group[ i ];
        if( !cr.IsPlayer() )
            continue;

        int lookLen = 1;

        if( lookLen == 2 && !locIds2Founded )
        {
            GetZoneLocationIds( zx, zy, 2, locIds2 );
            locIds2Founded = true;
        }

        // Open fog
        int mapw = __GlobalMapWidth;
        int maph = __GlobalMapHeight;
        for( int x = -lookLen; x <= lookLen; x++ )
        {
            for( int y = -lookLen; y <= lookLen; y++ )
            {
                int zx_ = zx + x;
                int zy_ = zy + y;
                if( zx_ >= 0 && zx_ < mapw && zy_ >= 0 && zy_ < maph )
                {
                    int fog = ( zx == zx_ && zy == zy_ ? FOG_NONE : FOG_HALF );
                    if( cr.GetFog( zx_, zy_ ) < fog )
                        cr.SetFog( zx_, zy_, fog );
                }
            }
        }

        // Find new locations
        /*uint[]@ locIds = lookLen == 1 ? locIds1 : locIds2;
           for(uint j = 0; j < locIds.length(); j++)
           {
                uint locId = locIds[j];
                if(!cr.IsKnownLoc(true, locId))
                {
                        Location@ loc = GetLocation(locId);
                        if(valid(loc)) cr.SetKnownLoc(true, locId);
                }
           }*/
    }
}

void CheckForLocationWithoutParking( Critter& cr, Item& car, float& curX, float& curY )
{
    Location@[] locations;
    if( GetVisibleLocations( uint(curX), uint(curY), 0, cr, locations ) != 0 )
    {
        Location@ loc = locations[ 0 ];
        Map@      map = loc.GetMapByIndex( 0 );

        bool      placeFounded = false;
        Entire[] entires;
        ParseEntires( map, entires, car.Proto.Car_Entrance );
        for( uint i = 0; i < entires.length(); i++ )
        {
            if( map.CheckPlaceForItem( entires[ i ].HexX, entires[ i ].HexY, car.GetProtoId() ) )
            {
                placeFounded = true;
                break;
            }
        }

        if( !placeFounded )
        {
            curX = loc.WorldX + int(loc.Radius) * ( Random( 0, 1 ) == 0 ? int(1) : int(-1) );
            curY = loc.WorldY + int(loc.Radius) * ( Random( 0, 1 ) == 0 ? int(1) : int(-1) );
        }
    }
}

bool plotAccess( Critter& cr )
{
	uint[] accessibles = { KARMA_SEPARATED };
	
	for( uint i = 0; i < accessibles.length(); i++ )
	{
		if( cr.KarmaBase[accessibles[i]] != 0 )
		{
			return true;
		}
	}
	
	return false;
}

void TransitCritterToCell( Critter& cr, Scenery& sceneryGrid )
{
    if( @world == null )
    {
        cr.Say( SAY_NETMSG, "world !valid" );
        return;
    }

    if( @sceneryGrid == null )
    {
        cr.Say( SAY_NETMSG, "grid !valid" );
        return;
    }

    Cell@ cell = world.GetCell( cr );

    if( @cell == null )
    {
        cr.Say( SAY_NETMSG, "cell !valid" );
        return;
    }
    if( @cell.Content == null )
    {
        cr.Say( SAY_NETMSG, "cont !valid" );
        return;
    }

    Map@ map = cr.GetMap();
    if( @map == null )
    {
        cr.Say( SAY_NETMSG, "map !valid" );
        return;
    }

    int8 offsetCellX = 0, offsetCellY = 0;
    uint8 direction = map.GetScenParam( sceneryGrid.HexX, sceneryGrid.HexY, sceneryGrid.ProtoId, 0 );
    uint16 destCellX = cell.X, destCellY = cell.Y, oldHexX = 0, oldHexY = 0;

    if( !map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, oldHexX, oldHexY ) )
    {
        cr.Say( SAY_NETMSG, "no ent" );
        return;
    }

    offsetCellX = ( ( cr.HexX - oldHexX ) / REGULAR_MAP_SIZE );
    offsetCellY = ( ( cr.HexY - oldHexY ) / REGULAR_MAP_SIZE );

    SetMapDirection( direction, destCellX, destCellY, offsetCellX, offsetCellY );

    uint16 tempX = 0, tempY = 0;

    tempX = ( direction != 5 && direction != 1 ? cr.HexX : sceneryGrid.HexX );
    tempY = ( direction != 3 && direction != 7 ? cr.HexY : sceneryGrid.HexY );
	
	Cell@ transitCell = world.GetCell( destCellX, destCellY );

    if( cell.SizeX > 1 || cell.SizeY > 1 )
    {
        uint8 tempHexX = ( ( cr.HexX - oldHexX ) / REGULAR_MAP_SIZE );
        uint8 tempHexY = ( ( cr.HexY - oldHexY ) / REGULAR_MAP_SIZE );
        if( tempX > 1)
        {
			if( transitCell.SizeX > 1 )
			{
				tempX -= ( tempHexX );
			}
			else
			{
				tempX -= ( tempHexX ) * REGULAR_MAP_SIZE;
			}
		}
		
        if( tempY > 1 )
        {
            if( transitCell.SizeY > 1 )
			{
				tempY -= ( tempHexY );
			}
			else 
			{
				tempY -= ( tempHexY ) * REGULAR_MAP_SIZE;
			}
		}
    }

	int _oldHexX = oldHexX;
	int _oldHexY = oldHexY;
    oldHexX = ABS( int(tempX - oldHexX) );
    oldHexY = ABS( int(tempY - oldHexY) );

	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
	{
		cr.Say( SAY_NETMSG, oldHexX + " " + oldHexY + " : " + _oldHexX + " " + _oldHexY );
	}
	
    uint8 worldOffsetX = ( ( ( REGULAR_MAP_SIZE - oldHexX ) * 100 ) / REGULAR_MAP_SIZE ), worldOffsetY = ( ( ( REGULAR_MAP_SIZE - oldHexY ) * 100 ) / REGULAR_MAP_SIZE );

    uint16 wX = cell.X * 10, wY = cell.Y * 10 + CELL_SIZE;
    uint16 mapId = 0;

    // generator
    if( transitCell is null || transitCell.Content is null )
    {
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, MSG_ONLY_LOCAL_MAP );
		return;
    }

    int level = GetMapLevelByPid( map.GetProtoId() );

    mapId = transitCell.Content.MapId[ CELL_LEVEL_DEFAULT + level ];

	if( mapId == 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_FORBIDDEN_LOCATION );
		return;
	}
		
    @map = GetMap( mapId );
    if( !valid( map ) )
    {
		return;
    }
	
	uint[] disabled_map_pids = { MAP_snd_bos };
	if( disabled_map_pids.find( map.GetProtoId() ) > -1 ) 
	{
		if( plotAccess( cr ) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_SECRET_PATH );
		}
		else
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CANT_TRESPASS_TERAIN );
			return;
		}
	}
		
    uint16 destHexX = 0, destHexY = 0;
    if( !map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, destHexX, destHexY ) )
    {
        return;
    }
	
    SetHexDirection( cell, transitCell, direction, oldHexX, oldHexY );

	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
	{
		cr.Say( SAY_EMOTE, oldHexX + " " + oldHexY + " : " + destHexX + " " + destHexY );
    }
	
	if( oldHexX < 1000 && oldHexY < 1000 )
    {
		if( CheckMonsterTransitePlace( cr, map, destHexX + oldHexX, destHexY + oldHexY ) )
		{
			cr.StatBase[ ST_OBJECT_TYPE ] = direction;
			cr.StatBase[ ST_ITEM_HEXX ] = destHexX + oldHexX;
			cr.StatBase[ ST_ITEM_HEXY ] = destHexY + oldHexY;
			cr.StatBase[ ST_ITEM_PID ] = mapId;
			
			ShowAnswerScreen( cr );
		}
		else
		{
			if( !transitWithGroup( cr, mapId, destHexX + oldHexX, destHexY + oldHexY, direction, destCellX * 10, destCellY * 10 ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SOMETHING_WENT_WRONG );
			}
		}
		
        return;
    }
	
    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NO_FREE_HEX );
    return;
}

bool transitWithGroup( Critter& cr, uint mapID, uint16 x, uint16 y, uint8 dir, uint16 cx, uint16 cy )
{
	return transitToMap( cr, mapID, x, y, dir, 2, cx, cy );
}

bool transitToMap( Critter& cr, uint mapID, uint16 x, uint16 y, uint8 dir, uint8 radius, uint16 cx, uint16 cy ) //exported
{
	Map@ map = GetMap( mapID );
	if( !valid( map ) )
	{
		return false;
	}
	
	uint16 hexX = x, hexY = y;

	uint8 newDir = 0;
	switch( dir )
	{
		case( GRID_NE ):
			newDir = 0;
			break;
		case( GRID_E ):
		case( GRID_SE ):
			newDir = 1;
			break;
		case( GRID_S ):
			newDir = 2;
			break;
		case( GRID_SW ):
			newDir = 3;
			break;
		case( GRID_W ):
		case( GRID_NW ):
			newDir = 4;
			break;
		case( GRID_N ):
			newDir = 5;
			break;
		default:
			break;
	}


	map.MoveHexByDir( hexX, hexY, newDir, Random( 1, 3 ) );
	if( map.IsHexPassed( hexX, hexY ) ) 
	{
		cr.TransitToMap( mapID, hexX, hexY, newDir, 2, true );
		cr.ParamBase[ CR_GRID_TRANSFER_X ] = cr.HexX;
		cr.ParamBase[ CR_GRID_TRANSFER_Y ] = cr.HexY;
		cr.SetWorldPos( cx, cy );
		
		return true;
	}
	
	return false;
}

bool CheckMonsterTransitePlace(Critter& cr, Map& map, uint16 hexX, uint16 hexY)
{
	if( valid( map ) )
	{
		Critter@[] mobs;
		uint8 radius = cr.Skill[SK_OUTDOORSMAN] / SKILL_OUTDORSMAN_MOD;
		uint8 temp = map.GetCrittersHex(hexX, hexY, radius, FIND_LIFE, null);
		if(temp > 0)
		{
			return true;
		}
	}
	return false;
}

void ShowAnswerScreen(Critter& cr)
{
	cr.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_Mob" );
	cr.SayMsg( SAY_DIALOGBOX_TEXT, TEXTMSG_GAME, STR_FEEL_DANGER );
	cr.SayMsg( SAY_DIALOGBOX_BUTTON( 0 ), TEXTMSG_GAME, STR_AGREE_MAKE_TRANSFER );
}

void answer_Mob(Critter& cr, uint answerI, string& answerS)
{
	if( answerI == 0 )
	{
		Map @ map = GetMap( cr.StatBase[ST_ITEM_PID] );
		if( !valid( map ) ) 
		{
			cr.Say(SAY_NETMSG, "Mapid error.");
			return;
		}
		
		transitWithGroup( cr, map.Id, cr.StatBase[ST_ITEM_HEXX], cr.StatBase[ST_ITEM_HEXY], cr.StatBase[ST_OBJECT_TYPE], map.GetLocation().WorldX, map.GetLocation().WorldY );
	}
}

bool GetEnterHexFromGlobal( Critter& leader, Cell& cell, uint16& hexX, uint16& hexY )
{
    // leader.Say(SAY_NETMSG, "wSX "+(leader.WorldX * 0.1)+" wSY "+(leader.WorldY * 0.1)+" cSX "+cell.X+" cSY "+cell.Y+" x "+(ABS(cell.X - (leader.WorldX * 0.1)))+" y "+(ABS(cell.Y - (leader.WorldY * 0.1))));
    if( !valid( cell.Content ) )
	{
        return false;
	}
	
    Map @ map = GetMap( cell.Content.MapId[ CELL_LEVEL_DEFAULT ] );
    if( valid( map ) )
    {
        uint16 placeMapHexX = 0, placeMapHexY = 0;
        if( map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, placeMapHexX, placeMapHexY ) )
        {
            uint8 tempX = leader.WorldX - uint( cell.X * 10 );
            uint8 tempY = leader.WorldY - uint( cell.Y * 10 );
            int8  tempN = -1;

            // uint8 placeCellX = (leader.WorldX - uint(leader.WorldX * 0.1)), placeCellY = (leader.WorldY - uint(leader.WorldY * 0.1));
            uint8 placeCellX = ( uint( REGULAR_MAP_SIZE * 0.1 ) * tempX ), placeCellY = ( uint( REGULAR_MAP_SIZE * 0.1 ) * tempY );

            if( tempY <= 3 && tempX >= 0 )
			{
				tempN = 0;
            }
			else if( tempY >= 0 && tempX >= 5 )
			{
				tempN = 1;
            }
			else if( tempY >= 5 && tempX >= 0 )
			{
				tempN = 2;
			}
            else if( tempY >= 0 && tempX <= 3 )
			{
				tempN = 3;
			}

			switch( tempN )
            {
				case( 0 ):
					placeMapHexX += placeCellX;
					break;
				case( 1 ):
					placeMapHexX += ADD_HEX_COUNT;
					placeMapHexY += placeCellY;
					break;
				case( 2 ):
					placeMapHexX += placeCellX;
					placeMapHexY += REGULAR_MAP_SIZE - ADD_HEX_COUNT;
					break;
				case( 3 ):
					placeMapHexX += REGULAR_MAP_SIZE;
					placeMapHexY += placeCellY;
					break;
				default:
					break;
            }

            hexX = placeMapHexX;
            hexY = placeMapHexY;

            return true;
        }
    }
	
    return false;
}

bool SetMapDirection( uint8 direction, uint16& destCellX, uint16& destCellY, int8& offsetCellX, int8& offsetCellY )
{
    Cell@ cell = world.GetCell( destCellX, destCellY );
    if( cell is null || cell.Content is null )
	{
        return false;
	}
	
    int tempX = 0, tempY = 0;

    if( cell.X != cell.ParantX || cell.Y != cell.ParantY )
    {
        Cell@ parantCell = world.GetCell( cell.ParantX, cell.ParantY );

        if( parantCell is null || parantCell.Content is null )
		{
            return false;
		}
		
        tempX = cell.X - parantCell.X;
        tempY = cell.X - parantCell.X;

        destCellX = parantCell.X;
        destCellY = parantCell.Y;
    }

    Cell@ targetCell = null;

    uint sizeX = cell.SizeX,    // offsetCellX+1,
         sizeY = cell.SizeY;    // offsetCellY+1;


    switch( direction )
    {
		case( GRID_NE ):
			destCellX++;
			destCellY--;
			break;
		case( GRID_E ):
			destCellX++;
			destCellY += offsetCellY;
			break;
		case( GRID_SE ):
			destCellX++;
			destCellY += sizeY;
			break;
		case( GRID_S ):
			destCellX -= offsetCellX;
			destCellY += sizeY;
			break;
		case( GRID_SW ):
			destCellX -= sizeX;
			destCellY += sizeY;
			break;
		case( GRID_W ):
			destCellX -= sizeX;
			destCellY += offsetCellY;
			break;
		case( GRID_NW ):
			destCellX -= sizeX;
			destCellY--;
			break;
		case( GRID_N ):
			destCellX -= offsetCellX;
			destCellY--;
			break;
		default:
			return false;
    }

    @targetCell = world.GetCell( destCellX, destCellY );
    if( targetCell is null || targetCell.Content is null )
    {
        return false;
    }

    return true;
}

void SetHexDirection( Cell& cell, Cell& targetCell, uint8& direction, uint16& hexX, uint16& hexY ) // , uint8 sizeX, uint8 sizeY)
{
    uint16 mapSizeX = REGULAR_MAP_SIZE,
           mapSizeY = REGULAR_MAP_SIZE;

    bool bigSizeX = false,
         bigSizeY = false;

    if( targetCell.SizeX > 1 || targetCell.SizeY > 1 )
    {
        int tempX = targetCell.ParantX - cell.ParantX,
            tempY = targetCell.ParantY - cell.ParantY;

        uint tempXX = ABS( tempX ),
             tempYY = ABS( tempY );

        if( tempX != 0 )
        {
            mapSizeX = ABS( REGULAR_MAP_SIZE * tempX );
            bigSizeX = true;
        }
		
        if( tempY != 0 )
        {
            mapSizeY = ABS( REGULAR_MAP_SIZE * tempY );
            bigSizeY = true;
        }
    }

    switch( direction )
    {
		case( GRID_NE ):
			hexX = mapSizeX - hexX;
			hexY = mapSizeY - hexY;
			direction = 0;
			break;
		case( GRID_E ):
		{
			hexX = mapSizeX - hexX;
			if( bigSizeY )
			{
				hexY = mapSizeY + hexY;
			}
			direction = 1;
			break;
		}
		case( GRID_SE ):
			hexX = mapSizeX - hexX - ADD_HEX_COUNT;
			hexY = mapSizeY - hexY;
			direction = 2;
			break;
		case( GRID_S ):
		{
			if( bigSizeX )
			{
				hexX = mapSizeX + hexX;
			}
			hexY = mapSizeY - hexY;
			direction = Random( 2, 3 );
			break;
		}
		case( GRID_SW ):
			hexX = mapSizeX - hexX;
			hexY = mapSizeY - hexY;
			direction = 3;
			break;
		case( GRID_W ):
		{
			hexX = mapSizeX - hexX;
			if( bigSizeY )
			{
				hexY = mapSizeY + hexY;
			}
			direction = 4;
			break;
		}
		case( GRID_NW ):
			hexX = mapSizeX - hexX;
			hexY = mapSizeY - hexY - ADD_HEX_COUNT;
			direction = 5;
			break;
		case( GRID_N ):
		{
			if( bigSizeX )
			{
				hexX = mapSizeX + hexX;
			}
			hexY = mapSizeY - hexY;
			direction = ( Random( 0, 1 ) > 0 ? 5 : 0 );
			break;
		}
		default:
			return;
    }
    return;
}

void SetOffSetNonStandartMaps( Cell& cell, uint8 direction, uint16 hexX, uint16 hexY, int8 offsetCellX, int8 offsetCellY, uint16& destCellX, uint16& destCellY )
{
    uint16 tempX = hexX / REGULAR_MAP_SIZE,
           tempY = hexY / REGULAR_MAP_SIZE;

    switch( direction )
    {
		case( GRID_NE ):
			destCellX + offsetCellX;
			destCellY - offsetCellY;
			break;
		case( GRID_E ):
			destCellX + offsetCellX;
			break;
		case( GRID_SE ):
			destCellX + offsetCellX;
			destCellY + offsetCellY;
			break;
		case( GRID_S ):
			destCellY + offsetCellY;
			break;
		case( GRID_SW ):
			destCellX - offsetCellX;
			destCellY + offsetCellY;
			break;
		case( GRID_W ):
			destCellX - offsetCellX;
			break;
		case( GRID_NW ):
			destCellX - offsetCellX;
			destCellY - offsetCellY;
			break;
		case( GRID_N ):
			destCellY - offsetCellY;
			break;
		default:
			break;
    }
}

void SetWorldDirection( uint8 direction, uint16& wX, uint16& wY, uint8 worldOffsetX, uint8 worldOffsetY )
{
    wY -= uint( worldOffsetY * 0.1 );

    switch( direction )
    {
		case( GRID_NE ):
			wX += uint(worldOffsetX * 0.1);
			break;
		case( GRID_E ):
			wX += uint(worldOffsetX * 0.1);
			break;
		case( GRID_SE ):
			wX += uint(worldOffsetX * 0.1);
			break;
		case( GRID_S ):
			wY += uint(worldOffsetY * 0.1);
			break;
		case( GRID_SW ):
			wX -= uint(worldOffsetX * 0.1);
			break;
		case( GRID_W ):
			wX -= uint(worldOffsetX * 0.1);
			break;
		case( GRID_NW ):
			wX -= uint(worldOffsetX * 0.1);
			break;
		case( GRID_N ):
			wX += uint(worldOffsetX * 0.1);
			break;
		default:
			return;
    }
}

void RefrashCoords( Critter& cr )
{
    Cell @ cell = world.GetCell( cr );
    if( @cell == null )
	{
        return;
	}
}

void Ttransit( Item& item, bool firstTime )
{
}

void unsafe_ExitGridClick( Critter& cr, int hexX, int hexY, int protoId, string@ param3, int[] @ param4 )
{
    if( cr.IsKnockout() || cr.IsDead() )
	{
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CANT_MAKE_TRANSFER );
        return;
    }
	
    if( cr.Timeout[ TO_TRANSFER ] > 0 )
	{
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_TIMEOUT_TRANSFER_WAIT );
        return;
    }
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
    Scenery@ sceneryGrid = map.GetScenery( hexX, hexY, protoId );
    if( valid( sceneryGrid ) )
    {
        uint8 length = map.GetPathLength( cr, sceneryGrid.HexX, sceneryGrid.HexY, 0 );
        if( ABS( int( cr.HexX - sceneryGrid.HexX) ) <= EXIT_GRID_DISTATION && ABS( int( cr.HexY - sceneryGrid.HexY) ) <= EXIT_GRID_DISTATION )
        {
            TransitCritterToCell( cr, sceneryGrid );
        }
		else
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_TOO_FAR_FROM_GRID );
		}
	}

}

void unsafe_GetMapPid( Critter& cr, int hexX, int hexY, int protoId, string@ param3, int[] @ param4 )
{
	Map@ baseMap = cr.GetMap();
	if( !valid( baseMap ) )
	{
		return;
	}
	
	Scenery@ sceneryGrid = baseMap.GetScenery( hexX, hexY, protoId );
    if( valid( sceneryGrid ) )
    {
        Cell @ cell = world.GetCell( cr );
        if( valid( cell ) && valid( cell.Content ) )
        {
            int8 offsetCellX = 0;
			int8 offsetCellY = 0;
			int8 level = GetMapLevelByPid( baseMap.GetProtoId() );
			
            uint8  direction = baseMap.GetScenParam( hexX, hexY, protoId, 0 );
            uint16 destCellX = cell.X, destCellY = cell.Y, oldHexX = 0, oldHexY = 0;

			if( cell.Content.MapId[ CELL_LEVEL_DEFAULT + level ] == 0 ) // no map
			{
				return;
			}
			
            if( !GetMap( cell.Content.MapId[ CELL_LEVEL_DEFAULT + level ] ).GetEntireCoords( MAP_EDGE_ENTIRE, 0, oldHexX, oldHexY ) )
            {
                cr.Say( SAY_NETMSG, "no ent" );
                return;
            }

            oldHexX = sceneryGrid.HexX - oldHexX;
            oldHexY = sceneryGrid.HexY - oldHexY;

            cr.StatBase[ ST_LOCALMAP_DIR ] = direction;
            if( SetMapDirection( direction, destCellX, destCellY, offsetCellX, offsetCellY ) )
            {
                int mapId = GetCellMap( destCellX * 10, destCellY * 10, level );
				
                if( mapId != -1 )
                {
                    Map@ map = GetMap( mapId );
                    if( valid( map ) )
                    {
                        cr.StatBase[ ST_LOCALMAP_PID ] = map.GetProtoId();
                        return;
                    }
                }
            }
        }
    }
	
    cr.StatBase[ ST_LOCALMAP_PID ] = 0;
    return;
}

int GetCellMap( uint16 x, uint16 y )
{
    Cell @ cell = world.GetCell( int( x * 0.1 ), int( y * 0.1 ) );
    if( @cell == null || cell.Content is null )
	{
        return -1;
 	}
	
	return cell.Content.MapId[ CELL_LEVEL_DEFAULT ];
}

int GetCellMap( uint16 x, uint16 y, int level )
{
    Cell @ cell = world.GetCell( int( x * 0.1 ), int( y * 0.1 ) );
    if( @cell == null || cell.Content is null )
	{
        return -1;
    }
	
	return cell.Content.MapId[ CELL_LEVEL_DEFAULT + level ];
}

CellContent@ CreateContent( Cell& cell, uint mapId, uint8 type, int8 visibility )
{
    @cell.Content = CellContent( mapId, type, visibility );
    return cell.Content;
}

void CreateCell( uint16 x, uint16 y, uint mapId, uint8 type, int8 visibility )
{
    world.CreateCell( x, y, mapId, type, visibility );
}

void FindTransitHex( Map& map, uint16& hexX, uint16& hexY, uint8 radius, uint8& side )
{
    for( uint16 i = hexY - uint( radius * 0.5 ), j = hexY + uint( radius * 0.5 ); i < j; ++i )
    {
        for( uint16 ii = hexX - uint( radius * 0.5 ), jj = hexX + uint( radius * 0.5 ); ii < jj; ++ii )
        {
            Scenery @ scen = map.GetScenery( ii, i, EXIT_GRID_PID_BEGIN );
            if( !valid( scen ) )
			{
                continue;
			}
			
            hexX = ii;
            hexY = i;

            side = map.GetScenParam( scen.HexX, scen.HexY, scen.ProtoId, 0 );

            return;
        }
    }
}

void cellvisibleset( Critter& cr, int vis, int, int )
{
    Cell @ cell = world.GetCell( uint( cr.WorldX * 0.1 ), uint( cr.WorldY * 0.1 ) );
    if( cell is null || cell.Content is null )
	{
        return;
	}
	
    if( vis == 100 )
	{
        vis *= -1;
	}
	
    cell.Content.Visibility = vis;
}

void ChangeMonsterCount( uint8 x, uint8 y, bool increase )
{
    Cell @ cell = world.GetCell( uint( x * 0.1 ), uint( y * 0.1 ) );
    if( cell is null )
	{
        return;
	}
	
    cell.ChangeMonsterCount( increase );
}


void ChangeMonsterCount( Critter& cr, bool increase )
{
    Cell @ cell = world.GetCell( cr );
    if( cell is null )
	{
        return;
	}
	
    cell.ChangeMonsterCount( increase );
}

void ChangeMonsterCount( Critter& cr, uint8 count, bool increase )
{
    Cell @ cell = world.GetCell( cr );
    if( cell is null )
	{
        return;
	}
	
    cell.ChangeMonsterCount( count, increase );
}

const uint16[] wild_1 =
{
    311,
    311,
    312,
    319
};

const uint16[] wild_2 =
{
    313,
    314,
    316,
    318
};

const uint16[] wild_3 =
{
    315,
    317,
    318,
    320
};

const uint16[] wild_5 =
{
    315,
    317,
    318,
    320,
    324,
};

const uint16[] wild_6 =
{
    324,
    325
};

const uint16[] wild_7 =
{
    325,
    327
};

const uint16[] wild_8 =
{
    328,
    329
};

const uint16[] wild_10 = {      326     };

uint16 MonsterTypeTable( uint8 wild )
{
    uint16 type = 0;

    wild = int( wild * 0.1 );

    switch( wild )
    {
    case 1:
        type = wild_1[ Random( 0, wild_1.length() - 1 ) ];
        break;
    case 2:
        type = wild_2[ Random( 0, wild_2.length() - 1 ) ];
        break;
    case 3:
        type = wild_3[ Random( 0, wild_3.length() - 1 ) ];
        break;
    case 4:
        type = wild_3[ Random( 0, wild_3.length() - 1 ) ];
        break;
    case 5:
        type = wild_3[ Random( 0, wild_3.length() - 1 ) ];
        break;
    case 6:
        type = wild_6[ Random( 0, wild_6.length() - 1 ) ];
        break;
    case 7:
        type = wild_7[ Random( 0, wild_7.length() - 1 ) ];
        break;
    case 8:
        type = wild_8[ Random( 0, wild_8.length() - 1 ) ];
        break;
    case 9:
        type = wild_8[ Random( 0, wild_8.length() - 1 ) ];
        break;
    case 10:
        type = wild_10[ Random( 0, wild_10.length() - 1 ) ];
        break;
    default:
        type = 311;
        break;
    }

    return type;
}

void SpawMonstersCritter( Critter& cr )
{
    Cell @ cell = world.GetCell( cr );
    if( cell is null || cell.Content is null )
        return;

    SpawMonstersCell( cell, cell.MonsterCount );
}

void SpawMonstersCell( Cell& cell, uint16 count )
{
    for( uint8 i = 0, j = cell.Content.MapId.length(); i < j; ++i )
    {
        Map @ map = GetMap( cell.Content.MapId[ i ] );    // CELL_LEVEL_DEFAULT
        if( map is null )
            continue;

        int level = GetMapLevelByPid( map.GetProtoId() );
        uint8[] tileGroups;

        if( level < 0 )                         // underground
        {
            tileGroups.insertLast( 4 );
            tileGroups.insertLast( 5 );
            tileGroups.insertLast( 7 );
        }
        else                                    // ground maps
        {
            tileGroups.insertLast( 1 );
            tileGroups.insertLast( 2 );
            tileGroups.insertLast( 3 );
        }

        uint16 hexX = 0, hexY = 0, tempX = 0, tempY = 0;

        map.GetEntireCoords( 255, 0, hexX, hexY );

        uint16 type = wild_1[ Random( 0, wild_1.length() - 1 ) ];

        bool  condition = false;

        uint8 sizeX = cell.SizeX, sizeY = cell.SizeY;
        uint  hash = 0;

        for( uint8 k = 0; k < count; ++k )
        {
            do
            {
                tempX = Random( hexX, hexX + ( sizeX * REGULAR_MAP_SIZE ) - 5 );
                tempY = Random( hexY, hexY + ( sizeY * REGULAR_MAP_SIZE ) - 5 );
            }
            while( !map.IsHexPassed( tempX, tempY ) );

            Critter @ npc = map.AddNpc( type, tempX, tempY, 3, null, null, "mob@_MobInit" );

            if( npc is null )
                continue;
            npc.StatBase[ ST_TEAM_ID ] = 24;

            npc.StatBase[ ST_SPEED_MOD ] = 200;

            Log( "npc added " + npc.HexX + ":" + npc.HexY );
        }
    }
}

void GlobalCellPopulation()
{
    world.GlobalPopulation();
}

void DropWild()
{
    for( uint16 i = 0, j = world.Cells.length(); i < j; ++i )
    {
        if( world.Cells[ i ] is null )
            return;

        world.Cells[ i ].DropWildness();
    }
}

void ReduseWildByWildness( Critter& cr )
{
    Cell @ cell = world.GetCell( cr );
    if( cell is null )
        return;

    cell.ChangeWildness( cell.Wildness / cell.MonsterCount );
}

void ForcePopulation( Critter& cr, int count, int type, int )
{
    if( count > 1 )
        count = 1;

    for( int i = 0; i < count; ++i )
    {
        if( type > 0 )
        {
            SpawMonstersCritter( cr );
        }
        else
        {
            GlobalCellPopulation();
        }
    }
}

void CellWorldPop( Critter& cr, int count, int, int )
{
    for( uint16 i = 0, j = world.Cells.length(); i < j; ++i )
    {
        if( world.Cells[ i ].MonsterCount > 0 )
        {
            Log( "cell " + world.Cells[ i ].X + ":" + world.Cells[ i ].Y + " pop " + world.Cells[ i ].MonsterCount );
        }
    }
}

void CellAnyData( Critter& cr, int count, int, int )
{
    int[] monstersData;
    if( IsAnyData( "cells_monsters_v1" ) )
    {
        GetAnyData( "cells_monsters_v1", monstersData );

        for( uint16 i = 0, j = monstersData.length(); i < j; ++i )
        {
            Log( "cell " + i + " pop " + monstersData[ i ] );
        }
    }

}

void CellSetAnyData( Critter& cr, int min, int max, int add )
{
    if( max <= 0 )
        max = 1;
    if( min >= max )
        min = max - 1;
    int[] monstersData;
    if( IsAnyData( "cells_monsters_v1" ) )
    {
        GetAnyData( "cells_monsters_v1", monstersData );

        for( uint16 i = 0, j = monstersData.length(); i < j; ++i )
        {
            if( add > 0 )
                monstersData[ i ] += Random( min, max );
            else
                monstersData[ i ] = Random( min, max );
        }

        SetAnyData( "cells_monsters_v1", monstersData );
    }

}

int CellLocationCreate( int pid, int x, int y, int force )
{
    Cell @ cell = world.GetCell( x, y );
    if( cell is null )
        return -1;

    return cell.CellCreate( pid, force > 0 ? true : false );
}

int CellLocationCreate( int pid, int x, int y, int wild, int livetime, int force )
{
    Cell @ cell = world.GetCell( x, y );
    if( cell is null )
        return -1;

    return cell.CellCreate( pid, wild, livetime, force > 0 ? true : false );
}

int CellLocationMove( int x, int y, int x1, int y1 )
{
    Cell @ cell = world.GetCell( x, y );
    if( cell is null )
        return -1;

    return cell.CellMove( x1, y1 );
}

int CellLocationDelete( int x, int y )
{
    Cell @ cell = world.GetCell( x, y );
    if( cell is null )
        return -1;

    return cell.CellDelete();
}

int CellLocationSize( int x, int y, int sizeX, int sizeY )
{
    Cell @ cell = world.GetCell( x, y );
    if( cell is null )
	{
        return -1;
	}
	
    return cell.CellSetSize( sizeX, sizeY );
}

int GetMapLevelByPid( uint pid )
{
    int level = 0;
    switch( pid )
    {
		case( MAP_snd1_1dn ):
		case( MAP_snd1_2dn ):
		case( MAP_snd1_3dn ):
		case( MAP_snd1_4dn ):
		case( MAP_snd1_5dn ):
		case( MAP_snd2_1dn ):
		case( MAP_snd2_2dn ):
		case( MAP_snd2_3dn ):
			level =	-1;
			break;
		case( MAP_snd2_3dn2 ):
			level =	-2;
			break;
		case( MAP_snd2_3dn3 ):
			level =	-3;
			break;
		case( MAP_snd2_3dn4 ):
			level =	-4;
			break;
		case( MAP_snd2_3dn5 ):
			level =	-5;
			break;
		case( MAP_snd2_4dn ):
		case( MAP_snd2_5dn ):
		case( MAP_snd3_1dn ):
		case( MAP_snd3_2dn ):
		case( MAP_snd3_3dn ):
		case( MAP_snd3_4dn ):
		case( MAP_snd3_5dn ):
		case( MAP_snd4_1dn ):
		case( MAP_snd4_2dn ):
		case( MAP_snd4_3dn ):
		case( MAP_snd4_4dn ):
		case( MAP_snd4_5dn ):
		case( MAP_snd5_1dn ):
		case( MAP_snd5_2dn ):
		case( MAP_snd5_3dn ):
		case( MAP_snd5_4dn ):
		case( MAP_snd5_5dn ):
		case( MAP_snd_bos_dn1 ):
			level =	-1;
			break;	
		case( MAP_snd_bos_dn2 ):
			level =	-2;
			break;					
		case( MAP_snd_bos_dn3 ):
			level =	-3;
			break;
		case( MAP_snd0_2dn ):
			level =	-1;
			break;
		case( MAP_snd1_2dn2 ):
		case( MAP_snd4_3dn2 ):
			level =	-2;
			break;
		case( MAP_event2_slavers_in ):
		case( MAP_fort_rdr_dn ):
			level =	-1;
			break;
		case( MAP_fort_rdr_up1 ):
			level =	1;
			break;			
		case( MAP_fort_rdr_up2 ):
			level =	2;
			break;			
		case( MAP_rdr1_2dn ):
		case( MAP_rdr1_3dn ):
		case( MAP_rdr2_2dn ):
		case( MAP_rdr2_3dn ):
		case( MAP_rdr3_1dn ):
			level =	-1;
			break;			
		case( MAP_rdr3_1_mine1 ):
			level =	-2;
			break;			
		case( MAP_rdr3_1_mine2 ):
			level =	-3;
			break;
		case( MAP_fort_rdr_dn2 ):
			level =	-2;
			break;	
		case( MAP_fort_rdr_dn3 ):
        case( MAP_clinton13_7_dn_3 ):
			level =	-3;
			break;			
		case( MAP_rdr4_1dn ):
			level =	-1;
			break;			
		case( MAP_rdr4_1_mine1 ):
			level =	-2;
			break;			
		case( MAP_rdr5_2dn ):
		case( MAP_rdr5_3dn ):
		case( MAP_rdr6_1dn ):
			level =	-1;
			break;			
		case( MAP_rdr6_1_mine1 ):
			level =	-2;
			break;			
		case( MAP_rdr6_2dn ):
		case( MAP_rdr6_3dn ):
		case( MAP_rdr_dogs_motel_dn ):
		case( MAP_rdr2_1dn ):
		case( MAP_rdr1_1dn ):
		case( MAP_toxic_pit ):
			level = -1;
			break;
		case( MAP_rdr0_1dn ):
			level = -2;
			break;
		case( MAP_rdr0_2dn ):
		case( MAP_lair_of_death ):
			level = -1;
			break;
		case( MAP_rdr0_3dn ):
			level = -2;
			break;
		case( MAP_rdr_canyon_dn ):
		case( MAP_rdr_up_3_1dn ):
		case( MAP_rdr_up_3_2dn ):
		case( MAP_rdr_up_3_3dn ):
		case( MAP_rdr_up_2_1dn ):
		case( MAP_rdr_up_2_2dn ):
		case( MAP_rdr_up_2_3dn ):
		case( MAP_rdr7_1dn ):
		case( MAP_rdr7_2dn ):
		case( MAP_rdr7_3dn ):
			level = -1;
			break;
		case( MAP_rdr_7_3_mine1 ):
			level = -2;
			break;
		case( MAP_rdr_up_1_2dn ):
			level = -1;
			break;
		case( MAP_rdr8_2up ):
			level = 1;
			break;
		case( MAP_rdr8_2dn1 ):
			level = -1;
			break;
		case( MAP_rdr8_2dn2 ):
			level = -2;
			break;
		case( MAP_frisco2_3dn ):
			level = -1;
			break;
		case( MAP_frisco2_3up1 ):
			level = 1;
			break;
		case( MAP_frisco2_3up2 ):
			level =	2;
			break;
		case( MAP_frisco2_3up3 ):
			level = 2;
			break;
		case( MAP_frisco2_3up4 ):
			level =	2;
			break;
		case( MAP_frisco2_2_dn ):
		case( MAP_v66_lvl1 ):
			level =	-1;
			break;
		case( MAP_rdr_up_1_1dn ):
		case( MAP_canyon_3dn ):
		case( MAP_canyon_5dn ):
		case( MAP_mt_cave_01 ):
			level =	-1;
			break;
		case( MAP_mt_cave_02 ):
		case( MAP_v66_lvl2 ):
			level =	-2;
			break;
		case( MAP_mt_cave_03 ):
		case( MAP_v66_lvl3 ):
			level =	-3;
			break;
		case( MAP_mt_cave_04 ):
		case( MAP_v66_lvl4 ):
        case( MAP_clinton13_7_dn_4 ):
			level =	-4;
			break;			
		case( MAP_rdr0_4dn ):
		case( MAP_rdr0_5dn ):
		case( MAP_rdr1_4dn ):
		case( MAP_rdr1_5dn ):
		case( MAP_rdr_up_0_1dn ):
		case( MAP_rdr_up_0_2dn ):
		case( MAP_junk_dn ):
		case( MAP_phoenix_1 ):
			level =	-1;
			break;
		case( MAP_slake_quarry_mine1 ):
		case( MAP_slake_quarry_mine2 ):
		case( MAP_slake_mine_dn ):
		case( MAP_slake_uranium_fever ):
		case( MAP_slake_town_dn ):
		case( MAP_slake_downtown_dn ):
		case( MAP_slake_ruin1_dn ):
		case( MAP_slake_wasteland_dn ):
		case( MAP_slake_crossroads_dn ):
		case( MAP_slake_waterplant_dn ):
		case( MAP_slake_ruin2_dn ):
		case( MAP_slake_hive_dn ):
		case( MAP_slake_road2_dn ):
		case( MAP_slake_hill_dn ):
		case( MAP_slake_ruin3_mine ):
		case( MAP_slake_ruin3_dn ):
		case( MAP_slake_rad_twr_dn ):
		case( MAP_slake_rod_sth1_dn ):
		case( MAP_slake_rod_sth2_dn ):
		case( MAP_slake_elbrus_dn ):
		case( MAP_slake_radio_dsr_dn ):
		case( MAP_slake_shop_dn ):
		case( MAP_slake_dump_dn ):
		case( MAP_slake_ranch_dn ):
		case( MAP_slake_gas_rd_dn ):
		case( MAP_slake_hill_rd_dn ):
		case( MAP_slake_space_dn ):
		case( MAP_slake_lab1 ):
		case( MAP_slake_gas_dn ):
		case( MAP_RAIDERS_CAVE ):
		case( MAP_wood_3dn ):
		case( MAP_wolf_in ):
			level = -1;
			break;
		case( MAP_slake_lab2 ):
        case( MAP_clinton6_3_dn_2 ):
        case( MAP_clinton13_7_dn_2 ):
			level = -2;
			break;		
		case( MAP_slake_town_up ):
		case( MAP_slake_shuttle_ins ):
		case( MAP_wood_1 ):
		case( MAP_wood_turn ):
		case( MAP_wood_2 ):
		case( MAP_wood_3 ):
		case( MAP_wood_4 ):
		case( MAP_wood_out ):
		case( MAP_wolf ):
			level = 1;
			break;
		case( MAP_vbbox_town_dn ):
			level = -1;
			break;
		case( MAP_clinton_center_up ):
			level = 2;
			break;			
		case( MAP_clinton_center_dn1 ):
		case( MAP_clinton1_1_dn ):
		case( MAP_clinton1_2_dn ):
		case( MAP_clinton1_3_dn ):
		case( MAP_clinton1_4_dn ):
		case( MAP_clinton2_1_dn ):
		case( MAP_clinton2_2_dn ):
		case( MAP_clinton2_3_dn ):
		case( MAP_clinton2_4_dn ):
		case( MAP_clinton3_1_dn ):
		case( MAP_clinton3_4_dn ):
		case( MAP_clinton4_1_dn ):
		case( MAP_clinton4_4_dn ):
		case( MAP_clinton5_1_dn ):
		case( MAP_clinton5_2_dn ):
		case( MAP_clinton5_3_dn ):
		case( MAP_clinton5_4_dn ):
		case( MAP_clinton_highway_dn ):
		case( MAP_clinton_highway_lab1 ):
		case( MAP_clinton6_0_dn ):
			level = -1;
			break;
		case( MAP_clinton_lab1 ):
			level = -2;
			break;
		case( MAP_clinton_lab2 ):
			level = -3;
			break;
		case( MAP_clinton6_1_dn ):
        case( MAP_clinton6_2_dn ):
        case( MAP_clinton6_3_dn ):
        case( MAP_clinton6_4_dn ):
        case( MAP_clinton7_2_dn ):
        case( MAP_clinton7_3_dn ):
        case( MAP_clinton7_4_dn ):
        case( MAP_clinton8_2_dn ):
        case( MAP_clinton8_3_dn ):
        case( MAP_clinton8_4_dn ):
        case( MAP_clinton9_2_dn ):
        case( MAP_clinton9_3_dn ):
        case( MAP_clinton10_2_dn ):
        case( MAP_clinton10_3_dn ):
        case( MAP_clinton11_2_dn ):
        case( MAP_clinton11_3_dn ):
        case( MAP_clinton12_2_dn ):
        case( MAP_clinton12_3_dn ):
        case( MAP_clinton12_4_dn ):
        case( MAP_clinton13_3_dn ):
        case( MAP_clinton13_4_dn ):
        case( MAP_clinton13_6_dn ):
        case( MAP_clinton13_7_dn ):
        case( MAP_clinton14_2_dn ):
        case( MAP_clinton14_3_dn ):
        case( MAP_clinton14_4_dn ):
        case( MAP_clinton14_5_dn ):
        case( MAP_clinton14_6_dn ):
        case( MAP_clinton15_2_dn ):
        case( MAP_clinton15_3_dn ):
        case( MAP_clinton15_4_dn ):
        case( MAP_clinton15_5_dn ):
        case( MAP_clinton15_6_dn ):
        case( MAP_clinton16_2_dn ):
        case( MAP_clinton16_3_dn ):
        case( MAP_clinton16_4_dn ):
        case( MAP_clinton17_3_dn ):
			level = -1;
			break;
		case( MAP_clinton_center_dn2 ):
		case( MAP_clinton_highway_lab2 ):
		case( MAP_clinton_highway_station ):
		case( MAP_clinton_highway_tunnel1 ):
			level = -2;
			break;
        case( MAP_en_clinton_center_up ):
            level = 2;
            break;
        case( MAP_en_clinton_center_dn1 ):
		    level = -1;
			break;
        case( MAP_en_clinton_center_dn2 ):
		    level = -2;
			break;
// AZMA SESSION
		case( MAP_azm_session_1_2dn ):
		case( MAP_greenedale_dn ):
			level = -1;
			break;
		case( MAP_greenedale_up ):
			level = 1;
			break;
		case( MAP_azm_session_1_5dn ):
		case( MAP_azm_session_2_2dn ):
		case( MAP_azm_session_5_1dn ):
		case( MAP_azm_session_7_3dn ):
		case( MAP_azm_Portland_dn1 ):
			level = -1;
			break;
		case( MAP_azm_Portland_dn2 ):
			level = -2;
			break;
		case( MAP_azm_Portland_up ):
			level = 1;
			break;
		case( MAP_azm_session_11_3dn ):
			level = -1;
			break;
			//BLAIRE SESSION
		case( MAP_blaire1_1_dn1 ):
		case( MAP_blaire1_2_dn1 ):
		case( MAP_blaire1_3_dn1 ):
		case( MAP_blaire2_1_cav1 ):
		case( MAP_blaire2_2_dn1 ):
		case( MAP_blaire2_3_cav1 ):
		case( MAP_blaire2_3_cav2 ):
		case( MAP_blaire3_3_dn1 ):
		case( MAP_v23_1 ):
		case( MAP_v28_1 ):
		case( MAP_dv_1 ):
			level = -1;
			break;
		case( MAP_blaire2_2_dn2 ):
		case( MAP_v23_2 ):
		case( MAP_v28_2 ):
		case( MAP_dv_2 ):
			level = -2;
			break;
		case( MAP_v16_1 ):
		case( MAP_v23_3 ):
		case( MAP_v28_3 ):
		case( MAP_dv_3 ):
			level = -3;
			break;
		case( MAP_v16_2 ):
			level = -4;
			break;
		case( MAP_v16_3 ):
			level = -5;
			break;
         default:
			level = 0;
			break;
    }

    return level;

}

bool LocIsCity( uint locPid )
{
    return ( locPid <= 90 && locPid >= 96 || locPid != 300 );
}

bool LocIsHidden( uint locPid )
{
    return false;
}

//~run globalmap_group unsafe_DeleteLoc locId 0 0
void unsafe_DeleteLoc( Critter& player, int param0, int param1, int param2 )
{
    Location@ loc = GetLocationByPid( param0, 0 );
    DeleteLocation( loc.Id );
}

#endif //GLOBALMAP_GROUP