                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                        

import void critter_reload_weapon(Critter&cr,Item&weapon,Item@ammo)from"main";
import bool critter_use_item(Critter&cr,Item&item,Critter@targetCr,Item@targetItem,Scenery@targetScen,uint param)from"main";
import void CombatAttack(Critter&cr,Critter@target,ProtoItem&weapon,uint8 weaponMode,ProtoItem@ammo,uint16 hexX,uint16 hexY)from"combat";
import bool AddAttackPlane(Critter&npc,uint priority,Critter&target,bool run)from"npc_planes";
import bool AddWalkPlane(Critter&npc,uint priority,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";
import void Actions(Critter&cr,uint8 actionType,uint16 pickType)from"context_callback";

void unsafe_contmenu_callback(Critter&player,int id,int screenId,int actionId,string@command,int[]@myArr)
{          
	
	player.StatBase[(132)]=myArr[(2)];
	player.StatBase[(133)]=myArr[(3)];
	player.StatBase[(134)]=myArr[(5)];
	player.StatBase[(135)]=myArr[(6)];
	player.StatBase[(136)]=myArr[(7)]; 
	
	switch(myArr[(0)])
	{
		case(4):
		player.ShowScreen(myArr[(0)],id,"context_callback@ScreenBag");
		break;
		case(3):
		player.ShowScreen(myArr[(0)],id,"context_callback@ScreenSkillbox");
		break;
		case(9):
		Actions(player,myArr[(0)],0);
		break;
		case(10):
		Actions(player,myArr[(0)],myArr[(4)]);
		break;
		case(24):
		Actions(player,myArr[(0)],0);
		break;
		case(25):
		Actions(player,myArr[(0)],0);
		break;
		case(26):
		Actions(player,myArr[(0)],myArr[(8)]);
		break;
		default:
		break;
	}
	
}                     

void unsafe_log(Critter&cr,int locX,int locY,int type,string@message,int[]@p4){
	file f;
	if(f.open("logs\\commandslog.txt","a")>=0)
	{
		f.writeString(__Day+"."+__Month+"."+__Year+" "+MakeTime(__FullSecond)+message+"\n");
		f.close();
	}
	else
	Log("can't open log file!");
}

void unsafe_log_1(Critter&cr,int locX,int locY,int type,string@message,int[]@p4){
	file f;
	if(f.open("logs\\saylog.txt","a")>=0)
	{
		f.writeString(__Day+"."+__Month+"."+__Year+" "+MakeTime(__FullSecond)+message+"\n");
		f.close();
	}
	else
	Log("can't open log file!");
}

void unsafe_log_2(Critter&cr,int locX,int locY,int type,string@message,int[]@p4){
	file f;
	if(f.open("logs\\gm_panel.txt","a")>=0)
	{
		f.writeString(__Day+"."+__Month+"."+__Year+" "+MakeTime(__FullSecond)+message+"\n");
		f.close();
	}
	else
	Log("can't open log file!");
}

string@MakeTime(uint val)
{
	uint t=val%86400,
	m=t/60,mm=m%60,
	h=m/60,s=t%60;
	
	return((h<10)?"0":"")+h+((mm<10)?":0":":")+(mm)+((s<10)?":0":":")+(s)+" Х ";
}

void unsafe_set_arcade_stat(Critter&cr,int locX,int locY,int type,string@message,int[]@p4)
{
	string animIndex="";
	
	switch(type)
	{
		case(24):
		cr.ParamBase[(0)]=2;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=2;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=4;
		cr.ParamBase[(6)]=1;
		cr.ParamBase[(7)]=0;
		cr.ParamBase[(8)]=5;
		cr.ParamBase[(9)]=40;
		cr.ParamBase[(10)]=3;
		cr.ParamBase[(13)]=20;
		cr.ParamBase[(14)]=1;
		
		cr.ParamBase[(203)]=100;
		cr.ParamBase[(208)]=200;
		
		animIndex="masrat";
		break;
		
		case(52):
		cr.ParamBase[(0)]=2;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=2;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=4;
		cr.ParamBase[(6)]=1;
		cr.ParamBase[(7)]=0;
		cr.ParamBase[(8)]=4;
		cr.ParamBase[(9)]=40;
		cr.ParamBase[(10)]=5;
		cr.ParamBase[(13)]=10;
		cr.ParamBase[(14)]=1;
		
		cr.ParamBase[(203)]=150;
		cr.ParamBase[(208)]=150;
		
		animIndex="mamant";
		break;
		
		case(97):
		cr.ParamBase[(0)]=3;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=3;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=5;
		cr.ParamBase[(6)]=1;
		cr.ParamBase[(7)]=20;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=7;
		cr.ParamBase[(13)]=10;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=170;
		cr.ParamBase[(208)]=130;
		
		animIndex="maantt";
		break;
		
		case(55):
		cr.ParamBase[(0)]=4;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=4;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=5;
		cr.ParamBase[(6)]=1;
		cr.ParamBase[(7)]=35;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=10;
		cr.ParamBase[(13)]=6;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=180;
		cr.ParamBase[(208)]=110;
		
		animIndex="mamurt";
		break;
		
		case(67):
		cr.ParamBase[(0)]=4;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=4;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=5;
		cr.ParamBase[(6)]=1;
		cr.ParamBase[(7)]=35;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=20;
		cr.ParamBase[(10)]=16;
		cr.ParamBase[(13)]=4;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=150;
		cr.ParamBase[(208)]=70;
		
		animIndex="magko2";
		break;
		
		case(16):
		cr.ParamBase[(0)]=5;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=5;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=5;
		cr.ParamBase[(6)]=1;
		cr.ParamBase[(7)]=35;
		cr.ParamBase[(8)]=7;
		cr.ParamBase[(9)]=25;
		cr.ParamBase[(10)]=7;
		cr.ParamBase[(13)]=6;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=180;
		cr.ParamBase[(208)]=110;
		
		animIndex="maddog";
		break;
		
		case(68):
		cr.ParamBase[(0)]=5;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=5;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=2;
		cr.ParamBase[(7)]=40;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=25;
		cr.ParamBase[(10)]=16;
		cr.ParamBase[(13)]=5;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=180;
		cr.ParamBase[(208)]=80;
		
		animIndex="magcko";
		break;
		
		case(15):
		cr.ParamBase[(0)]=5;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=5;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=2;
		cr.ParamBase[(7)]=70;
		cr.ParamBase[(8)]=12;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=4;
		cr.ParamBase[(13)]=7;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=200;
		cr.ParamBase[(208)]=40;
		
		animIndex="mabrom";
		break;
		
		case(19):
		cr.ParamBase[(0)]=6;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=6;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=2;
		cr.ParamBase[(7)]=60;
		cr.ParamBase[(8)]=7;
		cr.ParamBase[(9)]=25;
		cr.ParamBase[(10)]=16;
		cr.ParamBase[(13)]=5;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=180;
		cr.ParamBase[(208)]=40;
		
		animIndex="mamrat";
		break;
		
		case(76):
		cr.ParamBase[(0)]=6;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=6;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=2;
		cr.ParamBase[(7)]=80;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=16;
		cr.ParamBase[(13)]=5;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=200;
		cr.ParamBase[(208)]=40;
		
		animIndex="mabran";
		break;
		
		case(59):
		cr.ParamBase[(0)]=6;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=6;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=2;
		cr.ParamBase[(7)]=80;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=12;
		cr.ParamBase[(13)]=5;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=200;
		cr.ParamBase[(208)]=140;
		
		animIndex="mascp2";
		break;
		
		case(22):
		cr.ParamBase[(0)]=7;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=7;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=2;
		cr.ParamBase[(7)]=100;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=16;
		cr.ParamBase[(13)]=4;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=210;
		cr.ParamBase[(208)]=80;
		
		animIndex="mascrp";
		break;
		
		case(60):
		cr.ParamBase[(0)]=7;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=7;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=6;
		cr.ParamBase[(6)]=3;
		cr.ParamBase[(7)]=80;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=25;
		cr.ParamBase[(10)]=10;
		cr.ParamBase[(13)]=4;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=210;
		cr.ParamBase[(208)]=140;
		
		animIndex="maclw2";
		break;
		
		case(80):
		cr.ParamBase[(0)]=7;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=7;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=3;
		cr.ParamBase[(7)]=120;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=15;
		cr.ParamBase[(13)]=4;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=240;
		cr.ParamBase[(208)]=80;
		
		animIndex="malien";
		break;
		
		case(25):
		cr.ParamBase[(0)]=8;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=8;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=4;
		cr.ParamBase[(7)]=150;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=15;
		cr.ParamBase[(13)]=3;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=240;
		cr.ParamBase[(208)]=40;
		
		animIndex="mathng";
		break;
		
		case(51):
		cr.ParamBase[(0)]=8;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=8;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=4;
		cr.ParamBase[(7)]=170;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=25;
		cr.ParamBase[(10)]=13;
		cr.ParamBase[(13)]=3;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=240;
		cr.ParamBase[(208)]=80;
		
		animIndex="maclaw";
		break;
		
		case(23):
		cr.ParamBase[(0)]=8;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=8;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=3;
		cr.ParamBase[(7)]=220;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=20;
		cr.ParamBase[(10)]=15;
		cr.ParamBase[(13)]=2;
		cr.ParamBase[(14)]=3;
		
		cr.ParamBase[(203)]=250;
		cr.ParamBase[(208)]=100;
		
		animIndex="masphn";
		break;
		
		case(86):
		cr.ParamBase[(0)]=9;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=9;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=3;
		cr.ParamBase[(7)]=200;
		cr.ParamBase[(8)]=8;
		cr.ParamBase[(9)]=30;
		cr.ParamBase[(10)]=25;
		cr.ParamBase[(13)]=1;
		cr.ParamBase[(14)]=5;
		
		cr.ParamBase[(203)]=260;
		cr.ParamBase[(208)]=120;
		
		animIndex="maquen";
		break;
		
		case(100):
		cr.ParamBase[(0)]=9;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=9;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=3;
		cr.ParamBase[(7)]=250;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=20;
		cr.ParamBase[(10)]=15;
		cr.ParamBase[(13)]=1;
		cr.ParamBase[(14)]=5;
		
		cr.ParamBase[(203)]=240;
		cr.ParamBase[(208)]=80;
		
		animIndex="madeth";
		break;
		
		case(81):
		cr.ParamBase[(0)]=9;
		cr.ParamBase[(1)]=6;
		cr.ParamBase[(2)]=9;
		cr.ParamBase[(3)]=1;
		cr.ParamBase[(4)]=1;
		cr.ParamBase[(5)]=7;
		cr.ParamBase[(6)]=3;
		cr.ParamBase[(7)]=150;
		cr.ParamBase[(8)]=6;
		cr.ParamBase[(9)]=15;
		cr.ParamBase[(10)]=10;
		cr.ParamBase[(13)]=4;
		cr.ParamBase[(14)]=1;
		
		cr.ParamBase[(203)]=240;
		cr.ParamBase[(208)]=100;
		
		animIndex="mafire";
		default:
		animIndex="hmjmps";
		break;
	}
	
	cr.ParamBase[(72)]=cr.ParamBase[(7)]*0.1;
	cr.ParamBase[(301)]=0;
	skin(cr,type);
	
	cr.RunClientScript("client_screen_additional@SendAnimIndex",locX,locY,type,animIndex,null);
}

import int GetCellMap(uint16 x,uint16 y)from"globalmap_group";
import uint GenerateWasteland(Critter&cr,uint8 x,uint8 y)from"mapgen_wasteland";

void unsafe_set_arcade_start(Critter&cr,int x,int y,int p2,string@message,int[]@p4)
{
	int mapId=GetCellMap(x,y);
	
	if(mapId==-1)
	{
		mapId=GenerateWasteland(cr,x*0.1,y*0.1);
	}
	
	Map@map=GetMap(mapId);
	if(@map==null)
	return;
	
	cr.TransitToMap(map.Id,0);
	
	cr.StatBase[(121)]=0;
	cr.StatBase[(146)]=0;
}       

funcdef uint PROCESS(Critter@,int&,int&,int&);                  

import bool RegisterProcess(uint8 type,any func)from"ltp";

import bool StartProcess(Critter&cr,uint8 type,int param0,int param1,int param2,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,int param0,uint time)from"ltp";
import bool StartProcess(Critter&cr,uint8 type,uint time)from"ltp";

import bool StopProcess(Critter&cr)from"ltp";

import bool checkTDH(Critter&cr)from"ltp";
import bool checkTDH(Critter&cr,uint8 type)from"ltp";            

string[]skillNames={"Легкое оружие","Тяжелое оружие","Энергооружие","Рукопашная","Xолодное оружие","Метательное оружие","Санитар","Доктор","Скрытность","Взлом замков","Воровство","Ловушки","Наука","Ремонт","Красноречие","Торговля","Азартные игры","Скиталец"};

bool ltp_teach_inited=false; 

void unsafe_teach(Critter&cr,int skill,int p1,int p2,string@message,int[]@p4)
{
	if(cr.Param[(703)]==(3))
	{
		cr.Say((11),"Запрещено аркадным игрокам.");
		return;
	}
	if(p1>0)
	{
		uint studyExp=cr.StatBase[(138)];
		if(skill>studyExp||skill<=0)
		{
			cr.Say((11),"Недостаточно опыта.");
			return;
		}
		Critter@target=GetCritter(p2);
		if(@target==null)
		return;
		if(cr.Id==target.Id)
		{
			cr.Say((11),"Нельзя дать опыт самому себе.");
			return;
		}
		if(target.IsNpc())
		{
			cr.Say((11),"Нельзя дать опыт не игровому персонажу.");
			return;
		}
		target.StatBase[(76)]+=skill;
		cr.StatBase[(138)]=(((cr.StatBase[(138)]-skill)>(10000))?(10000):(((cr.StatBase[(138)]-skill)<(0))?(0):(cr.StatBase[(138)]-skill)));
		
		cr.Say((11),"Вы наградили юзернеим "+skill+" очками опыта");
		return;
		
	}
	
	if(cr.Skill[skill]<120)
	{
		cr.Say((11),"Вашего навыка недостаточно для обучения.");
		return;
	}
	
	if(!ltp_teach_inited)
	ltp_teach_init();
	
	bool validSKill=false;
	for(uint8 i=0;i<4;i++)
	{
		if(cr.Param[226+i]==skill)
		{
			validSKill=true;
		}
	}
	
	if(validSKill)
	StartProcess(cr,(35),skill,0,0,(60000)-(cr.Skill[(214)]*200));
	else
	cr.Say((11),"Выбранный навык не является профилирующим.");
}

void ltp_teach_init()
{
	PROCESS@___pfunc=@process_teach;any ___pany;___pany.store(@___pfunc);RegisterProcess((35),___pany);
	ltp_teach_inited=true;
}

uint process_teach(Critter@cr,int&param0,int&param1,int&param2)
{
	if(param0==-1&&(cr is null)){param0=int((35));return(0xF035BCF3);}
	
	GameVar@wearinessMaster=GetLocalVar((9960),cr.Id);
	if(wearinessMaster<1000)
	wearinessMaster.opAddAssign(Random(50,75));
	else
	{
		cr.Say((11),"Вы слишком устали");
		return 0;
	}
	
	Critter@[]crs;
	cr.GetMap().GetCrittersHex(cr.HexX,cr.HexY,7,(0x01),crs);
	
	uint8 length=crs.length();
	if(length<=0)
	return 0;
	uint16 skillTeacher=cr.Skill[param0];
	
	for(uint8 i=0;i<length;i++)
	{
		uint16 skillStude=crs[i].Skill[param0];
		if(cr.Id!=crs[i].Id)
		{
			if(skillTeacher>=skillStude+30)
			{
				GameVar@wearinessSlave=GetLocalVar((9960),crs[i].Id);
				
				if(wearinessSlave.GetValue()<1000)
				{
					uint16 wearSlave=(wearinessSlave.GetValue()/10);
					int16 skillDifference=skillTeacher-skillStude;
					uint16 skillBase=(skillDifference>0?skillDifference:1)/(wearSlave>0?wearSlave:1)*(crs[i].Stat[(4)]/2);
					
					if(skillBase>0)
					{
						wearinessSlave.opAddAssign(Random(50,150));
						skillBase=(((skillBase)>(5))?(5):(((skillBase)<(1))?(1):(skillBase)));
						crs[i].SkillBase[param0]+=skillBase;
						crs[i].Say((11),"Вы научились лучше обращаться с навыком "+skillNames[param0-200]+".");
					}
					else
					{
						crs[i].Say((11),"Вы ничему не научились.");
					} 
					
				}
				else
				{
					crs[i].Say((11),"Вы слишком устали.");
				} 
				
			}
			else
			{
				crs[i].Say((11),"Вас нельзя научить.");
			}
		}
		
	}
	
	return(60000)-((cr.Skill[(214)]*200)/wearinessMaster.GetValue());
}  

void unsafe_fastpanel_say(Critter&player,int p0,int p1,int p2,string@message,int[]@p4)
{
	if(message.length()>0)
	{
		uint8 sayType=0;
		switch(p0)
		{
			case 1:
			sayType=(1);
			break;
			
			case 2:
			sayType=(3);
			break;
			case 3:
			sayType=(5);
			break;
			case 4:
			sayType=(7);
			break;
			default:
			sayType=(11);
			break;
		}
		
		if(sayType>=(1)&&sayType<=(10))
		{
			for(uint i=0,len=message.length();i<len;i++)
			{
				uint8 chr=message[i];
				if(chr<32||(chr>34&&chr<42)||(chr>42&&chr<44)||chr==47||(chr>57&&chr<63)||chr==64||(chr>90&&chr<97)||(chr>122&&chr<192&&chr!=168&&chr!=184))
				{
					player.Say((11),"В сообщениии есть запрещенные символы.");
					return;
				}
			}
		}
		
		player.Say(sayType,""+message);
	}
}

void SendFastPanelInfo(Critter&cr,bool type)
{
	file f;
	string word="",word2="";
	uint pos=0;
	
	if(f.open("./fastpanel/"+cr.Id,"r")==0)
	{
		
		f.setPos(0);
		while(!f.isEndOfFile())
		{
			pos=f.getPos();
			f.readLine(word);
			word2+=word;  
			
		}
		f.close();
	}
	
	if(!type)
	{
		if(pos!=0)
		cr.RunClientScript("client_screen_fastpanel@GetServerFileSize",pos,0,0,"",null);
	}
	else
	{
		if(word2!="")
		cr.RunClientScript("client_screen_fastpanel@LoadPanel",0,0,0,word2,null);
		else
		cr.Say((11),"error with sending fastpanel info");
	}
}

void unsafe_fastpanel_save(Critter&player,int p0,int p1,int p2,string@info,int[]@p4)
{
	file f;
	if(f.open("./fastpanel/"+player.Id,"w")==0)
	{
		
		f.writeString(info);
	}
	f.close();
}

void unsafe_send_fastpanel(Critter&cr,int p0,int p1,int p2,string@info,int[]@p4)
{
	file f;
	string word="",word2="";
	uint pos=0;
	
	if(f.open("./fastpanel/"+cr.Id,"r")==0)
	{
		
		f.setPos(0);
		while(!f.isEndOfFile())
		{
			pos=f.getPos();
			f.readLine(word);
			word2+=word;  
			
		}
		f.close();
	}
	
	if(p0==0)
	{
		if(pos!=0)
		cr.RunClientScript("client_screen_fastpanel@GetServerFileSize",pos,0,0,"",null);
	}
	else
	{
		if(word2!="")
		cr.RunClientScript("client_screen_fastpanel@LoadPanel",0,0,0,word2,null);
		else
		cr.Say((11),"error with sending fastpanel info");
	}
	
}

void unsafe_openCodeDoor(Critter&player,int itemId,int code,int param2,string@param3,int[]@param4)
{
	Item@item=GetItem(itemId);
	if(@item==null)
	{
		return;
	}
	if((player.HexX<item.HexX+2||player.HexX>item.HexX-2)&&(player.HexY<item.HexY+2||player.HexY>item.HexY-2))
	{
		if(param2!=0)
		if(code>=pow(10,item.Val1))
		{
			item.Val4=code;
			player.Say((11),"Вы установили новый код : "+code);
			return;
		}
		else
		{
			player.Say((11),"Не допустимый код");
			return;
		}
		if(item.Val4==code)
		{
			if((not((item.LockerCondition&(0x01))!=0)))
			{
				item.LockerOpen();
				player.RunClientScript("client_screen_codedoor@HideScreen",0,0,0,"",null);
			}
			
		}
		else
		player.Say((11),"Не верный код");
	}
	else
	player.Say((11),"Слишком далеко");
}

import void LoadClientHistoryBase(Critter&cr,bool all)from"history_menu";
import void SaveCritterHistory(Critter&cr,string saveText)from"history_menu";
import void LoadCritterHistory(Critter&cr)from"history_menu";

void unsafe_history_load(Critter&player,int loadType,int param1,int param2,string@param3,int[]@param4)
{
	if(player.GetAccess()<2)
	{
		player.Say((11),"hey dude. don't try to hack this. just gohome.");
		Log("hack detected player "+player.Id+" name "+GetPlayerName(player.Id)+" try crack history menu");
		return;
	}
	Critter@cr=GetCritter(param1);
	switch(loadType)
	{
		case 0:
		LoadClientHistoryBase(player,false);
		break;
		case 1:
		LoadClientHistoryBase(player,true);
		break;
		case 2:
		LoadCritterHistory(@cr!=null?cr:player);
		break;
	}
}

void unsafe_history_save(Critter&player,int param0,int param1,int param2,string@saveText,int[]@param4)
{
	if(saveText=="")
	{
		player.Say((11),"Oops! Same error here!");
		return;
	}
	SaveCritterHistory(player,saveText);
}

void unsafe_hotkey_command(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	
	string type="",command="";
	string@[]@cmd=split(param3,"*");
	{
		command=cmd[0];
		type=cmd.length()>1?cmd[1]:"";
	}
	if(type=="TEXT")
	{
		if(__FullSecond<player.Timeout[(251)])
		{
			player.SayMsg((11),(3),12601);
			return;
		}
		player.TimeoutBase[(251)]=(__FullSecond+((3)*__TimeMultiplier));
		if(command.length()>64)
		command=substring(command,0,64);
		string@[]@words=split(command,"_");
		string text=join(words," ");
		player.Say((param4[0]*2+1),text);
	}
	
	else
	{
		if(command=="RELOAD")
		{
			Item@[]weapon;
			player.GetItems((1),weapon);
			if(not(@weapon[0]!=null))
			return;
			Item@ammo=player.GetItem(weapon[0].AmmoPid,(0));
			
			if((@ammo!=null)&&weapon[0].AmmoCount<weapon[0].Proto.Weapon_MaxAmmoCount&&player.Stat[(75)]>=2)
			{
				critter_reload_weapon(player,weapon[0],ammo);
				player.Action((7),0,weapon[0]);
				player.ParamBase[(75)]-=200;
			}
			else if(not(@ammo!=null)&&weapon[0].AmmoCount>0&&player.Stat[(75)]>=2)
			{
				critter_reload_weapon(player,weapon[0],null);
				player.Action((7),0,weapon[0]);
				player.ParamBase[(75)]-=200;
			}
		}
		
		else if(command=="USE_SELF")
		{
			Item@use_item=player.GetItem(param4[0],-1);
			if((@use_item!=null)&&player.Stat[(75)]>=2)
			{
				critter_use_item(player,use_item,null,null,null,0);
				player.Action((4),0,use_item);
				player.ParamBase[(75)]-=200;
			}
		}
		
		else
		Log("Chiter detected: "+GetPlayerName(player.Id));
	}
}

void unsafe_hex_attack(Critter&player,int hexX,int hexY,int param2,string@command,int[]@param4)
{
	
	Map@map=player.GetMap();
	
	if(map is null)
	return;
	
	Item@[]realweapon;
	player.GetItems((1),realweapon);
	if(realweapon.length()<1||(realweapon[0]is null))
	return;
	
	uint8 mode=realweapon[0].Mode;
	ProtoItem@weapon=GetProtoItem(realweapon[0].GetProtoId());
	
	ProtoItem@ammo; 
	
	uint16 toHx=hexX,toHy=hexY;
	int dist=GetDistantion(player.HexX,player.HexY,hexX,hexY);
	map.GetHexCoord(player.HexX,player.HexY,toHx,toHy,0.0f,dist);
	if((hexX!=toHx)||(hexY!=toHy))
	{
		player.SayMsg((11),(5),104);
		return;
	}
	
	bool isFlareGun=(realweapon[0].AmmoPid==(1038))&&(mode==1);
	
	bool isRocket=(realweapon[0].AmmoPid==(14))||(realweapon[0].AmmoPid==(37))||(realweapon[0].AmmoPid==(274))||(realweapon[0].AmmoPid==(1035));
	if(((mode)==0?weapon.Weapon_Skill_0:((mode)==1?weapon.Weapon_Skill_1:((mode)==2?weapon.Weapon_Skill_2:0)))!=(205)&&!isRocket&&!isFlareGun)
	return;
	
	int wpnMaxDist=((mode)==0?weapon.Weapon_MaxDist_0:((mode)==1?weapon.Weapon_MaxDist_1:((mode)==2?weapon.Weapon_MaxDist_2:0)));
	if(((mode)==0?weapon.Weapon_Skill_0:((mode)==1?weapon.Weapon_Skill_1:((mode)==2?weapon.Weapon_Skill_2:0)))==(205))
	wpnMaxDist=(((wpnMaxDist)<(3*(((int(10))<(player.Stat[(0)]+2*player.Perk[(336)]))?(int(10)):(player.Stat[(0)]+2*player.Perk[(336)]))))?(wpnMaxDist):(3*(((int(10))<(player.Stat[(0)]+2*player.Perk[(336)]))?(int(10)):(player.Stat[(0)]+2*player.Perk[(336)]))));
	if(dist>wpnMaxDist)
	{
		player.SayMsg((11),(5),102);
		return;
	} 
	
	if(player.Stat[(75)]<((mode)==0?weapon.Weapon_ApCost_0:((mode)==1?weapon.Weapon_ApCost_1:((mode)==2?weapon.Weapon_ApCost_2:0)))){
		return;
	}
	
	if(weapon.Weapon_MaxAmmoCount>0)
	{
		if(realweapon[0].AmmoCount==0)
		return;
		else
		@ammo=GetProtoItem(realweapon[0].AmmoPid);
	} 
	
	Critter@target=map.GetCritter(uint16(hexX),uint16(hexY));
	
	player.ParamBase[(75)]-=((mode)==0?weapon.Weapon_ApCost_0:((mode)==1?weapon.Weapon_ApCost_1:((mode)==2?weapon.Weapon_ApCost_2:0)))*100;
	
	CombatAttack(player,target,weapon,mode,ammo,uint16(hexX),uint16(hexY));
	player.Wait(200*((mode)==0?weapon.Weapon_ApCost_0:((mode)==1?weapon.Weapon_ApCost_1:((mode)==2?weapon.Weapon_ApCost_2:0))));
}

int[]zomb_skins={33,36,37,39,40,41,43,48,57,61,62,63,64}; 

void zomb(Critter&player,int on,int param1,int param2)
{
	if(on==0)
	{
		__Zombies=false;
		player.Say((11),"Зомби-мод отключен.");
	}
	else
	{
		__Zombies=true;
		player.Say((11),"Зомби-мод включен.");
	}
}

import void skin(Critter&cr,int crType)from"skins";

void unsafe_zombie(Critter&player,int hexX,int hexY,int param2,string@lex,int[]@param4)
{
	if(!__Zombies)
	{
		player.Say((11),"Зомби-мод отключен.");
		return;
	}
	
	Map@map=player.GetMap();
	Map@modoc=GetMapByPid((10),0);
	if(modoc is null)
	return;
	
	if(player.Param[(67)]==(29))
	{
		if(player.IsDead())
		{
			Item@[]items;
			if(player.GetItems(0,items)>0)
			DeleteItems(items);
			
			player.ParamBase[(502)]=0;
			player.ParamBase[(503)]=0;
			player.ParamBase[(504)]=0;
			player.ParamBase[(505)]=0;
			player.ParamBase[(506)]=0;
			player.ToLife();
			player.ParamBase[(72)]=player.Param[(7)];
			player.ParamBase[(241)]=-1;
			player.ParamBase[(252)]=__FullSecond+((Random(30,60))*__TimeMultiplier);
			player.ParamBase[(117)]=Random(200,800);
			player.TransitToMap(modoc.Id,0);
			uint zsl=zomb_skins.length();
			if(zsl>0)
			skin(player,zomb_skins[Random(0,zsl-1)]);
		}
		
	}
	else if(map is null or map.GetProtoId()!=51)
	{
		return;
	}
	else
	{
		player.ParamBase[(67)]=(29);
		
		uint zsl=zomb_skins.length();
		if(zsl>0)
		skin(player,zomb_skins[Random(0,zsl-1)]);
		
		player.ParamBase[(7)]+=100;
		player.ParamBase[(72)]+=100;
		player.ParamBase[(540)]=1;
		player.ParamBase[(117)]=Random(200,800);
		player.ParamBase[(252)]=__FullSecond+((2)*__TimeMultiplier*60);
		player.ParamBase[(84)]=-1;
		player.TransitToMap(modoc.Id,0);
	}
} 

void unsafe_stopMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param0*10,ii=10+param0*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@controlled!=null)&&controlled.ParamBase[(800)]!=player.Id)
		{
			player.Say((11),"Нет доступа.");
			return;
		}
		if((@player!=null)&&(@controlled!=null)&&controlled.IsNpc())
		{
			controlled.ErasePlane(-1,true);
			controlled.ClearEnemyStack();
			controlled.EraseTimeEvents(9);
			controlled.SetDir(GetDirection(controlled.HexX,controlled.HexY,param1,param2));
		}
	}
}

void unsafe_moveMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	for(uint i=param0*10,ii=10+param0*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@controlled!=null)&&controlled.ParamBase[(800)]!=player.Id)
		{
			player.Say((11),"Нет доступа.");
			return;
		}
		if((@player!=null)&&(@controlled!=null)&&controlled.IsNpc())
		{
			controlled.ErasePlane(-1,true);
			AddWalkPlane(controlled,1,param1+Random(-i,i),param2+Random(-i,i),GetDirection(controlled.HexX,controlled.HexY,param1,param2),(param3!=null),0);
			if(param0==0)
			controlled.ClearEnemyStack();
		}
	}
}

void unsafe_attackMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	Critter@target=GetCritter(param0);
	for(uint i=param2*10,ii=10+param2*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@controlled!=null)&&controlled.ParamBase[(800)]!=player.Id)
		{
			player.Say((11),"Нет доступа.");
			return;
		}
		if((@player!=null)&&(@controlled!=null)&&(@target!=null)&&controlled.IsNpc())
		{
			controlled.ErasePlane(-1,true);
			AddAttackPlane(controlled,0,target,__RunOnCombat);
			controlled.AddEnemyInStack(target.Id);
		}
	}
}

import uint follow(Critter&cr,int master,uint&rate)from"raiders";

void unsafe_chaseMob(Critter&player,int param0,int param1,int param2,string@param3,int[]@vals)
{
	Critter@target=GetCritter(param0);
	for(uint i=param2*10,ii=10+param2*10;i<ii;i++)
	{
		Critter@controlled=GetCritter(vals[i]);
		if((@controlled!=null)&&controlled.ParamBase[(800)]!=player.Id)
		{
			player.Say((11),"Нет доступа.");
			return;
		}
		if((@player!=null)&&(@controlled!=null)&&(@target!=null)&&controlled.IsNpc())
		{
			controlled.ErasePlane(-1,true);
			controlled.ModeBase[(517)]=1;
			controlled.StatBase[(188)]=target.Id;
			controlled.AddTimeEvent("follow",30,9);
		}
	}
}

import void say(Critter&player,int param0,int param1,int param2)from"gm";

void unsafe_say(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	Critter@controlled=GetCritter(param0);
	if(param1!=1&&param1!=5&&controlled.IsPlayer())
	{
		player.Say((11),"Нет доступа.");
		return;
	}
	if((@controlled!=null)&&controlled.ParamBase[(800)]!=player.Id)
	{
		player.Say((11),"Нет доступа.");
		return;
	}
	say(player,param0,param1,0);
}

void unsafe_sleep(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	if(!(@player!=null))
	return;
	if(!player.IsDead()&&!player.IsKnockout()&&player.GetTimeEvents((9),null,null,null)==0)
	{
		player.StatBase[(75)]=-100000;
		player.ToKnockout((((param0==0))?(82):(83)),(((param0==0))?(86):(87)),(((param0==0))?(88):(89)),5,player.HexX,player.HexY);
		player.Say((11),"вы упали.");
		player.AddTimeEvent("cte_sleep",0,(9),0);
		return;
	}
	else if(!player.IsDead()&&player.IsKnockout()&&player.GetTimeEvents((9),null,null,null)!=0)
	{
		player.StatBase[(75)]=0;
		player.EraseTimeEvents((9));
		player.Say((11),"вы поднимаетесь.");
		return;
	}
	
}

uint cte_sleep(Critter&player,int identifier,uint&rate)
{
	if(player.StatBase[(75)]>=-50000)
	player.StatBase[(75)]=-100000;
	return 100;
}

import void InjureCritter(Critter&cr,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";

import void DragAndDrop(Critter&cr,Critter@target)from"handcuffs";

void unsafe_itemhit2(Critter&player,int itemId,int x,int y,string@param3,int[]@param4)
{
	if(!(player.IsDead()||player.IsKnockout()))
	{
		if(player.Timeout[(235)]>0)
		{
			player.Say((11),"Вы не можете бить так часто.");
			return;
		}
		if((((int(x-player.HexX))>0)?(int(x-player.HexX)):-(int(x-player.HexX)))<=1&&(((int(y-player.HexY))>0)?(int(y-player.HexY)):-(int(y-player.HexY)))<=1)
		{
			player.SetDir(GetDirection(player.HexX,player.HexY,x,y));
			player.GetMap().SetText(x,y,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),"cтук");
			player.Say((11),"Вы постучали.");
			player.TimeoutBase[(235)]=__FullSecond+((2)*__TimeMultiplier);
			return;
		}
		else player.Say((11),"Далеко.");
		return;
	}
}

void unsafe_itemhit(Critter&player,int id,int itemId,int param2,string@param3,int[]@param4)
{
	Critter@target=GetCritter(id);
	
	if(!(player.IsDead()||player.IsKnockout())&&(@target!=null))
	{
		if(player.Timeout[(235)]>0)
		{
			player.Say((11),"Вы не можете бить так часто.");
			return;
		}
		if(target.IsDead()||target.IsKnockout())
		{
			DragAndDrop(player,target);
			player.TimeoutBase[(235)]=__FullSecond+((3)*__TimeMultiplier);
			return;
		}
		if((((int(target.HexX-player.HexX))>0)?(int(target.HexX-player.HexX)):-(int(target.HexX-player.HexX)))<=1&&(((int(target.HexY-player.HexY))>0)?(int(target.HexY-player.HexY)):-(int(target.HexY-player.HexY)))<=1)
		{
			Item@weapon=player.GetItem(0,(1));
			
			if(!(weapon is null))
			{
				uint16 weight=weapon.Proto.Weight;
				weight=(((weight)>(8000))?(8000):(((weight)<(2000))?(2000):(weight)));
				uint8 ap=weight*0.001;
				ap=(((ap)>(8))?(8):(((ap)<(2))?(2):(ap)));
				if(ap<=player.Stat[(75)])
				{
					player.SetDir(GetDirection(player.HexX,player.HexY,target.HexX,target.HexY));
					player.Animate(0,(53),null,true,true);
					player.StatBase[(75)]=0;
					
					if(player.Skill[(204)]-target.Stat[(9)]-(weight*0.002)-target.Stat[(186)]*50<Random(0,100))
					{
						player.Say((11),"Вы промахнулись.");
						return;
					}
					uint8 strBonus=(player.Stat[(0)]>6?player.Stat[(0)]-6:1);
					int damage=Random(strBonus+player.StatBase[(10)],strBonus+player.StatBase[(10)]+(weight*0.002));
					InjureCritter(target,damage,(1),target.Dir,player.Id);
					
					player.TimeoutBase[(235)]=__FullSecond+((2)*__TimeMultiplier);
					player.TimeoutBase[(249)]=__FullSecond+((1)*__TimeMultiplier*60);
					player.TimeoutBase[(238)]=__FullSecond+((1)*__TimeMultiplier*60);
					target.TimeoutBase[(238)]=__FullSecond+((1)*__TimeMultiplier*60);
					
					if(target.IsNpc()&&target.IsSee(player))
					target.AddEnemyInStack(player.Id);
					
					return;
				}
				player.Say((11),"Недостаточно очков действия.");
				return;
			}
			else if(4<=player.Stat[(75)])
			{
				player.SetDir(GetDirection(player.HexX,player.HexY,target.HexX,target.HexY));
				player.Animate(0,(53),null,true,true);
				player.StatBase[(75)]=0;
				
				if(player.Skill[(203)]-target.Stat[(9)]-target.Stat[(186)]*50<Random(0,100))
				{
					player.Say((11),"Вы промахнулись.");
					return;
				}
				uint8 strBonus=(player.Stat[(0)]>6?player.Stat[(0)]-6:1);
				int damage=Random(strBonus,strBonus+player.StatBase[(10)]+1);
				InjureCritter(target,damage,(1),target.Dir,player.Id);
				
				player.TimeoutBase[(235)]=__FullSecond+((2)*__TimeMultiplier);
				player.TimeoutBase[(249)]=__FullSecond+((1)*__TimeMultiplier*60);
				player.TimeoutBase[(238)]=__FullSecond+((1)*__TimeMultiplier*60);
				target.TimeoutBase[(238)]=__FullSecond+((1)*__TimeMultiplier*60);
				
				if(target.IsNpc()&&target.IsSee(player))
				target.AddEnemyInStack(player.Id);
				return;
			}
			else player.Say((11),"Недостаточно очков действия.");
			return;
		}
		player.Say((11),"Далеко.");
	}
	
}

void unsafe_itemthrow(Critter&player,int hx,int hy,int param2,string@param3,int[]@param4){
	Map@currentMap=player.GetMap();
	uint16 tx=hx,ty=hy;
	uint distance=GetDistantion(player.HexX,player.HexY,hx,hy);
	currentMap.GetHexCoord(player.HexX,player.HexY,tx,ty,0.0f,distance);
	Critter@target=currentMap.GetCritter(tx,ty);
	if(!currentMap.IsHexPassed(tx,ty)&&target is null){
		currentMap.GetHexCoordWall(player.HexX,player.HexY,tx,ty,0.0f,distance);
	}
	Item@itemInHand=player.GetItem(0,(1));
	if(itemInHand is null)return;
	if(itemInHand.GetProtoId()==(692)||itemInHand.GetProtoId()==(694)){
		player.Say((11),"Вы не можете бросить то, чем связаны. Увы.");
		return;
	}
	bool canThrow=true;
	
	if(player.Param[(761)]!=0){
		player.Say((11),"Вы пытаетесь бросить предмет, но сознание владельца тела не дает вам этого сделать.");
		return;
	}
	
	if(!player.IsDead()&&!player.IsKnockout()&&distance<player.Stat[(0)]*2){
		player.SetDir(GetDirection(player.HexX,player.HexY,tx,ty));
		if((@target!=null)){
			currentMap.RunFlyEffect(((((0)&0xF))==0?GetProtoItem((25)).Weapon_Effect_0:((((0)&0xF))==1?GetProtoItem((25)).Weapon_Effect_1:((((0)&0xF))==2?GetProtoItem((25)).Weapon_Effect_2:0))),player,target,player.HexX,player.HexY,tx,ty);
			player.Animate(0,(53),null,true,true);
			bool targetFreeHands=(target.GetItem(0,(1))is null);
			if(targetFreeHands&&!(target is player)){
				MoveItem(itemInHand,1,target);
				target.Say((5),"Поймал предмет");
			}else{
				MoveItem(itemInHand,1,currentMap,tx,ty);
				if(!(target is player))target.Say((5),"Руки заняты, не может поймать предмет");
			}
		}else{
			currentMap.RunFlyEffect(((((0)&0xF))==0?GetProtoItem((25)).Weapon_Effect_0:((((0)&0xF))==1?GetProtoItem((25)).Weapon_Effect_1:((((0)&0xF))==2?GetProtoItem((25)).Weapon_Effect_2:0))),player,null,player.HexX,player.HexY,tx,ty);
			player.Animate(0,(53),null,true,true);
			MoveItem(itemInHand,1,currentMap,tx,ty);
		}
	}else{
		player.Say((11),"Вы не в состоянии кидать так далеко");
	}
}
