#include "_macros.fos"

#define SK_DESTROY	SK_REPAIR
#define SK_MIN		100

#define State		Val9
#define Durability	Val8
#define Holding		Val0

#define MAX_POWER	100
#define GetPower	#(item, power)		item.Durability * CLAMP( MAX_POWER - power, 0, MAX_POWER )

import bool isGM( Critter& player ) from "gm";
import void LockerBudge( Item& item ) from "lockers";
import bool IsKeyAviable( Critter& cr, uint lockerId ) from "lockers";
import bool _TryRemoveTrap( Item& door, Critter& player ) from "trap";
import bool UseSkillOnTrappedItem( Item& trappedItem, Critter& cr, int skill ) from "trap";

#ifndef __FURNITURE_DATA_HOLDERS
	#define __FURNITURE_DATA_HOLDERS

	FurnitureList@ furnitures;
	void InitFurnitures()
	{
		if( valid( furnitures ) ) return;
		//TODO: Нормально проименовать все эти циферки пидов сценери.
		@furnitures = @CreateFurniture( "Единый список мебели")
		//	.add( Furniture( "Имя для скрипта", PID_крафтаемого_объекта, изображения "при повороте" ) )
			.add( Furniture( "Деревянный стул", PID_CR_WOOD_CHAIR ).add(2670).add(2676).add(2663) )
			.add( Furniture( "Удобный стул", PID_CR_CMFRT_CHAIR ).add(2672).add(2677).add(2662) )
			.add( Furniture( "Металлический стул", PID_CR_METAL_CHAIR ).add(2673).add(2674).add(2664) )
			.add( Furniture( "Стул с тканевой обивкой", PID_CR_RAGS_CHAIR ).add(2671).add(2675).add(2665) )
			.add( Furniture( "Спальный мешок", PID_CR_SLP_BAG ).add(2209) )
			.add( Furniture( "Матрас", PID_CR_MTRS ).add(2207) )
			.add( Furniture( "Двойная кровать", PID_CR_BD_DBL_BED ).add(2211) )
			.add( Furniture( "Простенькая кровать'", PID_CR_JNK_BED ).add(2212) )
			.add( Furniture( "Лежак", PID_CR_SUN_BED).add(2949) )
			.add( Furniture( "Удобная кровать", PID_CR_WOOD_BED ).add(2680) )
			.add( Furniture( "Роскошная кровать", PID_CR_LUX_BED ).add(2681) )
			.add( Furniture( "Деревянный стол", PID_CR_WOOD_TBL ) )
			.add( Furniture( "Круглый деревянный стол", PID_CR_WOOD_TBL_GD ) )
			.add( Furniture( "Небольшой металлический стол", PID_CR_MT_TBL_SMALL ) )
			.add( Furniture( "Овальный металлический стол", PID_CR_MT_TBL_OVAL ) )
			.add( Furniture( "Большой металлический стол", PID_CR_MT_TBL_BG ).add(2606) )
			.add( Furniture( "Большой металлический стол с покрытием", PID_CR_MT_TBL_BG_ALT ).add(2607) )
			.add( Furniture( "Металлический рабочий стол", PID_CR_MT_TBL_WR ).add(187) )
			.add( Furniture( "Ржавый рабочий стол", PID_CR_JNK_TBL_WR ).add(184) )
			.add( Furniture( "Большой деревянный стол", PID_CR_WOOD_TBL_DINNER ).add(167) )
			.add( Furniture( "Деревянный рабочий стол", PID_CR_WOOD_TBL_WR ).add(8248) )
			.add( Furniture( "Ящик", PID_CR_BOX ).add(8254) )
			.add( Furniture( "Деревянный шкаф", PID_CR_WOOD_CAB_SMALL ).add(63).add(15440) )
			.add( Furniture( "Деревянный полки", PID_CR_WOOD_SHELF ).add(246).add(8260) )
			.add( Furniture( "Ржавый шкафчик", PID_CR_JNK_CAB ).add(189).add(8252).add(8253) )
			//.add( Furniture( "Грибная грядка", PID_MUSHBED_EMPTY ).add(1628) )//Нет привязанного скрипта.
			.add( Furniture( "Офисное кресло", PID_CR_OF_CHAIR ).add(2052).add(2053).add(2054) )
			.add( Furniture( "Офисное кресло", PID_CR_OF_CHAIR_2 ).add(2058).add(2059).add(2060) )
			.add( Furniture( "Кустарный диванчик", PID_CR_JNK_SOFA ).add(2096).add(2097).add(2098) )
			.add( Furniture( "Ковер", PID_CR_CARPET ).add(2377).add(2378) .add(16505) .add(16506) .add(16507) .add(16508) )
			.add( Furniture( "Сушилка для шкур", PID_CR_CARPET ) )
			.add( Furniture( "Алтарь", PID_CR_ALTAR ).add(4502).add(4503).add(4504) )
			.add( Furniture( "Дикарская подставка", PID_CR_STAND ).add(4506).add(4507).add(4508) )
			.add( Furniture( "Деревянный стол с настольной лампой", PID_CR_WOOD_TBL_LP ).add(3644) )
			.add( Furniture( "Кол", PID_CR_STAKE ).add(3225).add(3226).add(3227) )
			.add( Furniture( "Тачка", PID_CR_CART) )
			.add( Furniture( "Больше кресло", PID_CR_ARM_CHAIR ).add(2231) )
			.add( Furniture( "Армейская кровать", PID_CR_ARM_BED ) )
			.add( Furniture( "Компостная бочка", PID_SHIT_BAREL_EMPTY ).add( PID_SHIT_BAREL_FULL ) )
			.add( Furniture( "Компостная ванна", PID_SHIT_BATH_X_EMPTY ).add( PID_SHIT_BATH2_Y_EMPTY ).add( PID_SHIT_BATH1_X_FULL ).add( PID_SHIT_BATH2_Y_FULL ) )
			;
	}

	Tools@ ToolsList;
	void InitTools()
	{
		if( valid( ToolsList ) ) return;
		
		@ToolsList = @CreateToolsList()
			.add( PID_AXE, 15 )
			.add( PID_SLEDGEHAMMER, 30 )
			.add( PID_CROWBAR, 45 )
			.add( PID_WELDING, 60 )
		;
	}
#endif

#ifndef __FURNITURE_EVENTS
	#define __FURNITURE_EVENTS
	
	void _InitFurniture( Item& furniture, bool firstTime )
	{
		furniture.SetEvent( ITEM_EVENT_USE, "_Use" );
		furniture.SetEvent( ITEM_EVENT_SKILL, "_Skill" );
		furniture.SetEvent( ITEM_EVENT_USE_ON_ME, "_Tools" );
	}

	bool _Use( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
	{
		return false;
	}
		
	bool _Skill( Item& furniture, Critter& cr, int skill )
	{
		if( UseSkillOnTrappedItem( furniture, cr, skill ) ) return true;
		
		switch( skill )
		{
			case( SK_TRAPS ): 
				if( _TryRemoveTrap( furniture, cr ) ) return true;
				return Rotate( cr, furniture, false );
			case( SK_SCIENCE ): return SwitchLootability( cr, furniture );
			case( SK_REPAIR ): return Rotate( cr, furniture );
			case( SKILL_PICK_ON_GROUND ): return Pickup( cr, furniture );
			case( SKILL_PUT_CONT ): return FailedAttempt( cr, "Это сюда не влезет." );
			default: return false;
		}
		return false;
	}

	bool _Tools( Item& item, Critter& cr, Item@ usedItem )
	{
		if( !valid( usedItem ) ) return FailedAttempt( cr, "Из этого ничего не вышло." );
		
		if( cr.Timeout[ TO_SK_REPAIR ] > 0 && !isGM(cr) )
			return FailedAttempt( cr, "Вы слишком устали." );
		
		if( cr.Stat[ ST_LEVEL ] < 3 && !isGM(cr) )
			return FailedAttempt( cr, "Недоступно до 4-го уровня." );

		InitTools();
		
		return ToolsList.check( cr, item, usedItem );
	}
#endif

#ifndef __FURNITURE_ACTIONS
	#define __FURNITURE_ACTIONS
	
	bool FailedAttempt( Critter& cr, string text )
	{
		cr.Say( SAY_NETMSG, text );
		return true;
	}

	//Должен вернуть false что бы движок поднял предмет обычным путём.
	bool Pickup( Critter& cr, Item& furniture ) 
	{
		bool DoorOrContainer = ( ( furniture.GetType() == ITEM_TYPE_CONTAINER && furniture.Proto.Container_Volume > 0 ) || furniture.GetType() == ITEM_TYPE_DOOR );
		bool isPickingUp = true;

		if( furniture.Holding > 0 && !isGM(cr) ) 
		{
			if( DoorOrContainer )
				isPickingUp = false;
			else 
			{
				cr.Say( SAY_NETMSG, "Это вам не под силу." );
				return true;
			}
		}

		if( ( !FLAG( furniture.Flags, ITEM_CAN_PICKUP ) || furniture.Durability > 0 ) && !isGM(cr) )
		{
			if( DoorOrContainer )
				isPickingUp = false;
			else 
			{
				cr.Say( SAY_NETMSG, "Требуется демонтаж." );
				return true;
			}
		}
		
		if( DoorOrContainer && !isPickingUp )
		{
			if( furniture.Proto.Container_Changeble )
			{
				if( FLAG( furniture.LockerCondition, LOCKER_JAMMED ) || FLAG( furniture.LockerCondition, LOCKER_BROKEN ) || FLAG( furniture.LockerCondition, LOCKER_NOOPEN ) )
				{
					cr.Say( SAY_NETMSG, "Из этого ничего не вышло." );
					return true;
				}
				
				if( FLAG( furniture.LockerCondition, LOCKER_ISOPEN ) )
				{
					furniture.LockerClose();
					return true;
				}
				
				if( FLAG( furniture.LockerCondition, LOCKER_ELECTRO ) )
				{
					cr.RunClientScript( "client_screen_codedoor@ShowScreen", furniture.Id, furniture.Val1, 0, "Введите код", null );
					return true;
				}

				if( FLAG( furniture.LockerCondition, LOCKER_LOCKED ) )
				{
					if( !IsKeyAviable( cr, furniture.LockerId ) )
					{
						cr.Say( SAY_NETMSG, "Заперто." );
						LockerBudge( furniture );
						return true;
					}
				}
			}
			
			if( !furniture.Proto.Container_Changeble || !FLAG( furniture.LockerCondition, LOCKER_ISOPEN ) )
			{
                if( furniture.Proto.Container_Changeble )
					furniture.LockerOpen();
				
				cr.ParamBase[ ST_LAST_CONT_ID ] = furniture.Id;
				cr.ShowContainer( null, furniture, furniture.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
				return true;
			}
			
			cr.Say( SAY_NETMSG, "Что-то пошло не так." );
			return true;
		}
		
		if( DoorOrContainer && furniture.Proto.Container_Changeble )
			furniture.LockerClose();

		int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - cr.ItemsWeight(),
			contWeight = 0;
			
		if( furniture.GetType() == ITEM_TYPE_CONTAINER && furniture.Proto.Container_Volume > 0 )
		{
			Item@[] items;
			uint len = furniture.GetItems( uint( -1 ), items );
			for( uint i = 0; i < len; i++ )
			{
				if( !valid( items[i] ) ) continue;
				contWeight += items[i].Proto.Weight * items[i].GetCount();
			}
		}
		
		if( freeWeight < contWeight + furniture.Proto.Weight && !isGM(cr) )
		{
			cr.Say( SAY_NETMSG, "Слишком тяжело." );
			return true;
		}

		if( DoorOrContainer ) 
			UNSETFLAG( furniture.Flags, ITEM_CAN_USE );
		
		MoveItem( furniture, 1, cr );
		return true;
	}


	bool SwitchLootability( Critter& cr, Item& furniture )
	{
		if( furniture.Durability > 0 && !isGM(cr) )
		{
			cr.Say( SAY_NETMSG, "Объект вмонтирован. Сначала демонтируйте его инструментом." );	
			if( valid( ToolsList ) ) ToolsList.hint(cr);
			return true;
		}
		
		if( furniture.Holding > 0 && !isGM(cr) )
		{
			cr.Say( SAY_NETMSG, "Данный объект так просто не сдвинуть. Прийдётся проявить сноровку и фантазию." );	
			return true;
		}
		
		bool DoorOrContainer = ( ( furniture.GetType() == ITEM_TYPE_CONTAINER && furniture.Proto.Container_Volume > 0 ) || furniture.GetType() == ITEM_TYPE_DOOR );
		
		string state = "";
		if( !FLAG( furniture.Flags, ITEM_CAN_PICKUP ) )
		{
			UNSETFLAG( furniture.Flags, ITEM_CAN_USE );
			SETFLAG( furniture.Flags, ITEM_CAN_PICKUP );
			state = "поднимаем";
		}
		else 
		{
			if( DoorOrContainer ) SETFLAG( furniture.Flags, ITEM_CAN_USE );
			UNSETFLAG( furniture.Flags, ITEM_CAN_PICKUP );
			state = "неподъёмен";
		}		
		
		cr.Say( SAY_NETMSG, "Предмет " + state + ". Что бы изменить состояние - используйте науку." );	
		return true;
	}

	//import bool Rotate( Critter@ cr, Item& furniture, bool clockwise = true ) from "furniture";
	bool Rotate( Critter@ cr, Item& furniture, bool clockwise = true ) //exported
	{
		InitFurnitures();
		return furnitures.rotate( cr, furniture, clockwise );
	}

	//import bool isFurniture( Item@ item ) from "furniture";
	bool isFurniture( Item@ item ) //exported
	{
		if( !valid( item ) ) return false;
		
		InitFurnitures();
		
		return furnitures.has( item.GetProtoId() );
	}
#endif

#ifndef __FURNITURE_TOOLS
	#define __FURNITURE_TOOLS
	class Tool
	{
		uint pid;
		uint power;
		//Можно привязать стат, влияющий на мощность применения.
		
		Tool( uint pid, uint power )
		{
			this.pid = pid;
			this.power = power;
		}
		
		bool check( Critter& cr, Item& target, uint tool )
		{
			if( tool != pid ) return false;
			
			return UseOn( cr, target );
		}
		
		bool UseOn( Critter& cr, Item& target )
		{
			if( target.Durability <= 0 )
				return FailedAttempt( cr, "Объект не требует демонтажа, он уже готов к переноске." );
			
			if( target.Holding > 0 && !isGM(cr) )
				return FailedAttempt( cr, "Стандартные способы демонтажа тут бесполезны." );
				
			if( cr.ParamBase[ SK_DESTROY ] < SK_MIN + GetPower( target, power ) && !isGM(cr) )
				return FailedAttempt( cr, "Слишком прочно закреплено, попробуйте другой инструмент." );
			
			cr.Say( SAY_EMOTE_ON_HEAD, "Демонтирует" );
			cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_MINUTE(10) * target.Durability;
			target.Durability--;
			return true;
		}	
	}

	Tools@ CreateToolsList()
	{
		return Tools();
	}

	class Tools
	{
		Tool[] list;
		
		Tools() {}
		
		Tools@ add( uint pid, uint power ) 
		{
			return this.add( Tool( pid, power ) );
		}
		
		Tools@ add( Tool@ item ) 
		{
			list.insertLast( item );
			return this;
		}
		
		bool hint( Critter& cr )
		{
			if( list.length() == 0 ) return false;
			
			cr.Say( SAY_NETMSG, "Подходящие инструменты:" );
			
			for( uint i = 0, len = list.length(); i < len; i++ )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_ITEM, 100 * list[i].pid );
				cr.Say( SAY_NETMSG, "  Сила: " + list[i].power );
			}
			return true;
		}
		
		bool check( Critter& cr, Item& target, Item@ tool )
		{
			if( !valid( tool ) ) 
				return hint(cr);
			
			uint pid = tool.GetProtoId();
			
			if( pid == PID_IRON_PROD )
			{
				cr.Say( SAY_EMOTE_ON_HEAD, "Занимается монтажом" );
				
				if( cr.Timeout[ TO_SK_REPAIR ] > 0 )
				{
					cr.Say( SAY_NETMSG, "Вы ещё не закончили прошлый заход." );
					return true;
				}
				
				_SubItem( tool, 1 );
				target.Durability++;
				cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + REAL_MINUTE(5);
				return true;
			}
			
			for( uint i = 0, len = list.length(); i < len; i++ )
				if( list[i].check( cr, target, pid ) )
					return true;
			
			return false;
		}
	}
#endif

#ifndef __FURNITURE__TESTS
	#define __FURNITURE__TESTS
	
	//~run furniture go 0 0 0
	void go( Critter& cr, int p0, int p1, int p2 )
	{
		cr.Say( SAY_NETMSG, "Put firniture tests here." );
		TestUse( cr, p0, p1 );
	}

	void TestUse( Critter& cr, int furniture_id, int skill )
	{
		Item@ target = GetItem( furniture_id );
		if( !valid( target ) )
		{
			cr.Say( SAY_NETMSG, "Предмет не найден." );
			return;
		}
		
		if( _Skill( target, cr, skill ) )
		{
			cr.Say( SAY_NETMSG, "Тест успешен, дополнительная информация могла быть здесь." );
		}
		else
		{
			cr.Say( SAY_NETMSG, "Тест провален, дополнительная информация могла быть здесь." );
		}
	}
#endif

#ifndef __FURNITURE__CLASSES
	#define __FURNITURE__CLASSES
	
	FurnitureList@ CreateFurniture( string name )
	{
		return FurnitureList( name );
	}
	
	class FurnitureList
	{
		string name;
		Furniture@[] list;
		
		FurnitureList( string name )
		{
			this.name = name;
		}
		
		FurnitureList@ add( Furniture@ item )
		{
			list.insertLast( item );
			return this;
		}
			
		bool rotate( Critter@ cr, Item& furniture, bool clockwise = true )
		{
			if( ( furniture.Durability > 0 || furniture.Holding > 0 ) && !isGM(cr) )
			{
				cr.Say( SAY_NETMSG, "Предмет монтирован, его так просто не повернуть." );
				return true;
			}
			
			for( uint i = 0; i < list.length(); i++ )
				if( list[i].Rotate( furniture, clockwise ) )
					return true;
				
			return false;
		}
		
		bool has( uint pid )
		{
			for( uint i = 0; i < list.length(); i++ )
				if( list[i].has( pid ) )
					return true;
				
			return false;
		}
	}

	Furniture@ CreateFurniture( string name, uint basePID )
	{
		return Furniture( name, basePID );
	}

	class Furniture
	{
		uint basePID;
		string name;
		uint[] pids;
		
		Furniture( string name, uint basePID )
		{
			this.name = name;
			this.basePID = basePID;
			this.pids.insertLast( basePID );
		}
		
		void set( uint[] pids )
		{
			this.pids = pids;
		}
		
		bool has( uint pid )
		{
			if( basePID == pid ) return true;
			
			for( uint i = 0; i < pids.length(); i++ )
				if( pids[i] == pid )
					return true;
				
			return false;
		}
		
		Furniture@ add( uint rotation_picture_pid )
		{
			if( rotation_picture_pid != 0 )
				pids.insertLast( rotation_picture_pid );
			
			return this;
		}
		
		bool setPic( Item& target )
		{
			return setPic( target, target.State );
		}

		bool setPic( Item& target, uint index )
		{
			if( index >= pids.length() ) 
				return false;
			
			return setItemPic( target, pids[index] );
		}
		
		bool ChangeState( Item& target, bool clockwise = true )
		{
			if( clockwise )
				target.State++;
			else
				target.State--;

			int state = target.State;
			
			if( state >= int( pids.length() ) )
			{
				target.State = 0;
				return true;
			}
			
			if( state < 0 )
			{
				target.State = pids.length() - 1;
				return true;
			}
			
			return true;
		}
		
		bool Rotate( Item& target, bool clockwise = true )
		{
			if( target.GetProtoId() != basePID || pids.length() == 0 ) return false;
			
			ChangeState( target, clockwise );
			setPic( target );
			return true;
		}
	}
#endif

#ifndef __FURNITURE__UTILS
	#define __FURNITURE__UTILS
	
	bool setItemPic( Item& target, uint protoPID )
	{
		if( protoPID == 0 ) return false;
		
		ProtoItem@ proto = GetProtoItem( protoPID );
		if( !valid( proto ) ) return false;
		
		target.PicMap = proto.PicMap;
		target.PicInv = proto.PicMap;
		target.Update();
		return true;
	}
#endif