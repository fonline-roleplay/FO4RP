#include "_utils.fos"

import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void AffectPoison( Critter& cr, int value ) from "poison";

import bool CheckGard( Map& map, uint16 hexX, uint16 hexY ) from "farm";

#define PLANT_RADCVET     ( 0 )
#define PLANT_CABBAGE     ( 1 )
#define PLANT_CORN        ( 2 )
#define PLANT_MAX         ( 3 )

#define TIME_EVENT		Val0
#define GROW_STAGE		Val1
#define SELECTION		Val2
#define PLANT_TYPE		Val3
#define WATERING		Val4
#define FERTILITY		Val5
#define PLANT_GAIN		Val6

#define isSEED			#(item)		( item.GROW_STAGE == 0 )

string debugInfo( Item@ item )
{
	if( !valid( item ) ) return "[null]";
	
	return 
		"\n#" + item.Id + " / " + item.GetProtoId() + " x" + item.GetCount() +
		"\n TIME_EVENT " + item.TIME_EVENT +
		"\n GROW_STAGE " + item.GROW_STAGE +
		"\n SELECTION " + item.SELECTION +
		"\n PLANT_TYPE " + item.PLANT_TYPE +
		"\n WATERING " + item.WATERING +
		"\n PLANT_GAIN " + item.PLANT_GAIN
		;
}

//~run gm speedupPlants value 0 0
///Можно использовать команду для тестов - ускорения роста. 
///Где value - количество секунд на каждую стадию роста.
//import uint getStageTime() from "plant";
uint getStageTime() //exported
{
	GameVar@ speedUpPlants = GetGlobalVar( GVAR_speedUpPlants );		
	if( !valid( speedUpPlants ) || speedUpPlants.GetValue() == 0 )
		return REAL_HOUR( 1 ); //Анури, вот твоё дефолтное время, остальное не трожь!
	
	return( REAL_SECOND( speedUpPlants.GetValue() ) );
}

void go( Critter& cr, int, int, int )
{
	Item@[] loot;
	cr.GetItems( -1, loot );
	DeleteItems( loot );
	
	cr.Say( SAY_EMOTE, "Одевает соломенную шляпу" );
	
	cr.AddItem( PID_RADCVET_SEED, 5 );
	cr.AddItem( PID_CABBAGE_SEED, 5 );
	cr.AddItem( PID_CORN_SEED, 	  5 );
	cr.AddItem( PID_SHOVEL, 1 );
	cr.AddItem( PID_BOTTLE_FULL, 20 );
	cr.AddItem( PID_SHIT_SMALL, 20 );
}

void _InitShit(Item& item, bool firstTime)
{
	//TODO: Пачкаться в грязи.
}

#ifndef __PLANT_BEHAVIOR
	#define __PLANT_BEHAVIOR
	
	void _InitPlant( Item& item, bool firstTime )
	{
		UNSETFLAG( item.Flags, ITEM_FLAT );
		SETFLAG( item.Flags, ITEM_CAN_USE );
		
		if( firstTime )
		{
			
			uint proto = item.GetProtoId();
			
			if( item.GetType() != ITEM_TYPE_PLANT )
			{
				Log( "Not a plant #" + proto + " id " + item.Id + " [" + item.GetType() + "]" );
				return;
			}

			uint hashNum = item.PLANT_TYPE;
			CPlant@ plant = GetCPlant( proto );
			if( valid( plant ) )
				hashNum = plant.PlantType;
			else
			{
				item.GROW_STAGE = -1;
				/*
				cleanScripts( item );
				UNSETFLAG( item.Flags, ITEM_HIDDEN );
				item.ChangeProto( PID_SHIT_SMALL );
				item.Update();
				*/
			}
			item.PLANT_TYPE = hashNum;

			item.Update();
		}

		if( isSEED(item) )
			item.SetEvent( ITEM_EVENT_USE, "_PlantSeeds" );
		else
			item.SetEvent( ITEM_EVENT_USE, "_UsePlant" );

		item.SetEvent( ITEM_EVENT_SKILL, "_SkillPlant" );
		item.SetEvent( ITEM_EVENT_USE_ON_ME, "_OnMePlant" );

		item.Update();
	}
	
	bool CleanUpPlant( Critter& cr, Item& item )
	{
		CPlant @ plant = GetCPlant( item.PLANT_TYPE );
		if( !valid( plant ) )
			return inform( cr, "Растение мутировало, либо у вас не хватает навыков опознать его.\n\nКиньте скриншот в канал дискорда #баги. Информация:" + debugInfo( item ) );

		if( item.GROW_STAGE == int( plant.MaxCycle ) )
			return inform( cr, "Тут нет ничего ценного, остаётся пустить на перегной." );
		
		if( item.GROW_STAGE == int( plant.SeedCycle ) )
		{
			cr.AddItem( plant.BasePid, 2 );
			_SubItem( item, 1 );
			
			return action( cr, "Собирает семена" );
		}
		
		if( item.GROW_STAGE == int( plant.SeedCycle + 1 ) )
		{
			cr.AddItem( plant.CollectPid, 1 );
			_SubItem( item, 1 );
			
			return action( cr, "Собирает плоды" );
		}
		
		return inform( cr, "Вы не знаете, что с этим делать."  );
	}
	
	bool _UsePlant(Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)
	{
		if( ( valid( onCritter ) && onCritter.Id != cr.Id ) || valid( onItem ) || valid( onScenery ) )
			return inform( cr, "\"Используйте\" объект в инвентаре или на себя." );

		return CleanUpPlant( cr, item );
	}
	
	bool _PlantSeeds(Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery)
	{
		if( ( valid( onCritter ) && onCritter.Id != cr.Id ) || valid( onItem ) || valid( onScenery ) )
			return inform( cr, "\"Используйте\" объект в инвентаре или на себя." );
		
		Map@ map = cr.GetMap();
		if( !valid( map ) )
			return inform( cr, "На глобале нельзя." );

		if( !isSEED(item) )
			return inform( cr, "С семечком что-то не так, его уже не посадить." );

		if( map.GetItems( cr.HexX, cr.HexY, null ) > 0 )
			return inform( cr, "Сначала очистите место, семечку нужно больше пространства для роста." );

		uint time = 0;
		if( !CheckGard( map, cr.HexX, cr.HexY ) )
			return inform( cr, "Семечка сможет прорасти лишь на грядке." );
		
		_SubItem( item, 1 );

		Item@ seed = map.AddItem( cr.HexX, cr.HexY, item.GetProtoId(), 1 );
		seed.TIME_EVENT = CreateTimeEvent( __FullSecond + getStageTime(), "e_ProcessPlant", seed.Id, true );
		
		return action( cr, "Сеет" );
	}

	bool _OnMePlant( Item& plant, Critter& cr, Item@ usedItem )
	{
		if( !valid( usedItem ) )
			return inform( cr, "Киньте скриншот в канал дискорда #баги, указав что за предмет вы использовали на растении." );

		if( Fertilize( cr, plant, usedItem, false ) )
			return true;
		
		if( Watering( cr, plant, usedItem, false ) )
			return true;
		
		return inform( cr, "Вы не смогли сделать ничего толкового с растением." );
	}

	bool _SkillPlant( Item& item, Critter& cr, int skill )
	{
		if( skill == SKILL_PICK_ON_GROUND )
		{
			CPlant @ plant = GetCPlant( item.PLANT_TYPE );
			if( !valid( plant ) )
				return inform( cr, "Растение мутировало, либо у вас не хватает навыков опознать его.\n\nКиньте скриншот в канал дискорда #баги. Информация:" + debugInfo( item ) );

			if( item.GROW_STAGE == int( plant.MaxCycle ) )
			{
				cr.ParamBase[ CR_DIRTINESS ] += Random( 0, 2 );
				cleanScripts( item );
				
				//CPlant@ plant = GetCPlant( item.PLANT_TYPE );
				//	if( valid( plant ) )
					plant.Kill( item );
				
				MoveItem( item, item.GetCount(), cr );
				
				return action( cr, "Собирает" );
			}
			
			if( item.GetProtoId() == PID_SHIT_SMALL )
			{
				cr.ParamBase[ CR_DIRTINESS ] += Random( 1, 4 );
				cleanScripts( item );
				MoveItem( item, item.GetCount(), cr );
				
				return action( cr, "Убирает перегной" );
			}			
				
			return AskCheckout( cr, item );
		}
		
		if( skill == SK_SCIENCE )
		{
			Watering( cr, item, null );
			return true;
		}

		if( skill == SK_REPAIR )
		{
			Fertilize( cr, item );
			return true;
		}
		
		if( skill == SK_TRAPS )
		{
			PlantPickup( cr, item );
			return true;
		}

		return false;
	}
	
#endif

#ifndef __PLANT_SUBFUNCTIONS
	#define __PLANT_SUBFUNCTIONS
	
	void cleanScripts( Item@ item )
	{
		if( !valid( item ) ) return;
		
		item.SetEvent( ITEM_EVENT_SKILL, null );
		item.SetEvent( ITEM_EVENT_USE_ON_ME, null );
		item.SetEvent( ITEM_EVENT_USE, null );
		item.SetEvent( ITEM_EVENT_DROP, null );
		
		if( item.TIME_EVENT != 0 )
		{
			EraseTimeEvent( item.TIME_EVENT );
			item.TIME_EVENT = 0;
		}
		if( isSEED( item) )
		{
			_InitPlant( item , true );
			return;
		}
		
	}

	bool AskCheckout( Critter& cr, Item@ item )
	{
		if( !valid( item ) ) 
			return inform( cr, "Киньте скриншот в канал дискорда #баги, указав что вы сделали перед появлением сообщения." );
		
		string stage = "Мутант";
		string[] stage_names = { "Семечка", "Побег", "Росток" };
		if( item.GROW_STAGE < int( stage_names.length() ) )
			stage = stage_names[item.GROW_STAGE];

		if( cr.Skill[SK_OUTDOORSMAN] + cr.Skill[SK_SCIENCE] < 200 )
			stage = "Вы недостаточно образованы, что бы понять что к чему.";
		else
		{
			CPlant@ plant = GetCPlant( item.PLANT_TYPE );
			if( !valid( plant ) )
				return inform( cr, "Растение мутировало, либо у вас не хватает навыков опознать его.\n\nКиньте скриншот в канал дискорда #баги. Информация:" + debugInfo( item ) );

			if( isSEED( item) )
				stage = "Семечка";

			if( item.GROW_STAGE == int( plant.SeedCycle ) )
				stage = "Семяносная";

			if( item.GROW_STAGE == int( plant.SeedCycle + 1 ) && item.GROW_STAGE != int( plant.MaxCycle ) )
				stage = "Плодоносная";
			
			if( item.GROW_STAGE == int( plant.MaxCycle ) )
				stage = "Перегной";
		}
		
		cr.ParamBase[CR_VAL0] = int( item.Id );
		
		string[] data = { 
			"plant@answer_CHECKOUT", 
			"Информация о растении:\n" 
			+ "\nСтадия роста: " + stage
			+ "\nУрожайность: " + item.PLANT_GAIN, 
				"Поли" + ( item.WATERING < 1 ? "ть" : "то" ),
				"Удобр" + ( item.FERTILITY < 1 ? "ить" : "ено" ),
				"Собрать" };
		DIALOG_MENU( cr, data );
		
		return true;
	}

	void answer_CHECKOUT( Critter& cr, uint answerI, string& answerS )
	{
		Item@ plant = GetItem( cr.ParamBase[CR_VAL0] );
		if( !valid( plant ) ) 
		{
			inform( cr, "Киньте скриншот в канал дискорда #баги, указав что конкретно вы сделали перед появлением этого сообщения." );
			return;
		}
		
		switch( answerI )
		{
			case( 0 ): Watering( cr, plant, null ); break;
			case( 1 ): Fertilize( cr, plant );		break;
			case( 2 ): AskRemove( cr, plant.Id ); 	return;
			default: break;
		}
		
		AskCheckout( cr, plant );
	}

	bool AskRemove( Critter& cr, uint targetId )
	{
		cr.ParamBase[CR_VAL0] = targetId;
		cr.ShowScreen( SCREEN_DIALOGBOX, 1, "plant@answer_REMOVE" );
		cr.Say( SAY_DIALOGBOX_TEXT, "Вы уверены?" );
		cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "да" );
		return true;
	}

	void answer_REMOVE( Critter& cr, uint answerI, string& answerS )
	{
		PlantPickup( cr, GetItem( cr.ParamBase[CR_VAL0] ) );
	}

	bool PlantPickup( Critter& cr, Item@ plant )
	{
		if( !valid( plant ) )
			return inform( cr, "Киньте скриншот в канал дискорда #баги, указав что за растение вы попытались собрать." );

		cr.Animate( 0, ANIM2_PICKUP, null, false, true );
		cleanScripts( plant );//TODO: Проверить - не генерило-ли это баг с потерей поведения.
		
		if( isSEED(plant) )
		{
			cr.ParamBase[ CR_DIRTINESS ] += Random( 0, 1 );
			cr.Say( SAY_EMOTE_ON_HEAD, "Выковыривает семена из земли" );
		}
		else
		{
			cr.Say( SAY_EMOTE_ON_HEAD, "Собирает" );
			plant.SetEvent( ITEM_EVENT_USE, "_UsePlant" );
			
			if( plant.PLANT_GAIN > 1 )
			{
				Item@ item = cr.AddItem( plant.GetProtoId(), plant.PLANT_GAIN );
				if( valid( item ) ) {
					item.PLANT_TYPE = plant.PLANT_TYPE;
					item.GROW_STAGE = plant.GROW_STAGE;
					item.SetEvent( ITEM_EVENT_USE, "_UsePlant" );
				}
				
				DeleteItem( plant );
				return true;
			}
		}
		
		MoveItem( plant, plant.GetCount(), cr );
		return true;
	}
#endif

#ifndef __PLANT_WATERING
	#define __PLANT_WATERING
	
	bool Watering( Critter& cr, Item& plant, Item@ usedItem, bool TMI = true )
	{
		InitWaterSourceList();	
		return WaterSources.watering( cr, plant, usedItem, TMI );
	}
	
	WaterSourceList@ WaterSources;
	void InitWaterSourceList()
	{
		if( valid( WaterSources ) ) return;
		
		@WaterSources = CreateWaterSourceList( "Источники воды" )
		//  .add( PID_полный, PID_пустой )
			.add( PID_BOTTLE_FULL, PID_BOTTLE_EMPTY )
			.add( PID_BOTTLE_DIRTY_FULL, PID_BOTTLE_EMPTY )
			.add( PID_GLASS_BOTTLE_FULL, PID_BOTTLE_GLASS )
			.add( PID_GLASS_BOTTLE_DIRTY_FULL, PID_BOTTLE_GLASS )
			.add( PID_FLASK_FULL, PID_FLASK_EMPTY )
		;
	}
	
	class WaterSource
	{
		//uint power; //TODO: Различная ценность/сила источников воды. Или можно сделать логику, по которой вода не тратится сразу вся за 1 юз.
		uint pidFull;
		uint pidEmpty;
		
		WaterSource( uint pidFull, uint pidEmpty )
		{
			this.pidFull = pidFull;
			this.pidEmpty = pidEmpty;
		}
		
		bool use( Critter& cr )
		{
			if( cr.CountItem( pidFull ) < 1 ) return false;
			
			cr.DeleteItem( pidFull, 1 );
			cr.AddItem( pidEmpty, 1 );
			
			return true;
		}
		
		bool isSource( Item@ source )
		{
			if( !valid( source ) ) return false;
			
			return source.GetProtoId() == pidFull;
		}
		
		bool watering( Critter& cr, Item@ plant )
		{
			if( !valid(plant) || !use( cr ) ) return false;
			
			plant.WATERING++;
			
			return action( cr, "Поливает растение" );
		}
	}

	WaterSourceList@ CreateWaterSourceList( string name )
	{
		return WaterSourceList( name );	
	}

	class WaterSourceList
	{
		string name;
		WaterSource[] list;
		
		WaterSourceList( string name )
		{
			this.name = name;
		}
		
		WaterSourceList@ add( uint pidFull, uint pidEmpty )
		{
			return this.add( WaterSource( pidFull, pidEmpty ) );
		}

		WaterSourceList@ add( WaterSource@ item )
		{
			list.insertLast( item );
			return this;
		}
		
		bool watering( Critter& cr, Item@ plant, Item@ item, bool TMI = true )
		{
			if( !valid( item ) )
				return watering( cr, plant );
			
			for( uint i = 0; i < list.length(); i++ )
				if( list[i].isSource( item ) )
				{
					if( list[i].watering( cr, plant ) )
						return true;
					else
						break;
				}
				
			return inform( cr, "У вас не вышло нормально полить растение.", false, TMI );
		}
		
		bool watering( Critter& cr, Item@ plant, bool TMI = true )
		{
			for( uint i = 0; i < list.length(); i++ )
				if( list[i].watering( cr, plant ) )
					return true;
			
			return inform( cr, "Вы не смогли полить растение.", false, TMI );
		}
	}
#endif

bool Fertilize( Critter& cr, Item& plant )
{
	if( cr.CountItem( PID_SHIT_SMALL ) > 0 ) 
		return Fertilize( cr, plant, cr.GetItem( PID_SHIT_SMALL, -1 ) );

	if( cr.CountItem( PID_SHIT_BIG ) > 0 ) 
		return Fertilize( cr, plant, cr.GetItem( PID_SHIT_BIG, -1 ) );
	
	return inform( cr, "У вас нет удобрений.", false );
}

bool Fertilize( Critter& cr, Item& plant, Item@ usedItem, bool TMI = true )
{
	if( !valid( usedItem ) ) 
		return inform( cr, "Ваши удобрения не подходят.", false, TMI );

	uint pid = usedItem.GetProtoId();
	
	if( pid != PID_SHIT_SMALL && pid != PID_SHIT_BIG )
		return inform( cr, "Вы не смогли удобрить растение.", false, TMI );

	cr.ParamBase[ CR_DIRTINESS ] += Random( 0, 3 );
	cr.DeleteItem( pid, 1 );
	plant.FERTILITY += 1;
	
	return action( cr, "Удобряет растение" );
}

#ifndef __PLANT_CLASSES
	#define __PLANT_CLASSES
	
	CPlant@ GetCPlant( uint plantNum )
	{
		switch( plantNum )
		{
			case( PID_RADCVET_SEED ): 	return CPlant( PID_RADCVET_SEED, 	4, 	3, 	PID_RADCVET_SEED, 	PID_RADCVET_SEED );
			case( PID_CABBAGE_SEED ): 	return CPlant( PID_CABBAGE_SEED, 	4, 	2, 	PID_CABBAGE_SEED, 	PID_CABBAGE 	 );
			case( PID_CORN_SEED ): 		return CPlant( PID_CORN_SEED, 		5, 	3, 	PID_CORN_SEED, 		PID_CORN 		 );
		}
		return null;
	}

	class CPlant
	{
		uint PlantType;
		
		uint MaxCycle;
		uint SeedCycle;
		
		uint BasePid;
		uint CollectPid;

		CPlant( uint PlantType, uint MaxCycle, uint SeedCycle, uint BasePid, uint CollectPid )
		{
			this.PlantType = PlantType;
			
			this.MaxCycle = MaxCycle;
			this.SeedCycle = SeedCycle;
			
			this.BasePid = BasePid;
			this.CollectPid = CollectPid;
		}

		uint Release( Item& item )
		{
			ChangePic( item );

			switch( item.GROW_STAGE )
			{
				case 1: return Cycle1( item );
				case 2: return Cycle2( item );
				case 3: return Cycle3( item );
				case 4: return Cycle4( item );
				case 5: return Cycle5( item );
			}
			return 0;
		}

		bool CheckWater( Item& item )
		{
			Map@ currentMap = GetMap( item.MapId );
			int rain = currentMap.GetRain();
			if( rain > 0 )
				item.WATERING++;
			
			if( item.GROW_STAGE > 1 && ( item.WATERING < 1 ) )
			{
				Kill( item );
				return false;
			}
			return true;
		}

		bool Kill( Item& item )
		{
			CPlant@ plant = GetCPlant( item.PLANT_TYPE );
			if( !valid( plant ) ) return false;

			UNSETFLAG( item.Flags, ITEM_HIDDEN );

			item.FERTILITY = 0;
			item.PLANT_GAIN = 0;
			item.GROW_STAGE = plant.MaxCycle;
			ChangePic( item );
			
			return true;
		}

		uint MakeShit( Item& item )
		{
			Kill( item );
			
			UNSETFLAG( item.Flags, ITEM_HIDDEN );
			item.ChangeProto( PID_SHIT_SMALL );
			item.Update();
			return 0;
		}

		void IncreaseFruits( Item& item )
		{
			item.PLANT_GAIN += 1;
		}

		void ChangePic( Item& item )
		{
			item.ChangeProto( BasePid + item.GROW_STAGE );
			item.Update();
		}
		
		uint CycleDead( Item& item )
		{
			return getStageTime();
		}

		uint Cycle1( Item& item ) //Семечка становится невидимой.
		{
			SETFLAG( item.Flags, ITEM_HIDDEN );
			item.Update();

			return getStageTime();
		}

		uint Cycle2( Item& item ) //Пробивается молодой побег.
		{
			IncreaseFruits( item );
			
			UNSETFLAG( item.Flags, ITEM_HIDDEN );
			item.Update();

			return getStageTime();
		}

		uint Cycle3( Item& item ) //Побег становится крупней.
		{
			if( item.FERTILITY > 0 && Random( 0, 1 ) == 0 )
				IncreaseFruits( item );

			item.Update();

			return getStageTime();
		}

		uint Cycle4( Item& item ) //Крупные побеги всходят, маленькие - стареют.
		{
			return getStageTime();
		}

		uint Cycle5( Item& item ) //Растение умирает и гниёт.
		{
			return getStageTime();
		}
	}

	uint e_ProcessPlant( uint[] @ values )
	{
		if( !valid( values ) || values.length() != 1 )
			return 0;

		Item@ item = GetItem( values[ 0 ] );
		if( !valid( item ) ) return 0;

		if( item.GetType() != ITEM_TYPE_PLANT ) return 0;

		CPlant@ plant = GetCPlant( item.PLANT_TYPE );
		if( !valid( plant ) ) return 0;

		if( isSEED( item ) )
			item.SetEvent( ITEM_EVENT_DROP, null );
		else if( item.GROW_STAGE >= int( plant.MaxCycle ) )
			return plant.MakeShit( item );

		if( item.GROW_STAGE > 0 )
		{
			if( !plant.CheckWater( item ) )
				return getStageTime();

			if( Random( 1, 95 ) == 5 )
			{
				Map @ map = GetMap( item.MapId );
				if( valid(map) )
				{
					uint[] mobs = { 2200, 2201, 2202, 2203, 2204, 2217 };
					map.AddNpc( mobs[ Random( 0, mobs.length() - 1 ) ], item.HexX, item.HexY, 0, null, null, "mob@_MobInit" );
					DeleteItem( item );
					return 0;
				}
			}
		}

		item.GROW_STAGE++;

		return plant.Release( item );
	}

#endif