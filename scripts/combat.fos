#ifndef COMBAT_MODULE
#define COMBAT_MODULE

#include "_utils.fos"
#include "combat_h.fos"
#include "firestarter_h.fos"
#include "_animation.fos"
#include "critter_item_movement_h.fos"
#include "repair_h.fos"
#include "reload_h.fos"
#include "radiation_h.fos"
#include "paralysis_h.fos"
#include "poison_h.fos"
#include "critter_status_h.fos"
#include "speed_h.fos"
#include "trap_h.fos"
#include "gm_h.fos"
#include "_npc_pids.fos"
#include "critical_table.fos"
#include "combat_msg.fos"
#include "npc_ai.fos"
#include "wait_time_h.fos"
#include "special_weapons_h.fos"
#include "effects_h.fos"
#include "linetracer_h.fos"
#include "hitchance_h.fos"

class AttackStruct
{
    Critter@	Attacker;
    Item@		RealWeapon;
    uint16		WeaponPid;
    uint16		Hx;
    uint16		Hy;
    uint8		Aim;
    bool		IsBurst;
    bool		BloodyMess;
    bool		CombatMessage;
    int			WeaponPerk;
	int			AmmoPerk;
    uint8		WeaponType;
    int			DmgMin;
    int			DmgMax;
    int			DmgType;
    int			BonusDmg;
    int			DrMod;
	int			MinDmgMod;
	int			MaxDmgMod;
    int			CritDmgMod;
    uint		TargetId;
    bool		TargetHit;
    ProtoItem@	Ammo;
    uint		ForceFlags;
    bool		ShowHitAnimForce;

    AttackStruct( AttackStruct original )
    {
        @Attacker = @original.Attacker;
        @RealWeapon = @original.RealWeapon;
        WeaponPid = original.WeaponPid;
        Aim = original.Aim;
        IsBurst = original.IsBurst;
        BloodyMess = original.BloodyMess;
        CombatMessage = original.CombatMessage;
        WeaponPerk = original.WeaponPerk;
		AmmoPerk = original.AmmoPerk;
        WeaponType = original.WeaponType;
        DmgMin = original.DmgMin;
        DmgMax = original.DmgMax;
        DmgType = original.DmgType;
        BonusDmg = original.BonusDmg;
        DrMod = original.DrMod;
		MinDmgMod = original.MinDmgMod;
		MaxDmgMod = original.MaxDmgMod;
        CritDmgMod = original.CritDmgMod;
        TargetId = original.TargetId;
        TargetHit = original.TargetHit;
        @Ammo = @original.Ammo;
        ForceFlags = original.ForceFlags;
        ShowHitAnimForce = original.ShowHitAnimForce;
	}
	
    AttackStruct()
    {
        @Attacker = null;
        @RealWeapon = null;
        WeaponPid = 0;
        Aim = HIT_LOCATION_UNCALLED;
        IsBurst = false;
        BloodyMess = false;
        CombatMessage = false;
        WeaponPerk = 0;
		AmmoPerk = 0;
        WeaponType = 0;
        DmgMin = 0;
        DmgMax = 0;
        DmgType = 0;
        BonusDmg = 0;
        DrMod = 1;
		MinDmgMod = 100;
		MaxDmgMod = 100;
        CritDmgMod = 100;
        TargetId = 0;
        TargetHit = false;
        @Ammo = null;
        ForceFlags = 0;
        ShowHitAnimForce = false;
    }
};

// AttackStruct[] delayed_attacks;
// int add_delayed_attack( AttackStruct attack ) { return -1; }
// AttackStruct@ get_delayed_attack( uint id ) { return null; }
// bool erase_delayed_attack( uint id ) { return false;}

void MissedShot( Map& map, Critter& attacker, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16& tx, uint16& ty, bool recursive )
{
	uint16 x = attacker.HexX, y = attacker.HexY; 
	uint distance = GetDistantion( x, y, tx, ty );		

	Critter@[] critters;
	map.GetCrittersPath( x, y, tx, ty, 0.0f, distance, FIND_LIFE_AND_KO, critters );
	
	uint[] IDs = sortByDist( x, y, critters );
	for( uint i = 0, l = IDs.length(); i < l; i++ )
	{
		Critter@ target = GetCritter( IDs[i] );
		if( target.Id == attacker.Id )
		{
			continue;
		}
		
		int hitChance = RandomTargetChance( attacker, target, ammo );
		if( Random( 1, 100 ) <= hitChance )
		{
			int toHit = to_hit( attacker, target, weapon, weaponMode, ammo, tx, ty, true );
			if( ( toHit - Random( 1, 100 ) ) >= 0 )
			{
				CombatAttack( attacker, target, weapon, weaponMode, ammo, tx, ty, recursive, true );
				return;
			}
		}
	}

	CombatAttack( attacker, null, weapon, weaponMode, ammo, tx, ty, false, true );
}

Critter@ checkHitLine( Map& map, Critter& attacker, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16& tx, uint16& ty )
{
	uint16 x = attacker.HexX, y = attacker.HexY; 
	uint distance = GetDistantion( x, y, tx, ty );		

	Critter@[] critters;
	map.GetCrittersPath( x, y, tx, ty, 0.0f, distance, FIND_LIFE_AND_KO, critters );
	
	uint[] IDs = sortByDist( x, y, critters );
	for( uint i = 0, l = IDs.length(); i < l; i++ )
	{
		Critter@ target = GetCritter( IDs[i] );
		if( target.Id == attacker.Id )
		{
			continue;
		}
		
		int hitChance = RandomTargetChance( attacker, target, ammo );
		
		if( Random( 1, 100 ) <= hitChance )
		{
			return target;
		}
	}
	
	return null;
}

int RandomTargetChance( Critter& attacker, Critter& target, ProtoItem@ ammo )
{
	int hitChance = 60;
	if( valid( ammo ) )
	{
		if( FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT ) )
		{
			hitChance = 80;
		}
	}
	
	if( target.IsKnockout() || target.Param[ CR_IS_RELAXING ] > 0 )
	{
		hitChance /= 2;
	}
	
	if( target.Param[ PET_OWNER_ID ] == int( attacker.Id ) || target.Param[ PET_PROTECT_ID ] == int( attacker.Id ) )
	{
		hitChance /= 10;
	}
	
	return hitChance;
}

uint[] sortByDist( uint16 x, uint16 y, Critter@[] crs )
{
	uint[] result;
	while( result.length() < crs.length() )
	{
		uint min_dist = 250, n = 0;
		for( uint i = 0, l = crs.length(); i < l; i++ )
		{
			if( !valid( crs[i] ) )
			{
				continue;
			}
			
			uint distance = GetDistantion( x, y, crs[i].HexX, crs[i].HexY );	
			if( distance < min_dist )
			{
				min_dist = distance;
				n = i;
			}
		}
		result.insertLast( crs[n].Id );
		@crs[n] = null;		
	}	
	return result;
}

void ShotgunSpread( AttackStruct@ attack, Critter& attacker, uint16 target_x, uint16 target_y, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint distance, uint pellets_count )
{
	Map@ map = attacker.GetMap();
	const uint16 ax = attacker.HexX, ay = attacker.HexY;
	uint[] target_IDs, pellets_hit;

	for( uint pellet_number = 0; pellet_number < pellets_count; pellet_number++ )
	{
		float angle = spread_angle_array[ pellet_number ];
		//Log( "angle " + angle );
		uint16 tx = target_x, ty = target_y;
		RustyGetHexCoord( map, ax, ay, tx, ty, angle, distance );
		Critter @target = checkHitLine( map, attacker, weapon, weaponMode, ammo, tx, ty );
		if( valid( target ) )
		{
			int n = target_IDs.find( target.Id );
			if( n == -1 )
			{
				target_IDs.insertLast( target.Id );
				pellets_hit.insertLast( 1 );
			}
			else
			{
				pellets_hit[n]++;
			}
		}
		else
		{
			bulletVFX( map, attacker, tx, ty, weapon, weaponMode, ammo );
		}
	}
	
	for( uint n = 0, l = target_IDs.length(); n < l; n++ )
	{
	    CombatRes[] results;
		Critter @target = GetCritter(target_IDs[n]);
		bool isCritical = CritRoll( attacker.Stat[ ST_CRITICAL_CHANCE ], target, map, attacker.HexX, attacker.HexY );
		ApplyDamage( attack, target, pellets_hit[n], isCritical, true, results );
		FlushResults( results );
	}
}

void bulletVFX( Map& map, Critter& attacker, uint16 target_x, uint16 target_y, ProtoItem& weapon, uint8 weaponMode, ProtoItem& ammo, uint round = 1 )
{ //Bullet VFX must stop in a few hexes before hitting the target hex with VFXspark:
	uint16 vfx_x = target_x, vfx_y = target_y;
	int dist = GetDistantion( attacker.HexX, attacker.HexY, vfx_x, vfx_y );
	dist = CLAMP( dist - 3, 1, dist );
	RustyGetHexCoord( map, attacker.HexX, attacker.HexY, vfx_x, vfx_y, 0.0f, dist );

	uint baseTime = 250 * round;
	
	uint weapon_effect = _WeaponEffect( weapon, _WeaponModeUse( weaponMode ) );
	bool isShotgun = FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT );
	if( isShotgun )
	{
		weapon_effect = PID_FLYING_SPIKE;
	}
	
	uint[] flyEffectVals = { map.Id, weapon_effect, attacker.Id, 0, attacker.HexX, attacker.HexY, vfx_x, vfx_y };
	CreateTimeEvent( AFTER( REAL_MS( baseTime ) ), "combat@e_FlyEffect", flyEffectVals, true );
	
	int distance = int( GetDistantion( attacker.HexX, attacker.HexY, target_x, target_y ) * 7.75f );
	uint[] delayedAttackVals = { attacker.Id, 0, weapon.ProtoId, weaponMode, ammo.ProtoId, target_x, target_y };
	CreateTimeEvent( AFTER( REAL_MS( baseTime + distance ) ), "combat@e_DelayedAttackVFX", delayedAttackVals, false );
}

void CombatAttack( Critter& attacker, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY, bool recursive, bool autohit )
{
	if( !valid( target ) && hexX == 0 && hexY == 0 )
	{
        return;
	}

	bool validAttacker = valid( attacker );
    uint8 use = _WeaponModeUse( weaponMode );
    uint8 aim = _WeaponModeAim( weaponMode );
	
	if( ( attacker.Param[ CR_AUTO_AIM ] != HIT_LOCATION_NONE && aim == HIT_LOCATION_NONE ) )
	{
		aim = attacker.Param[ CR_AUTO_AIM ];
	}
	
    Item@ realWeapon = _CritGetItemHand( attacker );
	bool validWeapon = valid( realWeapon );
	
    Map@ map = attacker.GetMap();
	if( !valid( map ) )
	{
		return;
	}

	bool validTarget = valid( target );
	if( validTarget && target.IsDead() )
	{
		validTarget = false;
	}
	
    int wpnMaxDist = _WeaponMaxDist( weapon, use );
    int skillNum = _WeaponSkill( weapon, use );

    if( skillNum == SK_THROWING )
	{
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( 10, attacker.Stat[ ST_STRENGTH ] ) );
	}

    uint8 weaponType = ( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
    bool isRanged = ( weaponType == WS_THROWING || weaponType == WS_GUN );
    bool isUnarmed = weapon.Weapon_IsUnarmed;
    bool isHthAttack = ( weaponType == WS_MELEE || weaponType == WS_UNARMED );
    uint16 ammoRound = _WeaponRound( weapon, use );
    bool wpnIsRemoved = _WeaponRemove( weapon, use );
    uint16 hx = attacker.HexX;
    uint16 hy = attacker.HexY;
    uint16 tx = validTarget ? target.HexX : hexX;
    uint16 ty = validTarget ? target.HexY : hexY;
    uint16 weapPid = weapon.ProtoId;
	bool validAmmo = valid( ammo );
    uint16 ammoPid = validAmmo ? ammo.ProtoId : 0;
	uint8 weaponSubtype = validWeapon ? realWeapon.Proto.Item_Subtype : 0;

	int dmgType = _WeaponDmgType( weapon, use );
	if( dmgType == DAMAGE_UNCALLED )
	{
		if( validAmmo )
		{
			dmgType = ammo.Ammo_DmgType;
		}
	}

    bool isGrenade = ( weaponSubtype >= ITEM_SUBTYPE_WEAPON_GRENADE_FRAG && weaponSubtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END );
    bool isFlamethrower = ( weaponSubtype == ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER );
	bool isShotgun = ( validAmmo && FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT ) );
    bool isRocket = ( ammoPid == PID_EXPLOSIVE_ROCKET ) || ( ammoPid == PID_ROCKET_AP ) || ( ammoPid == PID_ROBO_ROCKET_AMMO ) || ( ammoPid == PID_40MM_HE ) || ( ammoPid == PID_BOLTS_HE );
    bool eyeDamage = attacker.Damage[ DAMAGE_EYE ] != 0;
    bool crIsPlayer = attacker.IsPlayer();
    bool isHit = false;
    bool isCritical = false;
    bool hitRandomly = false;
    bool isSneak = false;
    uint critfailFlags = 0;
    int weaponPerk = weapon.Weapon_Perk;
	bool isAmmoRegen = FLAG( weaponPerk, WEAPON_PERK_RECHARGE );
	bool isBurst = ( _WeaponAnim2( weapon, use ) == ANIM2_BURST );
	bool isAuto  = ( _WeaponAnim2( weapon, use ) == ANIM2_AUTO );
	
	if( isBurst && validWeapon && !recursive && !autohit )
	{
		uint burstDelay = 0;
		uint len = realWeapon.AmmoCount < ammoRound ? realWeapon.AmmoCount : ammoRound;
		for( uint i = 0; i < len; i++ )
		{
			burstDelay = burstDelay + ( _GetProtoWaitTime( weapon, use ) / len );
			uint[] vals = { attacker.Id, validTarget ? target.Id : 0, weapPid, use, ammoPid, tx, ty, 0, 1 };
			CreateTimeEvent( AFTER( REAL_MS( burstDelay ) ), "combat@e_DelayedAttack", vals, false );
		}

		return;
	}

    CombatRes[] results;

	//check for accidental hit
	if( !autohit )
	{
		Critter@ realTarget;
		@realTarget = checkHitLine( map, attacker, weapon, weaponMode, ammo, tx, ty );
		if( valid( realTarget ) )
		{
			if( validTarget )
			{
				if( realTarget.Id != target.Id )
				{
					@target = realTarget;
					validTarget = valid( target );
				}
			}
			else
			{
				@target = realTarget;
				validTarget = valid( target );
			}
		}
	}
	
	bool hexAttack = !validTarget;
	
	//void attackInfo(args)
	string wpn_info = itemName( weapPid ) + ( validWeapon ? " #" + realWeapon.Id : "" ) + ( ammoPid != 0 ? " " + itemName( ammoPid ) : "" );
	string attack_info = crInfo( attacker ) + " attacks" + ( isBurst ? " with burst" : "" ) + " using " + wpn_info + " on (" + tx + ":" + ty + ")";
	if( validTarget )
	{
		attack_info += ", where a " + crInfo( target ) + " is.";
	}
	
	uint _distance = GetDistantion( hx, hy, tx, ty );
	string distance_info = _distance > 1 ? " [ Distance: " + _distance + " ]" : "";
	
	SayLog( attacker, attack_info + "." + distance_info );
	//void attackInfo(args)

    // always unsneak
    if( attacker.Mode[ MODE_HIDE ] != 0 && !( weaponType == WS_THROWING && dmgType == DAMAGE_NORMAL && validTarget && !attacker.IsSeenBy( target ) ) )
    {
        if( !attacker.IsPlayer() || attacker.GetAccess() == ACCESS_CLIENT )
		{
            attacker.ModeBase[ MODE_HIDE ] = 0;
        }
		
		isSneak = true;
    }

	bool randomHit = false;
	// Hit location modifiers
	if( validAttacker && validTarget )
	{
		if( aim == HIT_LOCATION_NONE || ( isRanged && attacker.Trait[ TRAIT_FAST_SHOT ] != 0 && Random( 0, 2 ) != 0 ) )
		{
			aim = RandomAim();
		}
	
		if( aim == HIT_LOCATION_EYES && ( ( attacker.Dir + 3 ) % 6 != target.Dir ) )	
		{
			aim = HIT_LOCATION_HEAD;
		}
		
		if( isBurst || isAuto )
		{
			aim = RandomHit();
			randomHit = true;
		}
	}
	
    if( validTarget && target.IsNpc() )
    {
        target.EventAttacked( attacker );
    }

    int dist = _distance;

    // main attack structure
    AttackStruct attack;
    @attack.Attacker = attacker;
    @attack.RealWeapon = realWeapon;
    attack.WeaponPid = weapPid;
    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = aim;
    attack.IsBurst = isBurst;
    attack.BloodyMess = attacker.Trait[ TRAIT_BLOODY_MESS ] != 0;
    attack.CombatMessage = true;
    attack.WeaponPerk = weaponPerk;
    attack.WeaponType = weaponType;
    attack.DmgMin = ( isHthAttack || weaponType == WS_THROWING ) ? _WeaponDmgMin( weapon, use ) : ( validAmmo ? _GetAmmoDmgMin( ammo ) : 0 );
    attack.DmgMax = ( isHthAttack || weaponType == WS_THROWING ) ? _WeaponDmgMax( weapon, use ) : ( validAmmo ? _GetAmmoDmgMax( ammo ) : 0 );
    attack.DmgType = dmgType;
	attack.MinDmgMod = validAmmo ? _GetWeaponMinDmgMod( weapon ) : 100;
	attack.MaxDmgMod = validAmmo ? _GetWeaponMaxDmgMod( weapon ) : 100;
	attack.AmmoPerk = validAmmo ? ammo.Ammo_Perk : 0;
	attack.DrMod = validAmmo ? ammo.Ammo_DrMod : 1;
    attack.CritDmgMod = 100;
    @attack.Ammo = ammo;
	
    if( isHthAttack )
	{
		if( validWeapon )
		{
			//Swords Cleave attack
			if( weaponSubtype == ITEM_SUBTYPE_WEAPON_MELEE_LONG_KNIFE && !recursive && weaponMode == 0 )
			{
				Critter@[] critsCleave;
				map.GetCrittersPath( hx, hy, tx, ty, CLEAVE_ATTACK_ANGLE, wpnMaxDist, FIND_LIFE_AND_KO, critsCleave );
				map.GetCrittersPath( hx, hy, tx, ty, -CLEAVE_ATTACK_ANGLE, wpnMaxDist, FIND_LIFE_AND_KO, critsCleave );
				for( uint i = 0, j = critsCleave.length(); i < j; i++ )
				{
					Critter@ newTarget = critsCleave[i];
					if( valid( newTarget ) )
					{
						if( newTarget.Id != target.Id )
						{
							CombatAttack( attacker, newTarget, weapon, weaponMode, ammo, 0, 0, true, false );
						}
					}
				}
			}
		}
	}

	if( validWeapon && !recursive )
	{
		//Weapons penetrate
		if( FLAG( attack.WeaponPerk, WEAPON_PERK_PENETRATE ) )  
		{
			Critter@[] critsPenetrate;
			map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist - 1, FIND_LIFE, critsPenetrate );
			
			for( uint i = 0, j = critsPenetrate.length(); i < j; i++ )
			{
				Critter@ newTarget = critsPenetrate[i];
				if( valid( newTarget ) )
				{
					if( newTarget.Id != target.Id && newTarget.Id != attacker.Id )
					{
						if( isHthAttack )
						{
							CombatAttack( attacker, newTarget, weapon, weaponMode, ammo, 0, 0, true, false );
						}
						else
						{
							int distance = GetDistantion( hx, hy, newTarget.HexX, newTarget.HexY ) * 2;
							uint[] vals = { attacker.Id, newTarget.Id, weapon.ProtoId, weaponMode, realWeapon.AmmoPid, 0, 0, 0, 1 };
							CreateTimeEvent( AFTER( REAL_MS( distance ) ), "combat@e_DelayedAttack", vals, false );
						}
					}
				}
			}
			
			critsPenetrate.resize( 0 );
		}

		//Flamers AOE
		if( isFlamethrower )
		{
			Critter@[] critsBurn;
			for( int i = -FLAMER_ATTACK_ANGLE; i <= FLAMER_ATTACK_ANGLE; i += 5 )
			{
				uint16 x = tx, y = ty;
				map.GetCrittersPath( hx, hy, x, y, i, wpnMaxDist, FIND_LIFE_AND_KO, critsBurn );
			}
			
			uint[] processed;
				
			for( uint i = 0, j = critsBurn.length(); i < j; i++ )
			{
				Critter@ newTarget = critsBurn[i];
				if( valid( newTarget ) && processed.find( newTarget.Id ) == -1 )
				{
					CombatAttack( attacker, newTarget, weapon, weaponMode, ammo, 0, 0, true, false );
					processed.insertLast( newTarget.Id );
				}
			}
			
			critsBurn.resize( 0 );
		}

		if( isShotgun ) //OK BUT REVISE!!!
		{
			ShotgunSpread( attack, attacker, tx, ty, weapon, weaponMode, ammo, wpnMaxDist * 2, SHOTGUN_PELLETS );
			//most of combat logic was extracted, only ammo usage and miss-notifications left in CombatAttack
		}
	}

    if( validTarget )
	{
        attack.TargetId = target.Id;
	}

    int toHit = 100; 
	if( !autohit )
	{
		toHit = to_hit( attacker, target, weapon, weaponMode, ammo, hx, hy, randomHit );
	}
	
	//attacker.Say( SAY_NETMSG, "CR_AUTO_ROUNDS_FIRED " + attacker.Param[ CR_AUTO_ROUNDS_FIRED ] );
	//attacker.Say( SAY_NETMSG, "attacker.Id " + attacker.Id + " toHit " + toHit + " autohit " + autohit );
    int hitRoll = toHit - Random( 1, 100 );
	
	if( hitRoll < 0 )
    {
		SayLog( attacker, crInfo( attacker ) + " misses." );
    }
    else
    {
        isHit = true;
		if( !validTarget )
		{
			isCritical = false;
		}
		else
		{
			isCritical = CritRoll( attacker.Stat[ ST_CRITICAL_CHANCE ], target, map, hexX, hexY );
		}
    }

	if( attacker.Anim2Life == ANIM2_WINDUP )
	{
		attacker.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
	}
	
	if( attacker.ParamBase[ CR_IS_WINDUPED ] == 1 )
	{
		attacker.ParamBase[ CR_IS_WINDUPED ] = 0;
	}

    attacker.Action( ACTION_USE_WEAPON, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | ( ( ( !isHit && isCritical && !hitRandomly ) ? 1 : 0 ) << 8 ) | ( aim << 4 ) | use, realWeapon );

    // Commencing attack, various instances
    bool criticalHit = isHit && isCritical;

	// UNARMED AND MELEE ATTACK
    if( isHthAttack )
	{
		if( weapon.Weapon_MaxAmmoCount > 0 && realWeapon.AmmoCount == 0 )
		{ 
			uint[] values = { attacker.Id, weapon.ProtoId };
			CreateTimeEvent( AFTER( REAL_MS( 100 ) ), "general_unsafe@e_emptySFX", values, false );		
			return; 
		}
		
        if( isHit )
		{
            if( valid( target) )
			{
				ApplyDamage( attack, target, 1, criticalHit, true, results );
			}
		}
		else
		{
			if( !hexAttack )
			{
				NotifyMiss( attacker, results );
			}
		}
    }
	else if( ( attack.WeaponType == WS_GUN ) && !isRocket && !isFlamethrower && !isShotgun )
	{
        if( isHit )
		{
			if( valid( target ) )
			{
				ApplyDamage( attack, target, 1, criticalHit, false, results );
			}
		}
        else         // standard miss here - BULLET BEHAVIOUR - BURSTS FULL AUTO
        {
			uint16 mx = tx, my = ty;
			moveAimHexRandom( attacker, map, mx, my, MISS_ANGLE, 1 + dist * 10 / 100 );
			MissedShot( map, attacker, weapon, weaponMode, ammo, mx, my, recursive );
			
			if( !hexAttack )
			{
				NotifyMiss( attacker, results );
			}
			
			FlushResults( results );
			return;
		}
    }
	else if( isFlamethrower )
	{
		if( !recursive )
		{ //inital attack can't hit or miss - only spreads fire
			int radius = 0;
			uint8 strength = 1;
			if( validAmmo )
			{
				radius = ammo.Blast_Radius;
				strength = ammo.Fire_Strength;
			}
			
			GenerateFire( map, tx, ty, radius, strength, attacker.Id );
		}
		else
		{
			if( isHit )
			{
				if( valid( target ) )
				{
					ApplyDamage( attack, target, 1, criticalHit, false, results );
				}
			}
		}
	}
	else if( isShotgun )
	{
		if( isHit )
		{
			if( valid( target ) && recursive )
			{
				ApplyDamage( attack, target, 1, criticalHit, false, results );
			}
		}
       /*else 
        {
			if( !recursive && !hexAttack )
			{
				NotifyMiss( attacker, results );
			}
		}*/
	}
	else if( isRocket || attack.WeaponType == WS_THROWING )
	{
        bool exploding = isRocket || isGrenade;
        if( isHit )
		{
            if( exploding )
			{
                CommenceExplosion( attack, map, hx, hy, tx, ty, target, weapPid, criticalHit, valid( target ) ? target.Id : 0, isRocket, isGrenade, results );
            }
			else if( valid( target ) )
			{
				ApplyDamage( attack, target, 1, criticalHit, false, results );
			}
		}
		else if( exploding )
		{
			uint16 mx = tx, my = ty;
			moveAimHexRandom( attacker, map, mx, my, MISS_ANGLE, 1 + dist * 10 / 100 );
			//Log( "hx " + hx + " hy " + hy + " tx " + tx + " ty " + ty );
			CommenceExplosion( attack, map, hx, hy, mx, my, null, weapPid, false, valid( target ) ? target.Id : 0, isRocket, isGrenade, results );
			//NotifyMiss( attacker, results );
		}
	}

    // combat messages
    FlushResults( results );

/////// !!!!!!! !!!!!!!!! stuff like animations, effects - MOVE TO FUNC!!!!!!!!!!!!!!!!!!!!!!

    // Shoot
	if( isBurst ) // Old logic overide
	{
		recursive = false;
		use = 0;
		ammoRound = 1;
	}
	
	if( !recursive )
	{
		AttackSound( attacker, weapon, weaponMode );
	}

	bool showEffect = _WeaponEffect( weapon, use ) != 0 && !recursive;
	
	if( isShotgun )
	{
		showEffect = _WeaponEffect( weapon, use ) != 0 && recursive;
	}

    if( showEffect )
    {
		uint16 weaponPid = realWeapon.GetProtoId();
		uint16 ttx = tx, tty = ty;
		int ddist = GetDistantion( hx, hy, ttx, tty );
		ddist = CLAMP( ddist - 3, 1, ddist );
		RustyGetHexCoord( map, hx, hy, ttx, tty, 0.0f, ddist );

		uint[] valsN = { map.Id, _WeaponEffect( weapon, use ), attacker.Id, 0, hx, hy, ttx, tty };
		for( int i = 0; i < CLAMP( ammoRound, 1, 10 ); i++ )
		{
			uint baseTime = 250;
			uint k = i + 1;
			baseTime *= k;
			CreateTimeEvent( AFTER( REAL_MS( baseTime ) ), "combat@e_FlyEffect", valsN, true );
			
			if( !isHit || !validTarget )
			{
				uint[] vals = { attacker.Id, 0, weapon.ProtoId, weaponMode, realWeapon.AmmoPid, tx, ty };
				int distance = int( GetDistantion( hx, hy, tx, ty ) * 7.75f );
				CreateTimeEvent( AFTER( REAL_MS( baseTime + distance ) ), "combat@e_DelayedAttackVFX", vals, false );
			}
		}
	}

    if( ammoRound > 0 && validWeapon && !recursive )
	{
		if( validAmmo )
		{
			if( hasItem( attacker, PID_AMMO_PACK, SLOT_BACK ) )
			{
				Item@ ammoPack = _CritGetItemBack( attacker );
				Item@ usedAmmo = ammoPack.GetItem( attack.Ammo.ProtoId, uint( -1 ) );
				if( valid( usedAmmo ) )
				{
					uint count = usedAmmo.GetCount();
					if( count >= ammoRound )
					{
						_SubItem( usedAmmo, ammoRound );
						SpawnSpentCasing( attacker, map, realWeapon, ammo, ammoRound, false );
						ammoRound = 0;
					}
					else
					{
						ammoRound -= count;
						SpawnSpentCasing( attacker, map, realWeapon, ammo, count, false );
						_SubItem( usedAmmo, count );
					}
				}
			}
			
			if( realWeapon.AmmoCount <= ammoRound )
			{
				realWeapon.AmmoCount = 0;
				if( attacker.ParamBase[ CR_IS_WINDUPED ] == 1 )
				{
					attacker.ParamBase[ CR_IS_WINDUPED ] = 0;
					if( attacker.Anim2Life == ANIM2_WINDUP )
					{
						attacker.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
					}
				}
			}
			else
			{
				realWeapon.AmmoCount -= ammoRound;
			}
			
			SpawnSpentCasing( attacker, map, realWeapon, ammo, ammoRound, false );
		}
		else if( isAmmoRegen )
		{
			if( realWeapon.AmmoCount <= ammoRound )
			{
				realWeapon.AmmoCount = 0;
			}
			else
			{
				realWeapon.AmmoCount -= ammoRound;
			}
		}
		
		realWeapon.Update();
	}

    if( validWeapon )
	{
        if( validAttacker && realWeapon.IsDeteriorable() && crIsPlayer )
		{
			int wearCount = Random( 3, 5 );
			if( validAmmo )
			{
				if( FLAG( attack.AmmoPerk, AMMO_PERK_UNRELIABLE ) || FLAG( attack.AmmoPerk, AMMO_PERK_ERODING ) )
				{
					wearCount += Random( 9, 15 );
				}
			}
			
			DeteriorateItem( attacker, realWeapon, wearCount );
			if( realWeapon.Deterioration >= MAX_DETERIORATION )
			{
				realWeapon.Deterioration == MAX_DETERIORATION;
				SETFLAG( realWeapon.BrokenFlags, BI_BROKEN );
				realWeapon.Update();
			}
        }

        // One time weapon, erase current and push next ( if exist )
        if( wpnIsRemoved && attacker.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
		{
            bool placeOnHex = ( skillNum == SK_THROWING && !isGrenade );
			if( placeOnHex )
			{
				if( !validTarget )
				{
					if( !map.IsHexPassed( tx, ty ) )
					{
						map.SetTextMsg( tx, ty, COLOR_LGRAY, TEXTMSG_GAME, STR_MAPMSG_RICOCHET);
						uint8 revDir = GetDirection( tx, ty, hx, hy );
						map.MoveHexByDir( tx, ty, revDir, Random( 1, 2 ) );
					}
				}
				
				uint8 mode = realWeapon.Mode;
				uint16 weaponPid = realWeapon.GetProtoId();
				
				if( map.IsHexPassed( tx, ty ) || map.GetCrittersHex( tx, ty, 0, FIND_LIFE_AND_KO, null ) > 0 )
				{
					if( validTarget && ( attack.WeaponPid == PID_REV_BALL1 || attack.WeaponPid == PID_REV_BALL2 ) )
					{
						ThrowNets( attack.Attacker, target, attack.WeaponPid );
					}
					else
					{
						MoveItem( realWeapon, 1, map, tx, ty );
						Item@ thrownItem = map.GetItem( tx, ty, weaponPid );
						uint[] values = { thrownItem.Id };
						CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "critter_item_movement@e_stack_items", values, true );
					}
				}
				else
				{
					_SubItem( realWeapon, 1 );
					if( attacker.IsPlayer() )
					{
                        attacker.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_COMBAT_THROWN_SHATTERED );
                    }
				}
				
				ArmThrownWeapon( attack.Attacker, weaponPid, mode );
			}
        }
    }

    if( !attack.TargetHit && validTarget )
    {
        /*if( !target.IsPlayer() )
		{
            AI_TrySayCombatText( target, COMBAT_TEXT_MISS );
        }*/
		
		if( isHthAttack )
		{
			target.Action( ACTION_DODGE, 0, null );
		}
	}
	
	if( isBurst && attacker.Param[ CR_AUTO_ROUNDS_FIRED ] >=  int( _WeaponRound( weapon, weaponMode ) ) )
	{
		attacker.ParamBase[ CR_AUTO_ROUNDS_FIRED ] = 0;
	}
	
	return;
}

uint e_FlyEffect( uint[]@ vals )
{
	Map@ map = GetMap( vals[0] ); 
	int effect = vals[1];
	Critter@ attacker = GetCritter( vals[2] );
	Critter@ target = null;
	
	if( vals[3] != 0 )
	{
		@target = GetCritter( vals[3] );
	}
	
	int hx = vals[4];
	int hy = vals[5];
	int tx = vals[6];
	int ty = vals[7];
	map.RunFlyEffect( effect, attacker, target, hx, hy, tx, ty );
	return 0;
}

void ApplyDamage( AttackStruct& attack, Critter& target, uint rounds, bool isCritical, bool intentionally, CombatRes[]& results, int hexX = 0, int hexY = 0 )
{
	if( !valid( target ) )
	{
		return;
	}

    Map@ map = target.GetMap();
	if( !valid( map ) )
	{
		return;
	}

    if( target.IsDead() )
	{
        return;
	}

    uint eff = 0;
    uint msgEff = 0;
    int weaponPerk = attack.WeaponPerk;
	bool validAmmo = valid( attack.Ammo );
	int ammoPerk = validAmmo ? attack.AmmoPerk : 0;
    Critter@ attacker = attack.Attacker;
    bool validAttacker = valid( attacker );
    bool isBloodyMess = attack.BloodyMess;
    bool isCombatText = attack.CombatMessage;
    Item@ realWeapon = attack.RealWeapon;
	int critDmgMod = attack.CritDmgMod;
    uint aim = attack.Aim;
	bool isBurst = attack.IsBurst;
	bool isHthAttack = ( attack.WeaponType == WS_MELEE || attack.WeaponType == WS_UNARMED );
	bool validWeapon = valid( realWeapon );
    uint extraMessage = 0;
    uint extraMessageSelf = 0;
    bool targetIsPlayer = target.IsPlayer();
    bool attackerIsPlayer = ( validAttacker ? attacker.IsPlayer() : false );
	uint8 weaponSubtype = validWeapon ? realWeapon.Proto.Item_Subtype : 0;

	if( validWeapon )
	{
		if( attack.WeaponType == WS_THROWING && ( weaponSubtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weaponSubtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) )
		{
			attack.BonusDmg = attacker.Stat[ ST_MELEE_DAMAGE ] / 2;
		}
		else if( isHthAttack )
		{			
			attack.BonusDmg = attacker.Stat[ ST_MELEE_DAMAGE ];
			attack.BonusDmg += attack.WeaponType == WS_UNARMED ? attacker.Skill[ SK_UNARMED ] / 10 : attacker.Skill[ SK_MELEE_WEAPONS ] / 10;
		}
	}	
	else if( isHthAttack )
	{
		attack.BonusDmg = attacker.Stat[ ST_MELEE_DAMAGE ];
	}
	
	if( validAttacker )
	{
		if( hexX == 0 )
		{
			hexX = attacker.HexX;
		}

		if( hexY == 0 )
		{
			hexY = attacker.HexY;
		}
	}

    if( validAttacker && intentionally && target.Id != attack.TargetId )
	{
		DEBUG_SAY( target, "ApplyDamage: " + crInfo( attacker ) + " attacks " + crInfo( target ) );//DEBUG ONLY
        target.EventAttacked( attacker );
	}

    // check if hit
    if( target.Id == attack.TargetId )
	{
        attack.TargetHit = true;
	}

    if( validAttacker && attack.WeaponPid == PID_HAND_GRAPPLE )
	{
		int chance = Random( 0, 30 );
		int AttackerMaxStat = ( attacker.Stat[ ST_STRENGTH ] > attacker.StatBase[ ST_AGILITY ] ) ? attacker.Stat[ ST_STRENGTH ] : attacker.StatBase[ ST_AGILITY ];
		int DefenderMaxStat = ( target.Stat[ ST_STRENGTH ] > target.StatBase[ ST_AGILITY ] ) ? target.Stat[ ST_STRENGTH ] : target.StatBase[ ST_AGILITY ];
		int SkillDiff = ( attacker.Skill[ SK_UNARMED ] - target.Skill[ SK_UNARMED ] );
		int Modifier = 10 - ( AttackerMaxStat - DefenderMaxStat );
		chance += SkillDiff / Modifier;

		if( !target.IsDead() && target.Mode[ MODE_NO_PVP ] == 0 && attacker.Mode[ MODE_NO_PVP ] == 0 && chance >= 30 )
		{
            HookMeleeAttack( attacker, target );
            attacker.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_GRAPPLES );
			SayLog( attacker, crInfo( attacker ) + " grapples " + crInfo( target ) + "." );
        }
		else
		{
			attacker.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_GRAPPLE_FAIL );
			SayLog( attacker, crInfo( attacker ) + " attempts to grapple " + crInfo( target ) + "." );
		}
		
		return;
    }

    // Check no PvP
    if( targetIsPlayer && validAttacker && attackerIsPlayer && ( attacker.Mode[ MODE_NO_PVP ] != 0 || target.Mode[ MODE_NO_PVP ] != 0 ) )
	{
        attacker.Say( SAY_NETMSG, "No PvP." );
        target.Say( SAY_NETMSG, "No PvP." );
        return;
    }

    if( target.Mode[ MODE_HIDE ] != 0 && ( !target.IsPlayer() || target.GetAccess() == ACCESS_CLIENT ) )
	{
        target.ModeBase[ MODE_HIDE ] = 0;
	}

    int dmgType = attack.DmgType;
	
    if( validAmmo )
	{
		if( FireAmmo.find( attack.Ammo.ProtoId ) != -1 )
		{
			dmgType = DAMAGE_FIRE;
		}
		else if( attack.Ammo.ProtoId == PID_BOLTS_HE )
		{
			dmgType = DAMAGE_EXPLODE;
		}
	}
	
	int targetDR = target.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
    int targetDT = target.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];

    if( FLAG( eff, HF_BYPASS_ARMOR ) && dmgType != DAMAGE_EMP )
	{
        targetDT /= 5;
        targetDR /= 5;
    }

	//cover mechanics
	if( target.Param[ CR_IS_RELAXING ] == 5 && !FLAG( weaponPerk, WEAPON_PERK_IGNORE_COVER ) )
	{
		int coverDT = CheckCover( map, hexX, hexY, target );
		if( coverDT > 0 )
		{
			targetDT += coverDT;
			target.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_COMBAT_COVER_SAVE, "@$coverDT" + coverDT );
		}
	}

    targetDR += attack.DrMod;
    targetDR = CLAMP( targetDR, 0, 100 );
    int dmgMin = ( attack.DmgMin + attack.BonusDmg ) * attack.MinDmgMod / 100;
    int dmgMax = ( attack.DmgMax + attack.BonusDmg ) * attack.MaxDmgMod / 100;

    float rawDmg = 0;
    float totalDmg = 0;

    if( ( attack.WeaponType == WS_MELEE || attack.WeaponType == WS_THROWING ) && attack.RealWeapon.IsDeteriorable() )
	{
        dmgMin -= int( dmgMin * ( GetDeteriorationProcent( attack.RealWeapon ) * 0.01f ) );
        dmgMax -= int( dmgMax * ( GetDeteriorationProcent( attack.RealWeapon ) * 0.01f ) );
    }

	if( validAttacker )
	{
		inform( attacker, target, "DMin = " + dmgMin + ", DMax = " + dmgMax );
	}
	
    for( uint i = 0; i < rounds; i++ )
	{
        rawDmg = Random( dmgMin, dmgMax );
		// Boxing gloves modifier
		if( validWeapon && FLAG( weaponPerk, WEAPON_PERK_NON_LETHAL ) )
		{
			rawDmg /= 2;
		}

		if( validAttacker )
		{
			inform( attacker, target, "raw= " + rawDmg );
		}

		rawDmg -= targetDT;
        rawDmg -= rawDmg * targetDR / 100;
		
		// Shotgun modifier
		if( FLAG( ammoPerk, AMMO_PERK_SPREADSHOT ) )
		{
			rawDmg /= SHOTGUN_PELLETS;
		}
		
        if( rawDmg > 0 )
		{
            totalDmg += rawDmg;
		}
    }

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
	{
        isCritical = false;
    }
	
	if( totalDmg <= targetDT )
	{
		isCritical = false;
	}
	
	if( isCritical || attack.ForceFlags != 0 )
	{
        if( isCritical )
		{
            int aim_ = aim;
            if( aim_ == HIT_LOCATION_NONE )
			{
                aim_ = HIT_LOCATION_UNCALLED;
			}
            aim_--;
            
            int MaxRoll = 100;
            int roll = Random( 1, MaxRoll );
			int crit_level = 0;
			
			if( validAttacker && attacker.Trait[ TRAIT_SADIST ] > 0 ) // TRAIT_SADIST
			{
				roll += 15;
			}
			
            if( roll <= 15 )
			{
                crit_level = 0;
            }
			else if( roll <= 39 )
			{
                crit_level = 1;
            }
			else if( roll <= 69 )
			{
                crit_level = 2;
            }
			else if( roll <= 94 )
			{
                crit_level = 3;
            }
			else
			{
				crit_level = 4;
			}
			
            uint offset = aim_ * ROLL_MAX_STAGE * 7 + crit_level * 7;

			if( validAttacker && attacker.Trait[ TRAIT_FINESSE ] == 0 )
			{
				critDmgMod = CriticalTable[ offset ];
			}

            eff = CriticalTable[ offset + 1 ];

            int  stat = CriticalTable[ offset + 2 ];
            int  statMod = CriticalTable[ offset + 3 ];

            uint cMessage = CriticalTable[ offset + 5 ];
			
            uint cFailureMessage = CriticalTable[ offset + 6 ];

            extraMessage = cMessage;

            string info = "";
			if( stat != -1 )
			{
				int stat_roll = Random( 1, 10 );
				info = "For stat #" + stat + " '|0xFFFF00 " + GetGameMsgStr( 100001 + stat * 10 ) + "|0x00FF00 ' [" + target.Stat[ stat ] + "] with mod [" + statMod + "].";
				info += "\nStat roll [" + stat_roll + "], it's ";
				
				switch( aim )
				{
					case( HIT_LOCATION_LEFT_ARM ):
					{
						if( target.Param[ DAMAGE_LEFT_ARM ] != 0 )
						{
							statMod -= 2;
						}
						break;
					}
					case( HIT_LOCATION_RIGHT_ARM ):
					{
						if( target.Param[ DAMAGE_RIGHT_ARM ] != 0 )
						{
							statMod -= 2;
						}
						break;
					}
					case( HIT_LOCATION_RIGHT_LEG ):
					{
						if( target.Param[ DAMAGE_RIGHT_LEG ] != 0 )
						{
							statMod -= 2;
						}
						break;
					}
					case( HIT_LOCATION_LEFT_LEG ):
					{
						if( target.Param[ DAMAGE_LEFT_LEG ] != 0 )
						{
							statMod -= 2;
						}
						break;
					}
					default:
						break;
				}
				
                if( stat_roll > target.Stat[ stat ] + statMod )
				{
                    eff |= CriticalTable[ offset + 4 ];
                    extraMessage = cFailureMessage;
					
					info += "|0xFF6600 FAILED.";
                }
				else
				{
					info += "|0xAAFF00 PASSED.";
				}
			}						

            if( FLAG( weaponPerk, WEAPON_PERK_ENHANCED_KNOCKOUT ) )
			{
                SETFLAG( eff, HF_KNOCKOUT );
				info += "\n Weapon gave knockout!";
			}

            if( target.Mode[ MODE_NO_KNOCK ] != 0 )
			{
                UNSETFLAG( eff, HF_KNOCKDOWN );
				info += "\n Target could not be knocked down!";
			}
        }
		// Small creatures instant death
		if( isCritical )
		{
			if( target.CrType == CRTYPE_RAT || target.CrType == CRTYPE_MANTI || target.CrType == CRTYPE_RAT_PIGRAT || target.CrType == CRTYPE_GIANT_WASP || target.CrType == CRTYPE_GIANT_BEETLE ||
				target.CrType == CRTYPE_DOG_SMALL || target.CrType == CRTYPE_ALIEN_EGG || target.CrType == CRTYPE_GIANT_ANT_BROWN_L || target.CrType == CRTYPE_GIANT_ANT_BROWN || 
				target.CrType == CRTYPE_GIANT_ANT_GREEN || target.CrType == CRTYPE_GIANT_ANT_RED || target.CrType == CRTYPE_RADSCORPION_SMALL || target.CrType == CRTYPE_SPIDER )
			{
				eff |= HF_DEATH;
			}
		}
		
        if( attack.ForceFlags != 0 )
		{
            eff |= attack.ForceFlags;
            isCritical = true;
        }

        // in the following: in no lose limbs, then clear the effects and set msgEff
        // otherwise set msgEff first, then check for HF_RANDOM
        if( target.Mode[ MODE_NO_LOOSE_LIMBS ] != 0 )
		{
            UNSETFLAG( eff, ( HF_CRIPPLED_LEFT_LEG | HF_CRIPPLED_RIGHT_LEG | HF_CRIPPLED_LEFT_ARM | HF_CRIPPLED_RIGHT_ARM | HF_RANDOM ) );
            msgEff = eff;
        }
		else
		{
            msgEff = eff;
            if( FLAG( eff, HF_RANDOM ) )
			{
                UNSETFLAG( eff, HF_RANDOM );
                switch( Random( 1, 4 ) )
                {
					case( 1 ):
						SETFLAG( eff, HF_CRIPPLED_LEFT_LEG );
						break;
					case( 2 ):
						SETFLAG( eff, HF_CRIPPLED_RIGHT_LEG );
						break;
					case( 3 ):
						SETFLAG( eff, HF_CRIPPLED_LEFT_ARM );
						break;
					case( 4 ):
						SETFLAG( eff, HF_CRIPPLED_RIGHT_ARM );
						break;
					default:
						break;
                }
            }
        }
        if( target.Mode[ MODE_NO_DROP ] != 0 )
		{
            UNSETFLAG( eff, HF_DROPPED_WEAPON );
            UNSETFLAG( msgEff, HF_DROPPED_WEAPON );
        }
    }

    if( FLAG( weaponPerk, WEAPON_PERK_ENHANCED_KNOCKOUT ) )
	{
        if( validAttacker )
		{
            if( Random( 1, 100 ) <= ( attacker.Stat[ ST_STRENGTH ] ) - 8 )
			{
				SETFLAG( eff, HF_KNOCKOUT );
			}
		}
    }

	if( isCritical )
	{
		totalDmg = totalDmg * critDmgMod / 100;
		
		if( validAttacker )
		{
			inform( attacker, target, "critDmgMod = " + critDmgMod );
		}
	}

	if( validAttacker )
	{
		inform( attacker, target, "total= "+ totalDmg );
	}
	
    if( validAttacker && valid( target ) )
	{
        if( aim == HIT_LOCATION_HEAD )
		{
            totalDmg += totalDmg * CheckHelmet( target );
		}
		else if( aim == HIT_LOCATION_EYES )
		{
        	totalDmg += totalDmg * CheckHelmet( target );
			CheckGlasses( target );
        }
		else if( aim == HIT_LOCATION_GROIN )
		{
        	totalDmg += totalDmg * 0.1;
        }
		else if( aim == HIT_LOCATION_LEFT_ARM || aim == HIT_LOCATION_RIGHT_ARM || aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG )
		{
			totalDmg -= totalDmg * 0.25;
        }
		
        if( targetIsPlayer )
		{
			if( !attacker.IsNpc() && !target.IsNpc() )
			{
				if( attacker.Param[ ST_LEVEL ] < 2 )
				{
					totalDmg *= 0.5;
				}
				
				if( attacker.Param[ ST_LEVEL ] > 1 && target.Param[ ST_LEVEL ] < 2 )
				{
					totalDmg *= 2;
				}
			}
				
			//Bullet Wound
			if( attack.WeaponType != WS_MELEE && dmgType == DAMAGE_NORMAL && validAmmo && target.StatBase[ ST_BODY_TYPE ] != BT_ROBOT 
				&& Random( 0, 1 ) == 0 && ( totalDmg >= ( 0.25 * target.Stat[ ST_CURRENT_HP ] ) ) && !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) )
			{
				ChangeStatus( target, CR_STATUS_BULLET_OVER, 0, true );
				if( !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
				{
					ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, true );
				}
				FlushScreen( target, COLOR_RED, 0, 5000 );
			}
			
			//Heavy Wound
			if( Random( 0, 1 ) == 0 && ( totalDmg >= target.Stat[ ST_CURRENT_HP ] * 30 / 100 ) && target.StatBase[ ST_BODY_TYPE ] != BT_ROBOT 
			    && !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
			{
				ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, true );
				FlushScreen( target, COLOR_RED, 0, 5000 );
			}
			
			inform( attacker, target, "aftertotal= "+ totalDmg );
		}
	}
	// code for dropping weapon, adapted from critical failures
	bool droppedWeapon = FLAG( eff, HF_DROPPED_WEAPON );
	if( droppedWeapon )
	{
		Item@ realWeaponTarget = _CritGetItemHand( target );
		if( valid( realWeaponTarget ) )
		{
			if( realWeaponTarget.IsStackable() )
			{
				Item@ dropped = map.AddItem( target.HexX, target.HexY, realWeaponTarget.GetProtoId(), 1 );
				if( realWeaponTarget.GetCount() > 1 )
				{
					realWeaponTarget.SetCount( realWeaponTarget.GetCount() - 1 );
				}
				else
				{
					DeleteItem( realWeaponTarget );
				}
			}
			else
			{
				MoveItem( realWeaponTarget, 0, map, target.HexX, target.HexY );
			}
		}
    }

    bool isKo = false;
    bool knockDown = false;
    bool knockOut = false;
    bool isDead = false;
    bool isBelow = false;
    int  knockDmg = int( totalDmg );

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
	{
        eff = 0;
	}
	// Dazed
	if( FLAG( eff, HF_DAZED ) )
	{
		target.ParamBase[ CR_DAZED ] += DAZED_DURATION;
		
		uint[] index;
		if( target.GetTimeEvents( CTE_DAZED, index, null, null ) > 0 )
		{
			target.ChangeTimeEvent( index[0], REAL_SECOND( 0 ), 0 );
		}
		else
		{
			target.AddTimeEvent( "cte_Dazed", REAL_SECOND( 0 ), CTE_DAZED, 0 );
		}
	}
	// Stunned
	if( FLAG( eff, HF_STUNNED ) )
	{
		target.ParamBase[ CR_STUNNED ] += STUNNED_DURATION;
		
		uint[] index;
		if( target.GetTimeEvents( CTE_STUNNED, index, null, null ) > 0 )
		{
			target.ChangeTimeEvent( index[0], REAL_SECOND( 0 ), 0 );
		}
		else
		{
			target.AddTimeEvent( "cte_Stunned", REAL_SECOND( 0 ), CTE_STUNNED, 0 );
		}
	}
    // Knock down
    if( FLAG( eff, HF_KNOCKDOWN ) )
	{
        isKo = true;
        knockDown = true;
    }
	else if( dmgType == DAMAGE_EXPLODE && totalDmg > 9 )
	{
        isKo = true;
	}
    // Clipped LLeg
    if( FLAG( eff, HF_CRIPPLED_LEFT_LEG ) )
	{
        target.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
		SayLog( target, crInfo( target ) + " breaks left leg." );
		FlushScreen( target, COLOR_RED, 0, 5000 );
	}
    // Clipped RLeg
    if( FLAG( eff, HF_CRIPPLED_RIGHT_LEG ) )
	{
        target.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
		SayLog( target, crInfo( target ) + " breaks right leg." );
		FlushScreen( target, COLOR_RED, 0, 5000 );
	}
    // Clipped LArm
    if( FLAG( eff, HF_CRIPPLED_LEFT_ARM ) )
	{
        target.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
		SayLog( target, crInfo( target ) + " breaks left arm." );
		FlushScreen( target, COLOR_RED, 0, 5000 );
	}
    // Clipped RArm
    if( FLAG( eff, HF_CRIPPLED_RIGHT_ARM ) )
	{
        target.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
		SayLog( target, crInfo( target ) + " breaks right arm." );
		FlushScreen( target, COLOR_RED, 0, 5000 );
	}
    // Blinded
    if( FLAG( eff, HF_BLINDED ) )
	{
        target.DamageBase[ DAMAGE_EYE ] = 1;
		SayLog( target, crInfo( target ) + " blinded by attack." );
		FlushScreen( target, COLOR_RED, 0, 5000 );
	}
    // all legs clipped, can't move
    uint8 noMove = target.DamageBase[ DAMAGE_LEFT_LEG ] > 0 && target.DamageBase[ DAMAGE_RIGHT_LEG ] > 0 ? 1 : 0;
    if( target.IsPlayer() )
	{ 
		target.ModeBase[ MODE_NO_WALK ] = noMove;
		target.ModeBase[ MODE_NO_RUN ] = noMove;
	}
    // Knock out
    if( FLAG( eff, HF_KNOCKOUT ) )
	{
        isKo = true;
        knockOut = true;
    }

    // Instant death
    if( FLAG( eff, HF_DEATH ) )
	{
        if( target.Stat[ ST_CURRENT_HP ] > int( totalDmg ) )
		{
            target.StatBase[ ST_CURRENT_HP ] = -666;
			isDead = true;
			FlushScreen( target, COLOR_RED, 0, 5000 );
		}
	}
	
	//CAUSE DAMAGE
	bool bloodyAttack = isBloodyMess;
    if( int( totalDmg ) > 0 )
	{
        if( target.Mode[ MODE_INVULNERABLE ] == 0 )
		{
			target.StatBase[ ST_CURRENT_HP ] -= int( totalDmg );
			if( target.Stat[ ST_CURRENT_HP ] < 1 )
			{
				bloodyAttack = bloodyAttack || target.TraitBase[ TRAIT_BLOODY_MESS ] == 1;
				bloodyAttack = bloodyAttack && !FLAG( weaponPerk, WEAPON_PERK_NON_LETHAL );
				if( validAmmo )
				{
					bloodyAttack = bloodyAttack && !FLAG( ammoPerk, AMMO_PERK_NON_LETHAL );
				}	
				
				if( target.StatBase[ ST_CURRENT_HP ] <= getDeathHitPoints( target ) )
				{
					isDead = true;
				}
				
                if( target.Mode[ MODE_NO_KNOCK ] == 0 )
				{
                    isKo = true;
                    isBelow = true;
                }
            }
			
			ChangeCritterSpeed( target );
        }
    }

    bool attackFront = true;
    uint dir = GetDirection( attack.Hx, attack.Hy, target.HexX, target.HexY );
    if( dir == target.Dir || ( ( dir + 1 ) % 6 ) == target.Dir || ( ( dir + 5 ) % 6 ) == target.Dir )
	{
		target.StatBase[ST_VAR7] = 1;
        attackFront = false;
	}
	
    Item@ armor = _CritGetItemArmor( target );
    if( valid( armor ) )
	{
		if( int( totalDmg ) > 0 )
		{
			int armorDT = target.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];
			int armorDmg = int( totalDmg - armorDT );
			int mod_mul = 1;
			int mod_div = 1;
			if( armorDmg > 0 )
			{
				if( validWeapon )
				{
					if( FLAG( weaponPerk, WEAPON_PERK_CORROSIVE ) || ( validAmmo && FLAG( ammoPerk, AMMO_PERK_CORROSIVE ) ) )
					{
						mod_mul += 2;
					}
					
					if( FLAG( weaponPerk, WEAPON_PERK_ARMORBANE ) )
					{
						mod_mul += 4;
					}
				}
				
				DeteriorateItem( target, armor, ( armorDmg * mod_mul / mod_div ) );
				if( armor.Deterioration >= MAX_DETERIORATION )
				{
					armor.Deterioration == MAX_DETERIORATION;
					SETFLAG( armor.BrokenFlags, BI_BROKEN );
					armor.Update();
				}
			}
		}
	}
	
	//Critter knockOut
	if( isKo )
	{
        int maxAp = target.Stat[ ST_ACTION_POINTS ];
        int targetAp = 0;
		
        if( knockOut )
		{
            targetAp = Random( maxAp, maxAp * 2 );
		}
		
        if( knockDown )
		{
            targetAp = 200;
		}
		
		if( target.Trait[ TRAIT_SURE_FOOTED ] > 0 )
		{
			targetAp *= 2;
		}
		
        if( ( isBelow || knockOut || knockDown || dmgType == DAMAGE_EXPLODE ) && !target.IsKnockout() && !target.IsDead() && target.Mode[ MODE_NO_KNOCK ] == 0 )
		{
            int knockDist = knockDmg;
            if( ( dmgType == DAMAGE_EXPLODE || isHthAttack ) && target.IsCanWalk() )
			{
                if( FLAG( weaponPerk, WEAPON_PERK_KNOCKBACK ) )
				{
                    knockDist /= 5;
                }
				else
				{
                    knockDist /= 10;
                }
				
				knockDist--;
				
                if( knockDist > 10 )
				{
                    knockDist = 10;
				}
				
                uint16 knockHx = attack.Hx;
                uint16 knockHy = attack.Hy;
                if( knockDist > 0 )
				{
                    RustyGetHexCoordWall( map, target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist );
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), targetAp, knockHx, knockHy );
                } 
			}
			else
			{
				target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), targetAp, target.HexX, target.HexY );
			}
		}
		
		target.Wait( GetActionTime( ACTION_KNOCKOUT, target ) );
		target.ParamBase[ CR_IS_WINDUPED ] = 0;
		target.ParamBase[ CR_IS_RELAXING ] = 0;
		target.ParamBase[ CR_IS_RELOADING ] = 0;
		target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
		target.ParamBase[ CR_SNEAKING ] = 0;
    }
	
	//Critter death
	bool fatalDeath = false;
    if( isDead )
	{
        bool burst = attack.IsBurst;
        uint anim2Dead = 0;
		uint8 death_stage = 0;
		
		if( attackFront )
		{
			anim2Dead = ANIM2_DEAD_FRONT;
		}
		else
		{
			anim2Dead = ANIM2_DEAD_BACK;
		}
		
		if( isCritical || ( bloodyAttack && target.IsNpc() ) )
		{
			switch( dmgType )
			{
				case( DAMAGE_UNCALLED ): 
					break;
				case( DAMAGE_NORMAL ):
				{
					if( burst )
					{
						anim2Dead = ANIM2_DEAD_BLOODY_BURST;
						death_stage = 100;
					}
					else
					{
						anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
						death_stage = 50;
					}
					break;
				}
				case( DAMAGE_LASER ):
					anim2Dead = ANIM2_DEAD_LASER;
					death_stage = 50;	
					break;
				case( DAMAGE_FIRE ):
					anim2Dead = ANIM2_DEAD_BURN_RUN;
					death_stage = 100;
					break;
				case( DAMAGE_PLASMA ):
					anim2Dead = ANIM2_DEAD_FUSED;
					death_stage = 100;
					break;
				case( DAMAGE_ELECTR ):
				{
					if( Random( 0, 3 ) == 0 )
					{
						anim2Dead = ANIM2_DEAD_PULSE_DUST;
					}
					else
					{
						anim2Dead = ANIM2_DEAD_PULSE;
					}
					death_stage = 100;
					break;
				}
				case( DAMAGE_EXPLODE ):
					anim2Dead = ANIM2_DEAD_EXPLODE;
					death_stage = 100;
					break;
				default:
					anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
					death_stage = 1;
					break;
			}
		}
		else
		{
			switch( dmgType )
			{
				case( DAMAGE_NORMAL ):
				{
					if( isBurst )
					{
						anim2Dead = ANIM2_DEAD_BURST;
						death_stage = 1;
					}
					break;
				}
				case( DAMAGE_FIRE ):
				case( DAMAGE_ELECTR ):
					anim2Dead = ANIM2_DEAD_BURN;
					death_stage = 1;
					break;
			}
		}
		
		if( ( anim2Dead == ANIM2_DEAD_FRONT || anim2Dead == ANIM2_DEAD_BACK || anim2Dead == 0 ) && target.IsKnockout() )
		{
			if( target.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
			{
				anim2Dead = ANIM2_DEAD_PRONE_FRONT;
			}
			else
			{
				anim2Dead = ANIM2_DEAD_PRONE_BACK;
			}
		}

        if( validAttacker )
		{
			target.StatBase[ ST_KILLER_PERSON ] = attacker.Id;
			CrimeLog( target, crInfo( target ) + " was killed by " + crInfo( attacker, true ) + "." );
			
			if( target.IsPlayer() )
			{
				Log_Killings( attacker, target.Id, 0, 0, null, null );
			}
			
			if( attackerIsPlayer )
			{
				attacker.KillBase[ KILL_BEGIN + target.Stat[ ST_BODY_TYPE ] ]++;
			}
        }

		if( validAttacker && valid( target ) && attackerIsPlayer && !targetIsPlayer )
		{
			attacker.StatBase[ST_EXPERIENCE] += target.Stat[ST_KILL_EXPERIENCE];
		}
		
		Item@ hand = _CritGetItemHand( target );
		if( valid( hand ) )
		{
			target.MoveItem( hand.Id, hand.GetCount(), SLOT_INV );
		}
		
		Item@ handExt = _CritGetItemHandExt( target );
		if( valid( handExt ) )
		{
			target.MoveItem( handExt.Id, handExt.GetCount(), SLOT_INV );
		}
		
		target.ToDead( anim2Dead, validAttacker ? attacker : null );
		target.ParamBase[ CR_DEATH_STAGE ] = death_stage;
	}
	
   	string attack_info;
	if( !valid( attacker ) )
	{
		attack_info = itemName( attack.WeaponPid );
	}
	else
	{
		attack_info = crInfo( attacker );
	}
	
	string[] aim_names = { "whole", "head", "left arm", "right arm", "chest", "left leg", "right legó", "eyes", "abdomen", "body" };
	attack_info += " causes " + int( totalDmg ) + " damage " + crInfo( target, true ) + ( isBelow ? "[at -HP]" : "" ) + " in " + aim_names[aim] +
		( attackFront ? " frontal" : " back" ) + ( isCritical ? " with crit" : "" ) + ( isKo ? ", dropping" : "" ) + ( knockOut ? " in KO" : "" ) +
		( knockDown ? " in Knockdown" : "" ) + ( droppedWeapon ? ", removing weapon from hands" : "" ) + ( isDead ? ", killing the target" : "" ) +
		( fatalDeath ? " permanently" : "" ) + ". From target " + target.Stat[ ST_CURRENT_HP ] + "/" + target.Stat[ ST_MAX_LIFE ] + " HP.";
	SayLog( valid( attacker ) ? attacker : target, attack_info );

    bool isAimed = ( aim != HIT_LOCATION_NONE ) && ( aim != HIT_LOCATION_TORSO ) && ( aim != HIT_LOCATION_UNCALLED );

    uint mainMsg = CMSG_HIT;
    uint length = 3;

    if( isCritical )
    {
        mainMsg += 2;
        length += 2;
    }
	
    if( isDead )
    {
        mainMsg += 4;
        if( isCritical )
		{
            length -= 1;
		}
	}
	
    if( isAimed )
    {
        mainMsg += 1;
        length += 1;
    }

    uint[] sendEff( length + 1 );
    sendEff[ 0 ] = mainMsg;
    sendEff[ 1 ] = target.Id;
    uint now = 2;

    if( isAimed )
    {
        sendEff[ 2 ] = aim;
        now++;
    }

    sendEff[ now ] = int( totalDmg );
    now++;

    if( isCritical )
    {
        if( !isDead )
        {
            sendEff[ now ] = msgEff;
            now++;
        }
		
        sendEff[ now ] = extraMessage;
    }
	
	sendEff.insertLast( validAttacker ? attacker.Id : target.Id );

    Critter@[] source = { target };
    Critter@[] crits;

    if( @target.GetMap() != null )
    {
        target.GetMap().GetCrittersSeeing( source, true, FIND_ALL | FIND_ONLY_PLAYERS, crits );

        for( int i = 0, j = crits.length(); i < j; i++ )
		{
            if( crits[ i ].Id != target.Id )
			{
                AddEff( crits[ i ], sendEff, results );
			}
		}
	}
	crits.resize(0);
	
    if( isCritical )
	{
        sendEff[ now ] = extraMessage;
	}
	
	AddEff( target, sendEff, results );

    // poisoning and irradiating:
    if( validAttacker )
    {
        if( attacker.Stat[ ST_TOXIC ] > 0 && int( totalDmg ) > 1 )
        {
			int poison = CLAMP( int( totalDmg ), 0, attacker.Stat[ ST_TOXIC ] );
			AffectPoison( target, poison );
        }
		
		if( attacker.Stat[ ST_RADIOACTIVE ] > 0 && int( totalDmg ) > 1 )
        {
			int radiation =CLAMP( int( totalDmg ), 0, attacker.Stat[ ST_RADIOACTIVE ] );
			AffectRadiation( target, radiation );
		}
	}

    if( validAmmo && validAttacker && FLAG( ammoPerk, AMMO_PERK_POISONED ) )
	{
        AffectPoison( target, int( totalDmg * 30 / 100 ) );
    }
	
	if( validWeapon && FLAG( weaponPerk, WEAPON_PERK_POISONED ) )
	{
        AffectPoison( target, int( totalDmg * 30 / 100 ) );
	}
	
    if( validAmmo && validAttacker && FLAG( ammoPerk, AMMO_PERK_NEUROTOXIN ) )
	{
        AffectParalysis( target, 50 );
	}
	
	//Check for blood
	bool canBleed = true;
    if( IsRobot( target ) || target.Stat[ ST_BODY_TYPE ] == BT_PLANT || IsInsect( target ) || target.Mode[ MODE_INVULNERABLE ] != 0 )
    { 
        canBleed = false;
    }
    
    if( ( totalDmg > 5 ) && canBleed )
    {
        if( Random( 0, 9 ) == 0 && target.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0 )
        {
            target.EraseTimeEvents( CTE_SLOWRELOAD );
        }
        
        if( Random( 0, 1 ) == 0 && target.GetTimeEvents( CTE_HEAL, null, null, null ) > 0 )
        {
            target.EraseTimeEvents( CTE_HEAL );
        }
        
        if( ( ( dmgType == DAMAGE_NORMAL || dmgType == DAMAGE_UNCALLED ) && totalDmg >= target.Param[ ST_NORMAL_ABSORB ]  ) || ( dmgType == DAMAGE_EXPLODE && totalDmg >= target.Param[ ST_EXPLODE_ABSORB ] ) )
        {
            if( ( validWeapon && ( weaponSubtype >= ITEM_SUBTYPE_WEAPON_NORMAL_BEGIN && weaponSubtype <= ITEM_SUBTYPE_WEAPON_NORMAL_END || weaponSubtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE 
			 || weaponSubtype == ITEM_SUBTYPE_WEAPON_GRENADE_FRAG || weaponSubtype >= ITEM_SUBTYPE_WEAPON_MELEE_BEGIN && weaponSubtype <= ITEM_SUBTYPE_WEAPON_MELEE_END ) ) 
             || ( valid( attacker ) && !IsHuman( attacker ) ) 
             || ( !valid( attacker ) ) )
            {
				int bleed_damage = IsHuman( target ) ? int( totalDmg / 2 ) : int( totalDmg / 4 );
				if( attack.WeaponPerk == WEAPON_PERK_SHRED || ( validAmmo && FLAG( ammoPerk, AMMO_PERK_SHRED ) ) )
				{
					bleed_damage *= 2;
				}
				
				if( validWeapon && FLAG( weaponPerk, WEAPON_PERK_NON_LETHAL ) || validAmmo && FLAG( ammoPerk, AMMO_PERK_NON_LETHAL ) )
				{
					bleed_damage /= 5;
				}
				
                BleedCritter( target, bleed_damage );
            }
        }
    }
	
	//Check for special weapon effects
    if( attack.WeaponPid == PID_SOUND_BLASTER && target.ParamBase[ MODE_NO_KNOCK ] <= 0  )
	{
        QuakeScreen2( target );
        if( ( Random( 12, 40 ) - target.Stat[ ST_LUCK ] ) > 10 && ( target.Timeout[ TO_STEALING ] <= int( REAL_MINUTE( 2 ) ) ) )
		{
            int8 roll = Random( 10, 100 ) - target.Stat[ ST_ENDURANCE ] * 10;
            if( roll > 0 )
			{
				if( !target.IsDead() )
				{
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), roll * 10, target.HexX, target.HexY );
					target.ParamBase[ CR_IS_WINDUPED ] = 0;
					target.ParamBase[ CR_IS_RELAXING ] = 0;
					target.ParamBase[ CR_IS_RELOADING ] = 0;
					target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
					target.ParamBase[ CR_SNEAKING ] = 0;
					SayLog( target, crInfo( target ) + " stunned by sonic weapon." );
				}
            }
        }
    }
	
    if( validAttacker && ( attack.WeaponPid == PID_LEG_ATTACK1 || attack.WeaponPid == PID_LEG_ATTACK2 || attack.WeaponPid == PID_LEG_ATTACK3 || attack.WeaponPid == 1032 ) &&
        ( aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG ) && ( target.Timeout[ TO_STEALING ] <= 0 ) )
    {
		int rate = target.Trait[ TRAIT_NERD ] > 0 ? 1 : 100;
        if( ( ( Random( 10, 30 ) - target.Stat[ ST_ENDURANCE ] - target.Stat[ ST_AGILITY ] ) > 0 ) && ( ( Random( 1, 200 ) + attacker.Skill[ SK_UNARMED ] - target.Skill[ SK_UNARMED ] ) >= rate ) &&
            ( target.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( attacker.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( !target.IsDead() || !target.IsKnockout() ) )
        {
            attacker.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_FOOT_SWEEP );
			SayLog( attacker, crInfo( attacker ) + " performs a foot sweep " + crInfo( target ) + "." );
								   
            int roll = Random( 10, 25 ) - target.Stat[ ST_ENDURANCE ];
            if( roll > 0 )
            {
				if( !target.IsDead() )
				{
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), roll * 10, target.HexX, target.HexY );
					target.ParamBase[ CR_IS_WINDUPED ] = 0;
					target.ParamBase[ CR_IS_RELAXING ] = 0;
					target.ParamBase[ CR_IS_RELOADING ] = 0;
					target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
					target.ParamBase[ CR_SNEAKING ] = 0;
					SayLog( target, crInfo( target ) + " falls from foot sweep." );
				}
				
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_SECOND( 10 );
            }
        }
    }
		
    if( attack.WeaponPid == PID_CATTLE_PROD && valid( attack.Ammo ) && attack.Ammo.ProtoId != PID_CUENCELL_LOW && ( target.Timeout[ TO_STEALING ] <= int( REAL_MINUTE( 2 ) ) ) )
    {
        QuakeScreen2( target );
        if( ( !target.IsDead() || !target.IsKnockout() ) && ( Random( 13, 30 ) - target.Stat[ ST_LUCK ] ) > 10 )
        {
            int8 roll = Random( 1, 15 ) - target.Stat[ ST_ENDURANCE ];
            if( roll > 0 )
            {
				if( !target.IsDead() )
				{
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), roll * 10, target.HexX, target.HexY );
					target.ParamBase[ CR_IS_WINDUPED ] = 0;
					target.ParamBase[ CR_IS_RELAXING ] = 0;
					target.ParamBase[ CR_IS_RELOADING ] = 0;
					target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
					target.ParamBase[ CR_SNEAKING ] = 0;
					SayLog( target, crInfo( target ) + " falls from stunner hit." );
				}
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 15 );
            }
        }
    }
	
	if( validAttacker && weaponSubtype == ITEM_SUBTYPE_WEAPON_MELEE_HAMMER && target.ParamBase[ MODE_NO_KNOCK ] <= 0 )
    {
        if( ( !target.IsDead() || !target.IsKnockout() ) && target.Timeout[ TO_STEALING ] <= int( REAL_MINUTE( 2 ) ) )
        {
            int dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
            int aimmod = 0;
            if( aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES )
			{
                aimmod = 60;
            }
			else if( aim == HIT_LOCATION_UNCALLED || aim == HIT_LOCATION_NONE || aim == HIT_LOCATION_TORSO )
			{
                aimmod = 40;
			}
			
			if( attacker.StatBase[ ST_STRENGTH ] >= 6 )
			{
                aimmod += 6 + attacker.StatBase[ ST_STRENGTH ] * 2;
			}

			int knock_AP = 150 - target.Stat[ ST_ENDURANCE ] * 4 - target.Stat[ ST_STRENGTH ] * 2;
			knock_AP -= Random( 0, ( target.Stat[ ST_LUCK ] - 5 ) * knock_AP / 10 );
			int knock_sec = ( knock_AP + 5 ) / 10;
			
            if( target.IsRuning && target.Stat[ ST_CURRENT_HP ] < Random( aimmod, int ( totalDmg * 4 ) + aimmod * 2 ) && dist >= 3 )
            {
				SayLog( target, crInfo( target ) + " drops from a trown sledge." );
				
				if( !target.IsDead() )
				{
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), knock_AP, target.HexX, target.HexY );
                }
				
				target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( knock_sec + 15 );
            }
            else if( target.Stat[ ST_CURRENT_HP ] < Random( aimmod,  int ( totalDmg * 2 ) + aimmod ) && dist >= 3 )
            {
				SayLog( target, crInfo( target ) + " drops from a trown sledge." );
				if( !target.IsDead() )
				{
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), knock_AP, target.HexX, target.HexY );
					target.ParamBase[ CR_IS_WINDUPED ] = 0;
					target.ParamBase[ CR_IS_RELAXING ] = 0;
					target.ParamBase[ CR_IS_RELOADING ] = 0;
					target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
					target.ParamBase[ CR_SNEAKING ] = 0;
				}
				
				target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( knock_sec + 10 );
            }
            else if( target.Stat[ ST_CURRENT_HP ] < Random( aimmod,  int ( totalDmg * 2 ) + aimmod ) && dist <= 2 )
            {
				if( target.Mode[ MODE_NO_WALK ] == 0 && target.Mode[ MODE_NO_PUSH ] == 0 )
				{					
					SayLog( target, crInfo( target ) + " drops from a blunt weapon." );
					target.SayMsg( SAY_EMOTE, TEXTMSG_GAME, STR_EMOTE_FALL_SLEDGE );
					if( !target.IsDead() )
					{
						target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), knock_AP, target.HexX, target.HexY );
						target.ParamBase[ CR_IS_WINDUPED ] = 0;
						target.ParamBase[ CR_IS_RELAXING ] = 0;
						target.ParamBase[ CR_IS_RELOADING ] = 0;
						target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
						target.ParamBase[ CR_SNEAKING ] = 0;
					}
					
					target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( knock_sec + 15 );
				}
            }
        }
    }
	
	//CRITTER ACTION FOR TAKING DAMAGE
	if( target.Timeout[ TO_DAMAGE ] == 0 && !target.IsKnockout() && totalDmg > target.Stat[ ST_CURRENT_HP ] / 20 )
	{ 
		target.Action( ACTION_DAMAGE_FORCE, int( attack.WeaponPid << 16 ) | ( attackFront ? 0 : 1 ), realWeapon );
		target.TimeoutBase[ TO_DAMAGE ] = DAMAGE_TIMEOUT;
	}		

	//HIT_EFFECTS_ON_TARGET - WIP. TODO: Move to effect manager module. Change to class
	if( validWeapon )
	{
		uint16 effectPid = 0;
		uint8 attackDir =  attackFront? 0 : 1;
		
		if( valid( armor ) && ( armor.Proto.Material != MATERIAL_FABRIC || armor.Proto.Material != MATERIAL_LEATHER ) )
		{
			SparkManager( attackDir, target, aim, armor, rounds );
		}
		else
		{
			BloodManager( map, attackDir, target, aim, rounds );
		}
	}
}

void SparkManager( uint8 attackDir, Critter& target, int aim, Item& armor, int rounds )
{
	if( !valid(target) )
	{
		return;
	}
	
	if( rounds <= 0 )
	{
		return;
	}
	
	bool isHeadshot = ( aim == HIT_LOCATION_HEAD ) || ( aim == HIT_LOCATION_EYES );
	uint8 targetDir = target.Dir; 
	int prevIdx = -1;

	for( int j = 0; j < rounds; j ++ )
	{
		if( !target.IsKnockout() && !target.IsDead() )
		{
			uint16 effectPid = 0;
			int i = -1;
			if( !isHeadshot )
			{
				if( attackDir == 0 )
				{
					switch( targetDir )
					{
						case( 0 ):
							i = 3;
							break;
						case( 1 ):
							i = 2;
							break;
						case( 2 ):
						case( 3 ):
							i = 0;
							break;
						case( 4 ):
							i = 1;
							break;
						case( 5 ):
							i = 3;
							break;
					}
				}
				else
				{
					switch( targetDir )
					{
						case( 0 ):
							i = 0;
							break;
						case( 1 ):
							i = 1;
							break;
						case( 2 ):
						case( 3 ):
							i = 3;
							break;
						case( 4 ):
							i = 2;
							break;
						case( 5 ):
							i = 0;
							break;
					}
				}
			}
			else
			{
				uint16 armorPid = armor.GetProtoId();
				ProtoItem@ armorProto = GetProtoItem( armorPid );
				if( armorProto.Material == MATERIAL_POLYMER || armorProto.Material == MATERIAL_COMPOSITE )
				{
					i = 4;
				}
				else
				{
					Log( "headshot effect placeholder" );
				}
			}
			
			if( i != -1 )
			{
				int len = Sparks[i].length();
				int idx = Random( 0, ( len - 1 ) );
				
				if( ( len > 1 ) && ( prevIdx == idx ) )
				{
					int rnd = Random( 1, ( len - 1 ) );
					idx = ( idx + rnd ) % len ;
				} 			
				
				prevIdx = idx;
				effectPid = Sparks[i][idx];

				uint[] values = { target.Id, effectPid };
				int baseTime = 250;
				int k = j + 1;
				baseTime *= k;
				CreateTimeEvent( AFTER( REAL_MS( baseTime ) ), "combat@e_HitEffectVFX", values, false );
			}
		}
	}
}

void BloodManager( Map& map, uint8 attackDir, Critter& target, int aim, int rounds )
{
	if( !valid(target) )
	{
		return;
	}
	
	if( rounds <= 0 )
	{
		return;
	}
	
	int bodyType = target.Stat[ ST_BODY_TYPE ];
	uint8 targetDir = target.Dir; 

	for( int j = 0; j < rounds; j ++ )
	{
		uint16 effectPid = 0;
		if( !target.IsKnockout() && !target.IsDead() )
		{
			switch( bodyType ) 
			{
				case( BT_MEN ):
				case( BT_WOMEN ):
				case( BT_CHILDREN ):
				case( BT_BRAHMIN ):
					effectPid = PID_TARGET_BLOOD_NORM;
					break;
				case( BT_RAT ):
				case( BT_MANTI ):
				case( BT_DOG ):
				case( BT_GIANT_ANT ):
					effectPid = PID_TARGET_BLOOD;
					break;
				case( BT_GECKO ):
				case( BT_FLOATER ):
				case( BT_SUPER_MUTANT ):
				case( BT_GHOUL ):
				case( BT_CENTAUR ):
				case( BT_DEATHCLAW ):
				case( BT_ALIEN ):
					effectPid = PID_TARGET_BLOOD_DARK;
					break;
			}
		}
		else
		{
			effectPid = PID_TARGET_BLOOD;
		}
		
		if( effectPid == 0 )
		{
			return;
		}
		
		uint[] values = { target.Id, effectPid };
		int baseTime = 250;
		int k = j + 1;
		baseTime *= k;
		CreateTimeEvent( AFTER( REAL_MS( baseTime ) ), "combat@e_HitEffectVFX", values, false );
	}
}

uint e_HitEffectVFX( uint[]@ values )
{
	Critter@ target = GetCritter( values[0] );
	if( !valid(target) )
	{
		return 0;
	}
	
	Map@ map = target.GetMap();

	uint16 effectPid = values[1];
	
	map.RunEffect( effectPid, target.HexX, target.HexY, 0 );
	//Log( "drawing hit effect: " + effectPid );
	
	return 0;
}

void CommenceExplosion( AttackStruct& attack, Map@ map, uint16 hx, uint16 hy, uint16 tx, uint16 ty, Critter@ target, uint weapPid, bool isCritical, uint intentionallyId, bool isRocket, bool isGrenade, CombatRes[]& results )
{
	if( !valid(map) )
	{
		return;
	}
	
	Critter@ attacker = attack.Attacker;
	
	if( isGrenade )
	{
		ProtoItem@ grenade = null;
		@grenade = GetProtoItem( weapPid );

		if( !valid( target ) )
		{
			if( !map.IsHexPassed( tx, ty ) )
			{
				map.SetTextMsg( tx, ty, COLOR_LGRAY, TEXTMSG_GAME, STR_MAPMSG_RICOCHET );
				uint8 revDir = GetDirection( tx, ty, hx, hy );
				map.MoveHexByDir( tx, ty, revDir, Random( 1, 2 ) );
			}
		}
		
		int delay = REAL_SECOND( 3 );
		
		if( weapPid == PID_MOLOTOV_COCKTAIL || weapPid == PID_GRNMLTV )
		{
			delay = REAL_MS( 100 );
		}
		uint[] vals = { tx, ty, map.Id, weapPid, attacker.Id, 0 };
		CreateTimeEvent( __FullSecond + delay, "combat@e_DelayedExplosion", vals, true );
		
		uint distanceMod = GetDistantion( attack.Hx, attack.Hy, tx, ty ); 
		distanceMod = distanceMod * 10; // modify to match fly effect
		
		uint[] val = { map.Id, tx, ty, delay, weapPid };
		CreateTimeEvent( AFTER( REAL_MS( distanceMod ) ), "combat@e_SpawnGrenade", val, true );
		
		Item@ grenadeItm = _CritGetItemHand( attacker );
		_SubItem( grenadeItm, 1 );
		ArmThrownWeapon( attacker, weapPid, grenadeItm.Mode ); 
		grenadeItm.Update();
	}
	else if( isRocket )
	{
		uint distanceMod = GetDistantion( attack.Hx, attack.Hy, tx, ty );
		if( attack.Ammo.ProtoId == PID_40MM_HE )  // modify to match fly effect
		{
			distanceMod = distanceMod * 22;
		}
		else
		{
			distanceMod = distanceMod * 10; 
		}

		if( valid( target ) )
		{
			uint16 zx = tx, zy = ty;
			uint8 revDir = GetDirection( attack.Hx, attack.Hy, hx, hy );
			map.MoveHexByDir( zx, zy, revDir, 1 );
			if( CheckCover( map, zx, zy, target ) > 0 )
			{
				tx = zx;
				ty = zy;
				map.SetText( tx, ty, COLOR_LGRAY, ":cover hit:" );
			}
		}
		
		uint[] vals = { tx, ty, map.Id, weapPid, attacker.Id, attack.Ammo.ProtoId };
		CreateTimeEvent( AFTER( REAL_MS( distanceMod ) ), "combat@e_DelayedExplosion", vals, true );
	}
}

void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId, uint hitLocation, bool isCritical )
{
    if( dmgType > DAMAGE_EXPLODE )
    {
        Log( "Invalid damage type." );
        return;
    }

	Critter@ attacker = attackerId > 0 ? GetCritter( attackerId ) : cr;
	
    AttackStruct attack;
    @attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( valid( map ) )
	{
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );
	}
	
    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = hitLocation;
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = -1;
    attack.WeaponType = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DrMod = 0;
    attack.TargetId = cr.Id;
    attack.ShowHitAnimForce = true;

	if( attackerId < 0 )
	{
		attack.WeaponPid = -attackerId;
	}
	
    CombatRes[] results;
    ApplyDamage( attack, cr, 1, isCritical, true, results );

    FlushResults( results );
}

int FindCritterInArray( Critter@[]& crits, Critter& cr )
{
    for( uint i = 0, j = crits.length(); i < j; i++ )
	{
        if( crits[ i ].Id == cr.Id )
		{
            return i;
		}
	}
    return -1;
}

int attack_ap( Critter& cr, ProtoItem@ weapon, uint8 mode )
{
	mode = mode % 64;
	
	if( pow( 2, mode ) > int( weapon.Weapon_ActiveUses ) ) 
	{
		return 0;
	}
	
	int needAP = _WeaponApCost( weapon, mode );

	if( _WeaponModeAim( mode ) == HIT_LOCATION_NONE && _WeaponAim( weapon, mode & 0x0F ) )
	{
		mode = ( mode & 0x0F ) + ( cr.ParamBase[ CR_AUTO_AIM ] << 4 );
		
		if( cr.ParamBase[ CR_AUTO_AIM ] != HIT_LOCATION_NONE )
		{
			needAP = needAP * 120 / 100;
		}
	}
	
	int skillNum = _WeaponSkill( weapon, mode );
	uint8 weaponType = ( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
    bool isUnarmed = weapon.Weapon_IsUnarmed;
    bool isHthAttack = ( weaponType == WS_MELEE || weaponType == WS_UNARMED );
	if( cr.Trait[ TRAIT_FAST_SHOT ] != 0 && !isHthAttack )
	{
		needAP = needAP * FAST_SHOT_AP_MUL / 100;
	}
	
	if( cr.Trait[ TRAIT_SADIST ] != 0 )
	{
		needAP = needAP * ONE_HANDER_AP_MUL / 100;
	}
	
	return needAP;
}

void NotifyOops( Critter& cr, Critter@ t1, Critter@ t2, CombatRes[]& results )
{
    if( @t2 == null )
    {
        uint[] allEff = { CMSG_HIT_RANDOMLY, cr.Id };
        Critter@[] him = { cr };
        Critter@[] crits;
        cr.GetMap().GetCrittersSeeing( him, true, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, crits );
        for( int i = 0, j = crits.length(); i < j; i++ )
		{
            AddEff( crits[ i ], allEff, results );
		}
		
		crits.resize( 0 );
	}
    else if(@t1 != null)
    {
        uint[] allEff = { CMSG_OOPS, t1.Id, t2.Id };
        Critter@[] them = { t1, t2 };
        Critter@[] crits;
        t1.GetMap().GetCrittersSeeing( them, true, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, crits );
        for( int i = 0, j = crits.length(); i < j; i++ )
		{
            AddEff( crits[ i ], allEff, results );
		}
		
		crits.resize( 0 );
	}
	
    return;
}

void NotifyMiss( Critter@ cr, CombatRes[]& results )
{
    uint[] allEff = { CMSG_MISS, cr.Id };
    Critter@[] him = { cr };
    Critter@[] crits;
    cr.GetMap().GetCrittersSeeing( him, true, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, crits );
    for( int i = 0, j = crits.length(); i < j; i++ )
	{
        AddEff( crits[ i ], allEff, results );
	}
	
	crits.resize( 0 );
    return;
}

uint8 RandomAim()
{
	int roll = Random ( 0, 18 );
	if( roll <= 7  )
	{
		return HIT_LOCATION_TORSO;
	}
	else if( roll <= 9  )
	{
		return HIT_LOCATION_RIGHT_ARM;
	}
	else if( roll <= 11 )
	{
		return HIT_LOCATION_LEFT_ARM;
	}
	else if( roll <= 13 )
	{
		return HIT_LOCATION_RIGHT_LEG;
	}
	else if( roll <= 15 )
	{
		return HIT_LOCATION_LEFT_LEG;
	}
	else if( roll <= 17 )
	{
		return HIT_LOCATION_HEAD;
	}
	else
	{
		return HIT_LOCATION_GROIN;
	}
}

uint8 RandomHit()
{
	int roll = Random ( 1, 100 );
	if( roll == 1  )
	{
		return HIT_LOCATION_EYES;
	}
	else if( roll <= 5  )
	{
		return HIT_LOCATION_HEAD;
	}
	else if( roll <= 15  )
	{
		return HIT_LOCATION_LEFT_ARM;
	}
	else if( roll <= 25  )
	{
		return HIT_LOCATION_RIGHT_ARM;
	}
	else if( roll <= 35  )
	{
		return HIT_LOCATION_LEFT_LEG;
	}
	else if( roll <= 45  )
	{
		return HIT_LOCATION_RIGHT_LEG;
	}
	else if( roll <= 60  )
	{
		return HIT_LOCATION_GROIN;
	}
	else
	{
		return HIT_LOCATION_TORSO;
	}
}

bool ThrowNets( Critter& cr, Critter& target, int weapon )
{
	if( !valid( target ) )
	{
		return false;
	}
	
	switch( weapon )
	{
		case( PID_REV_BALL1 ):
			return CheckEvasion( cr, target, 3 );
		case( PID_REV_BALL2 ):
			return CheckEvasion( cr, target, 6 );
		default:
			return false;
	}
	return false;
}

bool CheckEvasion( Critter& cr, Critter& target, int power )
{
	if( !valid( target ) )
	{
		return false;
	}
	
	cr.SayMsg( SAY_EMOTE, TEXTMSG_GAME, STR_EMOTE_THROW_NET );
	SayLog( cr, crInfo( cr ) + " Throws net." );	

	Item@ net = _CritGetItemHand( cr );
	if( valid( net ) )
	{
		MoveItem( net, 1, cr.GetMap(), target.HexX, target.HexY );
		ArmThrownWeapon( cr, net.GetProtoId(), net.Mode );
	}
	
	if( GetDistantion( cr.HexX, cr.HexY, target.HexX, target.HexY ) < 4 )
	{
		target.SayMsg( SAY_EMOTE, TEXTMSG_GAME, STR_EMOTE_DODGE );
		//target.Wait( 500 );
		target.Action( ACTION_DODGE, Random( 0, 1 ), null );
		SayLog( target, crInfo( target ) + " Dodges." );
		return false;
	}
	
	float chance = 100 * ( cr.SkillBase[ SK_THROWING ] / 300.0 + ( target.IsRuning ? 0.2 : 0 ) );
	bool isHolded = chance >= Random( 1, 100 );
	
	if( !isHolded )
	{
		target.SayMsg( SAY_EMOTE, TEXTMSG_GAME, STR_EMOTE_RELEASES );
		target.Action( ACTION_DODGE, Random( 0, 1 ), null );
		SayLog( target, crInfo( target ) + " Gets released." );
		return false;
	}

	HookHoldAttack( target, power );
	
	uint line;
	switch( target.Stat[ ST_GENDER ] )
	{
		case( 0 ): 
			line = STR_COMBAT_ENTANGLED_MALE;
			break;
		case( 1 ): 
			line = STR_COMBAT_ENTANGLED_FEMALE;
			break;
		default: 
			line = STR_COMBAT_ENTANGLED_IT;
			break;
	}
	target.SayMsg( SAY_EMOTE, TEXTMSG_GAME, line );
	SayLog( target, crInfo( target ) + " " + "entangled" + "." );	
	target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( power * 5 );

	return true;
}

string HF_Info( uint flags )
{
	uint[] flag_effects =
	{
		HF_KNOCKOUT, HF_KNOCKDOWN, HF_CRIPPLED_LEFT_LEG, HF_CRIPPLED_RIGHT_LEG, HF_CRIPPLED_LEFT_ARM, HF_CRIPPLED_RIGHT_ARM, 
		HF_BLINDED, HF_DEATH, HF_DAZED, HF_BYPASS_ARMOR, HF_DROPPED_WEAPON, HF_STUNNED, HF_RANDOM,
	};
	
	string[] flag_names =
	{
		"Knockout", "Knockdown", "Left Legshot", "Right Legshot", "Left armshot", "Right armshot",
		"Blinded", "Died", "Burned alive", "Armor bypass", "Dropped weapon", "Lost turn", "Hit random",
	};
	
	if( flag_effects.length() != flag_names.length() )
	{
		Log( "Êòî-òî íàïîðòà÷èë ñ äëèííîé ìàññèâîâ ýôôåêòîâ[" + flag_effects.length() + "] è èõ èì¸í[" + flag_names.length() + "]." );
		return "[error]";
	}
	
	string result = "";
	for( int i = 0, l = flag_names.length(); i < l; i++ )
	{
		if( FLAG( flags, flag_effects[i] ) )
		{
			if( result.length() == 0 )
			{
				result = flag_names[i];
			}
			else
			{
				result += ", " + flag_names[i];
			}
		}
	}
	return result;
}

string MF_Info( uint flags )
{
	uint[] flag_effects = {
		MF_KNOCKED_DOWN, MF_ON_FIRE, MF_WEAPON_EXPLODED, MF_WEAPON_DESTROYED, MF_WEAPON_DROPPED, MF_LOST_NEXT_TURN, 
		MF_HIT_SELF, MF_LOST_REST_OF_AMMO, MF_FIRED_DUD_SHOT, MF_HURT_SELF, MF_HIT_RANDOMLY, MF_CRIPPLED_RANDOM_LIMB, MF_WAS_KILLED,
	};
	
	string[] flag_names = {
		"Knocked down", "Burned self", "Weapon blasted", "Weapon broken", "Weapon dropped", "Lost turn", 
		"Hit self",	"Lost ammo", "Dud shot", "Hurt self", "Hit randomly", "Crippled", "Killed",
	};
	
	if( flag_effects.length() != flag_names.length() )
	{
		Log( "Êòî-òî íàïîðòà÷èë ñ äëèííîé ìàññèâîâ ýôôåêòîâ è èõ èì¸í." );
		return "[error]";
	}
	
	string result = "";
	for( int i = 0, l = flag_names.length(); i < l; i++ )
		if( FLAG( flags, flag_effects[i] ) )
		{
			if( result.length() == 0 )
				result = flag_names[i];
			else
				result += ", " + flag_names[i];
		}
	
	return result;
}

// Check for spent casing at hex
bool check_casing( Map& map, uint16 x, uint16 y )
{
    Item@[] casings;
    uint count = map.GetItems ( x, y, casings );
    for ( uint j = 0; j < count; j++ )
	{
        if( casings[j].GetProtoId() == PID_SHELL_CASING )
        {
            uint amount = casings[j].GetCount() + 1;
			casings[j].SetCount( amount );
			ShellAmountChanger( casings[j], amount ); // critter_item_movement
            return true;
        }
	}
    return false;
}

uint e_CollateralDamageDelay( uint[]@ values )
{
	Map@ map = GetMap( values[0] );
	uint16 tx = values[1];
	uint16 ty = values[2];
	uint16 dmg = values[3];
	CollateralDamage( map, tx, ty, dmg );
	return 0;
}

// Collateral damage hex attack
void CollateralDamage( Map& map, uint16 tx, uint16 ty, uint dmgType = DAMAGE_LASER )
{
	if( dmgType == DAMAGE_LASER || dmgType == DAMAGE_PLASMA || dmgType == DAMAGE_EXPLODE || dmgType == DAMAGE_FIRE )
	{
		Item@[] heated;
		map.GetItems( tx, ty, heated );
		Item@ burningItem = null;
		for( uint i = 0, len = heated.length(); i < len; i++ )
		{
			@ burningItem = heated[i];
			if( valid( burningItem ) )
			{
				if( FireUp( burningItem, _GetOneRandom( WildFires ), 1 ) )
				{
					break;
				}
			}
		}
		heated.resize(0);
	}
	
	Item@[] glass_targets;
	map.GetItems( tx, ty, glass_targets );
	Item@ glass_target = null;
	for( uint i = 0, j = glass_targets.length(); i < j; i++ ) 
	{
		@ glass_target = glass_targets[i];
		if( valid( glass_target ) && ( find_any_glass( glass_target ) != 0 || glass_target.Proto.Material == MATERIAL_GLASS ) )
		{
			if( find_any_glass( glass_target ) != 0 )
			{
				if( Random( 1, 2 ) == 2 )
				{
					map.AddItem( tx, ty, PID_ROSETTE, 1 );
				}
			}
			
			PlayGenericSound( map, tx, ty, _GetOneRandom( glass_break_sounds ), 30 );
			DeleteItem( glass_targets[i] );
			@glass_targets[i] = null;
		}
	}
	
	glass_targets.resize(0);
}

uint e_SpawnGrenade( uint[]@ values )
{
	Map@ map = GetMap( values[0] );
	if( !valid( map ) )
	{
		return 0;
	}
	
	uint16 tx = values[1];
	uint16 ty = values[2];
	int delay = values[3];
	int pid = values[4];
	uint16 grenadeDummyPid = 0;
	
	switch( pid )
	{
		case( PID_FRAG_GRENADE ): 		
			grenadeDummyPid = PID_DUMMY_GRENADE_FRAG;
			break;
		case( PID_PLASMA_GRENADE ):
			grenadeDummyPid = PID_DUMMY_GRENADE_PLASMA;
			break;
		case( PID_PULSE_GRENADE ):
			grenadeDummyPid = PID_DUMMY_GRENADE_PULSE;		
			break;
		default:
			grenadeDummyPid = PID_DUMMY_GRENADE_FRAG;		
			break;
	}
	
	if( grenadeDummyPid != 0 )
	{
		Item@ grenadeVFX = map.AddItem( tx, ty, grenadeDummyPid, 1 );
		uint[] vals = { grenadeVFX.Id };
		CreateTimeEvent( __FullSecond + delay, "combat@e_DeleteGrenade", vals, true );
	}
	return 0;
}

uint e_DeleteGrenade( uint[]@ values )
{
	Item@ grenadeVFX = GetItem( values[0] );
	if( valid( grenadeVFX ) )
	{
		DeleteItem( grenadeVFX );
	}
	
	return 0;
}

void AttackSound( Critter& cr, ProtoItem& weapon, uint8 weaponMode )
{
	int radius = weapon.Weapon_HearRadius;
	uint8 use = _WeaponModeUse( weaponMode );
	Item@ realWeapon = _CritGetItemHand( cr );
	if( valid( realWeapon) )
	{
		if( use == 2 )  //for weapons with extra firing mode, since 2 is reload by default.
		{
			use++;
		}
		
		if( radius == 0 )
		{
			radius = 3;
		}
		Critter@[] players;
		int hx = cr.HexX, hy = cr.HexY;
		cr.GetMap().GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
		int[] values = { weapon.ProtoId, use, radius };
		for( uint i = 0; i < players.length(); i++ )
		{
			Critter@ player = players[i];
			if( valid( player ) )
			{
				player.RunClientScript( "fofmod@__PlayWeaponSound", cr.Id, hx, hy, "LAUGHTE1.mp3", values );
			}
		}
		
		players.resize(0);
	}
}

//hook attacks
// create Melee hook
void HookMeleeAttack( Critter& cr, Critter@ target )
{
    if( !valid( target ) || target.IsDead() || target.Mode[MODE_NO_PUSH] != 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
		return;
	}
	
	Map@ map = cr.GetMap();
	uint crit = cr.Id;

	Item @ Hook = map.GetItem( target.HexX, target.HexY, PID_MELEE_HOOK );
	if( !valid( Hook ) )
	{
		@ Hook = map.AddItem( target.HexX, target.HexY, PID_MELEE_HOOK, 1 );
		Hook.Val1 = int( crit );
		Hook.Val2 = 0;
		Hook.Val3 = 0;
		SETFLAG( Hook.Flags, ITEM_TRAP );
		Hook.SetScript( "_HookMeleeInit" );
	}
	else if( Hook.Val1 != int( crit ) )
	{
		Hook.Val1 = int( crit );
		Hook.Val2 = 0;
		Hook.Val3 = 0;
		Hook.SetScript( "_HookMeleeInit" );
	}

	Item @ Hook2 = map.GetItem( cr.HexX, cr.HexY, PID_MELEE_HOOK );
	if( !valid( Hook2 ) )
	{
		@ Hook2 = map.AddItem( cr.HexX, cr.HexY, PID_MELEE_HOOK, 1 );
		Hook2.Val1 = target.Id;
		Hook2.Val2 = 1;
		SETFLAG( Hook2.Flags, ITEM_TRAP );
		Hook2.SetScript( "_HookMeleeInit" );
	}
	else if( Hook2.Val1 != int( target.Id ) )
	{
		Hook2.Val1 = target.Id;
		Hook2.Val2 = 1;
		Hook2.SetScript( "_HookMeleeInit" );
	}
}

void _HookMeleeInit( Item& item, bool firstTime )
{
    if( item.GetProtoId() == PID_MELEE_HOOK )
	{
        item.SetEvent( ITEM_EVENT_WALK, "_HookMelee" );
	}
}

void _HookMelee( Item& Hook, Critter& cr, bool entered, uint8 dir )
{
    if( entered )
	{
		return;
	}
	
	Critter@ Hooker = GetCritter( Hook.Val1 );
	if( !valid( Hooker ) )
	{
		DeleteItem( Hook );
		return;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
	Item @ Hook1 = map.GetItem( Hooker.HexX, Hooker.HexY, PID_MELEE_HOOK );
	if( !valid( Hook1 ) )
	{
		DeleteItem( Hook );
		return;
	}

	if( cr.GetMapId() != Hooker.GetMapId() || Hooker.IsDead() || Hook1.Val1 != int( cr.Id ) )
	{
		DeleteItem( Hook ); 
		return;
	}

	if( Hook.Val2 != 0 )
	{
		if( Hooker.Stat[ ST_CURRENT_HP ] > 0 || cr.IsRuning )
		{
			DeleteItem( Hook );
			DeleteItem( Hook1 );
			return;
		}
		else 
		{
			uint16 HookHx = Hook.HexX;
			uint16 HookHy = Hook.HexY;

			MoveItem( Hook, Hook.GetCount(), map, cr.HexX, cr.HexY );
			if( cr.Timeout[ TO_SK_LOCKPICK ] > 0 )
			{
				return;
			}
			
			cr.TimeoutBase[ TO_SK_LOCKPICK ] = __FullSecond + REAL_SECOND( 1 );
			
			uint8  revDir;
			revDir = dir + 3;
			if( revDir > 5 )
			{
				revDir = revDir - 6;
			}
			
			map.MoveHexByDir( HookHx, HookHy, revDir, 1 );
			Hooker.TransitToHex(HookHx, HookHy, dir);
			MoveItem( Hook1, Hook1.GetCount(), map, Hooker.HexX, Hooker.HexY );
			return;
		}
	}

	
	int chance = Random( 0, 40 ) +
		( cr.Stat[ ST_CURRENT_HP ] - Hooker.Stat[ ST_CURRENT_HP ] ) / 2 + 
		( ( cr.Stat[ ST_STRENGTH ] * 4 ) - ( Hooker.Stat[ ST_STRENGTH ] * 4 ) ) + 
		( ( cr.Skill[ SK_UNARMED ] * 80 / 100 ) - ( Hooker.Skill[ SK_UNARMED ] * 80 / 100 ) ) / 2 + 
		( ( cr.Stat[ ST_LUCK ] * 2 ) - ( Hooker.Stat[ ST_LUCK ] * 2 ) ) * 2;
		
	chance = Hooker.Trait[ TRAIT_NERD ] > 0 ? 1 : CLAMP( chance, 1, 95 );

	if( chance >= Random( 1, 100 ) )
	{
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_FREE_FROM_GRAPPLE );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_FREE_FROM_GRAPPLE );
	}
	else
	{
		uint16 HookHx = cr.HexX;
		uint16 HookHy = cr.HexY;
		
		uint8  revDir;
		Hook.Val3 +=10;
		revDir = dir + 3;
		if( revDir > 5 )
		{
			revDir = revDir - 6;
		}
		
		map.MoveHexByDir( HookHx, HookHy, revDir, 1 );
		cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), 200, HookHx, HookHy );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_FAILED_FREE_FROM_GRAPPLE );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_FAILED_FREE_FROM_GRAPPLE );
		Hooker.SayMsg( SAY_EMOTE, TEXTMSG_GAME, STR_EMOTE_HOLD_GRAPPLE );
	}
	DeleteItem( Hook );
	DeleteItem( Hook1 );
}

// create Hold hook
void HookHoldAttack( Critter@ target, uint8 hardness )
{
    if( valid( target ) && !target.IsDead() )
    {
        Map@ map = target.GetMap();
        Item@ Hook = map.GetItem( target.HexX, target.HexY, PID_HOLD_HOOK );
        if( !valid( Hook ) )
        {
            @ Hook = map.AddItem( target.HexX, target.HexY, PID_HOLD_HOOK, 1 );
            Hook.Val1 = target.Id;
            Hook.Val5 = hardness;
            SETFLAG( Hook.Flags, ITEM_TRAP );
            Hook.SetScript( "_HookHoldInit" );
        }
		
		if( valid( Hook ) && Hook.Val1 != int( target.Id ) )
		{
            Hook.Val1 = target.Id;
            Hook.Val5 = hardness;
            Hook.SetScript( "_HookHoldInit" );
        }
    }
}

void _HookHoldInit( Item& item, bool firstTime )
{
    if( item.GetProtoId() == PID_HOLD_HOOK )
	{
        item.SetEvent( ITEM_EVENT_WALK, "_HookHold" );
	}
}

void _HookHold( Item& Hook, Critter& cr, bool entered, uint8 dir )
{
    if( !entered )
    {
        Map@ map = cr.GetMap();
        if( valid( Hook ) && Hook.Val1 == int( cr.Id ) )
        {
            if( ( cr.Stat[ ST_STRENGTH ] + cr.Stat[ ST_AGILITY ] + cr.Stat[ ST_ENDURANCE ] + cr.Stat[ ST_LUCK ] < Random( 5, 35 ) + 10 * Hook.Val5 ) )
            { 
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_CANT_BREAK_FREE );
                if( cr.IsPlayer() )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_CANT_BREAK_FREE );
                }
				uint16 HookHx = cr.HexX;
                uint16 HookHy = cr.HexY;
                uint8  revDir;
                revDir = dir + 3;
                if( revDir > 5 )
				{
                    revDir = revDir - 6;
                }
				
				map.MoveHexByDir( HookHx, HookHy, revDir, 1 );
                if( cr.IsPlayer() )
				{
					cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), 25, HookHx, HookHy );
				}
				else
				{
					cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), 50, HookHx, HookHy );
				}
				
				cr.Wait( 500 );
				
                if( Hook.Val5 > 0 )
				{
                    Hook.Val5 -= Random( 0, cr.Stat[ ST_STRENGTH ] / 3 );
				}
			}
            else
            {
                DeleteItem( Hook );
				cr.Wait( 500 );
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_GAME, STR_EMOTE_BREAK_FREE );
				if( cr.IsPlayer() )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BREAK_FREE );
				}
			}
        }
        else
		{
            DeleteItem( Hook );
		}
	}
}

uint e_DelayedAttack( uint[]@ values )
{
	if( !valid( values ) || values.length() != 9 )
	{
		return 0;
	}

	Critter@ attacker = GetCritter( values[0] );
	Critter@ target = GetCritter( values[1] );
	bool validTarget = valid( target );
	ProtoItem@ weapon = GetProtoItem( values[2] );
	uint8 weaponMode = values[3];
	ProtoItem@ ammo = GetProtoItem( values[4] );
	uint hexX = validTarget ? target.HexX : values[5];
	uint hexY = validTarget ? target.HexY : values[6];
	uint hexAttack = values[7];
	bool recursive = values[8] > 0;
	/*
	Log( "attacker.Id " + attacker.Id );
	Log( "target.Id " + ( validTarget ? target.Id : 0 ) );
	Log( "weapon.ProtoId " + weapon.ProtoId );
	Log( "weaponMode " + weaponMode );
	Log( "ammo.ProtoId " + ( valid( ammo ) ? ammo.ProtoId : 0 ) );
	Log( "hexX " + hexX );
	Log( "hexY " + hexY );
	Log( "hexAttack " + hexAttack );
	Log( "recursive " + recursive ); */
	
	if( !valid( attacker ) )
	{
		return 0;
	}
	
	if( !valid( weapon ) )
	{
		return 0;
	}
	
	if( !validTarget && ( hexX == 0 && hexY == 0 ) )
	{
		attacker.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
		return 0;
	}

	Item@ realWeapon = _CritGetItemHand( attacker );
	if( valid( realWeapon ) )
	{
		if( realWeapon.GetProtoId() != weapon.ProtoId )
		{
			attacker.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			return 0;
		}
		
		if( ( weapon.Weapon_MaxAmmoCount != 0 && realWeapon.AmmoCount == 0 ) || realWeapon.Deterioration == 10000 )
		{
			WeaponMissfire( attacker, weapon );
			return 0;
		}
		
		if( realWeapon.IsDeteriorable() )
		{
			//Low-tech ammo check
			if( valid( ammo ) )
			{
				float chance = realWeapon.Deterioration * 0.01f * 0.05f;
				if( chance >= Random( 1, 100 ) )
				{
					WeaponMissfire( attacker, weapon );
					return 0;
				}

				if( FLAG( ammo.Ammo_Perk, AMMO_PERK_UNRELIABLE ) )
				{
					if( Random( 0, 99 ) < AMMO_MISFIRE_CHANCE )
					{
						WeaponMissfire( attacker, weapon );
						return 0;
					}
				}		
			}
			
			//Low-tech gun check
			if( FLAG( weapon.Weapon_Perk, WEAPON_PERK_UNRELIABLE ) )
			{
				if( Random( 0, 99 ) < WEAPON_MISSFIRE_CHANCE )
				{
					WeaponMissfire( attacker, weapon );
					return 0;
				}			
			}
		}

		uint distance = GetDistantion( attacker.HexX, attacker.HexY, hexX, hexY );
		if( GetAttackDistantion( attacker, realWeapon, weaponMode ) >= distance )
		{
			Map@ map = attacker.GetMap();
			if( validTarget )
			{
				LineTrace_IsRaked lineTrace;
				bool isRakedLine = lineTrace.CheckLine( map, attacker.HexX, attacker.HexY, target.HexX, target.HexY );
				
				if( !isRakedLine )
				{
					@target = null;
					hexX = lineTrace.LastHexX;
					hexY = lineTrace.LastHexY;
				}
			}
		}
		
		if( ( _WeaponAnim2( weapon, weaponMode ) == ANIM2_BURST && recursive ) )
		{
			attacker.ParamBase[ CR_AUTO_ROUNDS_FIRED ] ++;
		}

		realWeapon.ROUNDS_FIRED ++;
		realWeapon.Update();

		CombatAttack( attacker, target, weapon, weaponMode, ammo, hexX, hexY, recursive, false );
		attacker.Wait( GetProtoTime( weapon, weaponMode, attacker ) );
	}

	return 0;
}

void WeaponMissfire( Critter& attacker, ProtoItem& weapon )
{
	missfireSFX( attacker, weapon );
	attacker.ParamBase[ CR_IS_WINDUPED ] = 1;
	if( attacker.GetTimeEvents( CTE_WINDUP, null, null, null ) == 0 )
	{
		attacker.AddTimeEvent( "windup@cte_windup", 0, CTE_WINDUP, 0 );
	}
	
	attacker.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_COMBAT_WEAPON_MISSFIRE );
	SayLog( attacker, crInfo( attacker ) + " had a weapon jam." );
	
	attacker.ParamBase[ CR_AUTO_ROUNDS_FIRED ] = 0;
}

class LineTrace_IsRaked : ITraceContext
{
	LineTrace_IsRaked()
    {
        LastHexX = 0;
        LastHexY = 0;
    }
    
    bool CheckLine( Map& map, uint16 hexX, uint16 hexY, uint16 targetHexX, uint16 targetHexY, uint distantion = 0 )
    {
        if( distantion == 0 )
		{
            distantion = GetDistantion( hexX, hexY, targetHexX, targetHexY );
        }
		
		return LineTracerHex( hexX, hexY, targetHexX, targetHexY, map, distantion, this ) == distantion;
    }

    bool Exec( Map& map, uint16 hexX, uint16 hexY ) override
    {
        LastHexX = hexX;
        LastHexY = hexY;
        return !map.IsHexRaked(hexX, hexY);
    }
    
    uint16 LastHexX;
    uint16 LastHexY;
}

//Missile, grenade explosion
uint e_DelayedExplosionEff( uint[]@ values )
{
	Map @map = GetMap( values[0] );
	if( !valid(map) )
	{
		return 0;
	}

	map.RunEffect( PID_EFFECT_SHRAPNELL, values[2], values[3], 0 );
	map.RunEffect( values[1], values[2], values[3], 0 );
	Item@ flashVFX = map.AddItem( values[2], values[3], PID_FLASH_NORM, 1 );
	if( valid( flashVFX ) )
	{
		uint[] val = { flashVFX.Id };
		CreateTimeEvent( AFTER( REAL_MS( 200 ) ), "combat@e_flashOff", val, false );
	}
	return 0;
}

uint e_DelayedExplosion( uint[]@ values )
{
	int hx = values[0];
	int hy = values[1];
	
	if( hx == 0 && hy == 0 )
	{
		return 0;
	}
	
	Map@ map = GetMap( values[2] );
	if( !valid( map ) )
	{
		return 0;
	}

	int weapPid = values[3];
	ProtoItem@ weapon = GetProtoItem( weapPid );
	if( !valid( weapon ) )
	{
		return 0;
	}

	AttackStruct attack;
	uint attackerId = values[4];
	Critter@ attacker = GetCritter( attackerId );
	@attack.Attacker = valid( attacker ) ? attacker : null;
	
	uint8 radius = weapon.Blast_Radius;
	
	ProtoItem@ ammo = GetProtoItem( values[5] );
	if( valid( ammo ) )
	{
		radius = ammo.Blast_Radius;
        attack.DrMod = ammo.Ammo_DrMod;
    }

	attack.WeaponPid = weapon.ProtoId;
    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = HIT_LOCATION_NONE;
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = weapon.Weapon_Perk;
    attack.WeaponType = 0;
    attack.DmgMin = valid( ammo ) ? ammo.Ammo_DmgMin : weapon.Weapon_DmgMin_0; //0 mode for now 
	int DmgMin = attack.DmgMin;
    attack.DmgMax = valid( ammo ) ? ammo.Ammo_DmgMax : weapon.Weapon_DmgMax_0; //0 mode for now
	int DmgMax = attack.DmgMax;
    attack.DmgType = weapon.Weapon_DmgType_0;
    attack.ShowHitAnimForce = true;
	attack.MinDmgMod = 100;
	attack.MaxDmgMod = 100;
	attack.CritDmgMod = 100;
	bool isCritical = false;
	
	CombatRes[] results;

	int type = 0;
	string sound = "LAUGHTE1.mp3";
	int hearRadius = 50;

	switch( weapPid )
	{
		case( PID_SMOKE_GRENADE ):
			type = PID_FLASH_NORM;
			hearRadius = 30;
			sound = "Smoke_Grenade_sound.mp3";
			break;
		case( PID_FLASH_GRENADE ): 
			type = PID_FLASH_NORM;
			hearRadius = 50;
			sound = "Flashbang_explode.mp3";
			break;
		case( PID_HOLY_HAND_GRENADE ):
		case( PID_IMPOVISED_TRAP_ACTIVE ):
		case( PID_FRAG_GRENADE ):	
			type = PID_EXPLODE_FIRE_SMALL;
			hearRadius = 140;
			sound = "Grenade_explode.wav";
			break;
		case( PID_GRNMLTV ):
		case( PID_MOLOTOV_COCKTAIL ): 	
			type = PID_EXPLODE_FIRE_BIG;
			hearRadius = 50;
			sound = "Fire_explode.mp3";
			break;
		case( PID_PIROZ_GRENADE ):
			type = PID_EXPLODE_ORB;
			hearRadius = 100;
			sound = "Piroz_explode.mp3";
			break;
		case( PID_PULSE_GRENADE ):
		case( PID_IMPOVISED_TRAP_PULSE_ACTIVE ):
		case( PID_ACTIVE_MINE_PULSE ):
			type = PID_EXPLODE_EMP;
			hearRadius = 80;
			sound = "Pulse_explode.mp3";
			break;
		case( PID_PLASMA_GRENADE ):
		case( PID_IMPOVISED_TRAP_PLASMA_ACTIVE ): 
		case( PID_ACTIVE_MINE_PLASMA ):
			type = PID_EXPLODE_PLASMA; 
			hearRadius = 100;
			sound = "Plasma_explode.wav";
			break;
		default:
			type = PID_EXPLODE_FIRE_BIG;
			hearRadius = 160;
			sound = "Rocket_explode.wav";				
			break;
	}

	PlayGenericSound( map, hx, hy, sound, hearRadius );
	
    Critter@[] critsHit;
	map.GetCrittersHex( hx, hy, radius, FIND_LIFE_AND_KO, critsHit );
	if( weapPid == PID_MOLOTOV_COCKTAIL || weapPid == PID_GRNMLTV )
	{
		GenerateFire( map, hx, hy, radius, weapon.Fire_Strength, attackerId ); 
	}
	
	if( weapPid == PID_FLASH_GRENADE )
	{
		SayLog( map, "Flashbang.", hx, hy );
	}

	if( weapPid == PID_SMOKE_GRENADE )
	{
		GenerateSmoke( map, hx, hy, radius ); 
		SayLog( map, "Smoke.", hx, hy );
	}

	if( type > 0 )
	{
		uint[] vals = { map.Id, type, hx, hy };
		CreateTimeEvent( __FullSecond + 1, "combat@e_DelayedExplosionEff", vals, true );
		SayLog( map, "Explosion " + itemName( weapPid ) + ".", hx, hy );
	}

	Item@ trap = null;
	if( weapon.Type == ITEM_TYPE_TRAP )
	{
		@trap = map.GetItem( hx, hy, weapPid );
		if( !valid( trap ) )
		{
			@trap = _CritGetItemHand( attacker );
		}
	}
	
	//Initial blast
    for( uint k = 0; k < critsHit.length(); k++ )
	{
		QuakeScreen2( critsHit[ k ] );
		int distance = GetDistantion( hx, hy, critsHit[ k ].HexX, critsHit[ k ].HexY );
		
        if( weapPid == PID_FLASH_GRENADE )
		{
			Item@ head = _CritGetItemHead( critsHit[ k ] );
			if( valid( head ) && head.Proto.HeadItem_Perk == HEAD_PERK_FLASHBANG_PROTECTION )
			{
				continue;
			}
			
            uint8 DirToCrit = GetDirection( hx, hy, critsHit[ k ].HexX, critsHit[ k ].HexY );
            uint8 FlashDir, Near1, Near2;
            REVERSE_DIRECTION( FlashDir, DirToCrit );
            GET_NEAR_DIRECTION( FlashDir, Near1, Near2 );
            if( ( critsHit[ k ].IsKnockout() ) || ( distance != 0 ) && ( critsHit[ k ].Dir != FlashDir ) && ( critsHit[ k ].Dir != Near1 ) && ( critsHit[ k ].Dir != Near2 ) )
			{
				continue;
			}
			
			ApplyFlashEff( critsHit[ k ], distance );
			SayLog( critsHit[ k ], crInfo( critsHit[ k ] ) + " blinded by flashbang." );
			continue;
        }
		
		if( weapPid == PID_SMOKE_GRENADE )
		{
			continue;
		}
		
		int dir = GetDirection( hx, hy, critsHit[ k ].HexX, critsHit[ k ].HexY );
		
		attack.TargetId = critsHit[ k ].Id;
		
		if( valid( attacker ) )
		{
			isCritical = CritRoll( attacker.Stat[ ST_CRITICAL_CHANCE ], critsHit[ k ], map, attack.Hx, attack.Hy );
		}
		else if( weapon.Type == ITEM_TYPE_TRAP )
		{
			@attack.Attacker = critsHit[ k ];
			if( valid( trap ) )
			{
				isCritical = CritRoll( trap.TRAP_CRITICAL_CHANCE, critsHit[ k ], map, attack.Hx, attack.Hy );
			}
		}

		ApplyDamage( attack, critsHit[ k ], 1, isCritical, true, results, hx, hy );
		if( valid( attacker ) && attackerId > 0 )
		{
			if( critsHit[ k ].IsNpc() )
			{
				critsHit[ k ].EventAttacked( attack.Attacker );
			}
		}
	}

	//Srapnel damage
	if( weapPid != PID_MOLOTOV_COCKTAIL && weapPid != PID_GRNMLTV && weapPid != PID_FLASH_GRENADE && weapPid != PID_SMOKE_GRENADE )
	{
		Critter@[] critsHit2;
		map.GetCrittersHex( hx, hy, int( radius * 2.5 ), FIND_LIFE_AND_KO, critsHit2 );
		for( uint l = 0; l < critsHit2.length(); l++ )
		{
			if( FindCritterInArray( critsHit, critsHit2[ l ] ) != -1 )
			{
				continue;
			}
			
			int dir2 = GetDirection( hx, hy, critsHit2[ l ].HexX, critsHit2[ l ].HexY );
			float distance2 = ( GetDistantion( hx, hy, critsHit2[ l ].HexX, critsHit2[ l ].HexY ) - radius ) / ( radius * 1.5f );
			float mul = 1.0f - 0.7f * CLAMP( distance2, 0.0f, 1.0f );
			attack.DmgMin = int( DmgMin * mul );
			attack.DmgMax = int( DmgMax * mul );
			attack.DmgType = DAMAGE_NORMAL;
			attack.TargetId = critsHit2[ l ].Id;

			if( valid( attacker ) )
			{
				isCritical = CritRoll( attacker.Stat[ ST_CRITICAL_CHANCE ], critsHit2[ l ], map, attack.Hx, attack.Hy );
			}
			else if( weapon.Type == ITEM_TYPE_TRAP )
			{
				@attack.Attacker = critsHit2[ l ];
				if( valid( trap ) )
				{
					isCritical = CritRoll( trap.TRAP_CRITICAL_CHANCE, critsHit2[ l ], map, attack.Hx, attack.Hy );
				}
			}
			
			ApplyDamage( attack, critsHit2[ l ], 1, isCritical, true, results, hx, hy );
			if( valid( attack.Attacker ) && attackerId > 0 )
			{
				if( critsHit2[ l ].IsNpc() )
				{
					critsHit2[ l ].EventAttacked( attack.Attacker );
				}
			}
		}
	}
	
	if( valid( trap ) )
	{
		if( trap.GetCount() > 1 )
		{
			_SubItem( trap, 1 );
			trap.TRAP_OWNER = 0;
			trap.Update();
		}
		else
		{
			DeleteItem( trap );
		}
	}
	
	FlushResults( results );
	
	//Collateral damage
	if( weapPid != PID_FLASH_GRENADE && weapPid != PID_SMOKE_GRENADE && weapPid != PID_MOLOTOV_COCKTAIL && weapPid != PID_GRNMLTV )
	{
		uint[] val = { map.Id, hx, hy, DAMAGE_EXPLODE };
		CreateTimeEvent( __FullSecond + 2, "combat@e_CollateralDamageDelay", val, true );
		uint16 tx = hx, ty = hy;

		if( radius <= 1 )
		{
			CollateralAroundHex( map, tx, ty );
		}
		else
		{
			for( uint m = 0; m < 6; m++ )
			{
				for( uint n = 1; n <= radius; n++ )
				{
					tx = hx; ty = hy;
					map.MoveHexByDir( tx, ty, m, n );
					if( !map.IsHexPassed( tx, ty ) && !map.IsHexRaked( tx, ty ) )
					{
						break;
					}
					
					CollateralAroundHex( map, tx, ty );
				}
			}
		}
	}	

	return 0;
}

void CollateralAroundHex( Map& map, uint x, int y )
{
	for( uint m = 0; m < 6; m++ )
	{
		uint16 tx = x, ty = y;
		map.MoveHexByDir( tx, ty, m, 1 );
		if( !map.IsHexPassed( tx, ty ) && !map.IsHexRaked( tx, ty ) )
		{
			continue;
		}
		
		uint[] val2 = { map.Id, tx, ty, DAMAGE_EXPLODE };
		CreateTimeEvent( __FullSecond + 2, "combat@e_CollateralDamageDelay", val2, true );
	}
}

void missfireSFX( Critter& cr, ProtoItem& weapon )
{
	int radius = 5;
	Critter@[] players;
	int hx = cr.HexX, hy = cr.HexY;
	cr.GetMap().GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
	int[] values = { weapon.ProtoId, 4, radius };
	for( uint i = 0; i < players.length(); i++ )
	{
		Critter@ player = players[i];
		if( valid( player ) )
		{
			player.RunClientScript( "fofmod@__PlayWeaponSound", cr.Id, hx, hy, "LAUGHTE1.mp3", values );
		}
	}
	players.resize(0);
}		

uint e_DelayedAttackVFX( uint[]@ values )
{
	if( !valid( values ) || values.length() != 7 )
	{
		return 0;
	}

	Critter@ cr = GetCritter(values[0]);
	if( !valid( cr ) )
	{
		return 0;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return 0;
	}
	
	ProtoItem@ weapon = GetProtoItem(values[2]);
	if( !valid( weapon ) )
	{
		return 0;
	}
	
	uint8 weaponMode = values[3];
	
	uint skillNum = _WeaponSkill ( weapon, weaponMode );
	if( skillNum == SK_THROWING )
	{
		return 0;
	}

	int dmgType = DAMAGE_LASER;
	uint16 ammoRound = 1;
	uint16 ammoPid = 0;
	ProtoItem@ ammo = GetProtoItem( values[4] );
	
	if( valid( ammo ) )
	{
		ammoRound = _WeaponRound( weapon, _WeaponModeUse( weaponMode ) );
		ammoPid = ammo.ProtoId;
		dmgType = _WeaponDmgType( weapon, _WeaponModeUse( weaponMode ) );
	}
	
	uint hexX = values[5];
	uint hexY = values[6];

	uint16 effectPid = 0;
	Item@ flashVFX = null;
	uint16 flashPid = 0;

	switch( dmgType )
	{
		case( DAMAGE_NORMAL ):
		{	
			effectPid = PID_EXPLODE_BULLET_SINGLE;
			PlayGenericSound( map, hexX, hexY, _GetOneRandom( DirtHitNormSFX ), 10 );
			flashPid = PID_FLASH_NORM;
			break;
		}
		case( DAMAGE_LASER ):
		{
			if( ammoRound == 1 )
			{
				effectPid = PID_EXPLODE_LASER_SINGLE;
			}
			else if ( ammoRound == 2 )
			{
				effectPid = PID_EXPLODE_LASER_DOUBLE;
			}
			else
			{
				effectPid = PID_EXPLODE_LASER_BURST;
			}
			flashPid = PID_FLASH_RED;
			break;
		}
		case( DAMAGE_FIRE ):
		{
			if( FireAmmo.find( ammoPid ) != -1 )
			{
				if( ammoRound == 1 )
				{
					effectPid = PID_EXPLODE_BULLET_SINGLE;
					PlayGenericSound( map, hexX, hexY, _GetOneRandom( DirtHitNormSFX ), 10 );
				}
				else
				{
					effectPid = PID_EXPLODE_BULLET_BURST;
				}
			}
			flashPid = PID_FLASH_RED;
			break;
		}
		case( DAMAGE_PLASMA ):
		{
			if( ammoRound == 1 )
			{
				effectPid = PID_EXPLODE_PLASMA_SINGLE;
			}
			else if ( ammoRound == 2 )
			{
				effectPid = PID_EXPLODE_PLASMA_DOUBLE;
			}
			else
			{
				effectPid = PID_EXPLODE_PLASMA_BURST;
			}
			flashPid = PID_FLASH_GREEN;
			break;
		}
		case( DAMAGE_ELECTR ):
		{
			effectPid = PID_EXPLODE_EMP;
			flashPid = PID_FLASH_BLUE;
			break;
		}
		case( DAMAGE_EXPLODE ):
		{
			effectPid = 0;
			flashPid = 0;
			break;
		}
	}

	CollateralDamage( map, hexX, hexY, dmgType );
	
	if( effectPid != 0 )
	{
		map.RunEffect( effectPid, hexX, hexY, 0 );
	}

	return 0;
}

uint e_flashOff( uint[]@ val )
{
	Item@ flashVFX = GetItem( val[0] );
	if( valid( flashVFX ) )
	{
		DeleteItem( flashVFX );
	}
	
	return 0;
}

int CheckCover( Map& map, uint16 hexX, uint16 hexY, Critter& target )
{
	int dr_bonus = 0;
	
	if( target.Param[ CR_IS_RELAXING ] == 5 )
	{
		uint16 hx = hexX, hy = hexY;
		uint8 dir = GetDirection( target.HexX, target.HexY, hx, hy );
		int coverType = GET_COVER_TYPE( dir, target.Param[ CR_IN_COVER ] );
		switch( coverType )
		{
			case( 1 ):
				dr_bonus += 5;
				break;
			case( 2 ):
				dr_bonus += 10;
				break;
			case( 3 ):
				dr_bonus += 15;
				break;
			case( 4 ):
				dr_bonus += 20;
				break;
			default:
				dr_bonus = 0;
				break;
		}
	}
	
	return dr_bonus;
}

bool CritRoll( int critBase, Critter& target, Map& map, uint16 hexX, uint16 hexY )
{
	bool isCritical = false;
	
	int anticrit = 0;
	
	if( valid( map ) && ( hexX != 0 && hexY != 0 ) && valid( target ) )
	{
		int coverDT = CheckCover( map, hexX, hexY, target );
		if( coverDT > 0 )
		{
			anticrit += coverDT;
		}
	}
	
	Item@ armor = _CritGetItemArmor( target );
	if( valid ( armor ) )
	{
		uint8 armor_material = _GetItemMaterial( armor );
		switch( armor_material )
		{
			case( MATERIAL_LEATHER ):
				anticrit = 5;
				break;
			case( MATERIAL_ARMORED_LEATHER ):
				anticrit = 10;
				break;
			case( MATERIAL_METAL ):
				anticrit = 15;
				break;
			case( MATERIAL_POLYMER ):
				anticrit = 20;
				break;
			case( MATERIAL_COMPOSITE ):
				anticrit = 25;
				break;
			default:
				break;
		}
	}
	
	int critChance = critBase - anticrit;
	
	float roll = Random( 1, 100 );
	
	isCritical = critChance >= roll;
	
	return isCritical;
}

void ArmThrownWeapon( Critter& cr, uint16 pid, uint8 mode )
{
	Item@ thrown = cr.GetItem( pid, -1 );
	if( valid( thrown ) )
	{
		Item@ hand = _CritGetItemHand( cr );
		if( valid( hand ) )
		{
			if( hand.GetProtoId() == pid )
			{
				return;
			}
			
			cr.MoveItem( hand.Id, hand.GetCount(), SLOT_INV );
		}
		cr.MoveItem( thrown.Id, 1, SLOT_HAND1 );
		thrown.SetMode( mode );
		thrown.Update();
		return;
	}

	Item@ belt = _CritGetItemMisc( cr );
	if( !valid( belt ) )
	{
		return;
	}
	
	if( belt.GetProtoId() == PID_AMMO_BELT )
	{
		Item@[] beltItems;
		belt.GetItems( 0, beltItems );
		for( uint i = 0, len = beltItems.length(); i < len; i ++ )
		{
			if( beltItems[i].GetProtoId() == pid )
			{
				@ thrown = beltItems[i];
				break;
			}
		}

		if( valid( thrown ) )
		{
			MoveItem( thrown, 1, cr );
			cr.MoveItem( thrown.Id, 1, SLOT_HAND1 );
			thrown.SetMode( mode );
			thrown.Update();
		}
	}
}

void SpawnSpentCasing( Critter& cr, Map& map, Item& weapon, ProtoItem& ammo, int ammoRound, bool extraction )
{
	if( valid( ammo ) )
	{
		bool isLow = FLAG( ammo.Ammo_Perk, AMMO_PERK_UNRELIABLE );
		bool is12Cal = ammo.Ammo_Caliber == CALIBER_12_GAUGE;
		bool isCaseless = FLAG( ammo.Ammo_Perk, AMMO_PERK_CASELESS );
		
		for( int i = 0; i < ammoRound; i++ )
		{
			if( weapon.Proto.Item_Subtype >= ITEM_SUBTYPE_WEAPON_NORMAL_BEGIN && weapon.Proto.Item_Subtype <= ITEM_SUBTYPE_WEAPON_NORMAL_END 
				&& ( weapon.Proto.Item_Subtype != ITEM_SUBTYPE_WEAPON_NORMAL_REVOLVER || extraction ) && !isCaseless
				&& ( ( !isLow && Random( 1 , 100 ) < 80 ) || ( isLow && Random( 1, 100 ) > 80 ) ) )
			{
				
				uint shellX = cr.HexX + Random( -1, 1 );
				uint shellY = cr.HexY + Random( -1, 1 );
				
				if( ( shellX == cr.HexX && shellY == cr.HexY ) || map.IsHexPassed( shellX, shellY ) )
				{
					if( !check_casing( map, shellX, shellY ) )
					{
						map.AddItem( shellX, shellY, PID_SHELL_CASING, 1 );
					}
				}
				
				string shellSound = is12Cal ? "SpentGauge.ogg" : _GetOneRandom( SpentShellSFX );
				PlayGenericSound( map, shellX, shellY, shellSound, 10 );
			}
		}
	}
}

float CheckHelmet( Critter& cr )
{
	float bonusDamage = 0.25;
	Item@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		uint det = 0;
		if( head.IsDeteriorable() )
		{
			det = GetDeteriorationProcent( head );
			SetDeterioration( head, det + 1 );
		}
		
		switch( head.Proto.Material )
		{
			case( MATERIAL_LEATHER ):
				bonusDamage -= 0.05 * ( 100 - det ) / 100;
				break;
			case( MATERIAL_ARMORED_LEATHER ):
				bonusDamage -= 0.10 * ( 100 - det ) / 100;
				break;
			case( MATERIAL_METAL ):
				bonusDamage -= 0.15 * ( 100 - det ) / 100;
				break;
			case( MATERIAL_POLYMER ):
				bonusDamage -= 0.20 * ( 100 - det ) / 100;
				break;
			case( MATERIAL_COMPOSITE ):
				bonusDamage -= 0.25 * ( 100 - det ) / 100;
				break;
			default:
				break;
		}
	}
	
	return bonusDamage;
}

void CheckGlasses( Critter& cr )
{
	Item@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		if( head.Proto.Material == MATERIAL_GLASS )
		{
			if( Random( 1, 10 ) == 10 )
			{
				if( Random( 0, 100 ) > cr.Stat[ ST_LUCK ] * 2 )
				{
					_SubItem( head, 1 );
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_COMBAT_HEAD_ITM_SHATTERED );
					cr.ParamBase[ DAMAGE_EYE ] = 1;
					BleedCritter( cr, 30 );
				}
			}
		}
	}
}

uint cte_Dazed( Critter& cr, int identifier, uint& rate )
{
	cr.ParamBase[ CR_DAZED ] --;
	if( cr.Param[ CR_DAZED ] <= 0 )
	{
		return 0;
    }
	
    return REAL_SECOND( 1 );
}

uint cte_Stunned( Critter& cr, int identifier, uint& rate )
{
	cr.ParamBase[ CR_STUNNED ] --;
	if( cr.Param[ CR_STUNNED ] <= 0 )
	{
		return 0;
    }
	
    return REAL_SECOND( 1 );
}

void moveAimHexRandom( Critter& cr, Map& map, uint16& x, uint16& y, int alpha, int beta )
{
    uint base_dist = GetDistantion( cr.HexX, cr.HexY, x, y );
    int dist = base_dist + Random( -beta, beta );
    dist = CLAMP( dist, 0, 999 );
	float angle = Random( -alpha, alpha );
 
    RustyGetHexCoord( map, cr.HexX, cr.HexY, x, y, angle, dist );
}

#endif // COMBAT_MODULE

