// Author: Atom, cvet
// 21-08-2010 05:09
// vanilla

#include "_macros.fos"
#include "_npc_pids.fos"
#include "critical_table.fos"
#include "combat_msg.fos"
#include "npc_ai.fos"
#include "combat_h.fos"
#include "_colors.fos"
#include "wait_time_h.fos"

import void DeteriorateItem( Critter& cr, Item& item, int deteriorateCount ) from "repair";
import void AffectPoison( Critter& cr, int value ) from "poison";
import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void QuakeScreen2( Critter& cr ) from "effects";
import void QuakeScreen( Map& map ) from "effects";
import void AffectParalysis( Critter& cr, int value ) from "paralysis";                                                    // TabaK
import void AffectPoisonByCritter( Critter& cr, int value, Critter& atacker )  from "poison";                              // TabaK
import void delmob( Critter& cr, int p0, int p1, int p2 )  from "debug";                                                   // ErlKing
import void HookAttack( Critter& cr, Critter@ target, uint8 force, uint8 pull )  from "handcuffs";                         // ErlKing
import void HookMeleeAttack( Critter& cr, Critter@ target )  from "handcuffs";                                             // ErlKing
import void HookHoldAttack( Critter@ target, uint8 hardness )  from "handcuffs";                                           // ErlKing
import void Log_Killings( Critter& player, int target, int param1, int param2, string@ param3, int[] @ param4 ) from "gm"; // ErlKing
import void hearshot( Critter& cr, ProtoItem& weapon, uint8 weaponMode ) from "rp_combat"; //Выстрелы на карте

import void ChangeCritterSpeed( Critter& cr ) from "speed";                                                                // pm added
import bool FlareGunUse( Critter& cr, Item& item ) from "item";                                                            // pm added flare gun


// binyan
/*---------------------------Ball---------------------------------------------*/
#include "_animation.fos"
import void BallAttackHandling( Critter& ball, Critter& crt, uint16 WeaponPid ) from "ball_init";
import void e_BallIntoInven( Critter& ball, Critter& crt, bool SetToActiveHand ) from "ball_init";
import void e_ConvertBallToCrit( Critter& attacker, Item& ball, uint16 tx, uint16 ty ) from "ball_init";
import void e_ConvertBallToCrit( Item& ball, Critter& crt ) from "ball_init";
/*---------------------------------------------------------------------------*/
/*---------------------------FlashGrenade------------------------------------*/
import void ApplyFlashEff( Critter& target, uint8 dist ) from "flash_grenade";
/*---------------------------------------------------------------------------*/
// ////////////////////////////////////////////////////////////////////////////////

import bool ChangeWildness( uint16 x, uint16 y, int delta ) from "globalmap_group";

// pm added
import void ChangeStatus( Critter& cr, uint16 status, uint8 value, bool set ) from "critter_status";
import int  GetDeteriorationProcent( Item& item ) from "repair";

// TUTURU ADDED
import void unsafe_log_1(Critter& cr, int locX, int locY, int type, string@ message, int[] @ p4 ) from "general_unsafe"; //логгирование

class AttackStruct
{
    Critter@   Attacker;
    Item@      RealWeapon;
    uint16     WeaponPid;
    uint16     Hx;
    uint16     Hy;
    uint8      Aim;
    bool       IsBurst;
    bool       BloodyMess;
    bool       CombatMessage;
    bool       scoreUnarmed;
    int        WeaponPerk;
    uint8      WeaponSubtype;
    int        DmgMin;
    int        DmgMax;
    int        DmgType;
    int        BonusDmg;
    int        DmgMul;
    int        DRMod;
    int        DMMod;
    int        DDMod;
    uint       TargetId;
    bool       TargetHit;
    ProtoItem@ Ammo;
    uint       ForceFlags;
    bool       ShowHitAnimForce;

    AttackStruct()
    {
        @Attacker = null;
        @RealWeapon = null;
        WeaponPid = 0;
        Hx = 0;
        Hy = 0;
        Aim = HIT_LOCATION_UNCALLED;
        IsBurst = false;
        BloodyMess = false;
        CombatMessage = false;
        scoreUnarmed = false;
        WeaponPerk = -1;
        WeaponSubtype = 0;
        DmgMin = 0;
        DmgMax = 0;
        DmgType = 0;
        BonusDmg = 0;
        DmgMul = 2;
        DRMod = 0;
        DMMod = 1;
        DDMod = 1;

        TargetId = 0;
        TargetHit = false;
        @Ammo = null;
        ForceFlags = 0;
        ShowHitAnimForce = false;
    }
};

int getFullSkill( Critter& cr, Critter@ target, int skillNum, uint8 weaponSubtype )
{
    int   skillVal = cr.Skill[ skillNum ];

    if( cr.IsPlayer() )
    {
        if( weaponSubtype == WS_GUN )
        {
            // Log("Тип оружия - стрелковое. Используется " + skillNum + " скилл (200 - лёгкое, 201 - тяжелое, 202 - энерго)");
            // Log("Скилл стреляющего " + skillVal + ", а номер скилла - " + skillNum);
            if( skillNum == SK_SMALL_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - лёгкое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 2;
                // Log("Добавляем энергооружие, поделенное на 2, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }

            if( skillNum == SK_BIG_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - тяжелое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 3;
                // Log("Добавляем скилл лёгкого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 3;
                // Log("Добавляем энергооружие, поделенное на 3, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }

            if( skillNum == SK_ENERGY_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - энергетическое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 2;
                // Log("Добавляем скилл лёгкого оружия, поделенный на 2, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }
        }
        else
        {
            // Log("Тип оружия - нестрелковое. Используется " + skillNum + " скилл (203 - рукопашка, 204 - холодное, 205 - метательное)");
            if( skillNum == SK_UNARMED && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }

            if( skillNum == SK_MELEE_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 2;
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }

            if( skillNum == SK_THROWING && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }
        }
    }
    // Roleplay

	if( cr.IsPlayer() && valid( target ) && target.IsPlayer() )
	{
		/*
		Если [маньяк, обычный, мирный] хочешь БЕЗ ШТРАФА
		 атаковать:  маньяка, обычного, мирного
		1) маньяк:   всегда,   всегда, цель в бою
		2) обычный:  всегда,    в бою, цель в бою
		3) мирный:    в бою,    в бою, ты и цель в бою
		*/
		//Если вне боя, и ты мирный, и вы оба НЕ маньяки..
		if( ( cr.Timeout[ TO_BATTLE ] == 0 && ( cr.Trait[ TRAIT_GOOD_NATURED ] != 0 || ( cr.Trait[ TRAIT_BLOODY_MESS ] == 0  && target.Trait[ TRAIT_BLOODY_MESS ] == 0 ) ) ) 
			|| ( target.Trait[ TRAIT_GOOD_NATURED ] != 0 && target.Timeout[ TO_BATTLE ] == 0 ) ) { //Либо цель - мирный НЕ в бою.
			if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
				cr.Say( SAY_NETMSG, skillVal + " div " + ( skillVal / 2 ) );
			skillVal /= 2; //Навык делим пополам.
		}
		
		if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
			cr.Say( SAY_NORM, cr.Timeout[ TO_BATTLE ] + " " + cr.Trait[ TRAIT_GOOD_NATURED ] + " " + cr.Trait[ TRAIT_BLOODY_MESS ] );
		if( target.Param[ QST_GAMEMODE ] == GAME_TEST )
			target.Say( SAY_NORM, target.Timeout[ TO_BATTLE ] + " " + target.Trait[ TRAIT_GOOD_NATURED ] + " " + target.Trait[ TRAIT_BLOODY_MESS ] );
	}
	
	return skillVal;
}

void CombatAttack( Critter& cr, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY ) // Export
{
	int point = 0;
	
    if( not valid( target ) && hexX == 0 && hexY == 0 )
        return;

    uint yyy = 0;

// //////////////////////
/*
        string testMsg = "";

        if(!(target is null)){testMsg +"target";}
        testMsg+=" weapon.PID "+weapon.ProtoId+" mode "+weaponMode;
        if(!(ammo is null)){testMsg +" ammo";}

        cr.Say(SAY_EMOTE_ON_HEAD, testMsg);*/
// //////////////////////

// ///////////////////////
    uint8 use = _WeaponModeUse( weaponMode );
    uint8 aim = _WeaponModeAim( weaponMode );
    Item@ realWeapon = _CritGetItemHand( cr );
    Map@  map = cr.GetMap();
    int   wpnMaxDist = _WeaponMaxDist( weapon, use );
    int   skillNum = _WeaponSkill( weapon, use );

    if( weapon.ProtoId == PID_FLARE_GUN && weaponMode == 1 )
    {
        FlareGunUse( cr, realWeapon );
        return;
    }// pm added flare gun check

    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), cr.Stat[ ST_STRENGTH ] ) );
		//wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), ( cr.Stat[ ST_STRENGTH ] + 2 * cr.Perk[ PE_HEAVE_HO ] ) ) );

    uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );


    bool   isRanged = ( weaponSubtype == WS_THROWING || weaponSubtype == WS_GUN );
    bool   isUnarmed = weapon.Weapon_IsUnarmed;
    bool   isHthAttack = ( weaponSubtype == WS_MELEE || weaponSubtype == WS_UNARMED );
    uint16 ammoRound = _WeaponRound( weapon, use );
    bool   wpnIsRemoved = _WeaponRemove( weapon, use );
    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    uint16 tx = ( valid( target ) ) ? target.HexX : hexX;
    uint16 ty = ( valid( target ) ) ? target.HexY : hexY;
    uint16 weapPid = weapon.ProtoId;
    uint16 ammoPid = 0;
    if( valid( ammo ) )
        ammoPid = ammo.ProtoId;
    bool isBurst = ( ammoRound > 1 ); // will suffice for now
    if( isBurst )
        aim = HIT_LOCATION_UNCALLED;
    int  dmgType = _WeaponDmgType( weapon, use );

    bool isGrenade = weaponSubtype == WS_THROWING && ( dmgType == DAMAGE_PLASMA || dmgType == DAMAGE_EMP || dmgType == DAMAGE_EXPLODE || dmgType == DAMAGE_FIRE ); // like in fo2 pm edit add fire dmg

    bool isFlamethrower = ( ( aim == HIT_LOCATION_NONE || aim == HIT_LOCATION_TORSO || aim == HIT_LOCATION_UNCALLED ) &&
		( ammoPid == PID_FLAMETHROWER_FUEL || ammoPid == PID_FLAMETHROWER_FUEL_MK_II || ammoPid == PID_SHOTGUN_SHELLS || ammoPid == PID_12g_LOW || weapPid == PID_FIRE_GECKO_FLAME_WEAPON ) );

    bool isRocket = ( ammoPid == PID_EXPLOSIVE_ROCKET ) || ( ammoPid == PID_ROCKET_AP ) || ( ammoPid == PID_ROBO_ROCKET_AMMO ) || ( ammoPid == PID_GRENADELAUNCHER_AMMO );

    bool eyeDamage = cr.Damage[ DAMAGE_EYE ] != 0;

    bool crIsPlayer = cr.IsPlayer();
    bool isHit = false;
    bool isCritical = false;
	bool fullParry = false; //wabil
    bool hitRandomly = false;

    bool     isSneak = false;
    bool     useNormal = false; // used to change target during RunFlyEffect
    bool     useHex = false;    // used to change end hex of RunFlyEffect, i.e. for thrown weapons and rockets.

    uint     critfailFlags = 0;
    int      weaponPerk = weapon.Weapon_Perk;

    Critter@ normalTarget;       // used as a target for weapon animations;
    Critter@ realTarget;

    CombatRes[] results;

    int acmod = 0;   // used many times

	int skillVal = getFullSkill( cr, target, skillNum, weaponSubtype );

    // Begin turn based combat
	
    if( !map.IsTurnBased() && map.IsTurnBasedAvailability() )
        map.BeginTurnBased( cr );

    // always unsneak
    if( cr.Mode[ MODE_HIDE ] != 0 && !( weaponSubtype == WS_THROWING && dmgType == DAMAGE_NORMAL && valid( target ) && !cr.IsSeenBy( target ) ) )
    {
        if( !cr.IsPlayer() || cr.GetAccess() == ACCESS_CLIENT )
            cr.ModeBase[ MODE_HIDE ] = 0;
        isSneak = true;
    }
    /*          if(valid(target)) //binyan - Hex attack - added
            {
                    if (!target.IsPlayer() || target.GetAccess()==ACCESS_CLIENT)
                    target.ModeBase[MODE_HIDE]=0;
            }*/

    cr.SetDir( GetDirection( hx, hy, tx, ty ) );

    // now we change aim:
    if( aim == HIT_LOCATION_EYES && valid( cr ) && valid( target ) && (( cr.Dir + 3 ) % 6 != target.Dir ) )	
		aim = HIT_LOCATION_HEAD; //erlking no eye attack without sniper perk
    //if( aim == HIT_LOCATION_EYES && valid( cr ) && valid( target ) && (( cr.Dir + 3 ) % 6 != target.Dir || cr.Perk[PE_SNIPER]==0 ))	aim = HIT_LOCATION_HEAD; //erlking no eye attack without sniper perk

    // fastshot penalty
	//if(!isHthAttack && cr.Trait[ TRAIT_FAST_SHOT ] != 0 ) skillVal*=0.65; //35% штраф к навыку за фастшот
	/*if(!isHthAttack && cr.Trait[TRAIT_FAST_SHOT] != 0) //крит промах фастшот
		{
		if (isHit != true)
			{
			isCritical = true;
			    int roll = Random( 1, 100 ) - 5 * ( cr.Stat[ ST_LUCK ] - 5 );
                if( roll <= 20 )
                    roll = 0;
                else if( roll <= 50 )
                    roll = 1;
                else if( roll <= 75 )
                    roll = 2;
                else if( roll <= 95 )
                    roll = 3;
                else
                    roll = 4;
                critfailFlags = CriticalFailureTable[ 5 * weapon.Weapon_CriticalFailture + roll ];
                hitRandomly = FLAG( critfailFlags, MF_HIT_RANDOMLY );
			}
		}*/
	//if( aim == HIT_LOCATION_NONE )
	//	aim = cr.ParamBase[CR_AUTO_AIM];
		
    // now we randomise targeting of uncalled shots:  ErlKing рандомизатор неприцельных атак
    if(  ( dmgType != DAMAGE_FIRE && dmgType != DAMAGE_EXPLODE ) && //..не являющихся атаками взрывом и огнём..
		( aim == HIT_LOCATION_NONE || cr.Param[ QST_GAMEMODE ] == GAME_ARCADE ) //..неприцельные или атаки аркад
		|| ( cr.Trait[ TRAIT_FAST_SHOT ] != 0 && Random( 0, 2 ) != 0 ) //А так же 66% атак "фастшотеров"
		&& valid( cr ) && valid( target ) ) 
    {	//Рандомятся:
		int randomAim = Random (0, 18);
		if (randomAim <= 7) aim = HIT_LOCATION_TORSO;
		else if (randomAim <= 9) aim = HIT_LOCATION_RIGHT_ARM;
		else if (randomAim <= 11) aim = HIT_LOCATION_LEFT_ARM;
		else if (randomAim <= 13) aim = HIT_LOCATION_RIGHT_LEG;
		else if (randomAim <= 15) aim = HIT_LOCATION_LEFT_LEG;
		else if (randomAim <= 17) aim = HIT_LOCATION_HEAD;
		else if (randomAim <= 18) aim = HIT_LOCATION_GROIN;
    }

    /*--------------------------------------------------------------------------------------------------------------------------*/
    if( valid( target ) ) // binyan - Hex attack - added
    {
        if( cr.Timeout[ TO_BATTLE ] == 0 )
            cr.StatBase[ ST_BLOCK ] = 0;

    // now we autoblock if target win sequence check:  ErlKing автоблок при успешной проверке на порядок
        if( target.Timeout[ TO_BATTLE ] == 0 )
        {
            if( target.StatBase[ ST_SEQUENCE ] < ( cr.StatBase[ ST_SEQUENCE ] + Random( -15, 15 ) ) )
                target.StatBase[ ST_BLOCK ] = 0;
            else
                target.StatBase[ ST_BLOCK ] = 1;
        }

        // Здесь атакующий и атакуемый вводятся в режим боя. Игнорируем сие действие при атаке мяча и мячем   -    binyan
        if( target.GetProtoId() != NPC_PID_Ball && weapPid != PID_BALL )
        {
            if( cr.Timeout[ TO_BATTLE ] < int(__TimeoutBattle) )
                cr.TimeoutBase[ TO_BATTLE ] = __FullSecond + ( cr.IsPlayer() ? __TimeoutBattle : __TimeoutBattle / 2 );
            if( target.Timeout[ TO_BATTLE ] < int(__TimeoutBattle) )
                target.TimeoutBase[ TO_BATTLE ] = __FullSecond + ( cr.IsPlayer() ? __TimeoutBattle : __TimeoutBattle / 10 );
        }
    }
    else if( cr.Timeout[ TO_BATTLE ] < int(__TimeoutBattle) )
        cr.TimeoutBase[ TO_BATTLE ] = __FullSecond + __TimeoutBattle / 2;
    /*--------------------------------------------------------------------------------------------------------------------------*/

    cr.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( cr );
    if( valid( target ) ) // binyan - Hex attack - added
        target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );
/*
        // leaderboard
        if(crIsPlayer)
        {
                if (weaponSubtype == WS_GUN) cr.AddScore(SCORE_SHOOTER,1);
                else if (skillNum==SK_MELEE_WEAPONS || skillNum==SK_THROWING) cr.AddScore(SCORE_MELEE,1);
                else if (skillNum==SK_UNARMED) cr.AddScore(SCORE_UNARMED,1);
        }*/

    // Npc attack text
    if( !crIsPlayer )
        AI_TrySayCombatText( cr, COMBAT_TEXT_ATTACK );

    // Add event, always
    if( valid( target ) )                                                                                    // binyan - Hex attack - added
    {
        if( ( target.GetProtoId() != NPC_PID_Ball ) && ( weapPid != PID_BALL ) && weapPid != PID_GM_PISTOL ) // binyan - если бросаем мяч, противник не агрится. Если пинаем мяч - он не агрится.
            target.EventAttacked( cr );
    }

    // essential start

    // baseToHit used for all targets, adjusted for distance and other target-dependent qualities every time it is necessary
    int baseToHit = skillVal;
	if ( cr.Param[ QST_GAMEMODE ] == GAME_TEST ) cr.Say( SAY_NETMSG, "baseToHit= "+ baseToHit); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "baseToHit= "+ baseToHit); //TestInfo
    if( eyeDamage )
        baseToHit -= 25;
    if( !isUnarmed )
    {
        if( cr.Trait[ TRAIT_ONE_HANDER ] != 0 )
            baseToHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

        int handlingStrength = cr.Stat[ ST_STRENGTH ];
        int reqStrength = weapon.Weapon_MinStrength;
        
		// if( cr.Perk[ PE_WEAPON_HANDLING ] != 0 )
            // handlingStrength += 3;
        
		if( handlingStrength < reqStrength )
            baseToHit -= ( reqStrength - handlingStrength ) * 20;

        if( weaponPerk == WEAPON_PERK_ACCURATE )
            baseToHit += 20;
    }

    // main attack structure
    AttackStruct attack;
    @attack.Attacker = cr;
    @attack.RealWeapon = realWeapon;
    attack.WeaponPid = weapon.ProtoId;
    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = aim;
    attack.IsBurst = isBurst;
    attack.BloodyMess = cr.Trait[ TRAIT_BLOODY_MESS ] != 0;
    attack.CombatMessage = true;
    attack.scoreUnarmed = ( weaponSubtype == WS_UNARMED );
    attack.WeaponPerk = ( isUnarmed && weapon.Weapon_UnarmedArmorPiercing ) ? WEAPON_PERK_PENETRATE : weaponPerk;
    attack.WeaponSubtype = weaponSubtype;
    attack.DmgMin = _WeaponDmgMin( weapon, use );
    attack.DmgMax = _WeaponDmgMax( weapon, use );
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    @attack.Ammo = ammo;

    if( isHthAttack )
	{
        attack.DmgMax += cr.Stat[ ST_MELEE_DAMAGE ];
		attack.DmgMin += cr.Stat[ ST_MELEE_DAMAGE ];
	}
	if( weaponSubtype == WS_THROWING )
	{
        attack.DmgMax += cr.Stat[ ST_MELEE_DAMAGE ] / 2;
		attack.DmgMin += cr.Stat[ ST_MELEE_DAMAGE ] / 2;
	}
    // if( weaponSubtype == WS_GUN )
        // attack.BonusDmg += cr.Perk[ PE_BONUS_RANGED_DAMAGE ] * 2;
		
    // Ammo
    if( valid( ammo ) )
    {
        attack.DRMod = ammo.Ammo_DrMod;
        attack.DMMod = ammo.Ammo_DmgMult;
        attack.DDMod = ammo.Ammo_DmgDiv;
        if( attack.DMMod == 0 )
            attack.DMMod = 1;
        if( attack.DDMod == 0 )
            attack.DDMod = 1;
    }

    if( valid( target ) ) // binyan - Hex attack - added
        attack.TargetId = target.Id;
        // to check if the target was hit:


    // here we're deciding the real toHit;
    int toHit = baseToHit;
    toHit -= isHthAttack ? ( GetHitAim( aim ) / 2 ) : GetHitAim( aim );

    // range considerations, we're storing everything for a later use
    int distmod1 = 2;   // used for initial weapon bonus
    int distmod2 = 0;   // minimal distance

    if( weaponPerk == WEAPON_PERK_LONG_RANGE ) //перки
        distmod1 = 4;
    else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = cr.Stat[ ST_PERCEPTION ];
    int dist = /*GetDistantion(hx,hy,tx,ty);//*/ GetDistantion( hx, hy, valid( target ) ? target.HexX : hexX, valid( target ) ? target.HexY : hexY ); // binyan - Hex attack - added
    int acc = dist;
    int accloss = ( crIsPlayer ? ( perception - 2 ) * distmod1 : ( perception * distmod1 ) );
    int sharpshooter = 0;
	//int sharpshooter = 2 * cr.Perk[ PE_SHARPSHOOTER ];

    if( !isHthAttack )
    {
        if( dist < distmod2 )
            acc += distmod2;
        else
            acc -= accloss;
        if( -2 * perception > acc )
            acc = -2 * perception;
        acc -= sharpshooter;
        if( acc > 0 && eyeDamage )
            acc *= 3;
        acc *= -4;
        toHit += acc;
        int blockers = map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null );
        if( valid( target ) && !target.IsKnockout() )
            blockers--;                                                // binyan - Hex attack - added
        toHit -= 10 * blockers;
    }

	if ( cr.Param[ QST_GAMEMODE ] == GAME_TEST ) cr.Say( SAY_NETMSG, "ToHitAfterMods= "+ toHit); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "ToHitAfterMods= "+ toHit); //TestInfo
	
    if( valid( target ) ) // binyan - Hex attack - added
    {
        acmod = target.Stat[ ST_ARMOR_CLASS ];
        if( valid( ammo ) )
            acmod += ammo.Ammo_AcMod;
        if( acmod > 0 )
            toHit -= acmod;
		
	if ( cr.Param[ QST_GAMEMODE ] == GAME_TEST ) cr.Say( SAY_NETMSG, "ToHitAfterAC= "+ toHit); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "ToHitAfterAC= "+ toHit); //TestInfo

        // //////////////////begin  ErlKing  Aiming ////////////////////
        // now we block attacks with arms:
        if( valid( cr ) && valid( target ) && ( ( cr.Dir + 3 ) % 6 == target.Dir || ( cr.Dir + 4 ) % 6 == target.Dir || ( cr.Dir + 2 ) % 6 == target.Dir ) &&
            ( target.StatBase[ ST_BLOCK ] >= 1 ) && ( target.DamageBase[ DAMAGE_RIGHT_ARM ] != 1 ) && ( target.DamageBase[ DAMAGE_LEFT_ARM ] != 1 ) &&
            ( target.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( cr.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) &&
            attack.DmgType != DAMAGE_FIRE && attack.DmgType != DAMAGE_EXPLODE )                                                                 // WTF?!
        {
            if( !target.IsDead() || !target.IsKnockout() )
            {
                uint8 dist = GetDistantion( cr.HexX, cr.HexY, target.HexX, target.HexY );
                Item@ hand1 = target.GetItem( 0, SLOT_HAND1 );
                Item@ hand2 = target.GetItem( 0, SLOT_HAND2 );
                Item@ hand3 = target.GetItem( 0, SLOT_ARMOR );

                int   itemweigh1 = 0;
                int   itemweigh2 = 0;
                int   itemweigh3 = 0;
                int   aimpenalty = 0;

                if( valid( hand1 ) )
                    itemweigh1 = hand1.Proto.Weight;
                if( valid( hand2 ) )
                    itemweigh2 = hand2.Proto.Weight;
                if( valid( hand3 ) )
                    itemweigh3 = hand3.Proto.Weight;


                if( dist > 4 && cr.Stat[ ST_BLOCK ] == 2 )
                    cr.StatBase[ ST_BLOCK ] = 0;
                if( aim == HIT_LOCATION_HEAD && cr.Stat[ ST_BLOCK ] != 2 )
                    aimpenalty = 50;

                uint16   h_x = target.HexX, h_y = target.HexY;
                map.MoveHexByDir( h_x, h_y, ( cr.Dir + 3 ) % 6, 1 );
                Critter@ poor_guy = map.GetCritter( h_x, h_y );

                if( !( map.IsHexPassed( h_x, h_y ) ) && dist >= 2 && ( Random( 0, 80 ) + aimpenalty - skillVal - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 >= 0 ) )  //Укрытие
                {
                    target.Say( SAY_EMOTE_ON_HEAD, "укрылся" );
                    skillVal = skillVal - Random( 100, 200 + aimpenalty - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 );
                }

                if( valid( poor_guy ) && ( !poor_guy.IsDead() || !poor_guy.IsKnockout() ) && dist >= 2 && ( Random( 0, 80 ) + aimpenalty - skillVal - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 >= 0 ) )
                {
                    target.Say( SAY_EMOTE_ON_HEAD, "укрылся за" );
                    skillVal = skillVal - Random( 100, 200 + aimpenalty - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001  );
                }

				/*
				if( ( target.Perk[ PE_HTH_EVADE ] != 0 || target.Perk[ PE_KARMA_BEACON ]  != 0 ) && dist >= 2 
                    && ( Random( 1, 100 ) + aimpenalty + (target.Skill[ SK_UNARMED ] - skillVal ) - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 >= 50 ) )  //шанс попасть по милишнику
                {
                    target.Say( SAY_EMOTE_ON_HEAD, "уклонение" );
                    skillVal = skillVal - Random( 100, 120 + aimpenalty + target.Skill[ SK_UNARMED ] * 0.2 - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 );

                    if( Random( 0, 1 ) == 0 )
                    {
                        target.StatBase[ ST_BLOCK ] = 0;
                    }
                    if( Random( 0, 1 ) == 0 )
                    {
                        aim = HIT_LOCATION_LEFT_ARM;
                    }
                    else
                    {
                        aim = HIT_LOCATION_RIGHT_ARM;
                    }
				}	
				*/
                if( ( dist <= 1 || isHthAttack ) && ( Random( 1, 200 ) - (cr.Stat[ST_LUCK]-5)*5 + aimpenalty * 2 - skillVal + target.Skill[ SK_MELEE_WEAPONS ] + target.Skill[ SK_UNARMED ] - ( itemweigh1 + itemweigh2 ) * 0.01 >= 100 ) )
                {
                    target.Say( SAY_EMOTE_ON_HEAD, "блок" );
                    skillVal = skillVal - Random( 30, 50 + aimpenalty + target.Skill[ SK_UNARMED ] * 0.2 - ( itemweigh1 + itemweigh2 + itemweigh3 ) * 0.001 );

                    if( isHthAttack )
                        attack.DmgMul -= 0.5;
                    if( Random( 0, 2 ) == 0 || ( ( aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES ) && Random( 0, 1 ) == 0 ) )
                    {
                        target.StatBase[ ST_BLOCK ] = 2;
                        target.Say( SAY_EMOTE_ON_HEAD, "жесткий блок" );
                    }

                    if( Random( 0, 1 ) == 0 )
                    {
                        aim = HIT_LOCATION_LEFT_ARM;
                    }
                    else
                    {
                        aim = HIT_LOCATION_RIGHT_ARM;
                    }
                }
            }
        }

        // attacking running target
        if( valid(target) && target.IsBusy() )
        {
            if( ( cr.Dir + 3 ) % 6 == target.Dir )
                toHit += 20;
            else if( ( cr.Dir ) % 6 != target.Dir )
            {
                toHit -= acmod / 2;
                if( aim == HIT_LOCATION_HEAD )
                    toHit -= acmod / 2;
            }
        }
        // advanced aiming
        if( aim == HIT_LOCATION_HEAD )
            toHit *= 0.5;
        else if( aim == HIT_LOCATION_LEFT_ARM || aim == HIT_LOCATION_RIGHT_ARM || aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG )
            toHit *= 0.7;

        // block drop
        if( cr.Stat[ ST_BLOCK ] == 2 )
        {
            cr.StatBase[ ST_BLOCK ] = 0;
            toHit += 30;
        }

        if( Random( 0, 2 ) < 1 && cr.Stat[ ST_BLOCK ] == 1 )
            cr.StatBase[ ST_BLOCK ] = 0;

		if (cr.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0) cr.EraseTimeEvents( CTE_SLOWRELOAD );
		
        // //////////////////end  ErlKing  Aiming ////////////////////
        if(valid(target))
		{
			if( target.IsKnockout() )
				toHit += 40;
			if( target.GetMultihex() > 0 )
				toHit += 15;
		}
    }
	
	if ( cr.Param[ QST_GAMEMODE ] == GAME_TEST ) cr.Say( SAY_NETMSG, "ToHitAfterErlTweaks= "+ toHit); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "ToHitAfterErlTweaks= "+ toHit); //TestInfo

	toHit += (cr.Stat [ST_LUCK]-5)*3;
    toHit = CLAMP( toHit, 0, 95 );
    
    // psi-shields
    bool psiShield = false;
    if (valid (target)) {
		psiShield = (target.GetTimeEvents (CTE_PSI_SHIELD, null, null, null) > 0);
		if (dmgType == DAMAGE_NORMAL && psiShield) {
			int psiRoll = Random (0, 99);
			int psiShieldChance = (target.Skill [SK_SPEECH] / 4) + target.Stat [ST_LUCK] + target.Stat [ST_INTELLECT];
			psiShieldChance = CLAMP (psiShieldChance, 5, 95);
			if (psiRoll < psiShieldChance) {
				target.Say (SAY_EMOTE, "Атака отражается");
				toHit = 0;
			}
		}
    }
	
	//full parry test
	
	if ( valid( target) && target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) //
	{
		toHit = 0;
		target.TimeoutBase[TO_BATTLE] = __FullSecond + REAL_SECOND( 10 );
		fullParry = true;
	
	}
	
	
    // main roll
    int margin = toHit - Random( 1, 100 );

	if ( cr.Param[ QST_GAMEMODE ] == GAME_TEST ) cr.Say( SAY_NETMSG, "ToHitRoll= "+ margin); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "ToHitRoll= "+ margin); //TestInfo
	
    if( margin < 0 )  // if missed
    {
        // not setting isHit, we try a critical failure
        if( cr.Mode[ MODE_INVULNERABLE ] == 0 )
        {
            isCritical = ( (( -margin ) / 10) >= Random( 1, 100 ) );

            // basic jinxed behaviour (upgrade if anyone is jinxed and coinflip is passed)
            if( !isCritical )
				isCritical = Random( 1, 10 ) == 1 //10%
					&& ( cr.Trait[ TRAIT_JINXED ] != 0 || ( valid( target ) && target.Trait[ TRAIT_JINXED ] != 0 ) ); //someone is jinxed
						// ( cr.Trait[ TRAIT_JINXED ] != 0 || cr.Perk[ PE_JINXED_II ] != 0 ) || 
						// ( valid( target ) && ( target.Trait[ TRAIT_JINXED ] != 0 || target.Perk[ PE_JINXED_II ] != 0 ) ) 
			
            if( isCritical )
            {
                int roll = Random( 1, 100 ) - 5 * ( cr.Stat[ ST_LUCK ] - 5 );
                if( roll <= 20 )
                    roll = 0;
                else if( roll <= 50 )
                    roll = 1;
                else if( roll <= 75 )
                    roll = 2;
                else if( roll <= 95 )
                    roll = 3;
                else
                    roll = 4;

                critfailFlags = CriticalFailureTable[ 5 * weapon.Weapon_CriticalFailture + roll ];
                if( critfailFlags == 0 )
                    isCritical = false;
                hitRandomly = FLAG( critfailFlags, MF_HIT_RANDOMLY );
            }
        }
    }
    else     // if hit
    {
        isHit = true;
		
		isCritical = ( cr.Stat[ ST_CRITICAL_CHANCE ] + margin*0.1 ) * ( valid( target ) ? ( ( 100 - ( target.Stat[ ST_LUCK ] + target.Stat[ ST_ARMOR_CLASS ] ) ) * 0.01 ) : 0 ) >= Random( 1, 100 );
		
		// uint cri_roll = Random( 1, 100 ) + ( valid( target ) ? target.Stat[ ST_CRITICAL_CHANCE ] : 0 );
		// uint cri_chance = cr.Stat[ ST_CRITICAL_CHANCE ] + margin*0.1;
		
		// if ( cr.Param[ QST_GAMEMODE ] == GAME_TEST ) cr.Say( SAY_NETMSG, "Crit_R= "+ cri_roll+" , Crit_C= "+ cri_chance); //TestInfo
		// if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "Crit_R= "+ cri_roll+" , Crit_C= "+ cri_chance); //TestInfo
		
		// isCritical = ( cri_roll <= cri_chance );

        // isCritical = ( Random( 1, 100 ) <= cr.Stat[ ST_CRITICAL_CHANCE ] + margin / 10 );
        // if( !isCritical ) isCritical = Random( 1, 100 ) <= skillVal / 10;

        // if (isHthAttack && cr.Perk[PE_SLAYER]!=0) isCritical=true;
        // if (!isCritical && weaponSubtype==WS_GUN && cr.Perk[PE_SNIPER]!=0) isCritical = (Random(1,10) <= cr.Stat[ST_LUCK]);
        // if (!isCritical && isUnarmed) isCritical = Random(1,100) <= weapon.Weapon_UnarmedCriticalBonus;
    }

    if( hitRandomly && valid( target ) )
    {
        Critter@ randomTarget = ChooseRandomTarget( map, cr, target, wpnMaxDist );
        if( @randomTarget != null )
        {
            @realTarget = randomTarget;
            tx = realTarget.HexX;
            ty = realTarget.HexY;
            attack.Aim = HIT_LOCATION_UNCALLED;
            realTarget.ModeBase[ MODE_HIDE ] = 0;         // done here to allow combat notifications later
            NotifyOops( cr, target, realTarget, results );
        }
    }
    else
        @realTarget = target;

    // initial animations
    // binyan - При ударе рукой вызываем процедуру помещения в инвентарь
    // ////////////////////////////////////////////////////////////////
    bool isArm = ( attack.WeaponPid == 1000 ) || ( attack.WeaponPid == 1001 ) || ( attack.WeaponPid == 1002 ) || ( attack.WeaponPid == 1003 ) || ( attack.WeaponPid == 1010 ) || ( attack.WeaponPid == 1011 ) || ( attack.WeaponPid == 1012 );
    if( valid( target ) ) // binyan - Hex attack - added
    {
        if( ( target.GetProtoId() == NPC_PID_Ball ) && ( isArm ) )
        {
            e_BallIntoInven( target, cr, true );
            return;
        }
    }
    // /////////////////////////////////////////////////////
	// Windup Action!
	if(cr.Anim2Life == ANIM2_WINDUP)
		cr.SetAnims(COND_LIFE, 0, ANIM2_IDLE);
    cr.Action(ACTION_USE_WEAPON, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | (((!isHit && isCritical && !hitRandomly) ? 1 : 0) << 8) | (aim << 4) | use, realWeapon);
	// ??? 
	// PROFIT!

    // Поправлен баг с отображением удара ногой - Ку3////////////////
    // cr.Action(ACTION_USE_WEAPON,(((!isHit && isCritical && !hitRandomly)?1:0)<<8)|(aim<<4)|((weapPid>=1000 && weapPid<1040)?((weapon.Weapon_Anim2==18)?1:0):(weapon.Weapon_CurrentUse)),realWeapon);
    // ниже из нового сдк, там фикс сделан по другому
    cr.Action( ACTION_USE_WEAPON, ( ( ( !isHit && isCritical && !hitRandomly ) ? 1 : 0 ) << 8 ) | ( aim << 4 ) | use, realWeapon );

    // //////////////////////////////////////////////////////////////
    // animations are now played, and we're updating the hit randomly status now
    bool changedTarget = ( hitRandomly && ( @realTarget != null ) );

    // commencing critical failures
    if( !isHit && isCritical && ( !hitRandomly  || @realTarget == null ) )
    {
        CriticalFailure( cr, weapon, use, ammo, critfailFlags, results );
        return;
    }

    // commencing attack, various instances
    bool criticalHit = isHit && isCritical;

    if( isHthAttack )                                                                                                                                // UNARMED AND MELEE ATTACK
    {
        if( isHit )
        {
            int crDir = cr.Dir;
            int tDir  = valid( realTarget) ? realTarget.Dir : cr.Dir;
            // if( isSneak && cr.Perk[ PE_SILENT_DEATH ] != 0 && ( crDir == tDir || ( ( crDir + 1 ) % 6 ) == tDir || ( ( crDir + 5 ) % 6 ) == tDir ) )
                // attack.DmgMul *= 2;
            if( valid( realTarget) )
				ApplyDamage( attack, realTarget, 1, criticalHit, true, results );
        }
        else
        {
            if( changedTarget )
			{
				if( valid( realTarget ) )
					ApplyDamage( attack, realTarget, 1, false, false, results );
			}
            else
                NotifyMiss( cr, results );
        }
    }
    else if( ( weaponSubtype == WS_GUN ) && !isBurst && !isRocket && !isFlamethrower )  // single shot, normal //split if pm
    {

        // if(!isBurst)
        // {
        if( isHit || changedTarget )
		{
			if( valid( realTarget ) )
				ApplyDamage( attack, realTarget, 1, criticalHit, !changedTarget, results );
		}
        else         // standard miss here
        {
            Critter@[] critsLine;
            attack.Aim = HIT_LOCATION_UNCALLED;
            baseToHit += GetHitAim( aim );
            map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine );
            int  bl = 0;
            bool anyHit = false;
            for( int i = 0, j = critsLine.length(); ( i < j ) && !anyHit; i++ )
            {
                if( valid( realTarget ) && critsLine[ i ].Id == realTarget.Id )
                {
                    bl++;
                    continue;
                }                                                                       // skip the primary target

                // adjust tohit
                dist = GetDistantion( hx, hy, critsLine[ i ].HexX, critsLine[ i ].HexY );
                acc = dist;
                toHit = baseToHit;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = critsLine[ i ].Stat[ ST_ARMOR_CLASS ];
                if( valid( ammo ) )
                    acmod += ammo.Ammo_AcMod;
                if( acmod > 0 )
                    toHit -= acmod;
                toHit -= 10 * bl;
                if( critsLine[ i ].IsKnockout() )
                    toHit += 40;
                else
                    bl++;
                if( critsLine[ i ].GetMultihex() > 0 )
                    toHit += 15;
                toHit = CLAMP( toHit, 5, 95 );
                toHit /= 3;               // after clamp
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
                if( Random( 1, 100 ) <= toHit )
                {
                    if( valid( target ) )
						NotifyOops( cr, target, critsLine[ i ], results );
                    @normalTarget = critsLine[ i ];
                    useNormal = true;
                    ApplyDamage( attack, normalTarget, 1, false, false, results );
                    anyHit = true;
                }
            }
            if( !anyHit )
                NotifyMiss( cr, results );
        }
        // }//end of split if
    }
    else if( isFlamethrower )    // FLAME ATTACK
    {
        // adjust toHit if random hit
        if( changedTarget )
        {
            dist = GetDistantion( hx, hy, tx, ty );
            acc = dist;
            toHit = baseToHit;
            if( dist < distmod2 )
                acc += distmod2;
            else
                acc -= accloss;
            if( -2 * perception > acc )
                acc = -2 * perception;
            acc -= sharpshooter;
            if( acc > 0 && eyeDamage )
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = valid( realTarget ) ? realTarget.Stat[ ST_ARMOR_CLASS ] : 0;
            if( valid( ammo ) )
                acmod += ammo.Ammo_AcMod;
            if( acmod > 0 )
                toHit -= acmod;
            if( valid( realTarget ) && realTarget.IsKnockout() )
                toHit += 40;
            if( valid( realTarget ) && realTarget.GetMultihex() > 0 )
                toHit += 15;
            int blockers = map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null );
            if( valid( realTarget ) && !realTarget.IsKnockout() )
                blockers--;
            toHit -= 10 * blockers;
            toHit = CLAMP( toHit, 5, 95 );
			if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
				toHit = 0;
        }

        // critical hit bonus, toHit can be increased over 100
        if( criticalHit )
            toHit += 20;

        // proceed with the flame attack
        Critter@[] critsHit( 0 );
        uint[]     critsHitBullets( 0 );
        int len_ = 0;

        if( Random( 1, 100 ) <= toHit && valid( realTarget ) )
        {
            critsHit.resize( 1 );
            @critsHit[ 0 ] = realTarget;
            critsHitBullets.resize( 1 );
            critsHitBullets[ 0 ] += 1;
            len_++;
        }

        Critter@[] lineCentral;
        map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral );
        int  bl;

        bool threeLines;
		if( lineCentral.length() > 0 )
			threeLines = ( GetDistantion( hx, hy, lineCentral[ 0 ].HexX, lineCentral[ 0 ].HexY ) > 1 ); // target not adjacent and weapon not shotgun
		else
			threeLines = ( GetDistantion( hx, hy, tx, ty ) > 1 ); // target not adjacent and weapon not shotgun
        // already shot: MAX(rounds/6,1);

        for( int lineCount = 0, lineMax = ( threeLines ? 1 : 3 ); lineCount < lineMax; lineCount++ )
        {

            // lineCentral
            bl = 0;           // zero blockers
            for( int i = 0, j = lineCentral.length(); i < j; i++ )
            {
                // adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = GetDistantion( hx, hy, lineCentral[ i ].HexX, lineCentral[ i ].HexY );
                acc = dist;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[ i ].Stat[ ST_ARMOR_CLASS ];
                if( valid( ammo ) )
                    acmod += ammo.Ammo_AcMod;
                if( acmod > 0 )
                    toHit -= acmod;
                if( lineCentral[ i ].IsKnockout() )
                    toHit += 40;
                else
                    bl++;
                if( lineCentral[ i ].GetMultihex() > 0 )
                    toHit += 15;
                toHit = CLAMP( toHit, 5, 95 );
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
                if( Random( 1, 100 ) <= toHit )
                {
                    int crIndex = FindCritterInArray( critsHit, lineCentral[ i ] );
                    if( crIndex == -1 )
                    {
                        critsHit.resize( len_ + 1 );
                        @critsHit[ len_ ] = lineCentral[ i ];
                        critsHitBullets.resize( len_ + 1 );
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[ crIndex ] += 1;
                }
            }
            // lineCentral end
        }

        if( threeLines )
        {
            // rounds for the left stack
            // real left

            uint8  leftDir = GetOffsetDir( hx, hy, tx, ty, 89.0f );
            uint16 sx = hx;
            uint16 sy = hy;
            uint16 ex = tx;
            uint16 ey = ty;

            map.MoveHexByDir( sx, sy, leftDir, 1 );
            map.MoveHexByDir( ex, ey, leftDir, 1 );

            Critter@[] lineLeft;
            map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft );
            int leftStart = 0;
            int leftLen = lineLeft.length();
            while( ( leftStart < leftLen ) && ( GetDistantion( hx, hy, lineLeft[ leftStart ].HexX, lineLeft[ leftStart ].HexY ) ) < 3 )
                leftStart++;

            for( int i = leftStart, j = leftLen; i < j; i++ )
            {
                // adjust tohit
                dist = GetDistantion( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY );
                bl = map.GetCrittersPath( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineLeft[ i ].Stat[ ST_ARMOR_CLASS ];
                if( valid( ammo ) )
                    acmod += ammo.Ammo_AcMod;
                if( acmod > 0 )
                    toHit -= acmod;
                if( lineLeft[ i ].IsKnockout() )
                    toHit += 40;
                if( lineLeft[ i ].GetMultihex() > 0 )
                    toHit += 15;
                toHit = CLAMP( toHit, 5, 95 );
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
                if( Random( 1, 100 ) <= toHit )
                {
                    int crIndex = FindCritterInArray( critsHit, lineLeft[ i ] );
                    if( crIndex == -1 )
                    {
                        critsHit.resize( len_ + 1 );
                        @critsHit[ len_ ] = lineLeft[ i ];
                        critsHitBullets.resize( len_ + 1 );
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[ crIndex ] += 1;
                }
            }             // left line

            uint8 rightDir = GetOffsetDir( hx, hy, tx, ty, -89.0f );
            sx = hx;
            sy = hy;
            ex = tx;
            ey = ty;

            map.MoveHexByDir( sx, sy, rightDir, 1 );
            map.MoveHexByDir( ex, ey, rightDir, 1 );

            Critter@[] lineRight;
            map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight );
            int rightStart = 0;
            int rightLen = lineRight.length();
            while( ( rightStart < rightLen ) && ( GetDistantion( hx, hy, lineRight[ rightStart ].HexX, lineRight[ rightStart ].HexY ) ) < 3 )
                rightStart++;
            for( int i = rightStart, j = rightLen; i < j; i++ )
            {
                // adjust tohit
                dist = GetDistantion( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY );
                bl = map.GetCrittersPath( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineRight[ i ].Stat[ ST_ARMOR_CLASS ];
                if( valid( ammo ) )
                    acmod += ammo.Ammo_AcMod;
                if( acmod > 0 )
                    toHit -= acmod;
                if( lineRight[ i ].IsKnockout() )
                    toHit += 40;
                if( lineRight[ i ].GetMultihex() > 0 )
                    toHit += 15;
                toHit = CLAMP( toHit, 5, 95 );
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
                if( Random( 1, 100 ) <= toHit )
                {
                    int crIndex = FindCritterInArray( critsHit, lineRight[ i ] );
                    if( crIndex == -1 )
                    {
                        critsHit.resize( len_ + 1 );
                        @critsHit[ len_ ] = lineRight[ i ];
                        critsHitBullets.resize( len_ + 1 );
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[ crIndex ] += 1;
                }
            }             // right line
        }

        for( int i = 0, j = critsHit.length(); i < j; i++ )
            ApplyDamage( attack, critsHit[ i ], 1, ( valid( realTarget ) && realTarget.Id == critsHit[ i ].Id ) && criticalHit, ( cr.IsPlayer() && !changedTarget ) || ( cr.IsNpc() && critsHit[ i ].Id == target.Id ), results );

        if( !changedTarget && !attack.TargetHit )
            NotifyMiss( cr, results );
    }
    else if( ( weaponSubtype == WS_GUN ) && isBurst )  // BURST FIRE
    {
        // adjust toHit if random hit
        if( changedTarget )
        {
            dist = GetDistantion( hx, hy, tx, ty );
            acc = dist;
            toHit = baseToHit;
            if( dist < distmod2 )
                acc += distmod2;
            else
                acc -= accloss;
            if( -2 * perception > acc )
                acc = -2 * perception;
            acc -= sharpshooter;
            if( acc > 0 && eyeDamage )
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = valid( realTarget ) ? realTarget.Stat[ ST_ARMOR_CLASS ] : 0;
            if( valid( ammo ) )
                acmod += ammo.Ammo_AcMod;
            if( acmod > 0 )
                toHit -= acmod;
            if( valid( realTarget ) && realTarget.IsKnockout() )
                toHit += 40;
            if( valid( realTarget ) && realTarget.GetMultihex() > 0 )
                toHit += 15;
            int blockers = map.GetCrittersPath( hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null );
            if( valid( realTarget ) && !realTarget.IsKnockout() )
                blockers--;
            toHit -= 10 * blockers;
            toHit = CLAMP( toHit, 5, 95 );
			if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
				toHit = 0;
        }

        // critical hit bonus, toHit can be increased over 100
        if( criticalHit )
            toHit += 20;

        // proceed with the burst attack
        int rounds = ammoRound;
        if( valid( realWeapon ) && realWeapon.AmmoCount < rounds )
            rounds = realWeapon.AmmoCount;
        Critter@[] critsHit( 0 );
        uint[]     critsHitBullets( 0 );

        int len_ = 0;
        int volleyRounds = MAX( ( rounds / 6 ), 1 );

        int curRounds = 0;
        for( int i = 0; i < volleyRounds; i++ )
        {
            if( (i+1)*Random( 1, 100 ) <= toHit )
                curRounds++;
        }
        if( curRounds != 0 && valid( realTarget ) )
        {
            critsHit.resize( 1 );
            critsHitBullets.resize( 1 );
            @critsHit[ 0 ] = realTarget;
            critsHitBullets[ 0 ] = curRounds;
            len_++;
        }
        volleyRounds -= curRounds;

        Critter@[] lineCentral;
        map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral );

        int bl = 0;
        curRounds = 0;
        for( int i = 0, j = lineCentral.length(); ( i < j ) && ( volleyRounds > 0 ); i++ )
        {
            if( valid( realTarget ) && lineCentral[ i ].Id == realTarget.Id )
            {
                bl++;
                continue;
            }                                                                       // skip the primary target, but add blocker
            // adjust tohit
            toHit = baseToHit - 10 * bl;
            dist = GetDistantion( hx, hy, lineCentral[ i ].HexX, lineCentral[ i ].HexY );
            acc = dist;
            if( dist < distmod2 )
                acc += distmod2;
            else
                acc -= accloss;
            if( -2 * perception > acc )
                acc = -2 * perception;
            acc -= sharpshooter;
            if( acc > 0 && eyeDamage )
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = lineCentral[ i ].Stat[ ST_ARMOR_CLASS ];
            if( valid( ammo ) )
                acmod += ammo.Ammo_AcMod;
            if( acmod > 0 )
                toHit -= acmod;
            toHit = CLAMP( toHit, 5, 95 );
            if( lineCentral[ i ].IsKnockout() )
                toHit += 40;
            else
                bl++;
            if( lineCentral[ i ].GetMultihex() > 0 )
                toHit += 15;
            for( curRounds = 0; curRounds < volleyRounds;)
            {
                if( (curRounds+1)*Random( 1, 100 ) <= toHit )
                    curRounds++;
                else
                    break;
            }
            volleyRounds -= curRounds;
            if( curRounds > 0 )
            {
                int crIndex = FindCritterInArray( critsHit, lineCentral[ i ] );
                if( crIndex == -1 )
                {
                    critsHit.resize( len_ + 1 );
                    @critsHit[ len_ ] = lineCentral[ i ];
                    critsHitBullets.resize( len_ + 1 );
                    critsHitBullets[ len_ ] = 0;
                    crIndex = len_;
                    len_++;
                }
                critsHitBullets[ crIndex ] += curRounds;
            }
        }

		
        // now we're shooting the rest of the bullets (=rounds-MAX(1,rounds/6))
        bool threeLines = false;
		if( lineCentral.length() > 0 && valid( lineCentral[0] ) )
			threeLines = ( GetDistantion( hx, hy, lineCentral[ 0 ].HexX, lineCentral[ 0 ].HexY ) > 1 ) && ( ammoRound > 3 ); // target not adjacent and weapon not shotgun
		else
			threeLines = ( GetDistantion( hx, hy, tx, ty ) > 1 ) && ( ammoRound > 3 ); // target not adjacent and weapon not shotgun
		
        // already shot: MAX(rounds/6,1);

        for( int lineCount = 0, lineMax = ( threeLines ? 1 : 3 ); lineCount < lineMax; lineCount++ )
        {
            // rounds for central stack

            if( lineCount == 0 )
            {
                volleyRounds = rounds - ( ( ( rounds + 1 ) / 3 ) + ( rounds / 3 ) ); // second central, always
                volleyRounds -= MAX( rounds / 6, 1 );
            }
            else
            {
                if( lineCount == 1 )
                    volleyRounds = ( rounds + 1 ) / 3;             // left line
                else
                    volleyRounds = rounds / 3;                     // right line
            }

            if( volleyRounds == 0 )
                continue;     // end this

            // lineCentral
            bl = 0;           // zero blockers
            for( int i = 0, j = lineCentral.length(); ( i < j ) && ( volleyRounds > 0 ); i++ )
            {
                // adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = GetDistantion( hx, hy, lineCentral[ i ].HexX, lineCentral[ i ].HexY );
                acc = dist;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[ i ].Stat[ ST_ARMOR_CLASS ];
                if( valid( ammo ) )
                    acmod += ammo.Ammo_AcMod;
                if( acmod > 0 )
                    toHit -= acmod;
                if( lineCentral[ i ].IsKnockout() )
                    toHit += 40;
                if( lineCentral[ i ].GetMultihex() > 0 )
                    toHit += 15;
				
                toHit = CLAMP( toHit, 5, 95 );
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
                bl++;
                for( curRounds = 0; curRounds < volleyRounds;)
                {
                    if( (curRounds+1)*Random( 1, 100 ) <= toHit )
                        curRounds++;
                    else
                        break;
                }
                volleyRounds -= curRounds;
                if( curRounds > 0 )
                {
                    int crIndex = FindCritterInArray( critsHit, lineCentral[ i ] );
                    if( crIndex == -1 )
                    {
                        critsHit.resize( len_ + 1 );
                        @critsHit[ len_ ] = lineCentral[ i ];
                        critsHitBullets.resize( len_ + 1 );
                        critsHitBullets[ len_ ] = 0;
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[ crIndex ] += curRounds;
                }
            }
            // lineCentral end
        }

        if( threeLines )
        {
            // rounds for the left stack
            volleyRounds = ( rounds + 1 ) / 3;

            if( volleyRounds > 0 )          // real left
            {
                uint8  leftDir = GetOffsetDir( hx, hy, tx, ty, 89.0f );
                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir( sx, sy, leftDir, 1 );
                map.MoveHexByDir( ex, ey, leftDir, 1 );

                Critter@[] lineLeft;
                map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft );
                int leftStart = 0;
                int leftLen = lineLeft.length();
                while( ( leftStart < leftLen ) && ( GetDistantion( hx, hy, lineLeft[ leftStart ].HexX, lineLeft[ leftStart ].HexY ) ) < 3 )
                    leftStart++;

                for( int i = leftStart, j = leftLen; ( i < j ) && ( volleyRounds > 0 ); i++ )
                {
                    // adjust tohit
                    dist = GetDistantion( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY );
                    bl = map.GetCrittersPath( hx, hy, lineLeft[ i ].HexX, lineLeft[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if( dist < distmod2 )
                        acc += distmod2;
                    else
                        acc -= accloss;
                    if( -2 * perception > acc )
                        acc = -2 * perception;
                    acc -= sharpshooter;
                    if( acc > 0 && eyeDamage )
                        acc *= 3;
                    acc *= -4;
                    toHit += acc;
                    acmod = lineLeft[ i ].Stat[ ST_ARMOR_CLASS ];
                    if( valid( ammo ) )
                        acmod += ammo.Ammo_AcMod;
                    if( acmod > 0 )
                        toHit -= acmod;
                    if( lineLeft[ i ].IsKnockout() )
                        toHit += 40;
                    if( lineLeft[ i ].GetMultihex() > 0 )
                        toHit += 15;
						
                    toHit = CLAMP( toHit, 5, 95 );
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
					
                    for( curRounds = 0; curRounds < volleyRounds;)
                    {
                        if( (curRounds+1)*Random( 1, 100 ) <= toHit )
                            curRounds++;
                        else
                            break;
                    }
                    volleyRounds -= curRounds;
                    if( curRounds > 0 )
                    {
                        int crIndex = FindCritterInArray( critsHit, lineLeft[ i ] );
                        if( crIndex == -1 )
                        {
                            critsHit.resize( len_ + 1 );
                            @critsHit[ len_ ] = lineLeft[ i ];
                            critsHitBullets.resize( len_ + 1 );
                            critsHitBullets[ len_ ] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[ crIndex ] += curRounds;
                    }
                }
            }             // left line


            // rounds for the right stack
            volleyRounds = ( rounds ) / 3;

            if( volleyRounds > 0 )
            {
                uint8  rightDir = GetOffsetDir( hx, hy, tx, ty, -89.0f );

                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir( sx, sy, rightDir, 1 );
                map.MoveHexByDir( ex, ey, rightDir, 1 );

                Critter@[] lineRight;
                map.GetCrittersPath( sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight );
                int rightStart = 0;
                int rightLen = lineRight.length();
                while( ( rightStart < rightLen ) && ( GetDistantion( hx, hy, lineRight[ rightStart ].HexX, lineRight[ rightStart ].HexY ) ) < 3 )
                    rightStart++;
                for( int i = rightStart, j = rightLen; ( i < j ) && ( volleyRounds > 0 ); i++ )
                {
                    // adjust tohit
                    dist = GetDistantion( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY );
                    bl = map.GetCrittersPath( hx, hy, lineRight[ i ].HexX, lineRight[ i ].HexY, 0.0f, dist, FIND_LIFE, null ) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if( dist < distmod2 )
                        acc += distmod2;
                    else
                        acc -= accloss;
                    if( -2 * perception > acc )
                        acc = -2 * perception;
                    acc -= sharpshooter;
                    if( acc > 0 && eyeDamage )
                        acc *= 3;
                    acc *= -4;
                    toHit += acc;
                    acmod = lineRight[ i ].Stat[ ST_ARMOR_CLASS ];
                    if( valid( ammo ) )
                        acmod += ammo.Ammo_AcMod;
                    if( acmod > 0 )
                        toHit -= acmod;
                    if( lineRight[ i ].IsKnockout() )
                        toHit += 40;
                    if( lineRight[ i ].GetMultihex() > 0 )
                        toHit += 15;
                    toHit = CLAMP( toHit, 5, 95 );
					if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
						toHit = 0;
                    for( curRounds = 0; curRounds < volleyRounds;)
                    {
                        if( (curRounds+1)*Random( 1, 100 ) <= toHit )
                            curRounds++;
                        else
                            break;
                    }
                    volleyRounds -= curRounds;
                    if( curRounds > 0 )
                    {
                        int crIndex = FindCritterInArray( critsHit, lineRight[ i ] );
                        if( crIndex == -1 )
                        {
                            critsHit.resize( len_ + 1 );
                            @critsHit[ len_ ] = lineRight[ i ];
                            critsHitBullets.resize( len_ + 1 );
                            critsHitBullets[ len_ ] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[ crIndex ] += curRounds;
                    }
                }
            }             // right line
        }

        for( int i = 0, j = len_; i < j; i++ )
            ApplyDamage( attack, critsHit[ i ], critsHitBullets [i], ( valid( realTarget ) && realTarget.Id == critsHit[ i ].Id ) && criticalHit, ( cr.IsPlayer() && !changedTarget ) || ( cr.IsNpc() && critsHit[ i ].Id == target.Id ), results );

        if( !changedTarget && !attack.TargetHit )
            NotifyMiss( cr, results );
    }                                                       // burst attack
    else if( isRocket || ( weaponSubtype == WS_THROWING ) ) // ROCKETS, THROWING
    {
        bool exploding = isRocket || isGrenade;

        if( isHit || changedTarget )
        {
            if( exploding )
                CommenceExplosion( attack, map, tx, ty, realTarget, weapPid, criticalHit, valid( realTarget ) ? realTarget.Id : 0, isRocket, results );
            else if( valid( realTarget ) )          // binyan - Hex attack - added
                ApplyDamage( attack, realTarget, 1, criticalHit, !changedTarget, results );
        }
        else
        {
            // miss with missiles
            attack.Aim = HIT_LOCATION_UNCALLED;
            baseToHit += GetHitAim( aim );

            if( weaponSubtype == WS_THROWING )
                sharpshooter = 0;
            uint16 bx = 0;
            uint16 by = 0;
            uint16 pbx = 0;
            uint16 pby = 0;


            Critter@[] critsLine;
            map.GetCrittersPath( hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine, pbx, pby, bx, by );

            int  bl = 0;
            bool anyHit = false;
            for( int i = 0, j = critsLine.length(); ( i < j ) && !anyHit; i++ )
            {
                if( valid( realTarget ) && critsLine[ i ].Id == realTarget.Id )
                {
                    bl++;
                    continue;
                }                                                                                            // skip the primary target // binyan - Hex attack - added
                // adjust tohit
                dist = GetDistantion( hx, hy, critsLine[ i ].HexX, critsLine[ i ].HexY );
                acc = dist;
                toHit = baseToHit;
                if( dist < distmod2 )
                    acc += distmod2;
                else
                    acc -= accloss;
                if( -2 * perception > acc )
                    acc = -2 * perception;
                acc -= sharpshooter;
                if( acc > 0 && eyeDamage )
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = critsLine[ i ].Stat[ ST_ARMOR_CLASS ];
                if( valid( ammo ) )
                    acmod += ammo.Ammo_AcMod;
                if( acmod > 0 )
                    toHit -= acmod;
                toHit -= 10 * bl;
                if( critsLine[ i ].IsKnockout() )
                    toHit += 40;
                else
                    bl++;
                if( critsLine[ i ].GetMultihex() > 0 )
                    toHit += 15;
                toHit = CLAMP( toHit, 5, 95 );
                toHit /= 3;               // after clamp
				if ( valid( realTarget ) && ( fullParry == true || ( target.Perk[PE_ART_KIT] > 0 && target.Timeout[TO_BATTLE] == 0 ) ) )
					toHit = 0;
                if( Random( 1, 100 ) <= toHit )
                {
                    tx = critsLine[ i ].HexX;
                    ty = critsLine[ i ].HexY;
                    @normalTarget = critsLine[ i ];
                    anyHit = true;
                }
            }

            if( anyHit )
            {
				if( valid( target ) )
					NotifyOops( cr, target, normalTarget, results );
                useNormal = true;
                if( weapPid != PID_BALL )                                                                                                                    // binyan - учитывем мяч
                {
                    if( exploding )
                        CommenceExplosion( attack, map, tx, ty, normalTarget, weapPid, false, valid( realTarget ) ? realTarget.Id : 0, isRocket, results );  // binyan - Hex attack - added
                    else
                        ApplyDamage( attack, normalTarget, 1, false, false, results );
                }
            }
            else
            {
                useHex = true;
                NotifyMiss( cr, results );
                if( isGrenade || weapPid == PID_BALL )           // binyan - при промахе расчитываем отклонение от траектори и для мяча в том числе.
                {
                    // binyan - Hex attack - added
                    tx = valid( realTarget ) ? realTarget.HexX : hexX;
                    ty = valid( realTarget ) ? realTarget.HexY : hexY;
                    // /////////////////////////////////////
                    int newdist = GetDistantion( hx, hy, tx, ty ) + 1;
                    map.MoveHexByDir( tx, ty, Random( 0, 5 ), Random( 1, newdist / 2 ) );
                    newdist = GetDistantion( hx, hy, tx, ty );
                    map.GetCrittersPath( hx, hy, tx, ty, 0.0f, newdist, FIND_LIFE, null, tx, ty, bx, by );
                }
                else
                {
                    if( isRocket )
                    {
                        tx = bx;
                        ty = by;
                    }
                    else
                    {
                        tx = pbx;
                        ty = pby;
                    }
                }

                if( exploding )
                    CommenceExplosion( attack, map, tx, ty, null, weapPid, false, valid( realTarget ) ? realTarget.Id : 0, isRocket, results );  // binyan - Hex attack - added

            }
        }                                                                                                                                        // miss
                                                                                                                                                 // binyan - Бросок мяча////////////////////////////////////////////////////////////
        if( weapPid == PID_BALL )
        {
            e_ConvertBallToCrit( cr, realWeapon, tx, ty );
            FlushResults( results );           // Уведомление о промахе в случае оного.
            return;
        }
        // ////////////////////////////////////////////////////////////////////////////

        // pm added //q3: fix or remove
//        if( !attack.RealWeapon.IsStackable() )
//	        cr.AddTimeEvent( "cte_throw", 1, CTE_THROW, attack.WeaponPid );

    }
    else
        cr.Say( SAY_NETMSG, "Combat error: weapon PID=" + weapPid + " not handled, please send bug report." );

    // combat messages

    FlushResults( results );

    // stuff like animations, effects

    // Shoot
	if( !isGrenade && !isHthAttack )
		hearshot( cr, weapon, weaponMode );
	
    if( _WeaponEffect( weapon, use ) != 0 )
    {
		string sfx = "";
		switch( dmgType )
		{
			case( DAMAGE_NORMAL ): 
				if( weaponSubtype == WS_THROWING )
					sfx = "стук"; 
				if( weaponSubtype == WS_GUN )
					sfx = "стук"; 
				if( valid( realTarget ) )
					sfx = "удар";
				break;
			case( DAMAGE_LASER ): sfx = "шипение"; break;
			case( DAMAGE_FIRE ): sfx = "треск"; break;
			case( DAMAGE_PLASMA ): sfx = "щипение"; break;
			case( DAMAGE_ELECTR ): sfx = "треск"; break;
			case( DAMAGE_EMP ): sfx = "треск"; break;
			//case( DAMAGE_EXPLODE ): sfx = ""; break;
		}
		if( isGrenade ) sfx = "стук";
		
		if( sfx.length() > 0 )
			map.SetText( tx - 1, ty - 1, COLOR_LGRAY, ":" + sfx + ":" );

		if( useHex || not valid( realTarget ) )                                          // binyan - Hex attack - added
            map.RunFlyEffect( _WeaponEffect( weapon, use ), cr, null, hx, hy, tx, ty );  // yeah, the target can be null (see: grenades, rocket launcher)
        else
            map.RunFlyEffect( _WeaponEffect( weapon, use ), cr, ( useNormal ? normalTarget : realTarget ), hx, hy, tx, ty );
    }

    if( ammoRound > 0 && valid( realWeapon ) && cr.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
    {
        if( realWeapon.AmmoCount <= ammoRound )
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;

		uint[] ammo_shells_normal = { 
			PID_5MM_JHP, PID_5MM_AP, PID_7_62MM_AMMO, PID_9MM_AMMO, PID_9MM_BALL, PID_10MM_JHP, PID_10MM_AP, PID_14MM_AP, PID_44_MAGNUM_JHP, PID_44_FMJ_MAGNUM, PID_45_CALIBER_AMMO, PID_223_FMJ, PID_SHOTGUN_SHELLS, PID_2MM_EC_AMMO, PID_NEED_CART_POISON, PID_NEED_CART_NT 
		};
		bool isNormal = ammo_shells_normal.find( attack.Ammo.ProtoId ) != -1;

		uint[] ammo_shells_poor = {
			PID_10mm_LOW, PID_044mag_LOW, PID_14mm_LOW, PID_12g_LOW, PID_223_LOW
		};
		bool isLow = ammo_shells_poor.find( attack.Ammo.ProtoId ) != -1;

		for( uint i = 0; i < ammoRound; i++ )
			if( ( isNormal && Random(0,3)!=0 ) || ( isLow && Random(0,2)==0 ) )
				map.AddItem( cr.HexX + Random( -1, 1 ), cr.HexY + Random( -1, 1 ), PID_gilza, 1 );

        realWeapon.Update();
    }

    if( valid( realWeapon ) )
    {
        if( realWeapon.IsDeteriorable() && crIsPlayer )                                                // разделил условия - pm &&
        {
            if( realWeapon.GetProtoId() != PID_CLAW_EXT && realWeapon.GetProtoId() != PID_FIREBREATH ) // TabaK. Убрал износ спецоружия.
            {
                // Roleplay
                // int wearCount = (200-skillVal) - cr.StatBase[ST_LUCK];
                int wearCount = Random( 50, 100 ) - (cr.Stat [ST_LUCK]-5)*5;
                if( attack.WeaponPid == PID_DRUM_GUN_LOW || attack.WeaponPid == PID_REV_RIFLE_LOW || attack.WeaponPid == PID_BIGGUN_LOW || attack.WeaponPid == PID_SMOKE_GUN_LOW || attack.WeaponPid == PID_AUTOGUN_LOW )
                    wearCount += Random( 50, 150 );
                if( ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_10mm_LOW ) || ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_14mm_LOW ) || ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_12g_LOW ) || ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_223_LOW ) )
                    wearCount += Random( 10, 20 );
                if( skillVal < 100 )
                    wearCount += Random( 25, 75 );
                if( Random( 0, 20 ) == 20 )
                {
                    if( cr.IsPlayer() )
                        cr.Say( SAY_NETMSG, "В оружии что-то неприятно щёлкнуло." );
                    wearCount += Random( 100, 200 );
                }
                // if (cr.IsPlayer()) Log("Wearcount: " +wearCount);
                DeteriorateItem( cr, realWeapon, wearCount / 3 );
            }
            // Кнокбэк себе и ломание конечностей:
            if( realWeapon.GetProtoId() == PID_ONEHAND_ROCKET_LAUNCHER )
            {
                if( ( Random( 0, 5 ) + cr.Stat[ ST_ENDURANCE ] + cr.Stat[ ST_STRENGTH ] ) < 15 )
                {
                    if( !cr.IsDead() || !cr.IsKnockout() )
                    {
                        cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 150, cr.HexX, cr.HexY );
                        switch( Random( 0, 1 ) )
                        {
                        case 0:
                            if( cr.DamageBase[ DAMAGE_LEFT_ARM ] != 1 )
                                cr.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
                            break;                                                                                                             // Clipped RArm
                        case 1:
                            if( cr.DamageBase[ DAMAGE_RIGHT_ARM ] != 1 )
                                cr.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
                            break;                                                                                                              // if(!FLAG(eff,HF_CRIPPLED_LEFT_ARM)) return; SETFLAG(eff, HF_CRIPPLED_LEFT_ARM);  break;
                        // if(!FLAG(eff,HF_CRIPPLED_RIGHT_ARM)) return; SETFLAG(eff, HF_CRIPPLED_RIGHT_ARM); break;
                        default:
                            break;
                        }
                    }
                }
            }
        }

        // One time weapon, erase current and push next (if exist)
        if( wpnIsRemoved && cr.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
        {
            bool placeOnHex = ( skillNum == SK_THROWING && !( isGrenade || weapPid == PID_ALGAE ) );
            if( realWeapon.IsStackable() )
            {
                // Place on hex
                if( placeOnHex )
                    map.AddItem( tx, ty, weapPid, 1 );

                // Sub 1 item
                if( realWeapon.GetCount() > 1 )
                    realWeapon.SetCount( realWeapon.GetCount() - 1 );
                else
				{
					//uint[] trowable_balls = { PID_REV_BALL1, PID_REV_BALL2 };
					//if( trowable_balls.find( realWeapon.GetProtoId() ) != -1 )
					// {
						// MoveItem( realWeapon, 0, map, tx, ty );
					// }
					// else
					DeleteItem( realWeapon );
				}
            }
            else
            {
                MoveItem( realWeapon, 0, map, tx, ty );
            }
        }
    }

    // Npc miss text
    if( !attack.TargetHit && valid( target ) )  // binyan - Hex attack - added
    {
        if( !target.IsPlayer() )
            AI_TrySayCombatText( target, COMBAT_TEXT_MISS );
        target.Action( ACTION_DODGE, 0, null );                                                                    // Todo: type front/back
    }

    return;
}

//import void ApplyDamage( AttackStruct& attack, Critter& target, uint rounds, bool isCritical, bool intentionally, CombatRes[]& results ) from "combat";
void ApplyDamage( AttackStruct& attack, Critter& target, uint rounds, bool isCritical, bool intentionally, CombatRes[]& results )
{
    int dmgMul = attack.DmgMul;
    int bt = target.Stat[ ST_BODY_TYPE ];
    if( bt == BT_ZOMBIE )
        bt = BT_MEN;
    uint     eff = 0;
    uint     msgEff = 0;
    int      weaponPerk = attack.WeaponPerk;
    Critter@ attacker = attack.Attacker;
    bool     validAttacker = valid( attacker );
    Map@     map = target.GetMap();
    bool     isBloodyMess = attack.BloodyMess;
    bool     isCombatText = attack.CombatMessage;
    Item@    realWeapon = attack.RealWeapon;
    uint     aim = attack.Aim;
    uint     extraMessage = 0;
    uint     extraMessageSelf = 0;

    bool     targetIsPlayer = target.IsPlayer();
    bool     attackerIsPlayer = ( valid( attacker ) ? attacker.IsPlayer() : false );
    
    bool isBurst = attack.IsBurst;

    if( target.IsDead() || not valid( map ) )
        return;

    if( validAttacker && intentionally && target.Id != attack.TargetId )
        target.EventAttacked( attacker );

    // check if hit
    if( target.Id == attack.TargetId )
        attack.TargetHit = true;

    // Check осечки лоу-тек оружия
    if( valid( realWeapon ) && realWeapon.IsDeteriorable() )  // разделил условия
    {
        if( ( realWeapon.Deterioration >= 300 * Random( 50, 200 ) ) && valid( attack.Ammo ) && valid( attack.Attacker ) &&
            attack.Ammo.ProtoId != PID_CUENCELL_LOW && attack.Ammo.ProtoId != PID_EXPLOSIVE_ROCKET &&
            attack.Ammo.ProtoId != PID_ROCKET_AP && attack.Ammo.ProtoId != PID_GRENADELAUNCHER_AMMO &&
            attack.Ammo.ProtoId != PID_FLAMETHROWER_FUEL && attack.Ammo.ProtoId != PID_FLAMETHROWER_FUEL_MK_II &&
            attack.Ammo.ProtoId != PID_SMALL_ENERGY_CELL && attack.Ammo.ProtoId != PID_MICRO_FUSION_CELL )
        {
            if( validAttacker )
                attacker.Say( SAY_EMOTE_ON_HEAD, "заклинило" );
				
			if( Random( 0, 9 ) == 0 )
				{
				realWeapon.AmmoCount = 0;
				realWeapon.Update();
				}
            return;
        }
        // Check осечки лоу-тек оружия
        if( attack.WeaponPid == PID_DRUM_GUN_LOW ||
            attack.WeaponPid == PID_REVOLVER_LOW ||
            attack.WeaponPid == PID_PISTOL_LOW ||
            attack.WeaponPid == PID_REV_RIFLE_LOW ||
            attack.WeaponPid == PID_BIGGUN_LOW ||
            attack.WeaponPid == PID_SMOKE_GUN_LOW ||
            attack.WeaponPid == PID_AUTOGUN_LOW )
        {
            if( Random( 0, 99 ) + (attack.Attacker.Stat [ST_LUCK]-5)*3 < 15 )
            {
                if( validAttacker ) attacker.Say( SAY_EMOTE_ON_HEAD, "заклинило" );
				
				if ( Random( 0, 4 ) == 0 && attack.WeaponPid != PID_REVOLVER_LOW && attack.WeaponPid != PID_REV_RIFLE_LOW && attack.WeaponPid != PID_BIGGUN_LOW )
				{
				realWeapon.AmmoCount = 0;
				realWeapon.Update();
				}
                return;
            }
        }
        if( ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_10mm_LOW ) ||
            ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_14mm_LOW ) ||
            ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_12g_LOW ) ||
            ( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_223_LOW ) )
        {
            if( Random( 0, 99 ) + (attack.Attacker.Stat [ST_LUCK]-5)*2 < 10 )
            {
                if( validAttacker )
                    attacker.Say( SAY_EMOTE_ON_HEAD, "осечка" );
                return;
            }
        }
    }

    //grapple захват
/*    if( attack.WeaponPid == PID_HAND_GRAPPLE )
    {
        if( (!target.IsDead() && attacker.Skill[ SK_UNARMED ] - target.Skill[ SK_UNARMED ] ) >= 70 ) &&
	    ( target.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( attacker.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) &&
            aim != HIT_LOCATION_LEFT_ARM && aim != HIT_LOCATION_RIGHT_ARM && target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) )
        {
            HookMeleeAttack( attacker, target );
            attacker.Say( SAY_EMOTE_ON_HEAD, "хватает" );
            target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 15 );
        }
		else
		{
			attacker.Say( SAY_EMOTE_ON_HEAD, "пытается схватить" );
		}
    return;
    }*/
//grapple захват	
    if( attack.WeaponPid == PID_HAND_GRAPPLE )
    {
        if( !target.IsDead() && ( Random( 0, 40 ) + attacker.StatBase[ ST_STRENGTH ]*1.5 + (attacker.Stat [ST_LUCK]-5)*2 - target.StatBase[ ST_STRENGTH ]*1.5 ) + 
		  ( attacker.Skill[ SK_UNARMED ] - target.Skill[ SK_UNARMED ] ) + ( attacker.StatBase[ ST_CURRENT_HP ] - target.StatBase[ ST_CURRENT_HP ] )*0.2 +
		  ( attacker.StatBase[ ST_AGILITY ] - target.StatBase[ ST_AGILITY ] ) >= 30)
        {
            HookMeleeAttack( attacker, target );
            attacker.Say( SAY_EMOTE_ON_HEAD, "хватает" );
        }
		else
		{
			attacker.Say( SAY_EMOTE_ON_HEAD, "пытается схватить" );
		}
    return;
    }

    // Check no PvP
    if( targetIsPlayer && attackerIsPlayer && validAttacker && ( attacker.Mode[ MODE_NO_PVP ] != 0 || target.Mode[ MODE_NO_PVP ] != 0 ) )
    {
        if( validAttacker )
            attacker.Say( SAY_NETMSG, "No PvP." );
        target.Say( SAY_NETMSG, "No PvP." );
        return;
    }

    // Проверка на мячик  -  binyan
    if( target.GetProtoId() == NPC_PID_Ball )
    {
        BallAttackHandling( target, attacker, attack.WeaponPid );
        return;
    }
    if( target.Mode[ MODE_HIDE ] != 0 && ( !target.IsPlayer() || target.GetAccess() == ACCESS_CLIENT ) )
        target.ModeBase[ MODE_HIDE ] = 0;

// Flash grenade - binyan//////////////////////////////////
    if( attack.WeaponPid == PID_FLASH_GRENADE )
    {
        uint8 dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
        // Применяем flash эффект, ослепляем цели на определенное время.
        ApplyFlashEff( target, dist );
        return;
    }
// /////////////////////////////////////////////////////////

    int targetTimeout = BATTLE_TIMEOUT( target );
    if( target.Timeout[ TO_BATTLE ] < targetTimeout - __FullSecond )
        target.TimeoutBase[ TO_BATTLE ] = targetTimeout;
    target.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( target );

    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
        isCritical = false;

    // if( isCritical && target.Perk[ PE_TERMINATOR ] != 0 && ( target.StatBase[ ST_STRENGTH ] + target.StatBase[ ST_ENDURANCE ] ) * 5 >= Random( 1, 100 ) )
        // isCritical = false;
    else if( isCritical || attack.ForceFlags != 0 )
    {
        if( isCritical )
        {
            int aim_ = aim;
            if( aim_ == HIT_LOCATION_NONE )
                aim_ = HIT_LOCATION_UNCALLED;
            aim_--;
            // int roll=Random(0,85)+(validAttacker?(  (attacker.Perk[PE_BETTER_CRITICALS]!=0?20:0)+(attacker.Trait[TRAIT_HEAVY_HANDED]!=0?-30:0)):0);
            int MaxRoll = 80 + ( validAttacker ? ( attacker.Stat[ ST_MAX_CRITICAL ] ) : 0 );
            int roll = Random( 0, MaxRoll );
            if( roll <= 35 )
                roll = 0;
            else if( roll <= 70 )
                roll = 1;
            else if( roll <= 90 )
                roll = 2;
            else if( roll <= 95 )
                roll = 3;
            else if( roll <= 100 )
                roll = 4;

            // 0x00000001 - knockout
            // 0x00000002 - knockdown
            // 0x00000004 - crippled left leg
            // 0x00000008 - crippled right leg
            // 0x00000010 - crippled left arm
            // 0x00000020 - crippled right arm
            // 0x00000040 - blinded
            // 0x00000080 - death
            // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug) // not used now
            // 0x00000800 - bypass armor
            // 0x00004000 - dropped weapon (doesn't work) // haha, really?
            // 0x00008000 - lose next turn
            // 0x00200000 - random

            uint offset = bt * 9 * 6 * 7 + aim_ * 6 * 7 + roll * 7;
            dmgMul *= CriticalTable[ offset ];
            dmgMul >>= 1;
            eff = CriticalTable[ offset + 1 ];
            int  stat = CriticalTable[ offset + 2 ];
            int  statMod = CriticalTable[ offset + 3 ];

            uint cMessage = CriticalTable[ offset + 5 ];
            uint cFailureMessage = CriticalTable[ offset + 6 ];

            extraMessage = cMessage;

            if( stat != -1 )
                if( Random( 1, 10 ) > target.Stat[ stat ] + statMod )
                {
                    eff |= CriticalTable[ offset + 4 ];
                    extraMessage = cFailureMessage;
                }

            if( weaponPerk == WEAPON_PERK_ENHANCED_KNOCKOUT )
                SETFLAG( eff, HF_KNOCKOUT );

            if( target.Mode[ MODE_NO_KNOCK ] != 0 )
                UNSETFLAG( eff, HF_KNOCKDOWN );
            // else if( FLAG( eff, HF_KNOCKDOWN ) && target.Perk[ PE_STONEWALL ] != 0 && ( Random( 0, 100 ) < 50 ) )
                // UNSETFLAG( eff, HF_KNOCKDOWN );
        }

        if( attack.ForceFlags != 0 )
        {
            eff |= attack.ForceFlags;
            isCritical = true;
        }

        // in the following: in no lose limbs, then clear the effects and set msgEff
        // otherwise set msgEff first, then check for HF_RANDOM
        if( target.Mode[ MODE_NO_LOOSE_LIMBS ] != 0 )
        {
            UNSETFLAG( eff, ( HF_CRIPPLED_LEFT_LEG | HF_CRIPPLED_RIGHT_LEG | HF_CRIPPLED_LEFT_ARM | HF_CRIPPLED_RIGHT_ARM | HF_RANDOM ) );
            msgEff = eff;
        }
        else
        {
            msgEff = eff;

            if( FLAG( eff, HF_RANDOM ) )
            {
                UNSETFLAG( eff, HF_RANDOM );
                switch( Random( 1, 4 ) )
                {
                case 1:
                    SETFLAG( eff, HF_CRIPPLED_LEFT_LEG );
                    break;
                case 2:
                    SETFLAG( eff, HF_CRIPPLED_RIGHT_LEG );
                    break;
                case 3:
                    SETFLAG( eff, HF_CRIPPLED_LEFT_ARM );
                    break;
                case 4:
                    SETFLAG( eff, HF_CRIPPLED_RIGHT_ARM );
                    break;
                default:
                    break;
                }
            }
        }
        if( target.Mode[ MODE_NO_DROP ] != 0 )
        {
            UNSETFLAG( eff, HF_DROPPED_WEAPON );
            UNSETFLAG( msgEff, HF_DROPPED_WEAPON );
        }

        if( validAttacker && attackerIsPlayer )
            attacker.AddScore( SCORE_SNIPER, 1 );
    }     // end isCritical

    if( weaponPerk == WEAPON_PERK_ENHANCED_KNOCKOUT )
    {
        if( validAttacker )
            if( Random( 1, 100 ) <= ( attacker.Stat[ ST_STRENGTH ] ) - 8 )
                SETFLAG( eff, HF_KNOCKOUT );
    }     // not messaged

    int dmgType = attack.DmgType;
    int targetDR = target.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
    int targetDT = target.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];

    if( FLAG( eff, HF_BYPASS_ARMOR ) && dmgType != DAMAGE_EMP )
    {
        targetDT /= 5;
        targetDR /= 5;
        targetDR -= ( valid( attacker ) ? ( attacker.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 ) : 0 );
    }
    else if( weaponPerk == WEAPON_PERK_PENETRATE )
        targetDT /= 5;

    targetDR += ( validAttacker ? ( attacker.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 ) : 0 );
    targetDR += attack.DRMod;   // always
    targetDR = CLAMP( targetDR, 0, 100 );
    int dmgMin = attack.DmgMin + attack.BonusDmg;
    ;
    int dmgMax = attack.DmgMax + attack.BonusDmg;
    ;
    int rawDmg;
    int totalDmg = 0;
    dmgMul *= attack.DMMod;
    int dmgDiv = 2 * attack.DDMod;

    if( attack.WeaponSubtype == WS_MELEE && attack.RealWeapon.IsDeteriorable() )   // pm added
    {
        dmgMin -= dmgMin * ( GetDeteriorationProcent( attack.RealWeapon ) * 0.01 );
        dmgMax -= dmgMax * ( GetDeteriorationProcent( attack.RealWeapon ) * 0.01 );
    }
	
	if ( attack.Attacker.Param[ QST_GAMEMODE ] == GAME_TEST ) attack.Attacker.Say( SAY_NETMSG, "DMin= "+ dmgMin+", DMax= "+dmgMax+", dmgMul= "+dmgMul+", dmgDiv= "+dmgDiv); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "DMin= "+ dmgMin+", DMax= "+dmgMax+", dmgMul= "+dmgMul+", dmgDiv= "+dmgDiv); //TestInfo

    for( uint i = 0; i < rounds; i++ )
    {
        rawDmg = Random( dmgMin, dmgMax );
        rawDmg *= dmgMul;
        rawDmg /= dmgDiv;
		
		if ( attack.Attacker.Param[ QST_GAMEMODE ] == GAME_TEST ) attack.Attacker.Say( SAY_NETMSG, "raw= "+ rawDmg); //TestInfo
		if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "raw= "+ rawDmg); //TestInfo

		rawDmg -= targetDT;
        rawDmg -= rawDmg * targetDR * 0.01;
		
        if( rawDmg > 0 )
            totalDmg += rawDmg;
    }
	
	if ( attack.Attacker.Param[ QST_GAMEMODE ] == GAME_TEST ) attack.Attacker.Say( SAY_NETMSG, "total= "+ totalDmg); //TestInfo
	if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "total= "+ totalDmg); //TestInfo
	
	
    if( validAttacker && valid( target ))                 // pm added
    {
        if( aim == HIT_LOCATION_HEAD )
            totalDmg += totalDmg * 0.2;
        if (aim == HIT_LOCATION_GROIN) {
        	totalDmg += totalDmg * 0.2;
        } // Kriegwolf: Небольшие фиксы боли
        else if( aim == HIT_LOCATION_LEFT_ARM || aim == HIT_LOCATION_RIGHT_ARM || aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG )
        {
			totalDmg -= totalDmg * 0.25;
        }

        // if( attack.Attacker.Perk[ PE_LIVING_ANATOMY ] != 0 && !( bt == BT_ALIEN || bt == BT_ROBOT ) )
            // totalDmg += 5;
       
		// if( attack.Attacker.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
            // totalDmg += 10;
		
		if ( target.Perk[PE_ART_KIT] > 0 && target.TimeoutBase[TO_BATTLE] == 0 )
		{
			totalDmg = 0;
			target.TimeoutBase[TO_BATTLE] = __FullSecond + REAL_SECOND( 10 );
		}
		
		if( target.TraitBase[TRAIT_SEX_APPEAL] > 0 )
			totalDmg += totalDmg * 0.5; //Плюс 50% чистого урона по сексуашкам.
			
		if( target.Stat[ ST_CURRENT_HP ] <= 0 && aim == HIT_LOCATION_HEAD && target.ModeBase[ MODE_INVULNERABLE ] == 0) //Добивание как игроков, так и на нпц
			{
           	attack.Attacker.StatBase[ ST_VAR0 ] = target.Id;
			attack.Attacker.ParamBase[ ST_VAR5 ] = 3;
			attack.Attacker.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_COUP_DE_GRACE" );
	        attack.Attacker.Say( SAY_DIALOGBOX_TEXT, "Добить цель?");
			attack.Attacker.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Добить" );
            }
        if( targetIsPlayer)
		{
			//if( !attack.Attacker.IsNpc() && attack.Attacker.Param[ ST_LEVEL ] <= 3 && target.Param[ ST_LEVEL ] >= 4 ) totalDmg *= 0.5; //1-3 лвл-ы наносят 50% от своего урона по 4-12 лвл-ам.
			//if( attack.Attacker.Param[ ST_LEVEL ] >= 4 && target.Param[ ST_LEVEL ] <= 3 ) totalDmg *= 3; // пижамы огребают в три раза сильнее //Srkf
			// if( target.Perk[ PE_TERMINATOR ] > 0 && target.Perk[ PE_HTH_EVADE ] <= 0 ) totalDmg *= 0.7; //Продался в рабство ПигБоссу
			// if( target.Perk[ PE_HTH_EVADE ] > 0 && target.Perk[ PE_TERMINATOR ] <= 0 ) totalDmg *= 0.7; //Сила красоты
			// if( target.Perk[ PE_TERMINATOR ] > 0 && target.Perk[ PE_HTH_EVADE ] > 0 ) totalDmg *= 0.5; // Комбинация Терм|Сила красоты
			// if( target.Perk[ PE_KARMA_BEACON ] > 0 && target.Perk[ PE_HTH_EVADE ] <= 0 ) totalDmg *= 0.9; //Сила тупизны //Che
				
			if( dmgType == DAMAGE_NORMAL && valid( attack.Ammo ) && target.StatBase[ ST_BODY_TYPE ] != BT_ROBOT && Random( 0, 1 ) == 0 && ( totalDmg >= (0.25 * target.Stat[ ST_CURRENT_HP ]) ) && !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) ) // тяжкое пулевое
			{
				ChangeStatus( target, CR_STATUS_BULLET_OVER, 0, true );
				if( !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
				ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, true );
			}
			if( Random( 0, 1 ) == 0 && ( totalDmg >= target.Stat[ ST_CURRENT_HP ]*0.3) && target.StatBase[ ST_BODY_TYPE ] != BT_ROBOT && !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) ) // тяжелое ранение
				ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, true );
			if( attack.Attacker.GetProtoId() == 128 && targetIsPlayer ) // Modoc guards
            {
				if( target.Param[ QST_GAMEMODE ] == GAME_ARCADE )
				   totalDmg += 40;
				if( target.Stat[ ST_CURRENT_HP ] < totalDmg )
				   totalDmg = ABS( target.Stat[ ST_CURRENT_HP ] ) + 2;
            }
			
			if ( attack.Attacker.Param[ QST_GAMEMODE ] == GAME_TEST ) attack.Attacker.Say( SAY_NETMSG, "aftertotal= "+ totalDmg); //TestInfo
			if ( valid( target ) && target.Param[ QST_GAMEMODE ] == GAME_TEST ) target.Say( SAY_NETMSG, "aftertotal= "+ totalDmg); //TestInfo
		}     // end of pm added
		if( target.Stat[ ST_BODY_TYPE ] == BT_ROBOT ) totalDmg *= 0.7; // Базовый резист роботам ( временно )
		/*if( target.StatBase[ ST_BODY_TYPE ] == BT_ROBOT && !FLAG( target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) ) // тяжелое ранение
	    {
			int rob = 0;
			if( totalDmg >= target.StatBase[ ST_LUCK ]*4 + target.StatBase[ ST_MAX_LIFE ]*0.1)
			{
				rob = 2;
				if( target.IsNpc() ) target.Say( SAY_NORM_ON_HEAD, "ПРОБИТИЕ ПЕРВОГО УРОВНЯ БРОНИ" );
				target.Say( SAY_NETMSG, "###ПРОБИТИЕ 1-K###" );
				totalDmg += 2;
			}
			if( rob >= 2 && totalDmg >= ( target.StatBase[ ST_MAX_LIFE ]/2 )*0.4 )
			{
				if( target.IsNpc() ) target.Say( SAY_NORM_ON_HEAD, "ПРОБИТИЕ ВТОРОГО УРОВНЯ БРОНИ" );
				target.Say( SAY_NETMSG, "###ПРОБИТИЕ 2-K###" );
				rob = 4;
				totalDmg += 3;
			}
			if( Random( 0, 1 ) == 0 && rob >= 4 && totalDmg >= 35 )
			{
				target.Say( SAY_NETMSG, "###ПРОБИТИЕ 3-K###" );				
				map.PlaySound( "robot_damage1.ogg", target.HexX, target.HexY, 60 );
				map.RunEffect( PID_EXPLODE_FIRE_BIG, target.HexX, target.HexY, 6 );
				target.Say( SAY_NETMSG, "###ВНИМАНИЕ! РАЗГЕРМЕТИЗАЦИЯ###" );
				target.Say( SAY_NORM, "#!@&#@!KO#BA&$URN@HLL#%PDR!" );
				totalDmg += 20;
				ChangeStatus( target, CR_STATUS_HEAVY_DMG, 0, true );
			}
	    }*/
		if( attack.Attacker.Param [P_PSI_LIMIT] >= 160 && valid( realWeapon ) && realWeapon.AmmoCount >= 1 ) //Проверка на пси-разложение
		{
			int roll = Random( 1, 20 ) + attack.Attacker.Stat[ ST_INTELLECT ] + attack.Attacker.Stat [ST_LUCK];
			if( roll <= 20 )
			{
				//attack.Attacker.ParamBase[BP_HEAD_HP] = 3000; 
				attack.Attacker.Say( SAY_EMOTE, "Стреляет себе в голову"); 
				attack.Attacker.ToDead( ANIM2_DEAD_BLOODY_SINGLE, attack.Attacker );
				Log_Killings( attack.Attacker, attack.Attacker.Id, 0, 0, null, null );
			}
			else
			{
				attack.Attacker.Say( SAY_EMOTE, "Еле сдерживается, чтобы не прострелить себе голову"); 
			}
		}
		bool canBleed = true;
		
		int bodyType = target.Stat[ST_BODY_TYPE];
		if ( ( bodyType == BT_ROBOT ) || ( bodyType == BT_PLANT ) ) canBleed = false;
		
		if( ( totalDmg > 5 ) && canBleed )
		{
			if ( Random( 0, 9 ) == 0 && target.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0 ) target.EraseTimeEvents( CTE_SLOWRELOAD ); // остановка перезарядки при повреждении
			if ( Random( 0, 1 ) == 0 && target.GetTimeEvents( CTE_HEAL, null, null, null ) > 0 ) target.EraseTimeEvents( CTE_HEAL ); // остановка долговременного лечения при повреждении
			if ( dmgType == DAMAGE_NORMAL && totalDmg >= target.Param[ ST_NORMAL_RESIST ] / 2 ) // Шанс выпадания кровотечения
			{
				uint[] bleed_weapon = {
					PID_10MM_SMG, PID_HUNTING_RIFLE, PID_MINIGUN, PID_ROCKET_LAUNCHER, PID_DESERT_EAGLE, PID_14MM_PISTOL, PID_ASSAULT_RIFLE, PID_FRAG_GRENADE, PID_9MM_MAUSER, PID_SNIPER_RIFLE, PID_223_PISTOL, PID_COMBAT_SHOTGUN,
					PID_HK_CAWS, PID_SHARP_SPEAR, PID_TOMMY_GUN, PID_SCOPED_HUNTING_RIFLE, PID_HK_P90C, PID_ZIP_GUN, PID_44_MAGNUM_REVOLVER, PID_GREASE_GUN, PID_BOZAR, PID_FN_FAL, PID_HK_G11, PID_INDEPENDENT, PID_PANCOR_JACKHAMMER,
					PID_LIGHT_SUPPORT_WEAPON, PID_M60, PID_AVENGER_MINIGUN, PID_HK_G11E, PID_M72_GAUSS_RIFLE, PID_PK12_GAUSS_PISTOL, PID_VINDICATOR_MINIGUN, PID_44_MAGNUM_SPEEDLOADER, PID_FN_FAL_NIGHT_SCOPE, PID_DESERT_EAGLE_EXT_MAG,
					PID_FN_FAL_HPFA, PID_DUAL_MINIGUN, PID_HEAVY_DUAL_MINIGUN, PID_MAUSER_SMG, PID_COLT, PID_CLAW_EXT, PID_SCISSORS, PID_ONEHAND_ROCKET_LAUNCHER, PID_GRENADELAUNCHER, PID_REMINGTON, PID_ANACONDA, PID_SPEAK_P, PID_GATLING_LOW,
					PID_DRUM_GUN_LOW, PID_REVOLVER_LOW, PID_PISTOL_LOW, PID_REV_RIFLE_LOW, PID_GECKO_LOW, PID_BIGGUN_LOW, PID_BOOMERANG_LOW, PID_SMOKE_GUN_LOW, PID_14mm_BIGGUN2_LOW, PID_3GUN_LOW, PID_DOUBLE_RIFLE, PID_SPIKED_KNUCKLES, PID_KNIFE,
					PID_KNIFE_P, PID_COMBAT_KNIFE, PID_LIL_JESUS_WEAPON, PID_SWITCHBLADE, PID_WAKIZASHI_BLADE, PID_RIPPER, PID_THROWING_KNIFE, PID_MKNIFE_P, PID_REV_BALL1, PID_REV_BALL2, PID_REVFIST1, PID_REVKNIFE1, PID_REVKNIFE2, PID_REVCLUB1,
					PID_SNIPER_GUN_LOW, PID_LOW_SNIPER2, PID_LOW_SNIPER3, PID_SAWGUN_LOW, PID_SHOTGUN, PID_SAWED_OFF_SHOTGUN, PID_SHOTPISTOL_LOW, PID_QUADRO_SHOTGUN
				};
				if( bleed_weapon.find( attack.WeaponPid ) != -1 )
					ChangeStatus( target, CR_STATUS_BLEED, totalDmg / 1.5 , true ); //кровотечение, равное 2/3 от входящего урона.
			}
		}
	}
    

    // 0x00000001 - knockout
    // 0x00000002 - knockdown
    // 0x00000004 - crippled left leg
    // 0x00000008 - crippled right leg
    // 0x00000010 - crippled left arm
    // 0x00000020 - crippled right arm
    // 0x00000040 - blinded
    // 0x00000080 - death
    // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug)
    // 0x00000800 - bypass armor
    // 0x00004000 !- dropped weapon (doesn't work)
    // 0x00008000 - lose next turn

    // code for dropping weapon, adapted from critical failures
 
 if( FLAG( eff, HF_DROPPED_WEAPON ) )
    {
        Item@ realWeaponTarget = _CritGetItemHand( target );
        if( valid( realWeaponTarget ) )
        {
            if( realWeaponTarget.IsStackable() )
            {
                Item@ dropped = map.AddItem( target.HexX, target.HexY, realWeaponTarget.GetProtoId(), 1 );
                if( realWeaponTarget.GetCount() > 1 )
                    realWeaponTarget.SetCount( realWeaponTarget.GetCount() - 1 );
                else
                    DeleteItem( realWeaponTarget );

                if( !target.IsPlayer() )
                {
                    NpcPlane@ plane = CreatePlane();
                    NpcPlane@[] crPlanes( 0 );

                    if( target.GetPlanes( crPlanes ) > 0 )
                        plane.Priority = crPlanes[ 0 ].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = dropped.HexX;
                    plane.Pick_HexY = dropped.HexY;
                    plane.Pick_Pid = dropped.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    target.AddPlane( plane );
                }
            }
            else
            {
                MoveItem( realWeaponTarget, 0, map, target.HexX, target.HexY );
                if( !target.IsPlayer() )
                {
                    NpcPlane@ plane = CreatePlane();

                    NpcPlane@[] crPlanes( 0 );

                    if( target.GetPlanes( crPlanes ) > 0 )
                        plane.Priority = crPlanes[ 0 ].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeaponTarget.HexX;
                    plane.Pick_HexY = realWeaponTarget.HexY;
                    plane.Pick_Pid = realWeaponTarget.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    target.AddPlane( plane );
                }
            }
        }
    }

    bool isKo = false;
    bool knockDown = false;
    bool knockOut = false;
    bool isDead = false;
    bool loseTurn = false;
    bool isBelow = false;
    int  knockDmg = totalDmg;


    if( target.Mode[ MODE_INVULNERABLE ] != 0 )
        eff = 0;
    // Knock down
    if( FLAG( eff, HF_KNOCKDOWN ) )
    {
        isKo = true;
        knockDown = true;
    }
    else if( dmgType == DAMAGE_EXPLODE && totalDmg > 9 )
        isKo = true;

    // Clipped LLeg
    if( FLAG( eff, HF_CRIPPLED_LEFT_LEG ) )
        target.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
    // Clipped RLeg
    if( FLAG( eff, HF_CRIPPLED_RIGHT_LEG ) )
        target.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
    // Clipped LArm
    if( FLAG( eff, HF_CRIPPLED_LEFT_ARM ) )
        target.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
    // Clipped RArm
    if( FLAG( eff, HF_CRIPPLED_RIGHT_ARM ) )
        target.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
    // Blinded
    if( FLAG( eff, HF_BLINDED ) )
        target.DamageBase[ DAMAGE_EYE ] = 1;

    // all legs clipped, can't move //pm added
    uint8 noMove = target.DamageBase[ DAMAGE_LEFT_LEG ] > 0 && target.DamageBase[ DAMAGE_RIGHT_LEG ] > 0 ? 1 : 0;
    if( target.IsPlayer() ) target.ModeBase[ MODE_NO_WALK ] = noMove;
    target.ModeBase[ MODE_NO_RUN ] = noMove;

    // Lose turn
    if( FLAG( eff, HF_LOST_NEXT_TURN ) )
    {
        isKo = true;
        loseTurn = true;
    }
    // Knock out
    if( FLAG( eff, HF_KNOCKOUT ) )
    {
        isKo = true;
        knockOut = true;
        loseTurn = false;       // overridden
    }

    // Instant death
    if( FLAG( eff, HF_DEATH ) )
        if( target.Stat[ ST_CURRENT_HP ] > totalDmg )
            totalDmg = target.Stat[ ST_CURRENT_HP ];
            
    if (target.Stat [ST_BODY_TYPE] == BT_ROBOT && FLAG(target.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG)) totalDmg *= 1.2;
    bool safeMode = (valid (realWeapon) && (realWeapon.GetProtoId() == PID_BOXING_GLOVES || realWeapon.GetProtoId() == PID_RING_BOXING_GLOVES ));

    if( totalDmg > 0 )
    {
        if( target.Mode[ MODE_INVULNERABLE ] == 0 )
        {
			target.StatBase[ ST_CURRENT_HP ] -= totalDmg;
			
            if( target.Stat[ ST_CURRENT_HP ] < 1 )
            {
				bool bloodyAttack = attacker.TraitBase[TRAIT_BLOODY_MESS] == 1 || target.TraitBase[TRAIT_BLOODY_MESS] == 1;
				uint[] not_bloody_attacks = { 
					PID_HAND_ATTACK1, PID_HAND_ATTACK2, PID_HAND_ATTACK3, //удары руками
					PID_HAND_GRAPPLE, PID_BOXING_GLOVES, PID_RING_BOXING_GLOVES, //захват и боксёрские перчи
					PID_LEG_ATTACK1, PID_LEG_ATTACK2, PID_LEG_ATTACK3 }; //удары ногами
				bloodyAttack = bloodyAttack && ( not_bloody_attacks.find( attack.WeaponPid ) == -1 ); 
				if( ( !target.IsPlayer() && bloodyAttack ) || target.StatBase[ ST_CURRENT_HP ] < __DeadHitPoints )
					isDead = true;
				
                if( target.Mode[ MODE_NO_KNOCK ] == 0 )
                {
                    isKo = true;
                    isBelow = true;
                }
            }

            ChangeCritterSpeed( target );      // pm added
        }

		/* //Гриндач отключён.
        if( (attacker.Param[ ST_LEVEL ] >= 4) && ((aim == HIT_LOCATION_HEAD) || (aim == HIT_LOCATION_TORSO) || aim == HIT_LOCATION_UNCALLED))  //опыт за урон
        {
            attacker.StatBase[ ST_EXPERIENCE ] += totalDmg;
            // ChangeWildness(target.WorldX/10, target.WorldY/10, 2);
        }
		*/
        if( attacker.Param[ ST_LEVEL ] >= 1 || target.Param[ ST_LEVEL ] >= 1 ) //Логгирование
        {
			unsafe_log_1( attacker, 0, 0, 0, attacker.Name + " " + attacker.Id + " нанес " + totalDmg + " урона " + " игроку " + target.Name + " " + target.Id, null );
            // ChangeWildness(target.WorldX/10, target.WorldY/10, 2);
        }
		/*
        if( !targetIsPlayer && attackerIsPlayer && attacker.Param[ QST_GAMEMODE ] == GAME_ARCADE )
            target.StatBase[ ST_DESEASE ] = 1;  // Опыт за урон в ркадном режиме
		*/
        // Score
        if( attack.scoreUnarmed && validAttacker && attackerIsPlayer )
            attacker.AddScore( SCORE_UNARMED_DAMAGE, totalDmg );
    }

    bool attackFront = true;
    uint dir = GetDirection( attack.Hx, attack.Hy, target.HexX, target.HexY );
    if( ( dir == target.Dir || ( ( dir + 1 ) % 6 ) == target.Dir || ( ( dir + 5 ) % 6 ) == target.Dir ) )
        attackFront = false;

    int   armorDr = target.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
    Item@ armor = _CritGetItemArmor( target );
    if( valid( armor ) && targetIsPlayer )
        DeteriorateItem( target, armor, ( ( 100 - armorDr ) * rounds + totalDmg ) / 3 );

    // Dead
    if( isDead )
    {
        bool burst = attack.IsBurst;
        uint anim2Dead = 0;

		if( attackFront )
			anim2Dead = ANIM2_DEAD_FRONT;
		else
			anim2Dead = ANIM2_DEAD_BACK;

		switch( dmgType )
		{
		case DAMAGE_UNCALLED: 
			break;
		case DAMAGE_NORMAL:
			if( burst )
			{
				if( isCritical || isBloodyMess )
					anim2Dead = ANIM2_DEAD_BLOODY_BURST;
				else
					anim2Dead = ANIM2_DEAD_BURST;
			}
			else
			{
				if( isCritical || isBloodyMess )
					anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
			}
			break;
		case DAMAGE_LASER:
			anim2Dead = ANIM2_DEAD_LASER;
			break;
		case DAMAGE_FIRE:
			if( Random( 0, 3 ) == 0 )
				anim2Dead = ANIM2_DEAD_BURN;
			else
				anim2Dead = ANIM2_DEAD_BURN_RUN;
			break;
		case DAMAGE_PLASMA:
			anim2Dead = ANIM2_DEAD_FUSED;
			break;
		case DAMAGE_ELECTR:
			if( Random( 0, 3 ) == 0 )
				anim2Dead = ANIM2_DEAD_PULSE_DUST;
			else
				anim2Dead = ANIM2_DEAD_PULSE;
			break;
		case DAMAGE_EXPLODE:
			anim2Dead = ANIM2_DEAD_EXPLODE;
			break;
		default:
			break;
		}
		if( ( anim2Dead == ANIM2_DEAD_FRONT || anim2Dead == ANIM2_DEAD_BACK || anim2Dead == 0 ) && target.IsKnockout() )
		{
			if( target.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
				anim2Dead = ANIM2_DEAD_PRONE_FRONT;
			else
				anim2Dead = ANIM2_DEAD_PRONE_BACK;
			target.Say( SAY_NETMSG, "У вас ещё есть шанс выкарабкаться в ближайшие полчаса, если сможете достать врача." );
		}
		else
		{
			target.Say( SAY_NETMSG, "Полученные повреждения слишком обширны, вас уже не спасти. Разум постепенно покидает ваше тело." );
		}

        if( targetIsPlayer )
            target.AddScore( SCORE_ZOMBY, 1 );

        if( validAttacker && attackerIsPlayer )
        {
            attacker.AddScore( SCORE_KILLER, 1 );
            if( targetIsPlayer )
            {
                attacker.AddScore( SCORE_MANIAC, 1 );
                target.StatBase[ ST_KILLER_PERSON ] = attacker.Id;
                if( attacker.Param[ QST_GAMEMODE ] != GAME_ARCADE && target.Param[ QST_GAMEMODE ] != GAME_ARCADE )
                    Log_Killings( attacker, target.Id, 0, 0, null, null );
            }
            else if( target.Id == attack.TargetId )
                target.AddEnemyInStack( attacker.Id );
        }

        if( validAttacker && !attackerIsPlayer )
            attacker.EraseEnemyFromStack( target.Id );

        if( valid( attacker ) && ( attacker.Param[ QST_GAMEMODE ] == GAME_ARCADE || target.Stat[ ST_DESEASE ] != 1 ) )
        {
            // attacker.StatBase[ST_EXPERIENCE]+=target.Stat[ST_KILL_EXPERIENCE];
            attacker.KillBase[ KILL_BEGIN + bt ]++;
        }

		if( valid(attacker) && valid(target) && attacker.IsPlayer() && !target.IsPlayer() )
			attacker.StatBase[ST_EXPERIENCE] += target.Stat[ST_KILL_EXPERIENCE];
        target.ToDead( anim2Dead, attacker );
    }
    else if( isKo )
    {
        int maxAp = target.Stat[ ST_ACTION_POINTS ];
        int currentAp = target.Stat[ ST_CURRENT_AP ];
        int targetAp = currentAp;
        if( loseTurn )
        {
            targetAp = -maxAp;
            target.StatBase[ ST_MOVE_AP ] = 0;
        }
        if( knockOut )
            targetAp = -Random( maxAp, 3 * maxAp );
        if( knockDown && !( target.IsKnockout() && map.IsTurnBased() ) )
            targetAp -= 30;
            // targetAp -= ( target.Perk[ PE_QUICK_RECOVERY ] != 0 ? 1 : 3 );
        if( ( isBelow || knockOut || knockDown || dmgType == DAMAGE_EXPLODE ) && !target.IsKnockout() && !target.IsDead() && target.Mode[ MODE_NO_KNOCK ] == 0 )
        {
            int knockDist = knockDmg;
            if( ( dmgType == DAMAGE_EXPLODE || attack.WeaponSubtype == WS_MELEE ) && target.IsCanWalk() )
            {
                if( weaponPerk == WEAPON_PERK_KNOCKBACK )
                    knockDist /= 5;
                else
                    knockDist /= 10;
                // if( target.Perk[ PE_STONEWALL ] != 0 )
                    // knockDist /= 2;
                knockDist--;
                if( knockDist > 10 )
                    knockDist = 10;
                uint16 knockHx = attack.Hx;
                uint16 knockHy = attack.Hy;
                if( knockDist > 0 )
                {
                    map.GetHexCoordWall( target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist );
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, knockHx, knockHy );
					target.Wait(GetActionTime(ACTION_KNOCKOUT, target));
                }
                else
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
					target.Wait(GetActionTime(ACTION_KNOCKOUT, target));
            }
            else
                target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( attackFront ), 0, target.HexX, target.HexY );
				target.Wait(GetActionTime(ACTION_KNOCKOUT, target));
        }
        /*
		if( targetAp < currentAp )
            target.StatBase[ ST_CURRENT_AP ] = 100 * targetAp;
		*/
    }

    // Damage
    else if( not target.IsKnockout() )
    {
		/*
		target.Wait( GetActionTime(ACTION_DAMAGE, target) );
		target.Action( ACTION_DAMAGE_FORCE, attackFront ? 0 : 1, null );
		*/

        // Npc hit message
        if( isCombatText && dmgType != DAMAGE_UNCALLED && !targetIsPlayer )
        {
            switch( aim )
            {
            case HIT_LOCATION_NONE:
            case HIT_LOCATION_UNCALLED:
            case HIT_LOCATION_TORSO:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_TORSO );
                break;
            case HIT_LOCATION_EYES:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_EYES );
                break;
            case HIT_LOCATION_HEAD:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_HEAD );
                break;
            case HIT_LOCATION_LEFT_ARM:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_LEFT_ARM );
                break;
            case HIT_LOCATION_RIGHT_ARM:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_RIGHT_ARM );
                break;
            case HIT_LOCATION_GROIN:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_GROIN );
                break;
            case HIT_LOCATION_RIGHT_LEG:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_RIGHT_LEG );
                break;
            case HIT_LOCATION_LEFT_LEG:
                AI_TrySayCombatText( target, COMBAT_TEXT_HIT_LEFT_LEG );
                break;
            default:
                break;
            }
        }
    }

    bool isAimed = ( aim != HIT_LOCATION_NONE ) && ( aim != HIT_LOCATION_TORSO ) && ( aim != HIT_LOCATION_UNCALLED );

    uint mainMsg = CMSG_HIT;
    uint length = 3;

    if( isCritical )
    {
        mainMsg += 2;
        length += 2;
    }
    if( isDead )
    {
        mainMsg += 4;
        if( isCritical )
            length -= 1;
    }
    if( isAimed )
    {
        mainMsg += 1;
        length += 1;
    }

    uint[] sendEff( length );
    sendEff[ 0 ] = mainMsg;
    sendEff[ 1 ] = target.Id;
    uint now = 2;

    if( isAimed )
    {
        sendEff[ 2 ] = aim;
        now++;
    }

    sendEff[ now ] = totalDmg;
    now++;

    if( isCritical )
    {
        if( !isDead )
        {
            sendEff[ now ] = msgEff;
            now++;
        }

        sendEff[ now ] = extraMessage;
    }

    Critter@[] source = { target };
    Critter@[] crits;

    if( @target.GetMap() != null )
    {
        target.GetMap().GetCrittersSeeing( source, true, FIND_ALL | FIND_ONLY_PLAYERS, crits );

        for( int i = 0, j = crits.length(); i < j; i++ )
            if( crits[ i ].Id != target.Id )
                AddEff( crits[ i ], sendEff, results );
    }
    if( isCritical )
        sendEff[ now ] = extraMessage + 1500;       // men_player - men_npc

    AddEff( target, sendEff, results );

    // poisoning and irradiating:
    if( validAttacker )
    {
        int poison = attacker.Stat[ ST_TOXIC ];
        int radiation = attacker.Stat[ ST_RADIOACTIVE ];
        if( poison != 0 || radiation != 0 )
        {
            if( Random( 2, 11 ) > target.Stat[ ST_LUCK ] && !attackerIsPlayer ) // ErlKing  temporary
            {
                if( poison > 0 )
                    AffectPoison( target, Random( poison / 3, poison ) );
                if( radiation > 0 )
                    AffectRadiation( target, Random( radiation / 3, radiation ) );
            }
        }
        else
        {
            int attackerBt = attacker.Stat[ ST_BODY_TYPE ];
            if( attackerBt == BT_RADSCORPION || attackerBt == BT_FLOATER || attackerBt == BT_GIANT_WASP || attackerBt == BT_ALIEN || attackerBt == BT_CENTAUR )
            {
                if( Random( 2, 11 ) > target.Stat[ ST_LUCK ] )
                {
                    if( attacker.IsNpc() )
                    {
                        if( attackerBt == BT_RADSCORPION )
                            AffectPoison( target, Random( 3, 15 ) );
                        else if( attackerBt == BT_FLOATER )
                            AffectPoison( target, Random( 10, 40 ) );
                        else if( attackerBt == BT_GIANT_WASP )
                            AffectPoison( target, Random( 10, 40 ) );
                        else if( attackerBt == BT_ALIEN )
                            AffectRadiation( target, Random( 10, 40 ) );
                        else if( attackerBt == BT_CENTAUR )
                        {
                            AffectPoison( target, Random( 10, 20 ) );
                            AffectRadiation( target, Random( 10, 20 ) );
                        }
                    }
                    else
                    {
                        if( attackerBt == BT_RADSCORPION )
                            AffectPoisonByCritter( target, Random( 3, 15 ), attacker );                                // TabaK урон от животных-игроков.
                        else if( attackerBt == BT_FLOATER )
                            AffectPoisonByCritter( target, Random( 10, 40 ), attacker );
                        else if( attackerBt == BT_GIANT_WASP )
                            AffectPoisonByCritter( target, Random( 10, 40 ), attacker );
                        else if( attackerBt == BT_ALIEN )
                            AffectRadiation( target, Random( 10, 40 ) );
                        else if( attackerBt == BT_CENTAUR )
                        {
                            AffectPoisonByCritter( target, Random( 10, 20 ), attacker );
                            AffectRadiation( target, Random( 10, 20 ) );
                        }
                    }
                }
            }
        }
    }

    if( target.ParamBase[ QST_GAMEMODE ] == GAME_ARCADE && !target.IsDead() && target.StatBase[ ST_CURRENT_HP ] <= 0 )
    {
        target.ToDead( dmgType, @attacker != null ? attacker : null );
        target.Action( ACTION_DEAD, 0, null );
    }
    if( attacker.CountItem( PID_COLLAR ) >= 1 && target.Karma[ KARMA_SLAVER ] != 0 )
    {
        attacker.StatBase[ ST_CURRENT_HP ] -= Random( 1, 4 );
        if( !attacker.IsDead() )
			attacker.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 50, attacker.HexX, attacker.HexY );
    }                                                                                                                                                                                                             // проверка на атаку рабом работорговца
    if( target.CountItem( PID_PACKAGE ) >= 1 && ( !target.IsDead() || !target.IsKnockout() ) )
    {
        Item@package = target.GetItem( PID_PACKAGE, 0 );
        MoveItem( package, 0, map, target.HexX, target.HexY );
        target.ModeBase[ MODE_NO_WALK ] = 0;
        target.ModeBase[ MODE_NO_RUN ] = 0;
        if( !target.IsDead() )
			target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), 1, target.HexX, target.HexY );
    }     // выбивание груза из цели
    
	if( valid( realWeapon ) && realWeapon.Val5 == 10 )
    {
        if( !attacker.IsDead() )
			attacker.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 150, attacker.HexX, attacker.HexY );
        attacker.Say( SAY_EMOTE_ON_HEAD, "оружие взрывается" );
        DeleteItem( realWeapon );
    }   

    if( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_NEED_CART_POISON )
        AffectPoisonByCritter( target, 25, attack.Attacker );                                                                                     // Проверка на картридж с ядом
    if( attack.WeaponPid == PID_KNIFE_P )
        AffectPoisonByCritter( target, 20, attack.Attacker );
    if( attack.WeaponPid == PID_SPEAK_P )
        AffectPoisonByCritter( target, 20, attack.Attacker );
    if( attack.WeaponPid == PID_MKNIFE_P )
        AffectPoisonByCritter( target, 20, attack.Attacker );
    if( attack.WeaponPid == PID_CKNIFE_P )
        AffectPoisonByCritter( target, 20, attack.Attacker );
    if( valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId == PID_CUENCELL_LOW )
        AffectRadiation( attacker, Random( 0, 10 ) );                                                                               // Проверка на радиоактивные патроны
    // Проверка на лучевую пушку "ОЖОГ"
    if( attack.WeaponPid == PID_PLASMA_SMG_LOW )
    {
        AffectRadiation( attacker, Random( 20, 30 ) );
        AffectRadiation( target, Random( 30, 50 ) );
    }
    if( valid( attack.Ammo ) && attack.Ammo.ProtoId == PID_NEED_CART_NT )
        AffectParalysis( target, 50 );                                                  // и нейротоксином - TabaK
	if( valid( attack.Ammo ) && ( !target.IsDead() || !target.IsKnockout() ) && ( aim == HIT_LOCATION_LEFT_ARM || aim == HIT_LOCATION_RIGHT_ARM ) && (valid (_CritGetItemHand(target))) && _CritGetItemHand(target).GetProtoId() == PID_FLAMER) //Эффект
		{
		if( Random( 0, 1 ) == 0 )
			{
			map.RunEffect( PID_EXPLODE_ROCKET, target.HexX, target.HexY, 1 );
			map.PlaySound( Random( 0, 1 ) == 0 ? "WHN1XXX1.ACM" : "WHN1XXX2.ACM" );
			QuakeScreen2( target );
			DeleteItem( _CritGetItemHand( target ) );
			}
		}
    if( attack.WeaponPid == PID_SOUND_BLASTER && target.ParamBase[ MODE_NO_KNOCK ] <= 0  )                                         // TabaK. Акустическое ружье.
    {
        QuakeScreen2( target );
        if( ( Random( 12, 40 ) - target.Stat[ ST_LUCK ] ) > 10 && ( target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) ) )
        {
            int8 roll = Random( 10, 100 ) - target.Stat[ ST_ENDURANCE ] * 10;
            if( roll > 0 )
            {
				if( !target.IsDead() )
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), roll * 10, target.HexX, target.HexY );
                //target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 30 );
            }
        }
    }
    if( ( attack.WeaponPid == PID_LEG_ATTACK1 || attack.WeaponPid == PID_LEG_ATTACK2 || attack.WeaponPid == PID_LEG_ATTACK3 || attack.WeaponPid == 1032 ) &&
        ( aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG ) && ( target.Timeout[ TO_STEALING ] <= 0 ) )
    {
        if( ( ( Random( 10, 30 ) - target.Stat[ ST_ENDURANCE ] - target.Stat[ ST_AGILITY ] ) > 0 ) && ( ( Random( 1, 200 ) + attacker.Skill[ SK_UNARMED ] - target.Skill[ SK_UNARMED ] ) >= 100 ) &&
            ( target.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( attacker.Param[ ST_BODY_TYPE ] < BT_BRAHMIN ) && ( !target.IsDead() || !target.IsKnockout() ) )
        {
            attacker.Say( SAY_EMOTE_ON_HEAD, "подсечка" );
            int8 roll = Random( 0, 25 ) - target.Stat[ ST_ENDURANCE ];
            if( roll > 0 )
            {
				if( !target.IsDead() )
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), roll * 10, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_SECOND( 10 );
            }
            target.StatBase[ ST_BLOCK ] = 0;
        }
    }
    if( attack.WeaponPid == PID_CATTLE_PROD && valid( attack.Ammo ) && valid( attack.Attacker ) && attack.Ammo.ProtoId != PID_CUENCELL_LOW && ( target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) ) )
    {
        QuakeScreen2( target );
        if( ( !target.IsDead() || !target.IsKnockout() ) && ( Random( 13, 30 ) - target.Stat[ ST_LUCK ] ) > 10 )
        {
            int8 roll = Random( 13, 50 ) - target.Stat[ ST_ENDURANCE ];
            if( roll > 0 )
            {
				if( !target.IsDead() )
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ) ), roll * 10, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 15 );
            }
        }
    }
//#########################################################    ЗВУКИ ВЫСТРЕЛОВ / БРОНИ ############################################################################
    if( attack.WeaponPid == PID_SAWGUN_LOW && target.ParamBase[ MODE_NO_KNOCK ] <= 0 ) // пушка пила // звук
    {
        if( Random( 0, 5 ) != 0 )
            realWeapon.AmmoCount ++;
        if( !target.IsDead() || !target.IsKnockout() )
        {
            uint8 dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
			
			Item@rope = attacker.GetItem( PID_ROPE, SLOT_HAND2 );
            if( ( target.IsRuning || Random( 0, 2 ) == 0 ) && dist >= 2 && valid(rope) )
            {
                HookHoldAttack( target, 10 );
                attacker.DeleteItem( PID_ROPE, 1 );
            }
            if( dist <= 1 && dmgType != DAMAGE_NORMAL )
            {
                QuakeScreen2( target );
                //map.PlaySound( "saw.ogg", target.HexX, target.HexY, 10 );
                if( aim == HIT_LOCATION_LEFT_ARM )
                    target.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
                else if( aim == HIT_LOCATION_RIGHT_ARM )
                    target.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
                else if( aim == HIT_LOCATION_RIGHT_LEG )
                    target.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
                else if( aim == HIT_LOCATION_LEFT_LEG )
                    target.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
                if( Random( 0, 10 ) - target.Stat[ ST_STRENGTH ] > 0 && !target.IsDead() )
                    target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), 100, target.HexX, target.HexY );
            }
        }
    }
    if( attack.WeaponPid == PID_SUN3 || attack.WeaponPid == PID_KIRE || attack.WeaponPid == PID_M41A || attack.WeaponPid == PID_LASER_RIFLE_LOW || attack.WeaponPid == PID_LASER_PISTOL_LOW || attack.WeaponPid == PID_LASER_PISTOL_LOW2  ) // Винтовки скорчер / звуки
    {

        if( !target.IsDead() || !target.IsKnockout() )
        {
            uint8 dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
			bool burst = attack.IsBurst;

            if( !burst )
            {
				int8 roll = Random( 0, 3 );
				if( roll == 0 ) map.PlaySound( "laser_01.ogg", attacker.HexX, attacker.HexY, 0 );
				else if( roll == 1 ) map.PlaySound( "laser_02.ogg", attacker.HexX, attacker.HexY, 0 );
				else if( roll == 2 ) map.PlaySound( "laser_03.ogg", attacker.HexX, attacker.HexY, 0 );
				else if( roll == 3 ) map.PlaySound( "laser_04.ogg", attacker.HexX, attacker.HexY, 0 );
            }
        }
    }
    if( attack.WeaponPid == PID_SPEARTHROWER2 || attack.WeaponPid == PID_SPEARTHROWER1)
    {
		Item@ rope;
        Item@[] items_hand2;
        uint items_hand2_count = attacker.GetItems( SLOT_HAND2, items_hand2 );
		if( items_hand2_count > 0 && items_hand2[0].GetProtoId() == PID_ROPE )
			@rope = items_hand2[0];

        if( !target.IsDead() && ( target.IsRuning || Random( 0, 2 ) == 0 ) && valid(rope) && target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) )
        {
			attacker.Say( SAY_EMOTE, "Стреляет сетью" );
			target.Say( SAY_EMOTE, "Опутан" );
            HookHoldAttack( target, 6 );
            attacker.DeleteItem( PID_ROPE, 1 );
        }
		target.AddItem( PID_DARTS_LOW, 1 );
    }
    if( attack.WeaponPid == PID_SPEAR || attack.WeaponPid == PID_SHARP_SPEAR || attack.WeaponPid == PID_SPEAK_P )
    {
		Item@ rope;
        Item@[] items_hand2;
        uint items_hand2_count = attacker.GetItems( SLOT_HAND2, items_hand2 );
		if( items_hand2_count > 0 && items_hand2[0].GetProtoId() == PID_ROPE )
			@rope = items_hand2[0];

        uint8 dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );

        if( !target.IsDead() && ( target.IsRuning || Random( 0, 2 ) == 0 ) && valid(rope) && dist > 2 && target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) )
        {
			attacker.Say( SAY_EMOTE, "Кидает сеть" );
            HookHoldAttack( target, 3 );
            attacker.DeleteItem( PID_ROPE, 1 );
            target.Say( SAY_EMOTE_ON_HEAD, "опутан" );
            target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 30 );
        }
    }
    if( attack.WeaponPid == PID_REV_BALL1 || attack.WeaponPid == PID_REV_BALL2 )
    {
        uint8 dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
        if( !target.IsDead() && ( target.IsRuning || Random( 0, 2 ) == 0 ) && dist > 1 )
        {
			uint bonusPower = ( attack.WeaponPid == PID_REV_BALL2 ? 3 : 0 ); //мк2 сильней в два раза
            HookHoldAttack( target, 3 + bonusPower );
            target.Say( SAY_EMOTE_ON_HEAD, "опутан" );
            target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 30 ); //архаик, не юзается
        }
    }
	if( target.ParamBase[ MODE_NO_KNOCK ] <= 0 ) //Кноки шотганов:
    {
		uint[][] shotguns = { 
		//	{ PID, 				     MOD1, MOD2,     DIST, COOLDOWN,                 AP1,                 AP2 }
			{ PID_REMINGTON,	        5,    2,        2,       15,   Random( 50, 150 ),  Random( 100, 200 ) },
			{ PID_COMBAT_SHOTGUN,       5,    2,        3,       20,   Random( 50, 150 ),  Random( 100, 200 ) },
			{ PID_SHOTGUN,             10,    4,        3,       25,   Random( 50, 150 ),  Random( 100, 200 ) },
			{ PID_SAWED_OFF_SHOTGUN,    8,    4,        4,       30,  Random( 100, 200 ),  Random( 100, 200 ) },
		};
		
		int _type = -1;
		for( uint i = 0; i < shotguns.length(); i++ )
			if( shotguns[i].length() > 0 && shotguns[i][0] != 0 && shotguns[i][0] == attack.WeaponPid )
			{
				_type = i;
				break;
			}
		
		if( _type >= 0 && !target.IsDead() && !target.IsKnockout() && target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) )
		{ //Если цель не мертва, и не лежит в кнокауте.
            uint8 dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
            uint8 aimmod = 0;
            if( aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES )
                aimmod = 50; //Бонус стрельбы в голову.
            else if( aim == HIT_LOCATION_UNCALLED || aim == HIT_LOCATION_NONE || aim == HIT_LOCATION_TORSO )
                aimmod = 30; //Бонус стрельбы в торс/неприцельными.
            if( ( attacker.Dir + 3 ) % 6 == target.Dir || ( attacker.Dir ) % 6 == target.Dir )
                aimmod += 40; //Бонус стрельбы в спину/сзади.
			
			int mod1 = shotguns[_type].length() > 1 ? shotguns[_type][1] : 0;
			int mod2 = shotguns[_type].length() > 2 ? shotguns[_type][2] : 0;
			int d = shotguns[_type].length() > 3 ? shotguns[_type][3] : 1;
			int cooldown =  shotguns[_type].length() > 4 ? shotguns[_type][4] : 5;
			int AP1 =  shotguns[_type].length() > 5 ? shotguns[_type][5] : 0;
			int AP2 =  shotguns[_type].length() > 6 ? shotguns[_type][6] : 0;
			
            /* //Временно отключено.
			if( target.IsRuning && target.Stat[ ST_CURRENT_HP ] < Random( aimmod, 30 + aimmod * 2 + totalDmg * mod1 ) )
            { //Если цель бежит, и её ТЕКУЩИЕ ХП < Random( бонус, бонус*2 + 30 + УРОН*5 )
				//Т.е. шанс кнока цели со 100 хп прицельным в пах (aimmod=0) выстрелом в X урона равен: ( 30 + 5*X ) %
				//При этом, стрельба неприцельными, в голову или торс - даёт практически 100% шанс кнока на любой дистанции.
				//Но это - лишь ПО БЕГУЩИМ ЦЕЛЯМ!!!
				target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), AP1, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( cooldown ); //Повторный кнок не удастся сделать ещё 15 секунд.
            }
			else */
            if( dist <= d && target.Stat[ ST_CURRENT_HP ] < Random( 0, 50 + aimmod + totalDmg * mod2 ) )
            { //Если же цель СТОИТ почти впритык (<d гексов), то: ТЕКУЩИЕ ХП < Random( 0, 50 + бонус + урон*2 )
				//Шанс кнока цели с 100 ТЕКУЩИМИ ХП прицельным в пах( aimmod=0) выстрелом на X урона равен: ( 50 + 2*X ) %
				//При этом, стрельба неприцельными, в голову или торс - даёт неплохой бонус к шансу кнока.
				//Но это - лишь "ВПРИТЫК"!
				target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), AP2, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( cooldown ); //Повторный кнок не чаще чем через 15 секунд.
            }
		}
    }
	
	if( attack.WeaponPid == PID_SLEDGEHAMMER && target.ParamBase[ MODE_NO_KNOCK ] <= 0 )    // Кувалда делает крушить
    {
        if( ( !target.IsDead() || !target.IsKnockout() ) && target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) )
        {
            int dist = GetDistantion( attack.Hx, attack.Hy, target.HexX, target.HexY );
            int aimmod = 0;
            if( aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES )
                aimmod = 60;
            else if( aim == HIT_LOCATION_UNCALLED || aim == HIT_LOCATION_NONE || aim == HIT_LOCATION_TORSO )
                aimmod = 40;
            if( ( attacker.Dir + 3 ) % 6 == target.Dir || ( attacker.Dir ) % 6 == target.Dir )
                aimmod += 40;
            if( attacker.StatBase[ ST_STRENGTH ] >= 6 )
                aimmod += 6 + attacker.StatBase[ ST_STRENGTH ]*2;
            if( target.IsRuning )
                aimmod += 20;
			

			int knock_AP = 150 - target.Stat[ ST_ENDURANCE ] * 4 - target.Stat[ ST_STRENGTH ] * 2;
			//DONE: Сделать влияние удачи на разброс кнокдуна:
			//При 10 удачи экономим 50% макс кнокдауна, при 1 получаем +40% макс кнокдауна
			string sub_info = 150 + " - " + ( target.Stat[ ST_ENDURANCE ] * 4 ) + " - "  + ( target.Stat[ ST_STRENGTH ] * 2 ) + " = " + knock_AP;
			knock_AP -= Random( 0, ( target.Stat[ ST_LUCK ] - 5 ) * knock_AP / 10 );
			int knock_sec = ( knock_AP + 5 ) / 10; //грубое подобие округления вверх
			
			sub_info += "\n With luck " + target.Stat[ ST_LUCK ] + " is " + knock_AP + " at " + knock_sec + ".";
			if( attacker.Param[ QST_GAMEMODE ] == GAME_TEST || target.Param[ QST_GAMEMODE ] == GAME_TEST )
			{
				if( attacker.IsPlayer() )
					attacker.Say( SAY_NETMSG, sub_info );
				if( target.IsPlayer() )
					target.Say( SAY_NETMSG, sub_info );
			}
			
            if( target.IsRuning && target.Stat[ ST_CURRENT_HP ] < Random( aimmod, totalDmg * 4 + aimmod * 2 ) && dist >= 3 )
            {
				target.Say( SAY_EMOTE, "Падает от столкновения с кувалдой" );
				if( !target.IsDead() )
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), knock_AP, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( knock_sec + 15 ); //5 секунд защита от кнока после вставания
            }
            else if( target.Stat[ ST_CURRENT_HP ] < Random( aimmod, totalDmg * 2 + aimmod ) && dist >= 3 )
            {
				target.Say( SAY_EMOTE, "Падает от столкновения с кувалдой" );
				if( !target.IsDead() )
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), knock_AP, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( knock_sec + 10 ); //10 секунд защита от кнока после вставания
            }
            else if( target.Stat[ ST_CURRENT_HP ] < Random( aimmod, totalDmg*2 + aimmod ) && dist <= 2 )
            {
				target.Say( SAY_EMOTE, "Падает от мощного удара" );
				if( !target.IsDead() )
					target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), knock_AP, target.HexX, target.HexY );
                target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( knock_sec + 15 ); //15 секунд защита от кнока после вставания
            }
        }
    }
	
	uint[] sniper_shouts = { PID_LOW_SNIPER2, PID_LOW_SNIPER3 };
	if( sniper_shouts.find( attack.WeaponPid ) != -1 )
		attacker.Say( SAY_SHOUT_ON_HEAD, "ВЫСТРЕЛ" );

	/*
    if( ( aim == HIT_LOCATION_RIGHT_LEG || aim == HIT_LOCATION_LEFT_LEG ) && ( !target.IsDead() || !target.IsKnockout() ) && target.Timeout[ TO_STEALING ] <= REAL_MINUTE( 2 ) ) // leg shot удар по ноге
    {
        uint8 hitmod = 0;
        if( attack.WeaponSubtype == WS_THROWING )
            hitmod = 20;
        if( target.IsRuning && ( ( attacker.Dir + 3 ) % 6 == target.Dir || ( attacker.Dir ) % 6 == target.Dir ) )
            hitmod += 40;
        if( target.IsRuning && target.Stat[ ST_CURRENT_HP ] < Random( hitmod, 50 + totalDmg * 8 + hitmod * 2 ) )
        {
			if( !target.IsDead() )
				target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 5, 10 ) * 10, target.HexX, target.HexY );
            target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 10 );
        }
        else if( target.Stat[ ST_CURRENT_HP ] < Random( hitmod, 50 + totalDmg * 2 + hitmod ) )
        {
			if( !target.IsDead() )
				target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), Random( 2, 6 ) * 10, target.HexX, target.HexY );
            target.TimeoutBase[ TO_STEALING ] = __FullSecond + REAL_MINUTE( 2 ) + REAL_SECOND( 10 );
        }
    }
	*/
    if( attack.WeaponPid == PID_PULSE_GRENADE ) // pulse knockout
    {
        if( !target.IsDead() || !target.IsKnockout() )
        {
			if( !target.IsDead() )
				target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 1 ? true : false ) ), 300, target.HexX, target.HexY );
        }
    }
}

uint e_DelayedExplosionEff( uint[]@ values )
{
	if( values.length() != 6 ) return 0;
	
	Map @map = ( values[0] > 0 ? GetMap( values[0] ) : null );
	if( !valid(map) ) return 0;
	
	map.RunEffect( values[1], values[2], values[3], values[4] );
	
	values[4]++;
	if( values[4] >= values[5] ) 
		return 0;
	
	CreateTimeEvent( __FullSecond + REAL_MS( 200 ), "e_DelayedExplosionEff", values, false );
	return 0;
}

uint e_DelayedExplosion( uint[]@ values )
{
	if( values.length() != 7 ) return 0;
	
	int i = 0;
	int x = values[i++];
	int y = values[i++];
	int mapId = values[i++];
	Map @map = mapId > 0 ? GetMap( mapId ) : null;
	if( !valid(map) ) return 0;
	
	int type = 0;
	int pid = values[i++];
	switch( pid )
	{
		case( PID_FLASH_GRENADE ): 		type = PID_EXPLODE_EMP; break;
		case( PID_HOLY_HAND_GRENADE ):
		case( PID_FRAG_GRENADE ): 		type = PID_EXPLODE_FIRE_SMALL; break;
		case( PID_MOLOTOV_COCKTAIL ): 	type = PID_EXPLODE_FIRE_BIG; break;
		case( PID_PULSE_GRENADE ): 		type = PID_EXPLODE_EMP; break;
		case( PID_PLASMA_GRENADE ): 	type = PID_EXPLODE_PLASMA; break;
		default: 						type = PID_EXPLODE_FIRE_BIG; break;
	}
	//QuakeScreen2( target );
	// if( pid != PID_FLASH_GRENADE && pid != PID_FLASH_GRENADE )
		// QuakeScreen( map );
	
	int maxDist = 4;
	int r = ( pid == PID_FLASH_GRENADE ? 5 : maxDist );

    Critter@[] critsHit;
	uint count = map.GetCrittersHex( x, y, r, FIND_LIFE_AND_KO, critsHit );
	
	int DmgMin = values[i++];
	int DmgMax = values[i++];
	int DmgType = values[i++];

	bool stopped = false;
	
    /*
	for( int k = 0; k < count; k++ )
		if( critsHit[ k ].HexX == x && critsHit[ k ].HexY == y && critsHit[ k ].IsKnockout() )
		{
			critsHit[ k ].Say( SAY_EMOTE, "закрывает собой" );
			if( pid == PID_FLASH_GRENADE )
				ApplyFlashEff( critsHit[ k ], 0 );
			else
				InjureCritter( critsHit[ k ], 2 * Random( DmgMin, DmgMax ), DmgType, GetDirection( x, y, critsHit[ k ].HexX, critsHit[ k ].HexY ), 0 );
			stopped = true;
			break;
		}
	*/

	if( pid == PID_FLASH_GRENADE )
		map.SetText( x, y, COLOR_GRAY, ":вспышка:" );

	if( type > 0 ) 
	{
		uint max = ( stopped ? 0 : ( pid == PID_FLASH_GRENADE ? 0 : 3 ) );
		uint[] vals = { mapId, type, x, y, 0, max };
		CreateTimeEvent( __FullSecond + 1, "e_DelayedExplosionEff", vals, false );
	}
	
	if( stopped ) return 0;	
	
    for( int k = 0; k < count; k++ )
    {
		QuakeScreen2( critsHit[ k ] );
		int distance = GetDistantion( x, y, critsHit[ k ].HexX, critsHit[ k ].HexY );
        if( pid == PID_FLASH_GRENADE )
        {
            uint8 DirToCrit = GetDirection( x, y, critsHit[ k ].HexX, critsHit[ k ].HexY );
            uint8 FlashDir, Near1, Near2;
            REVERSE_DIRECTION( FlashDir, DirToCrit );
            GET_NEAR_DIRECTION( FlashDir, Near1, Near2 );
            if( ( critsHit[ k ].IsKnockout() ) || ( distance != 0 ) && ( critsHit[ k ].Dir != FlashDir ) && ( critsHit[ k ].Dir != Near1 ) && ( critsHit[ k ].Dir != Near2 ) )
				continue;
			ApplyFlashEff( critsHit[ k ], distance );
			continue;
        }
		
		int dir = GetDirection( x, y, critsHit[ k ].HexX, critsHit[ k ].HexY );
		float mul = 1.0 - distance * ( 1.0 / maxDist );
		int dmg = Random( DmgMin, ( critsHit[ k ].IsKnockout() ? DmgMax * 0.5 : DmgMax ) );
		InjureCritter( critsHit[ k ], dmg * mul, DmgType, dir, 0 );
    }
	return 0;
}

void CommenceExplosion( AttackStruct& attack, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, bool isCritical, uint intentionallyId, bool isRocket, CombatRes[]& results )
{
	if( !isRocket )
	{
		if( !valid(map) ) return;
		uint[] vals = { tx, ty, map.Id, weapPid, attack.DmgMin, attack.DmgMax, attack.DmgType };
		CreateTimeEvent( __FullSecond + REAL_SECOND(3), "e_DelayedExplosion", vals, false );
		return;
	}
	
    uint radius = 3;
    map.RunEffect( PID_EXPLODE_ROCKET, tx, ty, 1 );
	QuakeScreen( map );//todo

    Critter@[] critsHit;
    map.GetCrittersHex( tx, ty, radius, FIND_LIFE_AND_KO, critsHit );
    bool validTarget = valid( target );
    uint targetId = 0;
    bool intentionally = ( valid( attack.Attacker ) && !attack.Attacker.IsNpc() || targetId == intentionallyId );

    if( validTarget )
    {
        targetId = target.Id;
        ApplyDamage( attack, target, 1, isCritical, intentionally, results );
    }

    attack.Hx = tx;
    attack.Hy = ty;

    for( int i = 0, j = critsHit.length(); i < j; i++ )
        if( !validTarget || targetId != critsHit[ i ].Id )
            ApplyDamage( attack, critsHit[ i ], 1, false, intentionally, results );
}


void CriticalFailure( Critter& cr, ProtoItem& weapon, uint8 weaponUse, ProtoItem@ ammo, uint eff, CombatRes[]& results )
{

    // 0x00000100 hit self OK
    // 0x00100000 weapon exploded OK

    // 0x00000200 lost rest of ammo OK
    // 0x00000400 fired dud shot OK?
    // 0x00000800 hurt self OK
    // 0x00001000 hit randomly ~OK, TODO
    // 0x00002000 crippled random limb OK
    // 0x00040000 on fire NOT USED NOW, TODO?

    // 0x00200000 weapon destroyed OK
    // 0x00400000 weapon dropped OK
    // 0x00800000 lost next turn OK
    // 0x02000000 knocked down OK


    int   totalDmg = 0;
    bool  tookDamage = false;
    Item@ realWeapon = _CritGetItemHand( cr );
    bool  wpnIsRemoved = _WeaponRemove( weapon, weaponUse );
    Map@  map = cr.GetMap();

    if( cr.Mode[ MODE_NO_DROP ] != 0 )
        UNSETFLAG( eff, MF_WEAPON_DROPPED );

    if( FLAG( eff, MF_HIT_SELF ) || FLAG( eff, MF_WEAPON_EXPLODED ) ) // only one bullet because burst weapons do not have the ability
    {
        bool validAmmo = valid( ammo );
        int  dmgType = _WeaponDmgType( weapon, weaponUse );
        int  targetDR = cr.Stat[ ST_NORMAL_RESIST + dmgType - 1 ];
        int  targetDT = cr.Stat[ ST_NORMAL_ABSORB + dmgType - 1 ];

        if( weapon.Weapon_Perk == WEAPON_PERK_PENETRATE )
            targetDT /= 5;

        targetDR += ( cr.Trait[ TRAIT_FINESSE ] != 0 ? 30 : 0 );
        targetDR += validAmmo ? ammo.Ammo_DrMod : 0;
        targetDR = CLAMP( targetDR, 0, 100 );
        int dmgMin = _WeaponDmgMin( weapon, weaponUse );
        int dmgMax = _WeaponDmgMax( weapon, weaponUse );
        int dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1; // technically, should be *2
        int dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;  // technically, should be *2
        totalDmg = Random( dmgMin, dmgMax );
        //totalDmg = Random( dmgMin, dmgMax ) + 2 * cr.Perk[ PE_BONUS_RANGED_DAMAGE ];
        totalDmg *= dmgMul;
        totalDmg /= dmgDiv;
        totalDmg -= targetDT;
        totalDmg -= ( totalDmg * targetDR ) / 100;
        if( totalDmg < 0 )
            totalDmg = 0;
        int bt = cr.Stat[ ST_BODY_TYPE ];
        // if( cr.Perk[ PE_LIVING_ANATOMY ] != 0 &&  !( bt == BT_ALIEN || bt == BT_ROBOT ) )
            // totalDmg += 8;
        // if( cr.Perk[ PE_PYROMANIAC ] != 0 && dmgType == DAMAGE_FIRE )
            // totalDmg += 10;
        tookDamage = true;
    }

    uint16 ammoRound = _WeaponRound( weapon, weaponUse );
    if( ammoRound > 0 && valid( realWeapon ) && cr.Mode[ MODE_UNLIMITED_AMMO ] == 0 )
    {
        if( realWeapon.AmmoCount <= ammoRound || FLAG( eff, MF_LOST_REST_OF_AMMO ) )
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }

    if( cr.Mode[ MODE_NO_DROP ] != 0 )
        UNSETFLAG( eff, MF_WEAPON_DROPPED );

    if( FLAG( eff, MF_WEAPON_DROPPED ) && valid( realWeapon ) )
    {
        if( weapon.ProtoId == PID_BALL ) // binyan - учитываем мяч
            e_ConvertBallToCrit( realWeapon, cr );
        else
        {
            if( realWeapon.IsStackable() )
            {
                Item@ dropped = map.AddItem( cr.HexX, cr.HexY, weapon.ProtoId, 1 );
                if( realWeapon.GetCount() > 1 )
                    realWeapon.SetCount( realWeapon.GetCount() - 1 );
                else
                    DeleteItem( realWeapon );

                if( !cr.IsPlayer() )
                {
                    NpcPlane@ plane = CreatePlane();
                    NpcPlane@[] crPlanes( 0 );

                    if( cr.GetPlanes( crPlanes ) > 0 )
                        plane.Priority = crPlanes[ 0 ].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = dropped.HexX;
                    plane.Pick_HexY = dropped.HexY;
                    plane.Pick_Pid = dropped.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    cr.AddPlane( plane );
                }
            }
            else
            {
                MoveItem( realWeapon, 0, map, cr.HexX, cr.HexY );
                if( !cr.IsPlayer() )
                {
                    NpcPlane@ plane = CreatePlane();

                    NpcPlane@[] crPlanes( 0 );

                    if( cr.GetPlanes( crPlanes ) > 0 )
                        plane.Priority = crPlanes[ 0 ].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeapon.HexX;
                    plane.Pick_HexY = realWeapon.HexY;
                    plane.Pick_Pid = realWeapon.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Run = true;
                    cr.AddPlane( plane );
                }
            }
        }

    }

    if( ( FLAG( eff, MF_WEAPON_DESTROYED ) || FLAG( eff, MF_WEAPON_EXPLODED ) ) && valid( realWeapon ) )
    {
        if( realWeapon.IsStackable() )
        {
            if( realWeapon.GetCount() > 1 )
                realWeapon.SetCount( realWeapon.GetCount() - 1 );
            else
                DeleteItem( realWeapon );
        }
        else
            DeleteItem( realWeapon );
    }

    if( FLAG( eff, MF_HURT_SELF ) )
    {
        totalDmg += Random( 1, 5 );
        tookDamage = true;
    }

    if( FLAG( eff, MF_LOST_NEXT_TURN ) )
    {
        cr.StatBase[ ST_CURRENT_AP ] = -100 * cr.Stat[ ST_ACTION_POINTS ];
        cr.StatBase[ ST_MOVE_AP ] = 0;
    }

    if( FLAG( eff, MF_KNOCKED_DOWN ) && !cr.IsKnockout() )
        cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 100, cr.HexX, cr.HexY );
        //cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), cr.Perk[ PE_QUICK_RECOVERY ] != 0 ? 1 : 3, cr.HexX, cr.HexY );

    if( FLAG( eff, MF_CRIPPLED_RANDOM_LIMB ) && cr.Mode[ MODE_NO_LOOSE_LIMBS ] == 0 )
    {
        switch( Random( 1, 4 ) )
        {
        case 1:
            cr.DamageBase[ DAMAGE_LEFT_LEG ] = 1;
            break;
        case 2:
            cr.DamageBase[ DAMAGE_RIGHT_LEG ] = 1;
            break;
        case 3:
            cr.DamageBase[ DAMAGE_LEFT_ARM ] = 1;
            break;
        case 4:
            cr.DamageBase[ DAMAGE_RIGHT_ARM ] = 1;
            break;
        default:
            break;
        }
    }
	

    if( FLAG( eff, MF_WEAPON_EXPLODED ) )
        map.RunEffect( PID_EXPLODE_FIRE_SMALL, cr.HexX, cr.HexY, 2 );

    if( totalDmg > 0 )
        cr.StatBase[ ST_CURRENT_HP ] -= totalDmg;

    uint[] allEff = { CMSG_CRIT_MISS, cr.Id, eff };


    if( tookDamage )
    {
        allEff.resize( 4 );
        allEff[ 3 ] = totalDmg;
        allEff[ 0 ] = CMSG_CRIT_MISS_DAMAGE;
    }

    if( cr.Stat[ ST_CURRENT_HP ] < 1 )
    {
        if( cr.Stat[ ST_CURRENT_HP ] > __DeadHitPoints && cr.Mode[ MODE_NO_KNOCK ] == 0 )
        {
            if( !cr.IsKnockout() )
                cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 0, cr.HexX, cr.HexY );
        }
        else
        {
            uint anim2Dead = ANIM2_DEAD_FRONT;
            if( cr.IsKnockout() )
            {
                if( cr.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT )
                    anim2Dead = ANIM2_DEAD_PRONE_FRONT;
                else
                    anim2Dead = ANIM2_DEAD_PRONE_BACK;
            }
            cr.ToDead( anim2Dead, null );
            allEff[ 2 ] |= MF_WAS_KILLED;
        }
    }

    Critter@[] him = { cr };
    Critter@[] crits;
    cr.GetMap().GetCrittersSeeing( him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits );
    for( int i = 0, j = crits.length(); i < j; i++ )
        AddEff( crits[ i ], allEff, results );

    FlushResults( results );

    return;
}


void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) // Export
{
    if( dmgType > DAMAGE_EXPLODE )
    {
        Log( "Invalid damage type." );
        return;
    }

    Critter@ attacker = null;
    if( attackerId != 0 /*&& cr.Id != attackerId */ )
        @attacker = GetCritter( attackerId );
	
	if( !valid( attacker ) )
		@attacker = cr;

    AttackStruct attack;
    @attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( valid( map ) )
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );

    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = HIT_LOCATION_UNCALLED;
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = -1;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ShowHitAnimForce = true;

    CombatRes[] results;
    ApplyDamage( attack, cr, 1, false, true, results );

    FlushResults( results );
}

void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId, uint forceFlags ) // Export
{
    if( dmgType > DAMAGE_EXPLODE )
    {
        Log( "Invalid damage type." );
        return;
    }

    Critter@ attacker = null;
    if( attackerId != 0 && cr.Id != attackerId )
        @attacker = GetCritter( attackerId );

    AttackStruct attack;
    @attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( valid( map ) )
        map.MoveHexByDir( hx, hy, ( dir + 3 ) % 6, 1 );

    attack.Hx = hx;
    attack.Hy = hy;
    attack.Aim = HIT_LOCATION_UNCALLED;
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = -1;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ForceFlags = forceFlags;
    attack.ShowHitAnimForce = true;

    CombatRes[] results;
    ApplyDamage( attack, cr, 1, false, true, results );

    FlushResults( results );
}

int FindCritterInArray( Critter@[]& crits, Critter& cr )
{
    uint crId = cr.Id;
    for( uint i = 0, j = crits.length(); i < j; i++ )
        if( crits[ i ].Id == crId )
            return i;
    return -1;
}

uint GetAimApCost( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __ApCostAimTorso;
    case HIT_LOCATION_EYES:
        return __ApCostAimEyes;
    case HIT_LOCATION_HEAD:
        return __ApCostAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __ApCostAimArms;
    case HIT_LOCATION_GROIN:
        return __ApCostAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __ApCostAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}


// client only, possible use by AI
int RawToHit( Critter& cr, Critter& target, ProtoItem@ weapon, uint8 weaponUse, ProtoItem@ ammo )
{
    int skillNum = valid( weapon ) ? _WeaponSkill( weapon, weaponUse ) : SK_UNARMED;
    
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
	int toHit = getFullSkill( cr, target, skillNum, weaponSubtype );

	if( ( cr.Timeout[ TO_BATTLE ] == 0 && ( cr.Trait[ TRAIT_GOOD_NATURED ] != 0 || ( cr.Trait[ TRAIT_BLOODY_MESS ] == 0  && target.Trait[ TRAIT_BLOODY_MESS ] == 0 ) ) ) 
		|| ( target.Trait[ TRAIT_GOOD_NATURED ] != 0 && target.Timeout[ TO_BATTLE ] == 0 ) ) { //Либо цель - мирный НЕ в бою.
		//cr.Say( SAY_NETMSG, toHit + " div " + ( toHit / 2 ) );
		toHit /= 2; //Навык делим пополам.
	}

    int weaponPerk = valid( weapon ) ? weapon.Weapon_Perk : 0;
    int blockers = 0;
    int dist = GetDistantion( cr.HexX, cr.HexY, target.HexX, target.HexY );
    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        // ranged attack modifiers
        int distmod1 = 2; // used for initial weapon bonus
        int distmod2 = 0; // minimal distance
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
            distmod1 = 4;
        else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = cr.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
            acc += distmod2;
        else
        {
            if( cr.IsPlayer() )
                acc -= ( perception - 2 ) * distmod1;
            else
                acc -= perception * distmod1;
        }

        if( -2 * perception > acc )
            acc = -2 * perception;

        //acc -= 2 * cr.Perk[ PE_SHARPSHOOTER ];

        if( acc >= 0 )
        {
            if( cr.Damage[ DAMAGE_EYE ] != 0 )
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;

        Map@ map = cr.GetMap();
        blockers = map.GetCrittersPath( cr.HexX, cr.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null );
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    } // end range modifiers

    if( valid( weapon ) )
    {
        if( !( weapon.Weapon_IsUnarmed ) && cr.Trait[ TRAIT_ONE_HANDER ] != 0 )
            toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

        int handlingStrength = cr.Stat[ ST_STRENGTH ];
        int reqStrength = weapon.Weapon_MinStrength;
        // if( cr.Perk[ PE_WEAPON_HANDLING ] != 0 )
            // handlingStrength += 3;
        if( handlingStrength < reqStrength )
            toHit -= ( reqStrength - handlingStrength ) * 20;

        if( weaponPerk == WEAPON_PERK_ACCURATE )
            toHit += 20;
    }

    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
        acmod += ammo.Ammo_AcMod;
    if( acmod > 0 )
        toHit -= acmod;

    if( cr.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;

    if( target.IsKnockout() )
        toHit += 40;
    if( target.GetMultihex() > 0 )
        toHit += 15;

	int hitLocation = _WeaponModeAim( weaponUse );
	if( valid(target) && target.IsBusy() )
	{
		if( ( cr.Dir + 3 ) % 6 == target.Dir )
			toHit += 20;
		else if( ( cr.Dir ) % 6 != target.Dir )
		{
			toHit -= acmod / 2;
			if( hitLocation == HIT_LOCATION_HEAD )
				toHit -= acmod / 2;
		}
	}
	// advanced aiming
	if( hitLocation == HIT_LOCATION_HEAD )
		toHit *= 0.5;
	else if( hitLocation == HIT_LOCATION_LEFT_ARM || hitLocation == HIT_LOCATION_RIGHT_ARM || hitLocation == HIT_LOCATION_RIGHT_LEG || hitLocation == HIT_LOCATION_LEFT_LEG )
		toHit *= 0.7;

	return toHit;
}


void NotifyOops( Critter& cr, Critter@ t1, Critter@ t2, CombatRes[]& results )
{
    // if (t2==null) pass "cr c\ritically missed and hit randomly."
    // otherwise pass "oops! t2 was hit instead of t1!"
    if( @t2 == null )
    {
        uint[] allEff = { CMSG_HIT_RANDOMLY, cr.Id };
        Critter@[] him = { cr };
        Critter@[] crits;
        cr.GetMap().GetCrittersSeeing( him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits );
        for( int i = 0, j = crits.length(); i < j; i++ )
            AddEff( crits[ i ], allEff, results );
    }
    else if(@t1 != null)
    {
        uint[] allEff = { CMSG_OOPS, t1.Id, t2.Id };
        Critter@[] them = { t1, t2 };
        Critter@[] crits;
        t1.GetMap().GetCrittersSeeing( them, true, FIND_ALL | FIND_ONLY_PLAYERS, crits );
        for( int i = 0, j = crits.length(); i < j; i++ )
            AddEff( crits[ i ], allEff, results );
    }



    return;
}

void NotifyMiss( Critter@ cr, CombatRes[]& results )
{

    uint[] allEff = { CMSG_MISS, cr.Id };
    Critter@[] him = { cr };
    Critter@[] crits;
    cr.GetMap().GetCrittersSeeing( him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits );
    for( int i = 0, j = crits.length(); i < j; i++ )
        AddEff( crits[ i ], allEff, results );

    return;
}

Critter@ ChooseRandomTarget( Map& map, Critter& cr, Critter& target, uint wpnMaxDist )
{
    Critter@[] crits;
    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    uint   n = map.GetCrittersHex( hx, hy, wpnMaxDist, FIND_LIFE_AND_KO, crits );
    if( n == 0 )
        return null;     // should never happen
    uint   start = Random( 0, n - 1 );
    uint16 bx = 0;
    uint16 by = 0;
    uint16 pbx = 0;
    uint16 pby = 0;
    for( uint i = start; i < n; i++ )
    {
        if( !valid( crits[ i ] ) )
            continue;
        if( crits[ i ].Id == cr.Id || ( valid( target ) && crits[ i ].Id == target.Id ) )
            continue;                                                                  // binyan - Hex attack - added
        // wallcheck:
        map.GetCrittersPath( hx, hy, crits[ i ].HexX, crits[ i ].HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by );
        if( bx == crits[ i ].HexX && by == crits[ i ].HexY )
            return crits[ i ];
    }
    for( uint i = 0; i < start; i++ )
    {
        if( !valid( crits[ i ] ) )
            continue;
        if( crits[ i ].Id == cr.Id || ( valid( target ) && crits[ i ].Id == target.Id ) )
            continue;                                                                   // binyan - Hex attack - added
        // wallcheck:
        map.GetCrittersPath( hx, hy, crits[ i ].HexX, crits[ i ].HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by );
        if( bx == crits[ i ].HexX && by == crits[ i ].HexY )
            return crits[ i ];
    }

    return null;
}

void answer_COUP_DE_GRACE( Critter& player, uint answerI, string& answerS )
{
    Critter@ targetCr = GetCritter( player.Stat[ ST_VAR0 ] );
    if( targetCr is null )
        return;

    if( answerI == 0 && !targetCr.IsDead() && player.ParamBase[ ST_VAR5 ]==3)
    {
		if( player.Param[ QST_GAMEMODE ] == GAME_SURVIVAL ) 
			targetCr.ToDead( ANIM2_DEAD_FRONT, player );
		// else 
			// targetCr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, player );
		targetCr.StatBase[ ST_KILLER_PERSON ] = player.Id;
		
		if( targetCr.IsPlayer() ) 
			Log_Killings( player, targetCr.Id, 0, 0, null, null );
		else
			player.StatBase[ST_EXPERIENCE] += targetCr.Stat[ST_KILL_EXPERIENCE];
			
		player.Say( SAY_NETMSG, "Вы нанесли смертельное ранение." );
    }
}

void telekineticExplosion (Critter& cr) { //Пси-способность
	AttackStruct telekineticDynamite;
	Map@ explosionMap = cr.GetMap ();
	CombatRes [] results;
	Critter@[] crits;
	Critter@[] psyonic = {cr};
	@telekineticDynamite.Attacker = cr;
	telekineticDynamite.DmgMin = cr.Stat[ST_INTELLECT]*7;
	telekineticDynamite.DmgMax = cr.Stat[ST_INTELLECT]*11;
	telekineticDynamite.DmgType = DAMAGE_EXPLODE;
	telekineticDynamite.DmgMul = 1;
	cr.ModeBase [MODE_INVULNERABLE] = 1;
	cr.ModeBase [MODE_NO_KNOCK] = 1;
	CommenceExplosion (telekineticDynamite, explosionMap, cr.HexX, cr.HexY, null, PID_PULSE_GRENADE, false, 0, false, results);
	cr.ModeBase [MODE_INVULNERABLE] = 0;
	cr.ModeBase [MODE_NO_KNOCK] = 0;
	FlushResults (results);
}
