                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

import bool AddWalkPlane(Critter&npc,uint priority,int identifier,uint identifierExt,uint16 hexX,uint16 hexY,uint8 dir,bool run,uint cut)from"npc_planes";   

void e_ConvertBallToCrit(Item&ball)
{
	uint16 x=0,y=0,tempX=0,tempY=0;
	uint8 Dir=0;
	Map@map=ball.GetMapPosition(tempX,tempY);
	x=tempX;
	y=tempY;
	while(!map.IsHexPassed(x,y)&&(Dir<6))
	{
		x=tempX;
		y=tempY;
		map.MoveHexByDir(x,y,Dir,1);
		Dir++;
	}
	if(Dir!=6)
	{
		if(ball.GetCount()>1)
		ball.SetCount(ball.GetCount()-1);
		else
		DeleteItem(ball);
		map.AddNpc((490),x,y,0,null,null,"ball_init@_CritterInit");
	}
	else
	return;
} 

void e_ConvertBallToCrit(Item&ball,Critter&crt)
{
	uint16 x=0,y=0,tempX=0,tempY=0;
	uint8 Dir=0;
	Map@map=ball.GetMapPosition(tempX,tempY);
	x=tempX;
	y=tempY;
	map.MoveHexByDir(x,y,crt.Dir,1);
	while(!map.IsHexPassed(x,y)&&(Dir<6))
	{
		x=tempX;
		y=tempY;
		map.MoveHexByDir(x,y,Dir,1);
		Dir++;
	}
	if(Dir!=6)
	{
		if(ball.GetCount()>1)
		ball.SetCount(ball.GetCount()-1);
		else
		DeleteItem(ball);
		map.AddNpc((490),x,y,0,null,null,"ball_init@_CritterInit");
	}
	else
	return;
} 

void e_ConvertBallToCrit(Critter&attacker,Item&ball,uint16 tx,uint16 ty)
{
	uint8 Dir;
	Map@map=attacker.GetMap();
	Dir=attacker.Dir+3;if(Dir>5)
	Dir=Dir-6;;
	
	if(ball.GetCount()>1)
	ball.SetCount(ball.GetCount()-1);
	else
	DeleteItem(ball);
	
	while(!map.IsHexPassed(tx,ty))
	map.MoveHexByDir(tx,ty,Dir,1);
	map.AddNpc((490),tx,ty,attacker.Dir,null,null,"ball_init@_CritterInit");
	
}      

void BallAttackHandling(Critter&ball,Critter&crt,uint16 WeaponPid)
{
	uint steps;
	uint16 x,y;
	
	Map@map=ball.GetMap();
	uint8 Dir=crt.Dir;
	ball.DropPlanes();
	bool isLeg=(WeaponPid==1020)||(WeaponPid==1021)||(WeaponPid==1022)||(WeaponPid==1023)||(WeaponPid==1030)||(WeaponPid==1031)||(WeaponPid==1032);
	
	if(isLeg)
	{
		if(crt.StatBase[(5)]<6)
		{
			uint8 NearPlus,NearMinus,rand;
			NearPlus=Dir+1;NearMinus=Dir-1;if(NearPlus>5)
			NearPlus=0;if(NearMinus<0)
			NearMinus=5;;
			rand=Random(0,2);
			switch(rand)
			{
				case 0:
				Dir=NearPlus;
				break;
				case 1:
				Dir=NearMinus;
				break;
			}
		}
		x=ball.HexX;
		y=ball.HexY;
		map.MoveHexByDir(x,y,Dir,1);
		steps=crt.StatBase[(0)];
		if(steps>11)
		{
			steps=11;
			Log("Внимание! Обнаружен гнусный читер! Id = "+crt.Id+", Nickname = "+GetPlayerName(crt.Id)+", Сила = "+crt.StatBase[(0)]+", сила удара уменьшена до 11");
		}
		trace_Path(ball,x,y,steps,Dir);
	}
	else
	{
		ball.Say((3),"Buuummm!!!");
		ball.ToDead((103),crt);
	}
	
}         

int e_Ball_Check_Path(Critter&ball,NpcPlane&plane)
{
	uint8 Dir=ball.Dir;
	uint16 x,y,curX,curY;
	uint stepsRest;
	
	int Id=plane.Identifier;
	Map@map=ball.GetMap();
	NpcPlane@[]tempPlanes;
	
	if(ball.GetPlanes(Id+1,tempPlanes)!=0)
	{
		if(tempPlanes.length()!=0)
		{
			x=tempPlanes[0].Walk_HexX;
			y=tempPlanes[0].Walk_HexY; 
			
			if(!map.IsHexPassed(x,y))
			{
				
				stepsRest=(ball.GetPlanes(null)-1)/2;
				ball.DropPlanes();
				Critter@crOccup=map.GetCritter(x,y);
				if(crOccup.GetProtoId()==(490))
				{
					map.MoveHexByDir(x,y,Dir,1);
					trace_Path(crOccup,x,y,stepsRest,Dir);
					return(2);
				}
				curX=ball.HexX;
				curY=ball.HexY;
				Dir=ball.Dir;
				Get_Next_Coord_Dynamic(curX,curY,x,y,Dir,map);
				if(!((curX==0)&&(curY==0)))
				{
					
					trace_Path(ball,curX,curY,stepsRest,Dir);
				}
				
			}
			
		}
	}
	return(2);
	
}  

void e_BallIntoInven(Critter&ball,Critter&crt,bool SetToActiveHand)
{
	if(GetDistantion(ball.HexX,ball.HexY,crt.HexX,crt.HexY)>1)
	crt.Say((11),"Вы слишком далеко от мяча");
	else
	{
		
		crt.Action((9),1,null);
		DeleteNpc(ball);
		Item@b_item=crt.AddItem((650),1);
		if(SetToActiveHand)
		crt.MoveItem(b_item.Id,(1),1);
	}
	
}  

void e_BallDeflated(Critter&ball,Critter@crt)
{
	
	uint16 x,y;
	x=ball.HexX;
	y=ball.HexY;
	Map@map=ball.GetMap();
	DeleteNpc(ball);
	map.AddItem(x,y,(651),1);
	
}   

void trace_Path(Critter&ball,uint16 x,uint16 y,uint steps,uint8 Dir)
{
	uint16 curX,curY,xOccuped,yOccuped;
	
	Map@map=ball.GetMap();
	curX=ball.HexX;
	curY=ball.HexY;
	
	for(uint i=1;i<=steps;++i)
	{  
		
		if(map.IsHexPassed(x,y)||(@map.GetCritter(x,y)!=null)) 
		
		{
			Critter@crOccup=map.GetCritter(x,y);
			if((@crOccup!=null)&&(i==1))
			{
				if(crOccup.GetProtoId()==(490))
				{
					map.MoveHexByDir(x,y,Dir,1);
					trace_Path(crOccup,x,y,steps/2,Dir);
					return;
				}
				xOccuped=x;
				yOccuped=y;
				x=curX;
				y=curY;
				steps/=2;
				Get_Next_Coord_Dynamic(x,y,xOccuped,yOccuped,Dir,map);
				if(((x==0)&&(y==0)))
				return;
			}
			AddWalkPlane(ball,(50),i,0,x,y,Dir,false,0);
			curX=x;
			curY=y;
			map.MoveHexByDir(x,y,Dir,1);
		}
		
		else
		{
			steps-=(steps-i)/2;
			x=curX;
			y=curY;
			Get_Next_Coord_Static(x,y,Dir,map);
		}
	}
	
}

void Get_Next_Coord_Dynamic(uint16&x,uint16&y,uint16 xOccuped,uint16 yOccuped,uint8&Dir,Map&map)
{
	uint8 RevDir,NearPlus;
	int8 NearMinus;
	Critter@crit=map.GetCritter(xOccuped,yOccuped); 
	
	RevDir=Dir+3;if(RevDir>5)
	RevDir=RevDir-6;
	
	NearPlus=RevDir+1;NearMinus=RevDir-1;if(NearPlus>5)
	NearPlus=0;if(NearMinus<0)
	NearMinus=5;
	
	if((@crit!=null)&&((crit.Dir==RevDir)||(crit.Dir==NearPlus)||(crit.Dir==NearMinus)))
	{
		x=0;y=0;
	}
	else
	Get_Next_Coord_Static(x,y,Dir,map);
} 

void Get_Next_Coord_Static(uint16&x,uint16&y,uint8&Dir,Map&map)
{
	uint8 RevDir,NearPlus;
	int8 NearMinus;
	
	RevDir=Dir+3;if(RevDir>5)
	RevDir=RevDir-6;
	
	NearPlus=Dir+1;NearMinus=Dir-1;if(NearPlus>5)
	NearPlus=0;if(NearMinus<0)
	NearMinus=5;
	map.MoveHexByDir(x,y,NearPlus,1);
	if(map.IsHexPassed(x,y))
	Dir=NearPlus;
	else
	{
		
		map.MoveHexByDir(x,y,NearMinus,1);
		if(map.IsHexPassed(x,y))
		Dir=NearMinus;
		else
		{
			
			map.MoveHexByDir(x,y,RevDir,1);
			if(map.IsHexPassed(x,y))
			Dir=RevDir;
			else
			{
				x=0;y=0;
			}
			
		}
	}
	
}           

void _OnItemDrop(Item&ball,Critter&crt)
{
	e_ConvertBallToCrit(ball,crt);
}            

void _OnCritterDead(Critter&ball,Critter@crt)
{
	e_BallDeflated(ball,crt);
}

bool _OnCritterTalk(Critter&ball,Critter&crt,bool attach,uint talk_count)
{
	e_BallIntoInven(ball,crt,false);
	return false;
}

int _OnPlaneEnd(Critter&ball,NpcPlane&plane,int reason,Critter@someCr,Item@someItem)
{
	return e_Ball_Check_Path(ball,plane);
}   

void _CritterInit(Critter&ball,bool firstTime)
{
	
	ball.SetEvent((39),"_OnCritterTalk");
	ball.SetEvent((2),"_OnCritterDead");
	ball.SetEvent((36),"_OnPlaneEnd");
}

void _ItemInit(Item&ball,bool firstTime)
{
	ball.SetEvent((5),"_OnItemDrop");
	
	if(ball.Accessory==(2))
	e_ConvertBallToCrit(ball);
}
