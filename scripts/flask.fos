#ifndef FLASK
#define FLASK

#include "_utils.fos"
#include "flask_h.fos"
#include "_ltp.fos"
#include "gathering_h.fos"
#include "food_h.fos"
#include "furniture_h.fos"

////////////////////////
// Liquid Transfer menu
////////////////////////

class MenuTransferLiquid: CenteredMenuHandler {
    uint target_id;

    MenuTransferLiquid(Item& target) {
        target_id = target.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu ) {
        Item@ target = GetItem(target_id);
		Item@ flask = _CritGetItemHand( cr );

        if( !valid(target) ) 
		{
            return false;
        }
		
		if( !valid(flask) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_HOLD_FLASK );
			return false;
		}
		
		if( !IsFlask(flask) && flask.GetProtoId() != PID_BOTTLE_GLASS || !IsFlask(target) )
		{
			return false;
		}
		
		if( flask.REMAINING_USES == 0 && target.REMAINING_USES == 0 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
			return false;
		}
		
		if(flask.REMAINING_USES > 0 && target.REMAINING_USES != int( target.Proto.Partial_Item ))
		{
			if( menu.Button("Transfer Liquid into") ) 
			{
				ProcessFlask( cr, flask, target );
				return false;
			}
		}
		
		if( ( target.REMAINING_USES > 0 && flask.REMAINING_USES != int( flask.Proto.Partial_Item ) ) || flask.GetProtoId() == PID_BOTTLE_GLASS)
		{
			if( menu.Button("Transfer Liquid out") ) 
			{
				ProcessFlask( cr, target, flask );
				return false;
			}
		}
    
        return true;
    }
    string@ ButtonCancel() {
        return ButtonDecorator("Hide menu", null);
    }
    void OnMenuDraw(Critter& cr) {
        cr.Say(SAY_NETMSG, DebugMenu(cr));
    }
}

void StartMenuTransferLiquid( Critter& cr, Item& target)
{
    iMenuHandler@ handler = MenuTransferLiquid(target);
    iDialogBox@ menu = OpenMenu(cr, "Flask", handler);
}

////////////////////////
// Water barrel menu
////////////////////////

class MenuWaterBarrel: CenteredMenuHandler
{
    uint waterBarrel_id;
    uint map_id;
	uint level;
	
    MenuWaterBarrel( Item& waterBarrel, Map& map )
	{
        waterBarrel_id = waterBarrel.Id;
        map_id = map.Id;
		level = 0;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
        Item@ waterBarrel = GetItem( waterBarrel_id );
	
        if( !valid( map ) )
		{
            return false;
        }
		
		if( !valid( waterBarrel ) )
		{
			return false;
		}
		
		if( menu.ButtonMsg( STR_WATERWORKS_MENU_COLLECT_WATER ) )
		{
			StartMenuTransferLiquid( cr, waterBarrel );
			return false;
		}
		
		if( waterBarrel.REMAINING_USES > 0 )
		{	
			if( menu.ButtonMsg( STR_WATERWORKS_MENU_DRINK ) )
			{
				DrinkFlask(cr, waterBarrel);
				return true;
			}
		}
		
		if( waterBarrel.REMAINING_USES == 0 && menu.ButtonMsg( STR_FURNITURE_MENU_BUTTON ) )
		{
			_InitFurniture( waterBarrel, true );
			waterBarrel.Update();
			StartMenuFuriture( cr, waterBarrel );
			return false;
		}
		
		return true;
    }
	
    string@ Description( Critter& cr )
	{
		Item@ waterBarrel = GetItem( waterBarrel_id );
		Map@ map = GetMap( map_id );

		string info = "Waterbarrel is filled for " + waterBarrel.REMAINING_USES / 10 + " liters";
		
        return info;
    }
}

void StartMenuWaterBarrel( Critter& cr, Item& waterBarrel )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        return;
    }
	
	iMenuHandler@ handler = MenuWaterBarrel( waterBarrel, map );
    iDialogBox@ menu = OpenMenu( cr, "Water Barrel", handler );
}


bool IsFlask(Item@ flask)
{
	if(!valid(flask))
	{
		return false;
	}
	
	if(flask.Proto.Type == ITEM_TYPE_FLASK )
	{
		return true;
	}
	
	return false;
}

bool DrinkFlask( Critter& cr, Item& flask )
{
	Map@ map = cr.GetMap(); 
	if( !valid( map ) || !valid( flask ) )
	{
		return false;
    }
	
	if( flask.CritSlot != SLOT_HAND1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_HOLD_FLASK );
		return false;
	}
	
	if( flask.REMAINING_USES <= 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
		return false;
	}
	
	if( flask.DRINK_DNA != 0 )
	{
		flask.REMAINING_USES--;
		flask.EXTRA_WEIGHT = flask.REMAINING_USES * 100;
		
		Item@ proxy = cr.AddItem(flask.DRINK_DNA, 1);
		
		ProccessDrink( cr, cr, proxy );
		(proxy.GetCount() > 1) ? proxy.SetCount(proxy.GetCount() - 1) : DeleteItem(proxy);
	}
	
	if( flask.REMAINING_USES == 0 )
	{ 
		flask.REMAINING_USES = 0;
		flask.DRINK_DNA = 0;
		flask.EXTRA_WEIGHT = 0;
		flask.Val3 = 0;
		flask.Val4 = 0;
		flask.FLASK_TOXIN_LEVEL = 0;
		flask.Val6 = 0;
		flask.FLASK_POLUTION_LEVEL = 0;
		flask.FLASK_TASTE = 0;
		flask.SPIRIT_LEVEL = 0;
		ChangeFlaskProto(flask);
	}
	
	flask.Update();
	return true;
}

bool PourFlask( Critter& cr, Item& flask )
{
	Map@ map = cr.GetMap(); 
	if( !valid( map ) || !valid( flask ) )
	{
		return false;
    }
	
	if( flask.REMAINING_USES <= 0 || flask.DRINK_DNA <= 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
		return false;
	}
	
	flask.REMAINING_USES = 0;
	flask.EXTRA_WEIGHT = 0;
	flask.DRINK_DNA = 0;
	flask.Val3 = 0;
	flask.Val4 = 0;
	flask.FLASK_TOXIN_LEVEL = 0;
	flask.Val6 = 0;
	flask.FLASK_POLUTION_LEVEL = 0;
	flask.Val8 = 0;
	flask.Val9 = 0;
	
	PlayGenericSound( map, cr.HexX, cr.HexY, "splash.ogg", 20 );
	
	cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_EMPTY_FLASK, "$proto@msg ITEM " +  ( flask.Proto.ProtoId * 100 ) + "@" );
	
	ChangeFlaskProto( flask );
	
	flask.Update();
	return true;
}

bool ProcessFlask(Critter& cr, Item@ input, Item@ output)
{
	if(!valid(input) || !valid(output))
	{
		return false;
	}
	
	if(!IsFlask(input) && input.GetProtoId() != PID_BOTTLE_GLASS || !IsFlask(output) && output.GetProtoId() != PID_BOTTLE_GLASS)
	{
		return false;
	}
	
	startTransfer(cr, input, output);
	
	return true;
}

void ChangeFlaskProto(Item& item)
{
	if(!valid(item))
	{
		return;
	}
	
	switch(item.GetProtoId())
	{
		case(PID_GLASS_BOTTLE_FULL_PRT):
		case(PID_DISTIL_WATER_PRT):
		case(PID_GLASS_BOTTLE_DIRTY_FULL_PRT):
		case(PID_NUKA_COLA_PRT):
		{
			Critter@ cr = GetCritter(item.CritId);
			DeleteItem(item);
			cr.AddItem(PID_BOTTLE_GLASS, 1);
			break;
		}
	}
}

// LTP SHIT GOES HERE

bool ltp_inited=false;
void ltp_init()
{
    LTPREG( LTP_TRANSFER_LIQ, process_transfer_liquid )
    ltp_inited=true;
}

void startTransfer( Critter& cr, Item& input, Item& output )
{	
    if(!ltp_inited)
	{
		ltp_init();
	}
	
	if(!valid(input) || !valid(output))
	{
		return;
	}
	
	if(!IsFlask(input) || !IsFlask(output) && output.GetProtoId() != PID_BOTTLE_GLASS)
	{
		return;
	}
	
	if(output.GetProtoId() == PID_BOTTLE_GLASS)
	{
		int pid = 0;
		if(index_glass_bottles( input.DRINK_DNA, 1 ) != -1) pid = input.DRINK_DNA;
		else
		{
			uint index = index_glass_bottles( input.DRINK_DNA, 2 );
			if( index != -1 )
			{
				pid = glass_bottles[1][index];
			}
		}	
		cr.AddItem(pid, 1);
		(output.GetCount() > 1) ? output.SetCount(output.GetCount() - 1) : DeleteItem(output);
		input.REMAINING_USES -= 5;
		input.EXTRA_WEIGHT = input.REMAINING_USES * 100; 
		return;
	}
	
	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ ST_AGILITY ] * ACTION_PAUSE_BONUS_RATE );
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	cr.ParamBase[ ST_LTP_SEQUENCE ] = input.REMAINING_USES > ( output.Proto.Partial_Item - output.REMAINING_USES ) ? ( output.Proto.Partial_Item - output.REMAINING_USES ) : input.REMAINING_USES;

	cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
	
    StartProcess( cr, LTP_TRANSFER_LIQ, 0, input.Id, output.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
}

void stopTransfer( Critter& cr )
{
    StopProcess( cr, true );
}

uint process_transfer_liquid( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_TRANSFER_LIQ )
	
	Item@ input = GetItem( param1 );
  	Item@ output = GetItem( param2 );
	
	if(valid(input) && valid(output))
	{
		Map@ map = cr.GetMap();
		PlayGenericSound( map, cr.HexX, cr.HexY, "homebrew_pouring.ogg", 10 );
		
		if(input.REMAINING_USES <= 0)
		{	
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
			cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			return 0;
		}
		
		if(output.REMAINING_USES == int( output.Proto.Partial_Item ))
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FINISHED_FILLING );
			cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			return 0;
		}
		
		if(output.REMAINING_USES == 0)
		{
			output.DRINK_DNA = input.DRINK_DNA;
			ChangeFlaskProto(output);
		}
		

		input.REMAINING_USES--;
		output.REMAINING_USES++;
		
		if(input.REMAINING_USES == 0)
		{
			input.DRINK_DNA = 0;
			ChangeFlaskProto(input);
		}
		
		input.EXTRA_WEIGHT = input.REMAINING_USES * 100;
		output.EXTRA_WEIGHT = output.REMAINING_USES * 100;
		
		if(input.FLASK_TOXIN_LEVEL > 0)
		{
			output.FLASK_TOXIN_LEVEL += (((output.EXTRA_WEIGHT * output.FLASK_TOXIN_LEVEL) + (100 * input.FLASK_TOXIN_LEVEL)) / (output.EXTRA_WEIGHT + 100));
		}
		
		if(input.SPIRIT_LEVEL > 0)
		{
			output.FLASK_TOXIN_LEVEL += (((output.EXTRA_WEIGHT * output.SPIRIT_LEVEL) + (100 * input.SPIRIT_LEVEL)) / (output.EXTRA_WEIGHT + 100));
		}
		
		input.Update();
		output.Update();
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}

	cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
	return 0;
}


#endif //FLASK