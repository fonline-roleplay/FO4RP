#ifndef FLASK
#define FLASK

#include "_utils.fos"
#include "flask_h.fos"
#include "_ltp.fos"
#include "gathering_h.fos"
#include "furniture_h.fos"
#include "poison_h.fos"
#include "paralysis_h.fos"

////////////////////////
// Liquid Transfer menu
////////////////////////

class MenuTransferLiquid: CenteredMenuHandler {
    uint target_id;

    MenuTransferLiquid(Item& target) {
        target_id = target.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu ) {
        Item@ target = GetItem(target_id);
		Item@ flask = _CritGetItemHand( cr );

        if( !valid(target) ) 
		{
            return false;
        }
		
		if( !valid(flask) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_HOLD_FLASK );
			return false;
		}
		
		if( !IsFlask(flask) && flask.GetProtoId() != PID_BOTTLE_GLASS || !IsFlask(target) )
		{
			return false;
		}
		
		if( flask.REMAINING_USES == 0 && target.REMAINING_USES == 0 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
			return false;
		}
		
		if(flask.REMAINING_USES > 0 && target.REMAINING_USES != int( target.Proto.Partial_Item ))
		{
			if( menu.ButtonMsg(STR_TRANSFER_LIQ_IN) ) 
			{
				ProcessFlask( cr, flask, target );
				return false;
			}
		}
		
		if( ( target.REMAINING_USES > 0 && flask.REMAINING_USES != int( flask.Proto.Partial_Item ) ) || flask.GetProtoId() == PID_BOTTLE_GLASS)
		{
			if( menu.ButtonMsg(STR_TRANSFER_LIQ_OUT) ) 
			{
				ProcessFlask( cr, target, flask );
				return false;
			}
		}
    
        return true;
    }
    string@ ButtonCancel() {
        return ButtonDecorator("Hide menu", null);
    }
    void OnMenuDraw(Critter& cr) {
        cr.Say(SAY_NETMSG, DebugMenu(cr));
    }
}

void StartMenuTransferLiquid( Critter& cr, Item& target)
{
    iMenuHandler@ handler = MenuTransferLiquid(target);
    iDialogBox@ menu = OpenMenu(cr, "Flask", handler);
}

////////////////////////
// Water barrel menu
////////////////////////

class MenuWaterBarrel: CenteredMenuHandler
{
    uint waterBarrel_id;
    uint map_id;
	uint level;
	
    MenuWaterBarrel( Item& waterBarrel, Map& map )
	{
        waterBarrel_id = waterBarrel.Id;
        map_id = map.Id;
		level = 0;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
        Item@ waterBarrel = GetItem( waterBarrel_id );
	
        if( !valid( map ) )
		{
            return false;
        }
		
		if( !valid( waterBarrel ) )
		{
			return false;
		}
		
		if( menu.ButtonMsg( STR_WATERWORKS_MENU_COLLECT_WATER ) )
		{
			StartMenuTransferLiquid( cr, waterBarrel );
			return false;
		}
		
		if( waterBarrel.REMAINING_USES > 0 )
		{	
			if( menu.ButtonMsg( STR_WATERWORKS_MENU_DRINK ) )
			{
				DrinkFlask(cr, cr, waterBarrel);
				return true;
			}
		}
		
		if( waterBarrel.REMAINING_USES == 0 && menu.ButtonMsg( STR_FURNITURE_MENU_BUTTON ) )
		{
			_InitFurniture( waterBarrel, true );
			waterBarrel.Update();
			StartMenuFuriture( cr, waterBarrel );
			return false;
		}
		
		return true;
    }
	
    string@ Description( Critter& cr )
	{
		Item@ waterBarrel = GetItem( waterBarrel_id );
		Map@ map = GetMap( map_id );

		string info = "Waterbarrel is filled for " + float(waterBarrel.REMAINING_USES / 10.0) + " liters";
		
        return info;
    }
}

void StartMenuWaterBarrel( Critter& cr, Item& waterBarrel )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        return;
    }
	
	iMenuHandler@ handler = MenuWaterBarrel( waterBarrel, map );
    iDialogBox@ menu = OpenMenu( cr, "Water Barrel", handler );
}


bool IsFlask(Item@ flask)
{
	if(!valid(flask))
	{
		return false;
	}
	
	if(flask.Proto.Type == ITEM_TYPE_FLASK )
	{
		return true;
	}
	
	return false;
}

uint GetFlagsCount(uint flags)
{	
	uint count = 0;

    while (flags > 0)
    {
        flags = flags & (flags - 1);
        count++;
    }
    return count;
}

void Emote( Critter& target, Item& consumed )
{
	target.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT,STR_EMOTE_DRINKS );
	target.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CONSUMED_DRINK, "$proto@msg item " + ( consumed.Proto.ProtoId * 100 ) + "@" );
	
	if( target.Param[ ST_RADIATION_LEVEL ] > 0 && consumed.SPIRIT_LEVEL != 0 )
	{
		target.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOST_RAD, "$rad" + consumed.SPIRIT_LEVEL );
	}
	
	if( consumed.FLASK_POLUTION_LEVEL != 0 )
	{
		target.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DRUNK_POISON, "$poison" + consumed.FLASK_POLUTION_LEVEL );
	}
}

bool DrinkFlask( Critter& cr, Critter& targetCr, Item& flask )
{
	Map@ map = cr.GetMap(); 
	bool isSameCr = cr.Id == targetCr.Id;
	
	if( !valid( map ) || !valid( flask ) )
	{
		return false;
    }
	
	if( flask.REMAINING_USES <= 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
		return false;
	}
	
	if(!isSameCr)
	{
		if(!targetCr.IsKnockout())
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TARGET_RESIST );
			return false;
		}
		targetCr.SayMsg(SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_CHOKING);
	}
	
	uint flags2count = flask.FLASK_TASTE & ~DRINK_FLAG_TOXIN;
	if(GetFlagsCount(flags2count) > 5)
	{
		if(isSameCr && cr.ParamBase[ ST_INTELLECT ] > 3)
		{
			cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_STRANGE_DRINK);
			return false;
		}
		else
		{
			cr.SayMsg(SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_CHOKING);
		}
		targetCr.ParamBase[ ST_POISONING_LEVEL ] += 15;
	}
		
	if(isSameCr)
	{
		Emote(cr, flask);
	}
	
	flask.REMAINING_USES--;
	flask.EXTRA_WEIGHT = flask.REMAINING_USES * 100;
		
	uint8 hungerModifier = flask.HUNGER_REDUSE;
	uint8 ThirstModifier = flask.THIRST_REDUSE;
	targetCr.StatBase[ ST_HUNGER ] += hungerModifier; //* SATURATION_SIMPLIFIER;
	targetCr.StatBase[ ST_THIRST ] += ThirstModifier; //* SATURATION_SIMPLIFIER;
	targetCr.ParamBase[ ST_POISONING_LEVEL ] += flask.FLASK_TOXIN_LEVEL;
		
	if( targetCr.Param[ ST_RADIATION_LEVEL ] > 0 && flask.FLASK_POLUTION_LEVEL == 0)
	{
		targetCr.ParamBase[ ST_RADIATION_LEVEL ] -= int( flask.SPIRIT_LEVEL * 0.25f );
		if( targetCr.Param[ ST_RADIATION_LEVEL ] < 0 )
		{
			targetCr.ParamBase[ ST_RADIATION_LEVEL ] = 0;
		}
	}
	else
	{
		targetCr.ParamBase[ ST_RADIATION_LEVEL ] += flask.FLASK_POLUTION_LEVEL;
	}
		
	if( targetCr.Param[ ST_DRUNK ] != 100 )
	{
		targetCr.ParamBase[ ST_DRUNK ] += int( flask.SPIRIT_LEVEL * 0.25f );
		if( targetCr.Stat[ ST_DRUNK ] > 0 && targetCr.GetTimeEvents( CTE_DRUNK, null, null, null ) < 1 )
		{
			targetCr.AddTimeEvent( "gameplay@cte_Drunk", REAL_SECOND( targetCr.Param[ CR_DRUNK_SPEED ] ), CTE_DRUNK, 0 );
		}
	}
	else
	{
		AffectPoison( targetCr, int( flask.SPIRIT_LEVEL ) );
	}
		
	if(FLAG(flask.FLASK_TASTE, DRINK_FLAG_TOXIN))
	{
		AffectParalysis( targetCr, 50 );
	}
	
	if( flask.REMAINING_USES == 0 )
	{ 
		flask.REMAINING_USES = 0;
		flask.DRINK_DNA = 0;
		flask.EXTRA_WEIGHT = 0;
		flask.HUNGER_REDUSE = 0;
		flask.THIRST_REDUSE = 0;
		flask.FLASK_TOXIN_LEVEL = 0;
		flask.Val6 = 0;
		flask.FLASK_POLUTION_LEVEL = 0;
		flask.FLASK_TASTE = 0;
		flask.SPIRIT_LEVEL = 0;
		ChangeFlaskProto(flask);
	}
	
	flask.Update();
	return true;
}

bool PourFlask( Critter& cr, Item& flask )
{
	Map@ map = cr.GetMap(); 
	if( !valid( map ) || !valid( flask ) )
	{
		return false;
    }
	
	if( flask.REMAINING_USES <= 0 || flask.DRINK_DNA <= 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
		return false;
	}
	
	flask.REMAINING_USES = 0;
	flask.EXTRA_WEIGHT = 0;
	flask.DRINK_DNA = 0;
	flask.Val3 = 0;
	flask.Val4 = 0;
	flask.FLASK_TOXIN_LEVEL = 0;
	flask.Val6 = 0;
	flask.FLASK_POLUTION_LEVEL = 0;
	flask.Val8 = 0;
	flask.Val9 = 0;
	
	PlayGenericSound( map, cr.HexX, cr.HexY, "splash.ogg", 20 );
	
	cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_EMPTY_FLASK, "$proto@msg ITEM " +  ( flask.Proto.ProtoId * 100 ) + "@" );
	
	ChangeFlaskProto( flask );
	
	flask.Update();
	return true;
}

bool CloseBottle(Critter& cr, Item& bottle)
{
	if(!valid(bottle) || !valid(cr))
	{
		return false;
	}
	
	if( bottle.REMAINING_USES == bottle.Proto.Partial_Item &&
		bottle.DRINK_DNA == bottle.Proto.StartValue_1 &&
		bottle.EXTRA_WEIGHT == bottle.Proto.Partial_Item * 100 &&
		bottle.HUNGER_REDUSE == bottle.Proto.Food_Restore &&
		bottle.THIRST_REDUSE == bottle.Proto.Food_Thrist &&
		bottle.FLASK_TASTE == bottle.Proto.StartValue_8 &&
		bottle.SPIRIT_LEVEL == bottle.Proto.StartValue_9
	)
	{
		_SubItem(bottle, 1);
		int index = glass_bottles[2].find( bottle.GetProtoId() );
		cr.AddItem( glass_bottles[1][index], 1 );
	}
	else
	{
		cr.Say(SAY_NETMSG, "You trying to close bottle and failing");
		return false;
	}
	
	return true;	
}

bool ProcessFlask(Critter& cr, Item@ input, Item@ output)
{
	if(!valid(input) || !valid(output))
	{
		return false;
	}
	
	if(!IsFlask(input) && input.GetProtoId() != PID_BOTTLE_GLASS || !IsFlask(output) && output.GetProtoId() != PID_BOTTLE_GLASS)
	{
		return false;
	}
	
	startTransfer(cr, input, output);
	
	return true;
}

void ChangeFlaskProto(Item& item)
{
	if(!valid(item))
	{
		return;
	}
	
	if(find_opened_drinks(item))
	{
		Critter@ cr = GetCritter(item.CritId);
		_SubItem(item, 1);
		cr.AddItem(PID_BOTTLE_GLASS, 1);
	}
}

// LTP SHIT GOES HERE

bool ltp_inited=false;
void ltp_init()
{
    LTPREG( LTP_TRANSFER_LIQ, process_transfer_liquid )
    ltp_inited=true;
}

void startTransfer( Critter& cr, Item& input, Item& output )
{	
    if(!ltp_inited)
	{
		ltp_init();
	}
	
	if(!valid(input) || !valid(output))
	{
		return;
	}
	
	if(!IsFlask(input) || !IsFlask(output) && output.GetProtoId() != PID_BOTTLE_GLASS)
	{
		return;
	}
	
	if(output.GetProtoId() == PID_BOTTLE_GLASS)
	{
		uint16 pid = 0;
		if(index_glass_bottles( input.DRINK_DNA, 1 ) != -1) pid = input.DRINK_DNA;
		else
		{
			uint index = index_glass_bottles( input.DRINK_DNA, 2 );
			if( index != -1 )
			{
				pid = glass_bottles[1][index];
			}
		}	
		cr.AddItem(pid, 1);
		_SubItem(output, 1);
		input.REMAINING_USES -= 5;
		input.EXTRA_WEIGHT = input.REMAINING_USES * 100; 
		return;
	}
	
	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ ST_AGILITY ] * ACTION_PAUSE_BONUS_RATE );
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	cr.ParamBase[ ST_LTP_SEQUENCE ] = input.REMAINING_USES > ( output.Proto.Partial_Item - output.REMAINING_USES ) ? ( output.Proto.Partial_Item - output.REMAINING_USES ) : input.REMAINING_USES;

	cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
	
    StartProcess( cr, LTP_TRANSFER_LIQ, 0, input.Id, output.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
}

void stopTransfer( Critter& cr )
{
    StopProcess( cr, true );
}

uint process_transfer_liquid( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_TRANSFER_LIQ )
	
	Item@ input = GetItem( param1 );
  	Item@ output = GetItem( param2 );
	
	if(valid(input) && valid(output))
	{
		Map@ map = cr.GetMap();
		PlayGenericSound( map, cr.HexX, cr.HexY, "homebrew_pouring.ogg", 10 );
		
		if(input.REMAINING_USES <= 0)
		{	
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
			cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			return 0;
		}
		
		if(output.REMAINING_USES == int( output.Proto.Partial_Item ))
		{
			CloseBottle( cr, output );
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FINISHED_FILLING );
			cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			return 0;
		}
		
		if(output.REMAINING_USES == 0)
		{
			output.DRINK_DNA = input.DRINK_DNA;
			ChangeFlaskProto(output);
		}
		
		output.FLASK_TASTE |= input.FLASK_TASTE;

		input.REMAINING_USES--;
		output.REMAINING_USES++;
		
		if(input.REMAINING_USES == 0)
		{
			input.DRINK_DNA = 0;
			ChangeFlaskProto(input);
		}
		
		input.EXTRA_WEIGHT = input.REMAINING_USES * 100;
		output.EXTRA_WEIGHT = output.REMAINING_USES * 100;
		
		if(input.FLASK_TOXIN_LEVEL > 0)
		{
			float toxPerc = output.REMAINING_USES * output.FLASK_TOXIN_LEVEL;
			output.FLASK_TOXIN_LEVEL = int(( input.FLASK_TOXIN_LEVEL + toxPerc ) / ( 1 + output.REMAINING_USES ));
		}
		
		if(input.SPIRIT_LEVEL > 0)
		{
			float spiritPerc = output.REMAINING_USES * output.SPIRIT_LEVEL;
			output.SPIRIT_LEVEL = int(( input.SPIRIT_LEVEL + spiritPerc ) / ( 1 + output.REMAINING_USES ));
		}
		
		output.HUNGER_REDUSE = input.HUNGER_REDUSE;
		output.THIRST_REDUSE = input.THIRST_REDUSE;
		
		input.Update();
		output.Update();
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}

	cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
	return 0;
}


#endif //FLASK