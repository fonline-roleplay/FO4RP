// comment this out to disable physical ui and enable "visible_items.fos"
#define PHYSICAL_UI

// Client main script
// Compile using fo_client.dll
#include "_utils.fos"
#include "sprite.fos"
#include "combat_h.fos"
#include "client_names_h.fos"
#include "wait_time_h.fos"
#include "fofmod_h.fos"
#include "perks_h.fos"
#include "parameters_h.fos"
#include "handcuffs_h.fos"
#include "radio_h.fos"
#include "client_gui_h.fos"
#include "firestarter_h.fos"
#include "hitchance_h.fos"
#include "geiger_h.fos"
#include "radiation_h.fos"
#include "client_event_h.fos"

import void InitializeGame() from "config";

import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";

import bool gm_msg( string& message ) from "client_gm";

import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";

import void DrawMapTiles() from "qmap_client";
import void qmap_loop() from "qmap_client";

//import void overlay_loop(bool show) from "overlay";
//import void overlay_connect() from "overlay";
//import void overlay_disconnect() from "overlay";
//import void overlay_visibility() from "overlay";
//import void overlay_message(string& message, int& sayType, uint& critterId, uint& delay) from "overlay";

import void InitContMenuScreen() from "client_screen_contmenu";

import void InitCodedoorScreen() from "client_screen_codedoor";

import void InitNumpadScreen() from "client_screen_numberpad";

import void InitScreenAddiotional() from "client_screen_additional";
import void SetCrtype( int[]& params ) from "client_screen_additional";

import void InitScreenInputbox() from "client_screen_inputbox";
import void InitInfoScreen() from "client_screen_info";
import void InitFixboyScreen() from "client_screen_fixboy";

import void WASDInputLoop() from "input_wasd";
import bool WASDInputKeyState(int key, bool state) from "input_wasd";
import void WASDInputLost() from "input_wasd";

import void FactionGuiInit() from "factions_gui";

import bool OutMessage(string& message, int& sayType) from "chat";
import bool InMessage(string& message, int& sayType, uint& senderCritterID, uint& delay) from "chat";
import bool MapMessage(string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay) from "chat";

import void AvatarRender( CritterCl& critter, int x, int y, int w, int h, uint alpha ) from "client_avatars";
import void SetAvatarPlaceholders( const array<Sprite@>@ placeholders ) from "client_avatars";
import void AvatarSizeUp() from "client_avatars";
import void AvatarSizeDown() from "client_avatars";
import void AvatarLoop() from "client_avatars";

import int[]@ GetIniValues2(string& iniKey, int[]@ defaultValues) from "ini_parser";
import int[]@ GetIniValues4(string& iniKey, int[]@ defaultValues) from "ini_parser";

import void CallCritStatsScreen(uint id) from "client_screen_info";

dictionary chosenContainerItems;

uint prevId = 0; // required for loading saved names
Sprite[] arrow;

Sprite F1_arrows, F1_tabs, F1_text, TabPic;
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
uint F1SpriteId = 0;
uint RadSpriteId = 0;
uint GasSpriteId = 0;
uint LightSpriteId = 0;
uint TalkSpriteId = 0;
uint QuestSpriteId = 0;
uint TradeSpriteId = 0;
uint OreSpriteId = 0;
uint JunkSpriteId = 0;
int F1_Width;
int F1_Height;
bool F1IsDraw = false;
bool hideF1 = false;
bool IfaceHidden = false;
int APCountX, APCountY;

bool start()
{
    bool result = true;
    InitializeGame();

    result = result && FOFMOD_Initialize();

    if( __ScreenWidth < 800 || __ScreenWidth > 1920 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
    }

    #ifdef PLAYERS_3D
		AppendIfaceIni( "players3d_chareg.ini" );
		# ifndef PLAYERS_3D_NO_HEAD
			AppendIfaceIni( "players3d_headinv.ini" );
		# endif
    #endif

	AppendIfaceIni( "rp_default.ini" );
	Message( GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_INFO) );
		
	string legacyGUI;
	legacyGUI = GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_LEGACY );
	string newGUI;
	newGUI    = GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_NEW);
	string errorGUI;
	errorGUI  = GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_ERROR);
	
	if( AppendIfaceIni( "rp_default.ini" ) )
    {
        Message( "" + newGUI ); 
    }
    else if( AppendIfaceIni( "default.ini" ) )
    {
        Message( "" + legacyGUI ); 
    }
	else
	{
		Message ( "" + errorGUI );
	}
	
	AppendIfaceIni( "avatar.ini" );
	AppendIfaceIni( "APAMk2.ini" ); // Standalone Modded Interface Pack - APAMk2
	
    GUI_Init();

    InitRadioScreen();
    InitChosenTabs();
	FactionGuiInit();

    // @pm menu
    InitContMenuScreen();
   // InitFastPanelScreen();
   // InitFastPanelSkillbox();
    //InitFastPanelTextbox();
    InitCodedoorScreen();
	InitNumpadScreen();
    InitScreenAddiotional();
    InitScreenInputbox();
	InitInfoScreen();
	InitFixboyScreen();

    arrow.resize( 8 );
    arrow[ 0 ].Load( "arrow0.png", int(PT_ART_INTRFACE) );
    arrow[ 1 ].Load( "arrow1.png", int(PT_ART_INTRFACE) );
    arrow[ 2 ].Load( "arrow2.png", int(PT_ART_INTRFACE) );
    arrow[ 3 ].Load( "arrow3.png", int(PT_ART_INTRFACE) );
    arrow[ 4 ].Load( "arrow4.png", int(PT_ART_INTRFACE) );
    arrow[ 5 ].Load( "arrow5.png", int(PT_ART_INTRFACE) );
    arrow[ 6 ].Load( "arrow6.png", int(PT_ART_INTRFACE) );
    arrow[ 7 ].Load( "arrow7.png", int(PT_ART_INTRFACE) );
    // #pm menu
	
	__MouseScroll = true;

    __ShowPlayerNames = true;
    __ShowNpcNames = true;

	TabPic.LoadByIni( "ChosenTabPic", PT_ART_INTRFACE );

    __global = CONF_GLOB_GRID | CONF_GLOB_WILD;

	F1SpriteId = LoadSprite( GetMsgStr(TEXTMSG_GAME, STR_F1_SPRITE_NAME), int( PT_ART_INTRFACE ) );
	F1_Width = GetSpriteWidth( F1SpriteId, 0 );
	F1_Height = GetSpriteHeight( F1SpriteId, 0 );
	
	int[] iniKeys;
	iniKeys = GetIniValues4("IntMain", null);
	APCountX = (__ScreenWidth - iniKeys[2]) / 2;
	APCountY = __ScreenHeight - iniKeys[3];
	iniKeys = GetIniValues2("IntAPCount", null);
	APCountX += iniKeys[0];
	APCountY += iniKeys[1];

	RadSpriteId		= LoadSprite( "RadIcon.png",		int( PT_ART_INTRFACE ) );
	GasSpriteId		= LoadSprite( "GasIcon.png",		int( PT_ART_INTRFACE ) );
	LightSpriteId	= LoadSprite( "LightIcon.png",		int( PT_ART_INTRFACE ) );
	TalkSpriteId	= LoadSprite( "SayIcon.png",		int( PT_ART_INTRFACE ) );
	QuestSpriteId	= LoadSprite( "QuestgiverIcon.png",	int( PT_ART_INTRFACE ) );
	TradeSpriteId	= LoadSprite( "TraderIcon.png",		int( PT_ART_INTRFACE ) );
	OreSpriteId		= LoadSprite( "OreMarker.png",		int( PT_ART_INTRFACE ) );
	JunkSpriteId	= LoadSprite( "JunkMarker.png",		int( PT_ART_INTRFACE ) );
		
	array<Sprite@> avatarsPlaceholder =
	{
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderNone.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderNoFound.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderDownload.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderGood.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderPlayer.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderUpload.png" ), 0 )
	};
	
	SetAvatarPlaceholders( avatarsPlaceholder );
	
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.

uint loop_turn = 0;

uint loop()
{
    FOFMOD_Update();
    WASDInputLoop();
	ProcessEvents();

    if( loop_turn % 4 == 0 )
	{
		SelectionBarUpdate();
		updateAllNicks();
			
		if( !last_radio_message_recieved )
		{
			Message( "|0xFFFFFF " + last_radio_message );
			last_radio_message_recieved = true;
		}
    }

    if( loop_turn % 5 == 0 )
	{
        qmap_loop();
    }

    if( loop_turn % 100 == 0 )
    {
        int[] result;
        GUI_GetActiveScreens( result );

        CritterCl@ ch = GetChosen();

        if( valid(ch) && ( prevId == ch.Id ) && ( ( result.length() > 0 && result[ result.length() - 1 ] == CLIENT_MAIN_SCREEN_GAME ) || ( result.length() > 1 && result[ result.length() - 2 ] == CLIENT_MAIN_SCREEN_GAME ) ) )
        {
            SaveNames();
        }
    }
    loop_turn += 1;
    if( loop_turn > 100 )
	{
        loop_turn = 0;
	}
	
	AvatarLoop();
	
    return 100;
}

void SelectionBarUpdate() 
{
	if( !isLMB_on() )
	{
		return;
	}
	
	if( GetCurrentCursor() == CURSOR_RTSA )
	{
		checkSelectionBarALL();
	}
	else if( GetCurrentCursor() == CURSOR_RTS )
	{
		checkSelectionBarNPC();
	}
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_GetActiveScreens( result );
}

// Show/hide screen behaviour.
int _MainScreen = CLIENT_SCREEN_NONE;
int _LastMainScreen = CLIENT_SCREEN_NONE;
void screen_change( bool show, int screen, int p0, int p1, int p2 )
{ 
    // qthree: sorry for the trash
    //debug_screen_change(show, screen, p0, p1, p2);
    if( show )
	{
        //if new screen - main or global and last is Login - connect to overlay
        if(
            ( screen == CLIENT_MAIN_SCREEN_GAME || screen == CLIENT_MAIN_SCREEN_GLOBAL_MAP ) &&
            ( _LastMainScreen == CLIENT_MAIN_SCREEN_LOGIN || _LastMainScreen == CLIENT_SCREEN_NONE )
        )
		{
            //Message("BINGO");
            //overlay_connect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }
        //if new screen - login and last main or global - disconnect overlay and reset names
        else if( screen == CLIENT_MAIN_SCREEN_LOGIN && (_LastMainScreen == CLIENT_MAIN_SCREEN_GAME || _LastMainScreen == CLIENT_MAIN_SCREEN_GLOBAL_MAP) )
		{
            prevId = 0;
            ClearNameCache();
            //overlay_disconnect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }

        if(screen>=CLIENT_MAIN_SCREEN_LOGIN && screen<=CLIENT_MAIN_SCREEN_WAIT)
		{
            _MainScreen = screen;
            if(screen != CLIENT_MAIN_SCREEN_WAIT)
			{
                _LastMainScreen = screen;
            }
        }
    }

// Hotkeys
    if( screen == CLIENT_SCREEN_SAY || screen == CLIENT_SCREEN_TIMER || screen == CLIENT_SCREEN_INPUT_BOX || screen == CLIENT_SCREEN_SPLIT )
	{
        __IsTextInput = show ? true : false;
	}
	
    if( show )
	{
        GUI_ShowScreen( screen, p0, p1, p2 );
	}
    else
	{
        GUI_HideScreen( screen, p0, p1, p2 );
	}
}

int[] @ data_color = null;
int[] @ data_number = null;
int[] @ data_char = null;

void _dr( int param0, int param1, int param2, string@ param3, int[] @ param4 ) // draw data
{
    switch( param0 )
    {
		case( 1 ):
			@data_color = param4;
			break;
		case( 2 ): 
			@data_number = param4;
			break;
		case( 3 ):
			@data_char = param4;
			break;
		default:
			break;
    }
}

// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    1
// Game map
//    2
// Console, Messbox
//    3
// PopUp menu, Cursor
//    4
//
// Extra layers:
// Global map
//    100 (over map), 101 (over all)
void render_iface( FOWindow@ window, uint layer )
{
	if( window !is MainWindow )
	{
		return;
	}
	
	CritterCl@ choo = GetChosen();
	
    if( layer == 1 )
    {
        show_player_info();
    }
    else if( layer == 2 )
    {
		if( !hideF1 )
		{
			ShowF1Help();
		}
		
		if( ( __sinf & SINF_RAD_SIGN ) != 0 )
		{
			ShowRadiation();
		}
		
		if( ( __sinf & SINF_GAS_SIGN ) != 0 )
		{
			ShowGases();
		}
		
		if( ( __sinf & SINF_LIGHT_SIGN ) != 0 )
		{
			ShowLights();
		}

		if( ( __sinf & SINF_ORE_SIGN ) != 0 )
		{
			ShowOreZone();
		}

		if( ( __sinf & SINF_JUNK_SIGN ) != 0 )
		{
			ShowJunkZone();
		}
		
		if( ( __sinf & SINF_MOB_SIGN ) != 0 )
		{
			ShowMobSpawners();
		}

		if( valid( choo ) && isGM( choo ) )
		{
			CritterCl@[] critters;
			uint len = GetCritters( 0, FIND_ALL, critters );
			for( uint i = 0; i < len; i++ )
			{
				CritterCl@ critter = critters[i];
				if( valid( critter ) )
				{
					if( critter.Param[ ST_TALKING_PUPPET ] == int( choo.Id ) || critter.ParamBase[ CR_TALKING_TARGET_ID ] == int( choo.Id ) )
					{
						string cr_sprite_name = GetCritterTypeName( critter.CrType ) + "aa.frm";
						uint CrSpriteId = LoadSprite( cr_sprite_name, int( PT_ART_CRITTERS ) );
						int crHeight = int( ( GetSpriteHeight( CrSpriteId, 0 ) ) / __SpritesZoom );
						
						int hx = 0, hy = 0;
						GetHexPos( critter.HexX, critter.HexY, hx, hy );
						DrawSprite( TalkSpriteId, -1, hx, hy - crHeight + 2, 0 );
					}
				}
			}
	
			critters.resize(0);
		}
		
		if( ! __GmapActive && ( _MainScreen == CLIENT_MAIN_SCREEN_GAME ) && valid( choo ) && FLAG( choo.Param[ PLAYER_FLAGS ], PLAYER_FLAG_NPC_ICONS ) )
		{
			CritterCl@[] crits;
			uint len = GetCritters( 0, FIND_LIFE_AND_KO, crits );
			for( uint i = 0; i < len; i++ )
			{
				CritterCl@ critter = crits[i];
				if( valid( critter ) )
				{
					if( critter.Mode[ MODE_QUESTGIVER ] != 0 || ( critter.IsNpc() && critter.Mode[ MODE_NO_BARTER ] == 0 ) )
					{
						string cr_sprite_name = GetCritterTypeName( critter.CrType ) + "aa.frm";
						uint CrSpriteId = LoadSprite( cr_sprite_name, int( PT_ART_CRITTERS ) );
						int crHeight = int( ( GetSpriteHeight( CrSpriteId, 0 ) ) / __SpritesZoom );
						
						int hx = 0, hy = 0;
						GetHexPos( critter.HexX, critter.HexY, hx, hy );
						
						if( critter.Mode[ MODE_QUESTGIVER ] != 0 )
						{
							DrawSprite( QuestSpriteId, -1, hx - 10, hy - crHeight - 40, COLOR_YELLOW );
							if( critter.IsNpc() && critter.Mode[ MODE_NO_BARTER ] == 0 )
							{
								DrawSprite( TradeSpriteId, -1, hx + 15, hy - crHeight - 35, COLOR_TEXT );
							}
						}
						else if( critter.IsNpc() && critter.Mode[ MODE_NO_BARTER ] == 0 )
						{
							DrawSprite( TradeSpriteId, -1, hx - 10, hy - crHeight - 30, COLOR_TEXT );
						}
					}
				}
			}
	
			crits.resize(0);
		}

		if( valid( choo ) && !IfaceHidden )
		{
			string action_points = "";
			int ap = choo.Stat[ ST_CURRENT_AP ];
			action_points = ap;
			int colour = ap > 0 ? COLOR_GREEN : COLOR_RED;
			DrawText( action_points, APCountX, APCountY, action_points.length() * 15, 15, colour, FONT_FAT, FT_BORDERED );
		}
	}
    else if( layer == 3 )
    {
		DrawChosenTabs();
		GUI_Render();

		ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
		if( valid( item ) )
		{
			uint16 grid_pid = item.GetProtoId();
			if( valid( choo ) && GetCurrentCursor() == CURSOR_MOVE && grid_pid >= EXIT_GRID_PID_BEGIN && item.GetProtoId() <= EXIT_GRID_PID_END )
			{
				int localmap_dir = 0;
				int x = 0, y = 0;
				switch( grid_pid )
				{
					case( EXIT_GRID_NE ):
						localmap_dir = 0;
						x = -100;
						y = -80;
						break;
					case( EXIT_GRID_E ):
						localmap_dir = 1;
						x = -120;
						y = -110;
						break;
					case( EXIT_GRID_SE ):
						localmap_dir = 2;
						x = -120;
						y = -120;
						break;
					case( EXIT_GRID_S ):
						localmap_dir = 3;
						x = -120;
						y = -100;
						break;
					case( EXIT_GRID_SW ):
						localmap_dir = 4;
						x = -90;
						y = -110;
						break;
					case( EXIT_GRID_W ):
						localmap_dir = 5;
						x = -100;
						y = -110;
						break;
					case( EXIT_GRID_NW ):
						localmap_dir = 6;
						x = -60;
						y = -125;
						break;
					case( EXIT_GRID_N ):
						localmap_dir = 7;
						x = -120;
						y = -120;
						break;
					default:
						break;
				}

				arrow[ localmap_dir ].Draw( __MouseX + x, __MouseY + y );

				uint localMapPid = choo.StatBase[ ST_LOCALMAP_PID ];

				if( localmap_dir != choo.StatBase[ ST_LOCALMAP_DIR ] )
				{
					RunServerScriptUnsafe( "globalmap_group@unsafe_GetMapPid", item.HexX, item.HexY, item.GetProtoId(), null, null );
				}
				
				localMapPid++;
				
				string mapName = GetMsgStr( TEXTMSG_GM, localMapPid * 10 + 8 );
				bool isRed = ( mapName == "error" ) || ( localMapPid == 0 );
				if( mapName == "error" ) 
				{
					mapName = GetMsgStr( TEXTMSG_GAME, STR_MAP_UNAVAILABLE );
				}
				
				DrawText( localMapPid != 0 ? mapName : GetMsgStr( TEXTMSG_GAME, STR_MAP_WASTELAND ), __MouseX - ( localMapPid != 0 ? mapName.length() * 7 : 45 ), __MouseY + 20, 400, 20, isRed ? COLOR_RED : COLOR_LGREEN, FONT_BIG, 0 );
			}
        }
        // Hex attack
        if( valid( choo ) && __IsHexAttack && GetCurrentCursor() == CURSOR_USE_WEAPON )
        {
			CritterCl@ target = MouseCritter;
			if( valid( target ) )
			{
				if( isGM( choo ) )
				{
					string sub_info;
					sub_info = target.Stat[ ST_CURRENT_HP ] + " / " + target.Stat[ ST_MAX_LIFE ];
					DrawText( sub_info, __MouseX + 6, __MouseY - 18, sub_info.length() * 10, 10, COLOR_GREEN, FONT_FALLOUT, FT_BORDERED );
				}
			}
        }
	}
    else if( layer == 4 )
	{
	}
    else if( layer == 5 )
    {
        int active_screen = GUI_GetActiveScreen();
        bool show = !__IsTextInput && active_screen == CLIENT_MAIN_SCREEN_GAME; //&& !__ConsoleActive
        //send positions of players' sprites, send empty if gui is active
        //overlay_loop(show);
    }
    else if( layer == 100 && __GmapActive )
    {
        render_global_map();
    }
}

void render_global_map()
{
    CritterCl@ ch = GetChosen();
    if( valid( ch ) )
    {
        // Here you can draw on global map

        // bool  __GmapActive - is global map active and all coords below are correct?
        // bool  __GmapWait   - encounter reply mode is active
        // float __GmapZoom   - current zoom, dont forget to accont for it whie drawing map
        // int   __GmapOffsetX/Y   - offset from 0 coodinate (top-left corner);
        // int   __GmapGroupCurX/Y - player group coordinates;
        // int   __GmapGroupToX/Y  - destination coordinates;
        // float __GmapGroupSpeed  - current group speed.
        // example of current group pixel calculation:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.

        int flags = ( FT_NOBREAK | FT_CENTERX | FT_CENTERY | FT_BORDERED );
        int font = FONT_FALLOUT;

        float size = 10 / __GmapZoom;

        uint16 chx = __GmapGroupCurX / 10, chy = __GmapGroupCurY / 10;

        if( @data_color != null && __global & CONF_GLOB_WILD != 0 )
        {
            int len = data_color.length();

            if( len > 0 && len % 2 == 0 )
            {
                int[] drawData( len * 18 / 2 );

                for( int i = 0, j = 0; i < len / 2; j++ )
                {
                    int x = ( data_color[ j * 2 ] & 0xFFFF );
					int y = ( ( data_color[ j * 2 ] >> 16 ) );

                    x = int( x * 10 / __GmapZoom + __GmapOffsetX );
                    y = int( y * 10 / __GmapZoom + __GmapOffsetY );

                    int a = data_color[ j * 2 + 1 ];

                    int k = i * 18;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = int( x + size );
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = int( y + size );
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = int( y + size );
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = int( x + size );
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = int( x + size );
                    drawData[ k++ ] = int( y + size );
                    drawData[ k++ ] = a;

                    i++;
                }
                drawData.resize( len * 18 / 2 );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLELIST, drawData );
            }
        }

        if( size > 10 && __global & CONF_GLOB_GRID != 0 )
        {
            int alpha = CLAMP( int( ( size - 5 ) * 20 ), 0, 0xAA );
            int r = 0x22, g = 0x22, b = 0x22;
            r = CLAMP( r, 0, 0xFF );
            g = CLAMP( g, 0, 0xFF );
            b = CLAMP( b, 0, 0xFF );
            int color = ( ( alpha ) << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );

            int x0 = __GmapOffsetX;
            int y0 = __GmapOffsetY;
            int x = int( ZONE_COUNT_X * ZONE_LENGTH / __GmapZoom + __GmapOffsetX );
            int y = int( ZONE_COUNT_Y * ZONE_LENGTH / __GmapZoom + __GmapOffsetY );

            int w = ZONE_COUNT_X * ZONE_LENGTH / 10;
            int h = ZONE_COUNT_Y * ZONE_LENGTH / 10;

            int[] drawData( ( w + h + 2 ) * 6 );

            for( int i = 0; i <= h; i++ )
            {
                drawData[ i * 6 ] = x0;
                drawData[ i * 6 + 1 ] = int( y0 + size * i );
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x;
                drawData[ i * 6 + 4 ] = int( y0 + size * i );
                drawData[ i * 6 + 5 ] = color;
            }
			
            for( int j = 0; j <= w; j++ )
            {
                int i = h + 1 + j;
                drawData[ i * 6 ] = int( x0 + size * j );
                drawData[ i * 6 + 1 ] = y0;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = int( x0 + size * j );
                drawData[ i * 6 + 4 ] = y;
                drawData[ i * 6 + 5 ] = color;
            }
            DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
        }

        if( size >= 5 )
        {
            int x = int( ( chx * 10 ) / __GmapZoom + __GmapOffsetX );
			int y = int( ( chy * 10 ) / __GmapZoom + __GmapOffsetY );
			int color = int( 0xAA00FFFF );

			int[]  drawData =
			{ 
				x + 1, y + 1, color,
				int( x + size - 1 ), y + 1, color,
				int( x + size - 1 ), int( y + size - 1 ), color,
				x + 1, int( y + size - 1 ), color,
				x + 1, y + 1, color
			};
			DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
        }

        if( @data_number != null )
        {
            int len = data_number.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( int i = 0; i < len / 2; i++ )
                {
                    int x = data_number[ i * 2 ] & 0xFFFF;
                    int y = data_number[ i * 2 ] >> 16;

                    x = int( x * 10 / __GmapZoom + __GmapOffsetX );
                    y = int( y * 10 / __GmapZoom + __GmapOffsetY );
                    int a = data_number[ i * 2 + 1 ] & 0xFFFF;
                    int b = data_number[ i * 2 + 1 ] >> 16;

                    string str = a;
                    if( b > 0 )
					{
                        str += "+" + ( b - a );
					}
					
					int alpha = MIN( int( 2000.0f / size ), 0x88 );
					int color = 0x00FFAA00 | ( ( alpha ) << 24 );

					int[]  drawData =
					{
						x + 1, y + 1, color,
						int( x + size - 1 ), y + 1, color,
						x + 1, int( y + size - 1 ), color,
						int( x + size - 1 ), int( y + size - 1 ), color
					};
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
                    
					int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), int( size + tw ), int( size + tw ), 0xFF22AAFF, font, flags );
                }
            }
        }

        if( @data_char != null )
        {
            int len = data_char.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( int i = 0; i < len / 2; i++ )
                {
                    int x = ( data_char[ i * 2 ] & 0xFFFF );
                    int y = ( ( data_char[ i * 2 ] >> 16 ) );

                    x = int( x * 10 / __GmapZoom + __GmapOffsetX );
                    y = int( y * 10 / __GmapZoom + __GmapOffsetY );
                    int a = ( data_char[ i * 2 + 1 ] & 0x00FFFFFF ) | 0xFF000000;
                    int b = data_char[ i * 2 + 1 ] >> 24;

                    string str = " ";
                    str[ 0 ] = b;

                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), int( size + tw ), int( size + tw ), a, font, flags );
                }
            }
        }

		int x = int( ( __MouseX - __GmapOffsetX ) * __GmapZoom );
		int y = int( ( __MouseY - __GmapOffsetY ) * __GmapZoom );

		x -= x % 10;
		y -= y % 10;

		string str = floor( x / 10 ) + " : " + floor( y / 10 );

		x = int( x / __GmapZoom + __GmapOffsetX );
		y = int( y / __GmapZoom + __GmapOffsetY );

		if( size >= 5 )
		{
			int[] drawData =
			{
				x + 1, y + 1, int( COLOR_RED ),
				int( x + size - 1 ), y + 1, int( COLOR_RED ),
				int( x + size - 1 ), int( y + size - 1 ), int( COLOR_RED ),
				x + 1, int( y + size - 1 ), int( COLOR_RED ),
				x + 1, y + 1, int( COLOR_RED )
			};
			DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
		}

		int tw = 0, th = 0, lines = 0;

		GetTextInfo( str, 0, 0, font, FT_NOBREAK, tw, th, lines );
		DrawText( str, __MouseX + 30, __MouseY + 10, tw, th, COLOR_LGREEN, font, FT_NOBREAK );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    DrawMapTiles();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down( FOWindow@ window, int click )
{
	if( window !is MainWindow )
		return false;
	if( IsDebugLookMode() && GetCurrentCursor() == CURSOR_MOVE && !IsMonitorGui( __MouseX, __MouseY ) )
	{
		CritterCl@ chosen = GetChosen();
		if( valid( chosen ) && click == MOUSE_CLICK_LEFT )
		{
			uint16 hexX = 0, hexY = 0;
			if( GetMonitorHex( __MouseX, __MouseY, hexX, hexY ) )
			{
				RunServerScript( "test@CheckHexSeeMe", hexX, hexY, GetDirection( hexX, hexY, chosen.HexX, chosen.HexY ), null, null );
				return true;
			}
		}
	}
    return GUI_MouseDown( click, __MouseX, __MouseY );
}

bool mouse_up( FOWindow@ window, int click )
{
	if( window !is MainWindow )
		return false;
		
    return GUI_MouseUp( click, __MouseX, __MouseY );
}

void mouse_move( FOWindow@ window, int x, int y )
{
	if( window !is MainWindow )
		return;
		
    GUI_MouseMove( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.

bool __altDown = false;
bool __shiftDown = false;

bool key_down( FOWindow@ window, uint8 key )
{
	if( window !is MainWindow )
	{
		return false;
	}
	
	//F1 help
	if( key == DIK_F1 && !__altDown && !__shiftDown )
	{
		F1IsDraw = !F1IsDraw;
	}
	
	//Hide F1 Help
	if( key == DIK_F1 && __shiftDown )
	{
		hideF1 = !hideF1;
	}
	
	CritterCl@ chosen = GetChosen();
	
	//F4 hide interface
	if( key == DIK_F4 && !__altDown && !__shiftDown && !__ctrlDown && ( valid( chosen ) || GUI_GetActiveScreen() == CLIENT_SCREEN_TOWN_VIEW ) )
    {
        IfaceHidden = !IfaceHidden;
    }
	
	//F9 item countour
	if( key == DIK_F9 )
	{
		if( __ShowContourItems )
		{
			__ShowContourContainer = false;
			__ShowContourItems = false;
		}
		else
		{
			__ShowContourContainer = true;
			__ShowContourItems = true;
		}
		ChosenRefreshMap();
	}	
	
	if( valid( chosen ) )
	{
		if( chosen.Perk[ PE_AVA_BLOCK ] == 0 )
		{
			if( __altDown && key == DIK_K )
			{
				CritterCl@ mouseCritter = MouseCritter;
				if( !valid( mouseCritter ) )
				{
					Message( "Select|0xFFFF00  Your|0x3CF800  Avatar." );
					@mouseCritter = chosen;
				}
				else if( mouseCritter !is chosen && mouseCritter.Param[ PET_OWNER_ID ] == int( chosen.Id ) )
				{
					Message( "Select|0xFFFF00  Pet|0x3CF800  Avatar." );
				}
				else if( mouseCritter !is chosen && !isGM( chosen ) )
				{
					Message( "Select|0xFFFF00  Your|0x3CF800  Avatar." );
					@mouseCritter = chosen;				
				}
				else
				{
					Message( "Select|0xFFFF00  Target|0x3CF800  Avatar." );
				}
				
				GUI_ShowScreen( CLIENT_SCREEN_AVATAR, mouseCritter.Id, 0, 0 );
			}
		}
		//F10 wall + roof transparency
		if( key == DIK_F10 )
		{
			if( __WallAlpha <= 200 )
			{
				__WallAlpha = 255;
				__ShowWall = true;
			}
			else
			{
				__WallAlpha = chosen.Param[ WALL_ALPHA ];
				__ShowWall = __WallAlpha > 0 ? true : false;
			}
			
			__RoofAlpha = __WallAlpha;
			__ShowRoof = __ShowWall;
			ChosenRefreshMap();
		}
		
		if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys && !__ConsoleActive )
		{
			if( !__ctrlDown )
			{
				switch( key )
				{
					case( DIK_C ):
					case( DIK_F ):
					case( DIK_I ):
					case( DIK_O ):
					case( DIK_P ):
					case( DIK_S ):
						return true;
				}
			}
		}

		if( !( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys ) && !__ConsoleActive && WASDInputKeyState( key, true ) )
		{
			return true;
		}
		
		/*if( __ctrlDown && key == DIK_O )
		{
			//show or hide overlay
			overlay_visibility();
			return true;
		}*/
		
		if( __ConsoleActive )
		{
			if( key != DIK_RETURN )
			{
				if( chosen.Param[CR_TYPING_TIME] < int( __FullSecond + __TypingDelay ) )
				{
					RunServerScriptUnsafe( "rp_chat@unsafe_ShowTyping", 0, 0, 0, null, null );
				}
			}
			else
			{
				if( chosen.Param[CR_TYPING_TIME] > int( __FullSecond + __TypingDelay ) )
				{
					RunServerScriptUnsafe( "rp_chat@unsafe_stopTyping", 0, 0, 0, null, null );
				}
			}
		} 

		if( __waiting )
		{
			if( __ConsoleActive ) 
			{
				bool key_disallowed = ( key == DIK_ESCAPE );
				return key_disallowed;
			}
			
			if( key == DIK_RETURN )
			{
				__ConsoleActive = true;
				return true;
			}

			if( key == DIK_ESCAPE || key == DIK_SPACE )
			{
				RunServerScriptUnsafe( "ltp@unsafe_StopProcess",  0, 0, 0, null, null );
			}
			
			return true;
		}
	}

    // Effect example, temporary
    if( key == DIK_LMENU || key == DIK_RMENU )
	{
        __altDown = true;
	}
	
    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
	{
        __ctrlDown = true;
	}
	
	if( key == DIK_LSHIFT || key == DIK_RSHIFT )
	{
		__shiftDown = true;
	}
	
    if( key == DIK_Z && !__ctrlDown && !__altDown )
	{
        __MapZooming = true;
    }

	if( __altDown )
	{
		if( key == DIK_LBRACKET )
		{
			AvatarSizeDown();
			return true;
		}
		
		if( key == DIK_RBRACKET )
		{
			AvatarSizeUp();
			return true;
		}
		
		if( key == DIK_P )
		{
			RunServerScriptUnsafe( "player_menu@unsafe_toggle_avatar", 0, 0, 0, null, null );
			//AvatarRenderMode++;
			//AvatarRenderMode = AvatarRenderMode%EAvatarRenderMode::AvatarRenderModeCount;
			return true;
		}
	}
	
	if( GUI_KeyDown( key ) )
	{
		// Hotkey consumed
		return true;
	}
	else
	{
		// disable hardcoded date and time hotkey
		if( key == DIK_SLASH && _MainScreen==CLIENT_MAIN_SCREEN_GAME && !__ConsoleActive && !__IsTextInput && !__ctrlDown && !__altDown )
		{
			RunServerScriptUnsafe( "time@unsafe_getIngameTime", 0, 0, 0, null, null );
			return true;
		}
	}
    return false;
}

bool key_up( FOWindow@ window, uint8 key )
{
	if( window !is MainWindow )
	{
		return false;
	}
	
    if( WASDInputKeyState( key, false ) )
	{
        return true;
    }

    if( key == DIK_LMENU || key == DIK_RMENU )
	{
        __altDown = false;
    }
	
	if( key == DIK_LCONTROL || key == DIK_RCONTROL )
	{
        __ctrlDown = false;   
	}
	
	if( key == DIK_LSHIFT || key == DIK_RSHIFT )
	{
		__shiftDown = false;
	}
	
    if( __waiting )
	{
        return !__ConsoleActive;
	}
	
    if( key == DIK_Z && !__ctrlDown && !__altDown )
	{
        __MapZooming = false;
	}
    return GUI_KeyUp( key );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost( FOWindow@ window )
{
	if( window !is MainWindow )
	{
		return;
	}
	
    __altDown = false;
    __ctrlDown = false;
	__shiftDown = false;
    __MapZooming = false;

    GUI_InputLost();
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on money counting for Dialog Box (APAMk2).
string critter_get_money( CritterCl& chosen )
{
	string result = "";
	
	uint moneyCount = 0;
	int[] currencyPids = { 
		PID_DOLLAR_100, PID_PREWAR_DOLLAR_100, 
		PID_DOLLAR_20, 	PID_PREWAR_DOLLAR_20,
		PID_GOLDEN_COIN, //10$
		PID_DOLLAR_5, 	PID_PREWAR_DOLLAR_5,
		PID_PREWAR_DOLLAR_1, PID_BOTTLE_CAPS
	};
	
	for( int i = 0, l = currencyPids.length(); i < l; i++ )
	{
		int currencyPid = currencyPids[i];
		
		int currencyAvailable = chosen.CountItem( currencyPid );
		moneyCount += currencyAvailable * GetProtoItem( currencyPid ).Cost;
	}
	
	result += moneyCount;
	result += "$";
	
	return result;
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in( CritterCl& cr )
{
	if( !valid( cr ) )
	{
		return;
	}
	
    CritterCl@ ch = GetChosen();
    if( valid( ch ) && ch.Id == cr.Id && prevId != cr.Id )
    {
        @data_number = null;
        @data_color = null;
        @data_char = null;
        LoadNames();
        prevId = cr.Id;

		updateNick( cr );
		
		updateSINF();
		initControlPanel();
    }

    updateNick( cr );

    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED );

	if( valid( ch ) )
	{
		if( SameFaction( ch, cr ) )
		{
			cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_GREEN : COLOR_CONTOUR_BLUE );
		}
		else if( cr.Stat[ ST_FOLLOW_CRIT ] == int( ch.Id ) || cr.Param[ PET_OWNER_ID ] == int( ch.Id ) || cr.Param[ PET_PROTECT_ID ] == int( ch.Id ) )
		{
			cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_GREEN : COLOR_CONTOUR_MNBLUE );
		}
	}
	
	checkCritterControl( cr );

   // if( __fastPanel )
	//{
       // HidePanel( true );
   // }
}

void critter_out( CritterCl& cr )
{
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{
	#ifndef PHYSICAL_UI
        iList().add( item );
    #endif //PHYSICAL_UI
}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{
    #ifndef PHYSICAL_UI
	    iList().change( itemNow, itemBefore );
    #endif //PHYSICAL_UI
}

void item_map_out( ItemCl& item )
{
    #ifndef PHYSICAL_UI
	    iList().remove( item );
    #endif //PHYSICAL_UI
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{
	if( item.GetType() == ITEM_TYPE_CONTAINER )
	{
		RunServerScriptUnsafe( "main@unsafe_ItemsWeight", item.Id, 0, 0, null, null );
  	}
}

void item_inv_out( ItemCl& item )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop( ItemCl& item )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
string last_radio_message = "";
bool last_radio_message_recieved = true;
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    if(message == "")
	{
		return false;
	}
	
    // Detect radio
    if( color == 0xFFFFFFFE )
	{
        MapMessage(message, hexX, hexY, color, delay);
        message = ".." + message + "..";
		
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			if( !last_radio_message_recieved )
			{
				Message( "|0xFFFFFF " + last_radio_message );
            }
			else
			{
				last_radio_message_recieved = false;
			}
			last_radio_message = message;
		}
	}
		
	if( color == COLOR_GRAY )
	{
        Message("|0x8F8F8F " + message );
	}
	
	if( color == COLOR_LGRAY )
	{
        Message("|0xD3D3D3 " + message );
	}
	
	if( color == COLOR_TEXT || color == COLOR_CHAT_SHOUT )
	{
        MapMessage(message, hexX, hexY, color, delay);
		Message( "???: " + message );
	}

    if( message == "")
	{
		return false;
	}
	
	return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{
    if(message == "")
	{
		return false;
	}
	
    if( sayType > SAY_RADIO )
	{
		return true;
	}

    if(!InMessage(message, sayType, critterId, delay))
	{
        return false;
    }

	CritterCl@ receiver = GetChosen();

    //send message to overlay, for logging and avatar position adjustment
    //overlay_message(message, sayType, critterId, delay);
	
    if( sayType == SAY_RADIO )
	{
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			last_radio_message = ".." + message + "..";
		}
		else
		{
			last_radio_message_recieved = true;
		}
		
        return true;	// for work radio and service messages
	}

    if( ( __sinf & SINF_CRID_CHAT ) != 0 && critterId != 0 && sayType <= SAY_WHISP_ON_HEAD )
    {
        message = "[" + critterId + "] " + message;
    }
	
    if( ( __sinf & SINF_INSIGHT ) != 0 )
	{
        return true;
	}

	return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message( string& message, int& sayType )
{
    if(message == "")
	{
		return false;
	}

	bool result = OutMessage(message, sayType);
    if(message == "")
	{
		return false;
    }
	return result;
}

bool out_command( string& message, int& sayType )
{
    if( __MessagePrefix != "" )
    {
        message = __MessagePrefix + " " + message;
        __MessagePrefix = "";
    }

    if( __IsHotkeysUse )
	{
        __IsTextInput = true;
	}

    if( message[ 0 ] == '%' ) // Command
	{
		string@[] @ valuesStr = splitEx( message, " " );
		int p0 = 0, p1 = 2, p2 = 6;
		if( valuesStr.length() == 2 ) 
		{
			if( !StrToInt( valuesStr[ 1 ], p0 ) )
			{
				string[] letters = 	{ "s", "p", "e", "c", "i", "a", "l" };
				p0 = ( letters.find( strlwr( valuesStr[ 1 ] ) ) % 7 ) + 1;
			}
		}
		
		if( valuesStr.length() == 3 ) 
		{
			StrToInt( valuesStr[ 1 ], p1 );
			StrToInt( valuesStr[ 2 ], p2 );
		}
		
		CritterCl@ chosen = GetChosen();
		CritterCl@ target = MouseCritter;
		if( isGM( chosen ) && valid( target ) )
		{
			int[] vals = { p0, p1, p2, target.Id };
			RunServerScriptUnsafe( "general_unsafe@unsafe_rolling_GM", 0, 0, 0, null, vals );
			return false;
		}
		RunServerScriptUnsafe( "general_unsafe@unsafe_rolling", p0, p1, p2, null, null );
		return false;
	}
	
	if( message[ 0 ] == '~' ) // Command
    {
		CritterCl@ chosen = GetChosen();
		if( findFirst( message, "~ilex" ) != -1 )
		{
			if( !chosen.IsLife() )
			{
				return false;
			}
			
			ItemCl@ hand = _CritGetItemHand( chosen );
			if( !valid( hand ) )
			{
				return false;
			}
			
			string new_lexem = "";
			
			if( message.length() > 5 )
			{
				new_lexem = substring( message, 6, message.length() - 6 );
			}
			
			string current_lexem = hand.Lexems;
			int remaining = 125 - current_lexem.length();
			if( remaining <= 32 )
			{
				Message( GetMsgStr( TEXTMSG_GAME, STR_ITM_LEX_WARN ) + remaining + GetMsgStr( TEXTMSG_GAME, STR_SYMBOLS ) );
				if( remaining - new_lexem.length() < 0 )
				{
					return false;
				}
			}
			
			RunServerScriptUnsafe( "general_unsafe@unsafe_addLexem", 0, 0, 0, new_lexem, null );
			return false;
		}
		
		if( message == "~sex" )
		{
			__InitSex( 0, 0, 0, null, null );
			return false;
		}
		
		if( message == "~eat" )
		{
			CritterCl@ choo = GetChosen();
			if( choo.Stat[ ST_BODY_TYPE ] != BT_MEN && choo.Stat[ ST_BODY_TYPE ] != BT_WOMEN && choo.Stat[ ST_BODY_TYPE ] != BT_CHILDREN )
			{
				__InitDevour( 0, 0, 0, null, null );
			}
			
			return false;
		}
		
		if( message == "~toglobal" ) //move to GM
		{
			if( isGM( chosen ) ) 
			{
				RunServerScriptUnsafe( "general_unsafe@unsafe_toglobal", 0, 0, 0, null, null );
				return false;
			}
		} 
		
		if( message == "~suicide" )
        {
            RunServerScriptUnsafe( "suicide@unsafe_killself", 0, 0, 0, "", null );
            return false;
        }
		
		if( message == "~naked" )
		{
            RunServerScriptUnsafe( "general_unsafe@unsafe_getNaked", 0, 0, 0, "", null );
            return false;
		}

		if( message == "~puke" )
		{
            RunServerScriptUnsafe( "vomit@unsafe_vomit", 0, 0, 0, "", null );
            return false;
		}

		string@[]@ parts = split( message, " " );

		if( parts[0] == "~name" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 6 )
			{
				text = substring( message, 6, message.length() - 6 );
			}
			
			CritterCl@ target = MouseCritter;
			if( valid( target ) )
			{
				RememberName( target.Id, text );
			}
			return false; 
		}

		if( parts[0] == "~lex" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 )
			{
				text = substring( message, 5, message.length() - 5 );
			}
			
			RunServerScriptUnsafe( "general_unsafe@unsafe_selfLex", 0, 0, 0, text, null ); 
			return false; 
		}

		if( parts[0] == "~afk" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 )
			{
				text = substring( message, 5, message.length() - 5 );
			}
			
			RunServerScriptUnsafe( "general_unsafe@unsafe_setAFK", 0, 0, 0, text, null ); 
			return false; 
		}

		if( parts[0] == "~drugs" )
        {
			uint id = 0;
			CritterCl@ target = MouseCritter;
			if( valid( target ) )
			{
				id = target.Id;
			}
			
			if( parts.length() == 2 ) 
			{
				int uid = 0;
				if( StrToInt( parts[1], uid ) )
				{
					id = uid;
				}
			}

            RunServerScriptUnsafe( "consumables@unsafe_menu", id, 0, 0, null, null );
            return false;
        }

		if( message == "~sf" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 1, 0, 0, "", null );
            return false;
        }

        if( message == "~sb" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 0, 0, 0, "", null );
            return false;
        }
		
        if( parts[0] == "~roofs" )
        {
            if( parts.length() > 1 )
            {
                int alpha = -1;
                if( StrToInt ( parts [ 1 ], alpha ) )
                {
                    if( alpha > -1 )
                    {
                        alpha = MIN( alpha, 255 );
                        __RoofAlpha = alpha;
                    }
                }
            }
            return false;
        }

		if( parts[0] == "~stats" ) 
		{			
			CritterCl@ target = MouseCritter;
			if( valid( target ) )
			{
				CallCritStatsScreen(target.Id);
			}
			return false; 
		}

        return true;
    }

    if( message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' ) // tnf commands
    {
		CritterCl @target = MouseCritter;
		string targetInfo = valid( target ) ? "[" + target.Name + " #" + target.Id + "]" : "";
        RunServerScriptUnsafe("general_unsafe@unsafe_log", 0, 0, 0, GetChosen().Name + " #" + GetChosen().Id + " " + targetInfo + " - " + message, null);
        return gm_msg(message);
    }

    Message( "|0xFFFF00" + GetMsgStr( TEXTMSG_GAME, STR_COMMAND_NOT_FOUND ) );
    return false;
}

bool out_speak( string& message, int& sayType )
{
    CritterCl@ chosen = GetChosen();
    if( chosen.IsDead() && sayType != SAY_NARATIVE )
    {
        Message( GetMsgStr( TEXTMSG_GAME, STR_DEAD_CANT_TALK ) );
        return false;
    }

    //Check for chars other than space
	bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != ' ' )
        {
            result = true;
            break;
        }
    }
	if( result == false )
	{
		return false;
	}
	
  	//Shaman radio listeners
    if( valid( chosen ) && ( sayType == SAY_NORM || sayType == SAY_PET || sayType == SAY_SHOUT || sayType == SAY_WHISP || sayType == SAY_RADIO ) )
	{
        RunServerScriptUnsafe( "radio@unsafe_OutMessage", sayType, 0, 0, message, null );
    }

	switch( sayType )
	{
		case( SAY_NORM ):
		case( SAY_EMOTE ):
		case( SAY_NARATIVE ):
			break;
		case( SAY_PET ):
			sayType = SAY_NORM;
			break;
		case( SAY_WHISP ):
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );
			break;
		case( SAY_SHOUT ):
			RunServerScriptUnsafe( "rp_chat@unsafe_shout_all", 0, 0, 0, message, null);
			break;
		case( SAY_RADIO ):
		{
			RunServerScriptUnsafe( "general_unsafe@unsafe_radioHead", 0, 0, 0, message, null );
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Radio", 0, 0, 0, message, null ); 
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );
			break;
		}
		default:
			Message( "Unhandled sayType: " + sayType );
			return false;
	}

	int[] controlled_npcs = control();
	//Gray text and ability to speak for targeted crit
	if( sayType != SAY_RADIO && ( isGM( chosen ) && controlled_npcs.length() > 0 || sayType == SAY_NARATIVE ) )
	{
		uint16 hexX = 0, hexY = 0;
		GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
		RunServerScriptUnsafe( "rp_chat@unsafe_SayChatMessage", sayType, hexX, hexY, message, controlled_npcs );
		return false; //does not send standard way, script intercept message
	}

	//Serverside - record into SayLog.txt
	RunServerScriptUnsafe( "rp_chat@unsafe_SayLog", sayType, 0, 0, message, null );

	if( chosen.IsKnockout() && ( sayType < SAY_NARATIVE || sayType == SAY_PET ) ) 
	{
		RunServerScriptUnsafe( "general_unsafe@unsafe_KnockSay", sayType, 0, 0, message, null ); 
		return false; 
	}

	return true;
}

// Hex attack
int to_hit_hex()
{
	CritterCl@ chosen = GetChosen();
    uint16 hexX = 0, hexY = 0;
    GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
    ItemCl@ realWeapon = _CritGetItemHand( chosen );
    uint8 mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) && valid( realWeapon ) )
	{
        @weapon = GetProtoItem( realWeapon.Proto.ProtoId );
	}
	
	if( !valid( weapon ) )
	{
		return 0;
	}
	
    uint skillNum = _WeaponSkill( weapon, mode );
    int dmgType = _WeaponDmgType( weapon, mode );

    int dist = GetDistantion( chosen.HexX, chosen.HexY, hexX, hexY );
	
    uint16 toHx = hexX, toHy = hexY;
    GetHexCoord( chosen.HexX,  chosen.HexY, toHx, toHy,  0.0f, dist );
    if( ( hexX != toHx ) || ( hexY != toHy ) )
	{
        return 0;
	}
	
    int weaponMode = _WeaponModeUse( mode );
	uint8 weaponType = ( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
	ProtoItem@ ammo = null;
	
	if( valid( realWeapon ) )
	{
		@ ammo = GetProtoItem( realWeapon.AmmoPid );
	}
		
	int toHit = to_hit( chosen, null, weapon, weaponMode, ammo, hexX, hexY, false );

	return toHit;
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// To-hit chance.
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int hitLocation = _WeaponModeAim( weaponMode );
	if( hitLocation == HIT_LOCATION_NONE && _WeaponAim( weapon, weaponMode & 0x0F ) )
	{
		hitLocation = chosen.Param[ CR_AUTO_AIM ];
	}
	
    int use = _WeaponModeUse( weaponMode );

    if( use > 2 )
	{
        return 0;
	}
	
    if( target.IsDead() )
	{
        return 0;
	}
	
    if( !chosen.IsLife() )
	{
        return 0;
	}
	
    ItemCl@ realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
	{
        if( realWeapon.AmmoCount == 0 )
		{
            return 0;
        }
		
		@ammo = GetProtoItem( realWeapon.AmmoPid );
    }

	int toHit = to_hit( chosen, target, weapon, weaponMode, ammo, 0, 0, false );

    return toHit;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results. REVISE - MAKE MUTUAL MODULE
void combat_result( uint[]& data )
{
	uint datalen = data.length();
    if( datalen < 4 )
	{
        return;
	}
	
    if( data[ 0 ] != datalen )
	{
        return;
	}
	
	testInfo( CR_TEST_MODE_COMBAT, "Data: " + enlistUINT(data) );
	
	CritterCl@ chosen = GetChosen();
	
    uint current = 1;

    while( current < datalen )
	{
        int damage = -1;
        uint effect = 0;
        uint loc = 0;
        int message = -1;

        uint mode = data[ current++ ];
        uint who = data[ current++ ];
        uint who2;
        CritterCl@ originalTarget;

        CritterCl@ cr = GetCritter( who );
		CritterCl@ trueTarget = null;

        bool self = ( who == GetChosen().Id );
		
		bool isDead = true;

        string name = "error0";
        if( valid( cr ) )
		{
			if( !self )
			{
				name = cr.Name;
			}
			else
			{
				name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
			}
			isDead = !cr.IsPlayer();
        }

        uint offset;
        if( self )
		{
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
			{
                offset = 506;
			}
			else
			{
                offset = 556;
			}
		}
		else
		{
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
			{
                offset = 606;
			}
			else if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
			{
                offset = 656;
			}
			else
			{
				offset = 706;
			}
		}

        string result;

        // reading and preparing the data:
        switch( mode )
        {
			case( CMSG_CRIT_MISS ):
			{
				effect = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
				result = ReplaceText( result, "%s", name );
				break;
			}
			case( CMSG_CRIT_MISS_DAMAGE ):
			{
				effect = data[ current++ ];
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 ) {
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_HIT ):
			case( CMSG_HIT_DEAD ):
			{
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
				
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_AIMED_HIT ):
			case( CMSG_AIMED_HIT_DEAD ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );

				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_HIT ):
			{
				damage = data[ current++ ];
				effect = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_AIMED_HIT ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				effect = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_HIT_DEAD ):
			{
				damage = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_AIMED_HIT_DEAD ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_OOPS ):
			{
				who2 = data[ current++ ]; // who2 was hit instead of who
				@trueTarget = GetCritter( who2 );
				if( self )
				{
					// It was original target
					uint gender_info = CLAMP( cr.Stat[ ST_GENDER ], GENDER_MALE, GENDER_IT ) * 100;
					result = GetMsgStr( TEXTMSG_COMBAT, 608 + gender_info );
					string nameTrue = "error1";
					if( valid( trueTarget ) )
					{
						nameTrue = trueTarget.Name;
					}
					result = ReplaceText( result, "%s", nameTrue );
				}
				else
				{
					// It was not original target
					result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
					if( who2 == GetChosen().Id )
					{
						result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
					}
					else
					{
						string nameTrue = "error1";
						if( valid( trueTarget ) )
						{
							nameTrue = trueTarget.Name;
						}
						result = ReplaceText( result, "%s", nameTrue );
					}
					result = ReplaceText( result, "%s", name );
				}
				break;
			}
			case( CMSG_MISS ):
			{			
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
				result = ReplaceText( result, "%s", name );
				break;
			}
			case( CMSG_HIT_RANDOMLY ):
			{
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
				result = ReplaceText( result, "%s", name );
				result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
			}
			default:
				break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;
		uint[] exts;

        if( message != -1 && isVerbose )       // Must be critical hit
		{
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
		else if( effect != 0 )
		{
            offset -= 306;
			uint[] flags = { HF_KNOCKOUT, HF_KNOCKDOWN, HF_CRIPPLED_LEFT_LEG, HF_CRIPPLED_RIGHT_LEG, HF_CRIPPLED_LEFT_ARM, HF_CRIPPLED_RIGHT_ARM, HF_BLINDED, 
								0, 0, 0, 0, HF_BYPASS_ARMOR, 0, 0, HF_DROPPED_WEAPON, HF_STUNNED, 0, 0, 0, 0, 0, HF_RANDOM };
			uint len = flags.length();
            if( mode > CMSG_CRIT_MISS_DAMAGE )
			{         // Hit flags
            	for( uint x = 0; x < len; x++ )
				{
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
				}
			}
			else
			{
				for( uint x = 0; x < len; x++ )
				{
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
				}
				
                if( FLAG( effect, MF_WAS_KILLED ) )
				{
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) ) );
					exts.insertLast( offset + ( isDead ? 7 : 0 ) );
				}
            }
            offset += 306;
        }

		if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
		{
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) );
			exts.insertLast( offset + ( isDead ? 7 : 0 ) - 306 );
		}

		uint n = ext.length();
		testInfo( CR_TEST_MODE_COMBAT, "Ext.length = " + n );

        for( uint m = 0; m < n; m++ )
		{
            if( m == n - 1 )
			{
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            }
			else
			{
                result += ", ";
			}
			
            result += valid( ext[m] ) ? ext[m] : "[" + m + "#" + exts[m] + "]" ;
			
			testInfo( CR_TEST_MODE_COMBAT, "#" + m + ":" + exts[m] + ": " + checkNull(ext[m]) + ";" );
        }

        result += ".";

		uint attacker_id = data[++current]; current++;
		bool MyHit = ( chosen.Id == attacker_id ); 
		bool silent = ( attacker_id == uint(-1) );
        
		if( !silent )
		{
			Message( ( MyHit ? "|0xF5D742 " : "" ) + result, FOMB_COMBAT_RESULT );
		}

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
		{
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) + ".", FOMB_COMBAT_RESULT );
		}
        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
		{
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
		}
	}
}

string generic_description_slot_maker( int slot )
{
	string result;
	string[] lines = generic_description_slot( slot );
	int l = lines.length();
	for( int i = 0; i < 6; i++ )
	{
		if( i < l && valid( lines[i] ) )
		{
			result += lines[i];
		}
		
		result += "\n";
	}
	return result;
}

string[] generic_description_slot( int slot )
{
	CritterCl@ chosen = GetChosen();

	string line;
	string[] result;

	result.insertLast( "|0x3CF800 -----------------------" );
	
	ItemCl@ item = null; 
	if( slot == SLOT_HAND1 )
	{
		@item = _CritGetItemHand( chosen );
	}
	else
	{
		@item = _CritGetItemHandExt( chosen );
	}
	
	if( !valid( item ) )
	{
		uint8 mode = 0;
		int bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
		ProtoItem@ unarmed = chosen.GetSlotProto( slot, mode );
		result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) );
		result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + "|0xFFFF00  "
							+ ( _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + bonus ) + "|0x3CF800  - " + "|0xFFFF00 "
							+ ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + bonus ) 
						);

		return result;
	}
	
	int use = _WeaponModeUse( item.Mode );
	if( use > 2 )
	{
		use = 0;
	}
	
	result.insertLast( getItemTextName( itemText( item ) ) );

	if( item.GetType() != ITEM_TYPE_WEAPON )
	{
		if( item.GetType() == ITEM_TYPE_TRAP )
		{
			result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + "|0xFFFF00  " + item.Proto.Weapon_DmgMin_0 
				+  "|0x3CF800  - |0xFFFF00 " + item.Proto.Weapon_DmgMax_0 );
			result.insertLast( "|0x3CF800 " + ( item.Proto.Blast_Radius > 0 ? 
				( GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS_TRAP ) + "|0xFFFF00 " + item.Proto.Blast_Radius + "|0x3CF800  " ) : "" ) );
			
			result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_DAMAGE ) + GetMsgStr( TEXTMSG_GAME, STR_INV_DAMAGE_TYPE( item.Proto.Weapon_DmgType_0 ) ) );
		}
		
		else if( item.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
		{
			switch( item.BONDAGE_STATE )
			{
				case( BONDAGE_STATE_ON ):
					line = GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_BONDS );
					break;
				case( BONDAGE_STATE_BROKEN ):
					line = GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
					break;
				default:
					line = GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_READY );
					break;
			}
			result.insertLast( line + "|0x3CF800 " );
		}
		
		if( item.GetCount() > 1 )
		{
			result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE ) + "|0xFFFF00 " + item.GetCount() ); 
		}

		return result;
	}
	
	// Main inventory screen weapon damage info
	line = GetMsgStr( TEXTMSG_GAME, STR_INV_DMG );
	bool isAmmoRegen = FLAG( item.Proto.Weapon_Perk, WEAPON_PERK_RECHARGE );
	float minDamage = _WeaponDmgMin( item.Proto, use );
	float maxDamage = _WeaponDmgMax( item.Proto, use );
	uint minDmgMod = 100;
	uint maxDmgMod = 100;
	uint16 ammoRound = _WeaponRound( item.Proto, use );
	bool isBurst = ( _WeaponAnim2( item.Proto, use ) == ANIM2_BURST );
	uint16 ammoPid = item.AmmoPid;
	int dmgBonus = 0;
	int minDmgMalus = 0;
	int maxDmgMalus = 0;
	string burst = "";
	uint skill = _WeaponSkill( item.Proto, use );
	uint8 weapon_Subtype = item.Proto.Item_Subtype;
	bool unarmed = ( skill == SK_UNARMED && weapon_Subtype == ITEM_SUBTYPE_UNDEFINED );
	
	if( unarmed )
	{
		dmgBonus = chosen.Stat[ ST_MELEE_DAMAGE ];
	}
	else if( skill == SK_UNARMED || skill == SK_MELEE_WEAPONS )
	{
		dmgBonus = chosen.Skill[ skill ] / 10 + chosen.Stat[ ST_MELEE_DAMAGE ] / 2;
	}
	else if( skill == SK_THROWING || isAmmoRegen )
	{
		if( weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE )
		{
			dmgBonus = chosen.Stat[ ST_MELEE_DAMAGE ] / 2;
		}
	}
	
	//Melee weapons and melee thrown weapons that can deteriorate
	if( item.IsDeteriorable() )
	{
		if( ( ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_MELEE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_MELEE_END ) 
				|| ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END ) )
		)
		{
			int deterioration = item.Deterioration * 100 / MAX_DETERIORATION;
			minDmgMalus = int( ( _WeaponDmgMin( item.Proto, use ) + dmgBonus ) * deterioration * 0.01f );
			maxDmgMalus = int( ( _WeaponDmgMax( item.Proto, use ) + dmgBonus ) * deterioration * 0.01f );
		}
	}
	//All other weapons with ammo
	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		ProtoItem@ ammoProto = GetProtoItem( ammoPid );
		if( valid ( ammoProto ) )
		{
			minDamage = ammoProto.Ammo_DmgMin;
			maxDamage = ammoProto.Ammo_DmgMax;
			minDmgMod = item.Proto.Weapon_MinDmgMod;
			maxDmgMod = item.Proto.Weapon_MaxDmgMod;
		}
	}
	
	//Non-lethal weapon modifier
	else if( FLAG( item.Proto.Weapon_Perk, WEAPON_PERK_NON_LETHAL ) )
	{
		minDmgMod /= 2;
		maxDmgMod /= 2;
	}
	//Final calculation
	minDamage = ( ( minDamage + dmgBonus - minDmgMalus ) * minDmgMod ) * 0.01f;
	maxDamage = ( ( maxDamage + dmgBonus - maxDmgMalus ) * maxDmgMod ) * 0.01f;
	line += "|0xFFFF00 " + uint( minDamage ) + "|0x3CF800  - |0xFFFF00 " + uint( maxDamage );
	
	//Add number of rounds if burst mode
	if( isBurst )
	{ 
        line += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BURST ) + "|0xFFFF00 " + ammoRound;
    }
	
	result.insertLast( line );
	
	//Distance info
	if( _WeaponMaxDist( item.Proto, use ) > 1 )
	{
		line = "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST );
		
		int wpnMaxDist = _WeaponMaxDist( item.Proto, use );
		if( skill == SK_THROWING )
		{
			wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
		}
		result.insertLast( line + "|0xFFFF00  " + wpnMaxDist );
	}
	
	if( _GetWeaponBlastRadius( item.Proto ) > 0 )
	{
		result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS ) + "|0xFFFF00 " + item.Proto.Blast_Radius );
	}

	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		if( !isAmmoRegen )
		{
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( _GetAmmoBlastRadius( AmmoProto ) > 0 )
			{
				result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS ) + "|0xFFFF00 " + AmmoProto.Blast_Radius );
			}
		}
		
		result.insertLast(
			  "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO )
			+ "|0xFFFF00 " + item.AmmoCount
			+ "|0x3CF800  / "
			+ "|0xFFFF00 " + item.Proto.Weapon_MaxAmmoCount );
		
		if( !isAmmoRegen )
		{
			result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_LOADED_AMMO ) + "|0xFFFF00 " +_GetAmmoShortDisc( ammoPid ) );
		}
		else
		{
			result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_LOADED_AMMO ) + "|0xFFFF00 " + GetMsgStr( TEXTMSG_GAME, STR_RECHARGABLE_AMMO ) );
		}
	}
	else if( item.GetCount() > 1 )
	{
		result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE ) += "|0xFFFF00 " + item.GetCount() );
	}
	else if( ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_MELEE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_MELEE_END ) 
			|| ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END ) )
	{
		uint count = chosen.CountItem( item.Proto.ProtoId );
		ItemCl@ belt = chosen.GetItem( PID_AMMO_BELT, SLOT_MISC );
		//if( valid( belt ) )
		//{
		//	count += thrownAmmoCount( belt, item.Proto.ProtoId ); !!!!!!!!!!TECH DEBT!!!!!
		//}
		result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE ) + "|0xFFFF00 " + count );
	}
	
	return result;
}

#define DESCRIPTION_DEFAULT_DELAY	( 33 )
int[] description_tick_delays = { 0, 0, 0, 0 };
string[] generic_descriptions = { "DESC_INVENTORY_MAIN", "DESC_INVENTORY_SPECIAL", "DESC_INVENTORY_STATS", "DESC_INVENTORY_RESIST" };

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
    CritterCl@ chosen = GetChosen();
    if( !valid( chosen ) || descType < 0 || descType >= int(generic_descriptions.length()) )
	{
        return "";
	}
	
	if( description_tick_delays[descType] <= 0 )
	{
		description_tick_delays[descType] = DESCRIPTION_DEFAULT_DELAY;
		generic_descriptions[descType] = update_generic_description( descType );
	}
	else
	{
		description_tick_delays[descType]--;
	}

	update_generic_description_offsets( descType, offsX, offsY );
	return generic_descriptions[descType];
}

void update_generic_description_offsets( int descType, int& offsX, int& offsY )
{
	switch( descType )
	{
		case( DESC_INVENTORY_MAIN ):
			offsY = -2;
			break;
		case( DESC_INVENTORY_SPECIAL ):
			offsX = 23;
			offsY = -12;
			break;
		case( DESC_INVENTORY_STATS ):
			offsX = -8;
			offsY = -12;
			break;
		case( DESC_INVENTORY_RESIST ):
			offsX = 35;
			offsY = 120;
			break;
	}
}

string update_generic_description( int descType )
{
	CritterCl@ chosen = GetChosen();
	
	string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += COLOR_CRITTER + chosen.Name + "\n";
        result += "|0x3CF800 -----------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) ) + "\n";
		result += "\n\n\n\n\n\n\n\n"; // FoRP Inventory 2020 adjustment

		result += generic_description_slot_maker( SLOT_HAND1 );
		result += generic_description_slot_maker( SLOT_HAND2 );
	
		// Additional slots
		result += "|0x3CF800 -----------------------\n-----------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_EXTRA_SLOTS ) + "\n";
		result += "-----------------------\n";
		
		ItemCl@ headwear = _CritGetItemHead( chosen );
		if( valid( headwear ) ) 
		{
			result += getItemTextName( itemText( headwear ) ) + "\n";
			result += "\n\n\n";
        } 
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_HEAD_EMPTY ) + "\n\n\n\n";
		}
		result += "\n|0x3CF800 -----------------------\n";
		
		ItemCl@ backpack = _CritGetItemBack( chosen );
		if( valid( backpack ) ) 
		{
			if( backpack.GetType() == ITEM_TYPE_CONTAINER )
			{
				result += getItemTextName( itemText( backpack ) );
				result += ContainerWeight( backpack ) + "\n\n\n";
			}
			else
			{
				result += getItemTextName( itemText( backpack ) ) + "\n\n\n";
			}
		}
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_BACK_EMPTY ) + "\n\n\n\n";
		}
		result += "\n|0x3CF800 -----------------------\n";
		
		ItemCl@ misc = _CritGetItemMisc( chosen );
		if( valid( misc ) ) 
		{ 
			if( misc.GetType() == ITEM_TYPE_CONTAINER )
			{
				result += getItemTextName( itemText( misc ) );
				result += ContainerWeight( misc );
			}
			else if( misc.GetProtoId() == PID_RUBBER_BOOTS || misc.GetProtoId() == PID_LEATHER_SHOES )
			{
				result += getItemTextName( itemText( misc ) ) + "\n";
				result += GetMsgStr( TEXTMSG_GAME, STR_ACID_PROOF_SHOES );
			}
			else
			{
				result += getItemTextName( itemText( misc ) );
			}
        }
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_MISC_EMPTY );
		}
    }
	
    if( descType == DESC_INVENTORY_SPECIAL )
    {
        result += "\n\n\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_STRENGTH ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_ENDURANCE ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_CHARISMA ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_INTELLECT ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_AGILITY ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_LUCK ];
    }
	
    if( descType == DESC_INVENTORY_STATS )
    {
        result += "\n\n\n";
		
		// Hit Points
        result += "               "  + GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += "|0xFFFF00 " + chosen.Stat[ ST_CURRENT_HP ] +"|0x3CF800  /" + "|0xFFFF00 " + chosen.Stat[ ST_MAX_LIFE ] + "\n";
		
		// AP Regen
		string apregen = GetMsgStr( TEXTMSG_GAME, STR_INV_APREGEN );
		string thatap = "|0xFFFF00 " + floor(chosen.Stat[ ST_APREGEN ] / 100.0f) + "." + ( chosen.Stat[ ST_APREGEN ] % 100 ); // + "\n"
		float current_weight = cutLesserDigits( chosen.Param[ CR_ITEMS_WEIGHT ] / 1000.0 );
		float max_weight = cutLesserDigits( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000.0 );
		string current_volume = chosen.ItemsVolume();
		string max_volume = chosen.Param[ST_MAX_VOLUME];
		
		// Armor Class
		string arclass = GetMsgStr( TEXTMSG_GAME, STR_INV_AC );
		string thatac = "|0xFFFF00 " + ( _GetArmorClass( chosen ) );
		result += "|0x3CF800                " + ReplaceText(arclass, "VALUE", thatac)  + "\n";
		
		// String calls
		result += "|0x3CF800                " + ReplaceText(apregen, "VALUE", thatap)  + "\n"; // Action Points Renegeration
		result += "|0x3CF800                " + GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + "|0xFFFF00 \n               " + current_weight + "|0x3CF800  / " + "|0xFFFF00 " + max_weight + "|0x3CF800  " + GetMsgStr( TEXTMSG_GAME, STR_INV_KG ) +"\n";
		result += "|0x3CF800                " + GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_VOLUME ) + "|0xFFFF00 \n               " + current_volume + "|0x3CF800  / " + "|0xFFFF00 " + max_volume + "|0x3CF800 \n";
		
		// Resistance type names
		result += "|0x3CF800   -----------------------\n";
		
		ItemCl@ armor = _CritGetItemArmor(chosen);
		if( valid( armor ) )
		{
			result += "  " + getItemTextName( itemText( armor ) ) + ":\n";
		}
		else
		{
			result += "|0x3CF800   " + GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + ": \n";
		}
		result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL )     + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_LASER )      + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE )       + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA )     + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE )    + "\n";
		result += "|0x3CF800   " + GetMsgStr( TEXTMSG_GAME, STR_INV_ELECTRO );
    }
	
    if( descType == DESC_INVENTORY_RESIST )
    {
        result += "|0xFFFF00      " + chosen.Stat[ ST_NORMAL_ABSORB ]  + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_NORMAL_RESIST ]  + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_LASER_ABSORB ]   + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_LASER_RESIST ]   + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_FIRE_ABSORB ]    + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_FIRE_RESIST ]    + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_PLASMA_ABSORB ]  + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_PLASMA_RESIST ]  + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_EXPLODE_ABSORB ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_EXPLODE_RESIST ] + "|0x3CF800  %\n";
		result += "|0xFFFF00      " + chosen.Stat[ ST_ELECTRO_ABSORB ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_ELECTRO_RESIST ] + "|0x3CF800  %";
    }
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
	RunServerScriptUnsafe( "general_unsafe@unsafe_store_last_checked_item", item.Id, lookType, 0, null, null ); //Gm shift+q look hack
	
	CritterCl@ chosen = GetChosen();
    // Default error text
    if( !IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
	{
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );
	}
    string result;

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
		result = ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", itemColor( item ) + getLexName( item ) + COLOR_NETMSG );
		
		if( ( ( __sinf & SINF_ITEMID ) != 0 ) && item.GetType() > 1 && item.GetType() < 13 )
		{
			result += " |0xffff0000 id: " + item.Id + " pid: " + item.GetProtoId();
		}
    }
    // Full info
    else
    {
		if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
		{
			result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
		}
		else
		{
			if( lookType == ITEM_LOOK_INVENTORY )
			{
				result = itemColor( item ) + getLexName( item ) + COLOR_NETMSG;
				result += "\n-----------------------\n";
			}
			string desc = getLexDesc( item );
			if( desc.length() > 0 )
			{
				result += desc + ".";
			}
        }
		
		if( item.GetProtoId() == PID_VAULT_DWELLER_BONES || item.GetProtoId() == PID_BONES )
		{
			result += corpse_description( item );
		}
		
		if( item.GetProtoId() == PID_WALL_CLOCK )
		{
			RunServerScriptUnsafe( "time@unsafe_getIngameClocksTime", 0, 0, 0, null, null );
		}

        if( lookType == ITEM_LOOK_INVENTORY )
		{
            uint16 pid = item.GetProtoId();
			if( item.GetType() == ITEM_TYPE_WEAPON )
			{
				// Strength Requirement
				result += "\n-----------------------\n";
				string str;
				str = GetMsgStr( TEXTMSG_GAME, STR_INV_STR_REQ );
				str = ReplaceText( str, "VALUE", item.Proto.Weapon_MinStrength  );
				result += str;
				
				//Weapon Skill
				int skillNum = _WeaponSkill( item.Proto, item.Mode );
				if( skillNum != 0 )
				{
					str = GetMsgStr( TEXTMSG_TEXT, STR_SKILL_USED );
					string value = GetMsgStr( TEXTMSG_GAME, STR_SKILL_NAME(skillNum) );
					result += "\n" + ReplaceText( str, "VALUE", value );
				}
				
				// Weapon Perk
				result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_TITLE );
				string perksInfo = "";
				str = GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK );
				int count = 0;
				for( int i = 0; i < 32; i ++ )
				{
					if( ISBIT( item.Proto.Weapon_Perk, i ) )
					{
						string perkStr = GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_NAME( i + 1 ) );
						count ++;
						if( perksInfo != "" )
						{
							perksInfo += GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_SPACING );
						}
						
						perksInfo += perkStr;
					}
				}
				
				if( perksInfo != "" )
				{
					result += ReplaceText( str, "VALUE", perksInfo );
				}
				else
				{
					result += GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_NAME( 0 ) );
				}
				
				//  Custom object speed
				if( FLAG( item.Flags, ITEM_CAN_USE ) || FLAG( item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON )
				{
					result += "\n";
					string str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_WAIT_TIME );
					uint val = _GetProtoWindupTime( item.Proto );
					if( chosen.Param[ CR_AUTO_AIM ] == HIT_LOCATION_NONE )
					{
						val = val / 2;
					}	

					str2 = ReplaceText( str2, "VALUE", val );
					result += str2;
				}
				
				//  Custom AP cost
				if( FLAG(item.Flags, ITEM_CAN_USE) || FLAG(item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON && item.Mode != USE_RELOAD )
				{
					result += "\n";
					uint8 aim = ( item.Mode >> 4 ) & 0x0F;
					uint val =  GetUseApCost( chosen, item, item.Mode);

					string str_a = GetMsgStr( TEXTMSG_GAME, STR_INV_AP_COST );
					str_a = ReplaceText( str_a, "VALUE", val );
					result += str_a;
				}
				
				// Ammo & Reload info
				if( item.Proto.Weapon_MaxAmmoCount > 0 )
				{
					// Custom Reload AP cost
					result += "\n";
					string str_b = GetMsgStr( TEXTMSG_GAME, STR_INV_RELOAD_COST );
					str_b = ReplaceText( str_b, "VALUE", item.Proto.Weapon_ReloadAp );
					
					// Ammo load
					string str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
					str2 = ReplaceText( str2, "VALUE",     item.AmmoCount );
					str2 = ReplaceText( str2, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
					
					// Caliber
					string str3 = GetMsgStr( TEXTMSG_GAME, STR_INV_CALIBER_MSG );
					str3 = ReplaceText( str3, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );

					string modMin = GetMsgStr( TEXTMSG_GAME, STR_INV_MIN_DMG_MOD );
					int mod1 = item.Proto.Weapon_MinDmgMod - 100;
					modMin = ReplaceText( modMin, "MINMOD", mod1 );
					string modMax = GetMsgStr( TEXTMSG_GAME, STR_INV_MAX_DMG_MOD );
					int mod2 = item.Proto.Weapon_MaxDmgMod - 100;
					modMax = ReplaceText( modMax, "MAXMOD", mod2 );
					
					result += str_b + "\n" + str2 + "\n" + str3 + "\n" + modMin + "\n" + modMax;
				}
				else
				{
					string DtMod = GetMsgStr( TEXTMSG_GAME, STR_INV_DTMOD );
					DtMod = ReplaceText( DtMod, "DTMOD", item.Proto.Item_DtMod );
					result += "\n" + DtMod;
				}
				
			}
			else if( item.GetType() == ITEM_TYPE_ARMOR )
			{
				result += "\n\n-----------------------";
				string str;
				
				// Armor Class Mod
				// if( item.Proto.Armor_AC > 0 )
				// {
					// str = GetMsgStr ( TEXTMSG_GAME, STR_INV_ARMOR_AC);
					// str = ReplaceText (str, "VALUE", item.Proto.Armor_AC);
					// result += str;
				// }
				
				// Armor Perk
				result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_TITLE );
				string perksInfo = "";
				str = GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK );
				int count = 0;
				for( int i = 0; i < 32; i ++ )
				{
					if( ISBIT( item.Proto.Armor_Perk, i ) )
					{
						string perkStr = GetMsgStr( TEXTMSG_TEXT, STR_ARMOR_PERK_NAME( i + 1 ) );
						count ++;
						if( perksInfo != "" )
						{
							perksInfo += GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_SPACING );
						}
						
						perksInfo += perkStr;
					}
				}
				
				if( perksInfo != "" )
				{
					result += ReplaceText( str, "VALUE", perksInfo );
				}
				else
				{
					result += GetMsgStr( TEXTMSG_TEXT, STR_ARMOR_PERK_NAME( 0 ) );
				}
			}
			else if( item.GetType() == ITEM_TYPE_AMMO )
			{
				// Ammo stats
				result += "\n-----------------------";
				string ammoACMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_ACMOD );
				ammoACMod = ReplaceText( ammoACMod, "ACMOD", item.Proto.Ammo_AcMod);
				string ammoMult  = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DAMAGE  );
				ammoMult  = ReplaceText( ammoMult,  "MINDMG", item.Proto.Ammo_DmgMin );
				ammoMult  = ReplaceText( ammoMult,  "MAXDMG", item.Proto.Ammo_DmgMax );
				string ammoDRMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DRMOD );
				ammoDRMod = ReplaceText( ammoDRMod, "DRMOD", item.Proto.Ammo_DrMod );
				string ammoDTMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DTMOD );
				ammoDTMod = ReplaceText( ammoDTMod, "DTMOD", item.Proto.Item_DtMod );
				
				string perk = GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_TITLE );
				string perksInfo = "";
				string str = GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK );
				int count = 0;
				for( int i = 0; i < 32; i ++ )
				{
					if( ISBIT( item.Proto.Ammo_Perk, i ) )
					{
						string perkStr = GetMsgStr( TEXTMSG_TEXT, STR_AMMO_PERK_NAME( i + 1 ) );
						count ++;
						if( perksInfo != "" )
						{
							perksInfo += GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_SPACING );
						}
						
						perksInfo += perkStr;
					}
				}
				
				if( perksInfo != "" )
				{
					perk += ReplaceText( str, "VALUE", perksInfo );
				}
				else
				{
					perk += GetMsgStr( TEXTMSG_TEXT, STR_AMMO_PERK_NAME( 0 ) );
				}
				
				ammoDRMod = ReplaceText( ammoDRMod, "DRMOD", item.Proto.Ammo_DrMod );
				string ammoCal = GetMsgStr( TEXTMSG_GAME, STR_INV_CALIBER_MSG );
				ammoCal = ReplaceText( ammoCal, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Ammo_Caliber ) ) );

				result += "\n" + ammoACMod + "\n" + ammoMult + "\n" + ammoDRMod + "\n" + ammoDTMod + "\n" + perk + "\n" + ammoCal;
			}
			else if( item.Proto.Type == ITEM_TYPE_DRUG )
			{
				result += "\n-----------------------";
				string str = GetMsgStr( TEXTMSG_TEXT, STR_DRUG_TYPE ) + "|0xFFFF00  " + GetMsgStr( TEXTMSG_TEXT, item.Proto.Item_Subtype ) + "|0x3CF800 .";
				result += str;
			}
			else if( item.Proto.Slot == SLOT_HEAD )
			{
				result += "\n\n-----------------------";
				string str;
				
				// Headgear Perk
				result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_TITLE );
				string perksInfo = "";
				str = GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK );
				int count = 0;
				for( int i = 0; i < 32; i ++ )
				{
					if( ISBIT( item.Proto.HeadItem_Perk, i ) )
					{
						string perkStr = GetMsgStr( TEXTMSG_TEXT, STR_HEADGEAR_PERK_NAME( i + 1 ) );
						count ++;
						if( perksInfo != "" )
						{
							perksInfo += GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_SPACING );
						}
						
						perksInfo += perkStr;
					}
				}
				
				if( perksInfo != "" )
				{
					result += ReplaceText( str, "VALUE", perksInfo );
				}
				else
				{
					result += GetMsgStr( TEXTMSG_TEXT, STR_WPN_PERK_NAME( 0 ) );
				}
			}
            
            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8 brokenFlags = item.BrokenFlags;
                uint8 brokenCount = 10 - item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
				}
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                }
				else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                }
				else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                }
				else
				{
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );
				}
				
                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
				{
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );
				}

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
				{
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );
				}
				
                // Repairs left
				if( !FLAG( brokenFlags, BI_NOTRESC ) )
				{
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
				}
			}

			if( pid == PID_TNT_PACK_ACTIVE || pid == PID_REMOTE_DETONATOR )
			{
				result += " " + GetMsgStr( TEXTMSG_GAME, STR_FREQUENCY ) + "|0xFFFF00 " + item.Val4 + "|0x3CF800 ";
			}

			if( pid == PID_SLAVE_COLLAR_SWITCH )
			{
				result += " " + GetMsgStr( TEXTMSG_GAME, STR_FREQUENCY ) + "|0xFFFF00 " + item.Val5 + "|0x3CF800 ";
			}

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
			{
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );
			}
			else if( item.Proto.Item_Subtype == ITEM_SUBTYPE_KEYCARD )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEYCARD_NUMBER ), "KEY_ID", item.Id );
			}
			
			result += "\n-----------------------";
			
			// Partial_Item
			if( item.Proto.Partial_Item > 0 && item.Val0 > 0 )
			{ 
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_USES_LEFT ), "VALUE", item.Val0 );
			}

			// Weight
			uint16 container = item.GetProtoId();
			uint8 itemType = item.GetType();
			if( container == PID_POT_ALCO || item.Proto.Type == ITEM_TYPE_FLASK )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight + item.Val2 );
			}
			else if( glass_bottles[2].find(  container ) != -1 )
			{
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight - ( item.Proto.Partial_Item * 100 - item.Val2 ) );
			}
			else if( itemType == ITEM_TYPE_CONTAINER )
			{
				result += ContainerWeight( item );
			}
			else if( itemType == ITEM_TYPE_ARMOR && item.CritSlot == SLOT_ARMOR )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * 75 / 100 );
				result += " (|0xFFFF00  75%|0x3CF800  )";
			}
			else
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );
			}
			
			// Volume
			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_VOLUME ), "VALUE", item.Proto.Volume * item.GetCount() );
			// Material
			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_MATERIAL ), "VALUE", GetMsgStr( TEXTMSG_GAME, item.Proto.Material + 170 ) );
			// Flashlight charge
			if( item.GetProtoId() == PID_FLASHLIGHT_OFF || item.GetProtoId() == PID_FLASHLIGHT_ON || item.GetProtoId() == PID_10MM_PISTOL_FLASHLIGHT || item.GetProtoId() == PID_TAPE_RECORDER )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_TEXT, STR_RECORDER_MENU_PROCESS_CHARGED ), "@lex charge@", "|0xFFFF00 " + item.Val1 * 100 / 480 + "|0x3CF800 %" );
			}
			
			// Homebrew Taste
			uint[] taste_pids = { PID_HOMEBREW_PRT };
			int m = taste_pids.find( item.GetProtoId() );
			if( m != -1 )
			{
				result += "\n-----------------------";
				item.Val8 > 0 ? result += GetMsgStr( TEXTMSG_TEXT, STR_HOMEBREW_TASTE ) + ReplaceText( GetMsgStr( TEXTMSG_TEXT, STR_HOMEBREW_TASTE_BEGIN + item.Val8 ), ".", "" ) : result;
			}
			
			// Flask Taste
			if( item.Proto.Type == ITEM_TYPE_FLASK )
			{
				result += "\n-----------------------";
				item.Val1 > 0 ? result += GetMsgStr( TEXTMSG_TEXT, STR_SMELL_CANTEEN ) + "|0xFFFF00  " + ReplaceText( GetMsgStr( TEXTMSG_ITEM, item.Val1*100 ) , ".", "|0x3CF800 " ) : result;
			}
			
			// Bondage Items with Lock
			uint[] bondage_items = { PID_HANDCUFFS, PID_SHACKLES, PID_SLAVE_COLLAR };
			int mm = bondage_items.find( pid );
			if( mm != -1 )
			{
				result += "\n-----------------------";
				result += GetMsgStr( TEXTMSG_TEXT, STR_SERIAL_NUMBER ) + "|0xFFFF00 " + item.Id + "|0x3CF800 .";
				switch( item.BONDAGE_STATE )
				{
					case( BONDAGE_STATE_ON ):
						result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_BONDS );
						break;
					case( BONDAGE_STATE_BROKEN ):
						result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
						break;
					default:
						result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_READY );
						break;
				}
			}
			
			// Bondage key items
			uint[] bondage_key = { PID_HANDCUFFS_KEY, PID_SHACKLES_KEY, PID_SLAVE_COLLAR_SWITCH };
			int mmm = bondage_key.find( pid );
			if( mmm != -1 && item.KEY_BONDAGE_ID != 0 )
			{
				result += "\n-----------------------";
				result += GetMsgStr( TEXTMSG_TEXT, STR_SERIAL_NUMBER ) + "|0xFFFF00 " + item.KEY_BONDAGE_ID + "|0x3CF800 .";
			}
		}
    }

	result = replaceLetterN( result );
	
    // Format tags
    if( item.Lexems != "" )
	{
        return FormatTags( result, item.Lexems );
    }
	
	return result;
}

string replaceLetterN( string line )
{//'#' ==	`35` && '' == 185
	return replaceLetter( line, uint('#'), uint('') );
}

string replaceLetter( string line, uint letter, uint replacement )
{
	for( uint i = 0, l = line.length(); i < l; i++ )
	{
		if( line[i] == letter )
		{
			line[i] = replacement;
		}
	}
	
	return line;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result = critter_description_maker( cr, lookType );

	if( lookType == CRITTER_LOOK_FULL )
    {
        critter_description_full( cr, result );
	}

    // Format tags
    if( cr.Lexems != "" )
	{
        return FormatTags( result, cr.Lexems );
	}
	
    return result;

}

string critter_description_full( CritterCl& cr, string& result )
{
	result += "" + COLOR_NETMSG + critter_description_health( cr ) + critter_description_hand( cr ) + critter_description_slots( cr ) + critter_description_stats( cr );

	return result;
}

string critter_description_maker( CritterCl& target, int lookType )
{
	CritterCl@ chosen = GetChosen();
	
	return critter_description_maker( lookType, target.Id, target.Stat[ ST_AGE ], target.Stat[ ST_GENDER ], target.CrType, target.Stat[ ST_BODY_TYPE ], target.IsPlayer(), target.Name, target.Pid, target.IsLife(), target.IsKnockout(), target.IsDead() );
}

string critter_description_maker( int lookType, int target_id, int age, int gender, int crType, int bodyType, bool isPlayer, string name, uint16 npcPid, bool isLife, bool isKnockout, bool isDead )
{
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
	
	CritterCl@ chosen = GetChosen();

	if( lookType == CRITTER_ONLY_NAME )
	{
		CritterCl@ cr = GetCritter( target_id );
		if( !valid( cr ) )
		{
			return "[null]";
		}
		
		if( cr.Param[ QST_MEDIUM ] != 0 )
		{
			if( ABS( cr.Param[ QST_MEDIUM ] ) == 2 && !isGM( GetChosen() ) )
			{
				name = "";
			}
			
			if( cr.Param[ QST_MEDIUM ] == 3 )
			{
				string@ s_temp = cr.Lexems;
				if( valid(s_temp) )
				{
					name = s_temp;
				}
			}
			
			if( cr.Param[ QST_MEDIUM ] >= 4 )
			{
				string@ s_temp = GetName( cr.Param[ QST_MEDIUM ] );
				if( valid(s_temp) )
				{
					cr.Name = s_temp;
					name = s_temp;
				}
			}
		}
		else 
		{
			if( !isPlayer )
			{
				name = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
			}
		}
		result = name;
    }
	
	if( lookType == CRITTER_LOOK_SHORT )
	{
		if( name != "" || ( __sinf & SINF_LOGIN ) != 0 )
		{
			result = GetMsgStr( TEXTMSG_GAME, STR_YOU_SEE ) + COLOR_CRITTER + name + "|0x3CF800 .";
		}
		else
		{
			if( !isPlayer )
			{
				name = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
			}
			else
			{
				lookType = CRITTER_LOOK_FULL;
				name = "Unknown";
			}
		}
	}
	
	if( lookType == CRITTER_LOOK_FULL )
	{
		CritterCl@ cr = GetCritter( target_id );

		string view_name = name;
		string view_age = "";

		bool GenderAgeDesc = true;
		ItemCl@ armor = _CritGetItemArmor( cr );
		if( valid( armor ) )
		{
			uint8 ArmorType = ArmorHidingLevel( armor.GetProtoId() );
			if( ( ArmorType == 2 ) || ( ArmorType == 3 && ABS( cr.Param[ QST_MEDIUM ] ) == 2 ) || ( ArmorType == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) ) )
			{
				GenderAgeDesc = false;
				view_name = "";
			}
		}
		
		ItemCl@ back = _CritGetItemBack( cr );
		if( valid( back ) )
		{
			if( ArmorHidingLevel( back.GetProtoId() ) == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) )
			{
				GenderAgeDesc = false;
				view_name = "";
			}
		}
		
		if( view_name == "" )
		{
			view_name = GetMsgStr( TEXTMSG_GAME, STR_GENDER_PERSON );
		}

		if( GenderAgeDesc )
		{
			bool hasAge = false;
			bool isMale = gender == GENDER_MALE;
			bool isFemale = gender == GENDER_FEMALE;
			uint skin = cr.Stat[ ST_BASE_CRTYPE ];
			switch( bodyType )
			{
				case( BT_MEN ): 
				case( BT_WOMEN ):
				{
					uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( CLAMP( gender, GENDER_MALE, GENDER_FEMALE ), CLAMP( age, 0, 90 ) ) );
					if( ageStr != 0 )
					{
						view_name += ", ";
						view_age = GetMsgStr( TEXTMSG_GAME, ageStr );
					}

					break;
				}
				case( BT_CHILDREN ):
					view_name = GetMsgStr( TEXTMSG_GAME, isMale ? STR_SEE_BOY : STR_SEE_GIRL );
					break;
				case( BT_SUPER_MUTANT ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SUPER_MUTANT );
					break;
				case( BT_GHOUL ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_GHOUL );
					break;
				case( BT_BRAHMIN ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_BRAHMIN );
					break;
				case( BT_RADSCORPION ):
				{
					switch( skin )
					{
						case( CRTYPE_RADSCORPION_BLC_HUGE ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_BLACK_SCORPION );
							break;
						case( CRTYPE_RADSCORPION_CAVE ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CAVE_SCORPION );
							break;
						default:
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_RAD_SCORPION );
							break;
					}
					break;
				}
				case( BT_RAT ):
				{	
					switch( skin )
					{
						case( CRTYPE_RAT_PIGRAT ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_PIG_RAT );
							break;
						case( CRTYPE_RAT_MOLERAT ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MOLERAT );
							break;
						case( CRTYPE_RAT_MOLERAT_MUTANT ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MUTANT_MOLE );
							break;
						default:
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_RAT );
							break;
					}
					break;
				}
				case( BT_FLOATER ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_FLOATER );
					break;
				case( BT_CENTAUR ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CENTAUR );
					break;
				case( BT_ROBOT ):
				{
					switch( skin )
					{
						case( CRTYPE_ROBOT_HANDY ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_HANDY );
							break;
						case( CRTYPE_ROBOT_PROTECTRON ):	
						case( CRTYPE_ROBOT_PROTECTRON2 ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_PROTECTRON );
							break;	
						case( CRTYPE_ROBOBRAIN ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_ROBOBRAIN );
							break;
						case( CRTYPE_ROBODOG ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CYBER_DOG );
							break;
						case( CRTYPE_ROBOEYE ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_ROBOEYE );
							break;
						case( CRTYPE_ROBOT ):						
						case( CRTYPE_ROBOT_BLUE ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SENTURY_BOT );
							break;	
						default:
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_TURRET );
							break;
					}
					break;
				}	
				case( BT_DOG ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_DOG );
					break;
				case( BT_MANTI ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MANTIS );
					break;
				case( BT_DEATHCLAW ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_DEATHCLAW );
					break;
				case( BT_PLANT ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_PLANT );
					break;
				case( BT_GECKO ):
				{
					switch( skin )
					{
						case( CRTYPE_GECKO_SILV ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SILVER_GECKO );
							break;
						case( CRTYPE_GECKO_GOLD_SMALL ):	
						case( CRTYPE_GECKO_GOLD ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_GOLDEN_GECKO );
							break;	
						case( CRTYPE_GECKO_CAVE ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CAVE_GECKO );
							break;
						case( CRTYPE_GECKO_FIRE ):
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_FIRE_GECKO );
							break;
						default:
							view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MONSTER );
							break;
					}
					break;				
				}
				case( BT_ALIEN ):
					view_name = GetMsgStr( TEXTMSG_GAME, skin == CRTYPE_ALIEN_QUEEN ? STR_SEE_ALIEN_QUEEN : ( skin == CRTYPE_ALIEN_REG ? STR_SEE_ALIEN : STR_SEE_EGG ) );
					break;		
				case( BT_GIANT_ANT ):
					view_name = GetMsgStr( TEXTMSG_GAME, skin == CRTYPE_GIANT_ANT_LION ? STR_SEE_ANT_LION : STR_SEE_ANT );
					break;
				case( BT_BIG_BAD_BOSS ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MONSTER );
					break;		
				case( BT_GIANT_BEETLE ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_BEETLE );
					break;
				case( BT_GIANT_WASP ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_WASP );
					break;
				case( BT_YAO ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_YAO );
					break;
				case( BT_SWAMP_LURKER ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MIREURKER );
					break;
				case( BT_CROCS ):
					view_name = GetMsgStr( TEXTMSG_GAME, skin == CRTYPE_CROCS_SHADOW ? STR_SEE_SHADOW_CROC : STR_SEE_CROC );
					break;
				case( BT_MILLEPEDE ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MILLEPEDE );
					break;	
				case( BT_LAVASH ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_LAVASH );
					break;
				case( BT_SPIDER ):
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SPIDER );
					break;
				default:
					view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MONSTER );
					break;
			}
		}
			
		string description = view_name + view_age ;
		if( description.length() > 1 )
		{
			description = strupr( substring ( description, 0, 1 ) ) + substring( description, 1, description.length() - 1 );
		}
		
		uint line_type = isLife ? STR_CRIT_LOOK_LIFE : ( isKnockout ? STR_CRIT_LOOK_KO : ( isDead ? STR_CRIT_LOOK_DEAD : STR_CRIT_LOOK_NOTHING ) );

		if( line_type != STR_CRIT_LOOK_NOTHING )
		{
			if( !isPlayer )
			{
				description = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
				if( valid( GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_DESC( npcPid ) ) ) )
				{
					description += "|0x3CF800 . " + GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_DESC( npcPid ) );
				}
			}
			
			result = TRIM_DOTS( ReplaceText( GetMsgStr( TEXTMSG_GAME, line_type ), "NAME", COLOR_CRITTER + description ) ) + ".";
		}
	}
	
	return result;
}

string critter_description_health( CritterCl& cr )
{
	int gender = cr.Stat[ ST_GENDER ];
	if( cr.Stat[ ST_BODY_TYPE ] > BT_GHOUL )
	{
		gender = GENDER_IT;
	}
	
	ItemCl@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		uint8 ArmorType = ArmorHidingLevel( armor.GetProtoId() );
		if( ( ArmorType == 2 ) || ( ArmorType == 3 && ABS( cr.Param[ QST_MEDIUM ] ) == 2 ) || ( ArmorType == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) ) )
		{
			gender = GENDER_UNKNOWN;
		}
	}
	
	ItemCl@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		if( ArmorHidingLevel( back.GetProtoId() ) == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) )
		{
			gender = GENDER_UNKNOWN;
		}
	}
	
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );
	
	int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
	if( cr.IsDead() )
	{
		if( cr.ParamBase[CR_DEATH_STAGE] < 50 )
		{
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) );
		}
		else if( cr.ParamBase[CR_DEATH_STAGE] < 100 )
		{
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) );
		}
		else
		{
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) );
		}
	}
	else if( cr.Stat[ ST_CURRENT_HP ] < 0 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) );
	}
	else if( hp_proc <= 30 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) );
	}
	else if( hp_proc <= 50 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 5 ) );
	}
	else if( hp_proc <= 70 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 6 ) );
	}
	else if( hp_proc <= 90 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 7 ) );
	}
	else
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 8 ) );
	}
	
	if( _CritIsInjured( cr ) )
	{
		bool needComa = false;

		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( hp_proc >= 90 ) ) + ": ";
		
		uint lineNum = 0;
		switch( cr.Stat[ ST_BODY_TYPE ] ) //Take line from FOCOMBAT.MSG based on CritterType Allias from CritterTypes.cfg
		{
			case( BT_BRAHMIN ):
				lineNum = 1150;
				break;
			case( BT_DOG ):
				lineNum = 1160;
				break;
			case( BT_SUPER_MUTANT ):
				lineNum = 1180;
				break;			
			case( BT_RAT ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_RAT_MOLERAT ):
						lineNum = 1190;
						break;	
					case( CRTYPE_RAT_PIGRAT ):
						lineNum = 1550;
						break;		
					default:  // CRTYPE_RAT
						lineNum = 1240;
						break;	
				}
				break;
			}	
			case( BT_RADSCORPION ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_RADSCORPION ):
						lineNum = 1570;
						break;
					case( CRTYPE_RADSCORPION_SMALL ):
						lineNum = 1590;
						break;
					default: // CRTYPE_RADSCORPION_HUGE, CRTYPE_RADSCORPION_BLC_HUGE, CRTYPE_RADSCORPION_CAVE
						lineNum = 1220;
						break;
				}
			}
			case( BT_FLOATER ):
				lineNum = 1230;
				break;
			case( BT_CENTAUR ):
				lineNum = 1250;
				break;
			case( BT_ROBOT ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_ROBOEYE ):
						lineNum = 1540;
						break;
					case( CRTYPE_TURRET_PLASMA ): 
					case( CRTYPE_TURRET_MINIGUN ):
					case( CRTYPE_TURRET_LASER_TOWER ):
					case( CRTYPE_TURRET_LASER ):
						lineNum = 1900;
						break;
					case( CRTYPE_ROBOT ):
					case( CRTYPE_ROBOT_BLUE ): 
						lineNum = 1660;
						break;
					case( CRTYPE_ROBOT_HANDY ): 
						lineNum = 1170;
						break;
					default: // CRTYPE_ROBOBRAIN
						lineNum = 1530;
						break;
				}
				break;
			}
			case( BT_MANTI ):
				lineNum = 1520;
				break;
			case( BT_DEATHCLAW ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_DEADCLAW_SMALL ):
						lineNum = 1600;
						break;
					case( CRTYPE_DEADCLAW_BEAST ):
						lineNum = 1310;
						break;
					default: // CRTYPE_DEADCLAW, CRTYPE_DEADCLAW_GREY
						lineNum = 1510;
						break;
				}
				break;
			}
			case( BT_PLANT ):
				lineNum = 1650;
				break;
			case( BT_GECKO ):
				lineNum = 1670;
				break;
			case( BT_ALIEN ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_ALIEN_EGG ):
						lineNum = 1580;
						break;
					default: // CRTYPE_ALIEN_REG, CRTYPE_ALIEN_QUEEN
						lineNum = 1800;
						break;
				}
				break;
			}
			case( BT_GIANT_ANT ):
				lineNum = 1970;
				break;
			case( BT_BIG_BAD_BOSS ):
				lineNum = 1850;
				break;
			case( BT_GIANT_BEETLE ):
				lineNum = 4030;
				break;
			case( BT_GIANT_WASP ):
				lineNum = 4150;
				break;
			case( BT_YAO ):
				lineNum = 4170;
				break;
			case( BT_SWAMP_LURKER ):
				lineNum = 3470;
				break;
			case( BT_CROCS ):
				lineNum = 4160;
				break;
			case( BT_MILLEPEDE ):
				lineNum = 4180;
				break;	
			case( BT_LAVASH ):
				lineNum = 4190;
				break;
			case( BT_SPIDER ):
				lineNum = 4200;
				break;
			default: // BT_MEN, BT_WOMEN, BT_CHILDREN, BT_GHOUL
				lineNum = 1110;
				break;
		}
		
		if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
		{
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 6 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 2 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
		{
			if( needComa )
			{				
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 1 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 4 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 5 );
			needComa = true;
		}
	}
	return result + "|0x3CF800 ."; 
}

string critter_description_hand( CritterCl& cr )
{
	ItemCl@ item  = _CritGetItemHand(cr);
	if( !valid( item ) ) return "";

	int bodyType = cr.Stat[ ST_BODY_TYPE ];
	int crType = cr.CrType;

	bool twoHanded = valid( item ) ? FLAG( item.Flags, ITEM_TWO_HANDS ) : false;
	bool determined = true;
	
	string hands;
	switch( crType )
	{
		case( CRTYPE_TURRET_PLASMA ): 
		case( CRTYPE_TURRET_MINIGUN ):
		case( CRTYPE_TURRET_LASER_TOWER ):
		case( CRTYPE_TURRET_LASER ):
		case( CRTYPE_ROBOEYE ):
			hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMAMENT );
			break;
		default:
			determined = false;
			break;
	}
	
	if( !determined )
	{
		switch( bodyType )
		{
			case( BT_BRAHMIN ):
			case( BT_LAVASH ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMAMENT );
				break;
			case( BT_RAT ):
			case( BT_DOG ):
			case( BT_PLANT ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CHAPS );
				break;
			case( BT_GIANT_ANT ):
			case( BT_GIANT_BEETLE ):
			case( BT_GIANT_WASP ):
			case( BT_SPIDER ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANDIBLES );
				break;
			case( BT_RADSCORPION ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_PINCERS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_PINCER );
				break;
			case( BT_FLOATER ):
			case( BT_ALIEN ):
			case( BT_CENTAUR ):
			case( BT_MILLEPEDE ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_TENTACLES ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_TENTACLE );
				break;
			case( BT_ROBOT ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANIPULATORS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANIPULATOR );
				break;
			case( BT_GECKO ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CHAPS );
				break;
			case( BT_MANTI ):
			case( BT_YAO ):
			case( BT_DEATHCLAW ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CLAWS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CLAW );
				break;
			default: //regular characters
				hands = twoHanded ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_HAND1_2H ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HAND1_1H );
				break;
		}
	}					
	return " " + hands + " " + getLexName( item ) + ".";
}

string critter_description_slots( CritterCl& cr )
{
	string result;
	
	ItemCl@ offhand = _CritGetItemHandExt( cr );
	if( valid( offhand ) )
	{
		result += " " + GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC ) + ".";
		result = ReplaceText( result, "MISC", getLexName( offhand ) );
	}
	
	bool hasPrefix = false;
	uint gender = cr.StatBase[ ST_GENDER ];
	bool show_armor = true;
	bool robed = false;
	
	ItemCl@ armor = _CritGetItemArmor( cr );
	uint8 ArmorType = 0;
	
	if( valid( armor ) )
	{
		ItemCl@ back = _CritGetItemBack( cr );
		if( valid( back ) )
		{
			ArmorType = ArmorHidingLevel( back.GetProtoId() );
			if( ArmorType == 1 )
			{
				show_armor = false;
				robed = true;
			}
		}
		
		if( show_armor )
		{
			ArmorType = ArmorHidingLevel( armor.GetProtoId() );
			if( ( ArmorType == 2 ) || ( ArmorType == 3 && ABS( cr.Param[ QST_MEDIUM ] ) == 2 ) || ( ArmorType == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) ) )
			{
				gender = GENDER_IT;
			}
			
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_MALE_ARMOR + gender ) + getLexName( armor );
			hasPrefix = true;
		}
		
		if( robed )
		{
			string shape = "";
			switch( armor.Proto.Material )
			{
				case( MATERIAL_METAL ):
				case( MATERIAL_POLYMER ):
					shape += GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMOR_UNDER_ROBE );
					hasPrefix = true;
					break;
				default:
					break;
			}
			
			result += shape;
			hasPrefix = false;
		}
		
	}

	ItemCl@ head = _CritGetItemHead( cr );
	if( valid( head ) && CanShowFace( cr ) )
	{
		result += hasPrefix ? ", " : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HE_HEAD + gender );
		result += getLexName( head );
		string desc = getLexDescRaw( head );
		if( desc.length() > 0 )
		{
			result += " " + getLexDescRaw( head ) + ".";
		}
		
		hasPrefix = true;
	}

	ItemCl@ misc = _CritGetItemMisc( cr );
	if( valid( misc ) )
	{
		result += hasPrefix ? GetMsgStr( TEXTMSG_GAME, STR_AND ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HE_HEAD + gender );
		result += getLexName( misc );
		hasPrefix = true;
	}

	if( hasPrefix )
	{
		result += ".";
	}
	
	ItemCl@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		if( back.GetType() == ITEM_TYPE_ARMOR )
		{
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_ROBE_BACK ) + getLexName( back ) + ".";
		}
		else
		{
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK ) + getLexName( back );
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK_HE_ENDLINE + gender );
		}
	}
	
	return result;
}

uint8 ArmorHidingLevel( uint pid )
{
	// Hide face and features armor lists
	uint16[][] ArmorHidingList =
	{
		{   // Can be toggled - hoods
			PID_PURPLE_ROBE, PID_BLACK_ROBE, PID_SANDROBE, PID_BROWN_ROBE, PID_DARK_GREEN_ROBE, PID_RED_RITUAL_ROBE, PID_BLACK_RITUAL_ROBE, PID_DARK_BLACK_ROBE, 
			PID_DARK_RED_ROBE, PID_RED_ROBE, PID_DARK_BROWN_ROBE, PID_DARK_BLUE_ROBE, PID_ATOM_CHILD_ROBE

		},{ // hides everything, cant be toggled
			 PID_EKZO, PID_OXIDENED_POWER_ARMOR, PID_HYDROID, PID_EKZO_2, PID_POWERED_ARMOR_NEVADA, PID_HYDROID_MK_II, PID_RAIDER_PA,
			 PID_PA_CLAW, PID_HYENA_PA, PID_HYENA_PA_MK2, PID_ADVANCED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR_MK2
		},{ // helmet can be taken off
			 PID_POWERED_ARMOR, PID_HARDENED_POWER_ARMOR
		}
	};

	uint8 result = 0;
	for( uint8 i = 0, l = ArmorHidingList.length(); i < l; i++ )
	{
		for( uint8 ii = 0, ll = ArmorHidingList[ i ].length(); ii < ll; ii++ )
		{
			if( pid == ArmorHidingList[ i ][ ii ] ) 
			{ 
				result = i+1;
				break;
			}
		}
	}
	
	return result;
}

bool CanShowFace( CritterCl& cr )
{
	ItemCl@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		if( ArmorHidingLevel( back.GetProtoId() ) == 1 )
		{
			return !FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE );
		}
	}
	
	ItemCl@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		switch( ArmorHidingLevel( armor.GetProtoId() ) )
		{
			case( 1 ): 
				return !FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE );
			case( 2 ): 
				return false;
			case( 3 ): 
				return ABS( cr.Param[ QST_MEDIUM ] ) != 2;
		}
	}
	
	return true;
}

//descriptions based on appearence and stats
string critter_description_stats( CritterCl& cr )
{
	string result = " ";
	if( cr.IsNpc() )
	{
		if( cr.Stat[ ST_BODY_TYPE ] == BT_DOG && cr.Pid == 3000 )
		{
			bool strength_desc = true;
			bool weak = true;
			switch( cr.Stat[ ST_STRENGTH ] )
			{
				case( 2 ):
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_FEEBLE );
					break;
				case( 3 ):
				case( 4 ):
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_WEAK );
					break;
				case( 7 ):
				case( 8 ):
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_MUSCULAR );
					weak = false;
					break;
				case( 9 ):
				case( 10 ):
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_VSTRONG );
					weak = false;
					break;
				default:
					strength_desc = false;
					weak = false;
					break;
			}
			
			bool endurance_desc = true;
			switch( cr.Stat[ ST_ENDURANCE ] )
			{
				case( 2 ):
					result += ( strength_desc ? ( weak ? GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_STATURE ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_BUT_STATURE ) ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ANIMAL_IS ) ) + GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_VSKINNY );
					break;
				case( 3 ):
				case( 4 ):
					result += ( strength_desc ? ( weak ? GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_STATURE ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_BUT_STATURE ) ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ANIMAL_IS ) ) + GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_RSKINNY );
					break;
				case( 7 ):
				case( 8 ):
					result += ( strength_desc ? ( weak ? GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_BUT_STATURE ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_STATURE ) ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ANIMAL_IS ) ) + GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_LARGE );
					break;
				case( 9 ):
				case( 10 ):
					result += ( strength_desc ? ( weak ? GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_BUT_STATURE ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_STATURE ) ) : GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ANIMAL_IS ) ) + GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_MASSIVE );
					break;
				default:
					endurance_desc = false;
					break;
			}
			
			bool agility_desc = true;
			switch( cr.Stat[ ST_AGILITY ] )
			{
				case( 7 ):
				case( 8 ):
				{
					if( strength_desc || endurance_desc )
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_AND );
					}
					else
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ANIMAL_IS );
					}
					
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_LEAN );
					break;
				}
				case( 9 ):
				case( 10 ):
					if( strength_desc || endurance_desc )
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_MOVEMENTS );
					}
					else
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ANIMAL_IS );
					}
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_VAGILE );
					break;
				default:
					agility_desc = false;
					break;
			}
			
			if( strength_desc || endurance_desc || agility_desc )
			{
				result += ". ";
			}
			
			switch( cr.Stat[ ST_CHARISMA ] )
			{
				case( 7 ):
				case( 8 ):
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_CUTE );
					break;
				case( 9 ):
				case( 10 ):
					result += GetMsgStr( TEXTMSG_GAME, STR_DOG_LOOK_ADORABLE );
					break;
			}
			
			return result;
		}
		else if( cr.Stat[ ST_BODY_TYPE ] >= BT_BRAHMIN ) 
		{
			return result;
		}
	}

	bool isRobot = cr.StatBase[ST_BODY_TYPE] == BT_ROBOT;
	if(isRobot)
	{
		return result;
	}
	
	CritterCl@ chosen = GetChosen();

	uint8 OpenArmor = 0;
	ItemCl@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		OpenArmor = ArmorHidingLevel( armor.GetProtoId() );
	}

	bool hidelex = false;
	bool showface = true;
	bool showbody = true;
	bool female = cr.Stat[ ST_GENDER ] == GENDER_FEMALE;
	bool male = cr.Stat[ ST_GENDER ] == GENDER_MALE;
	
	string usual = " " + ( female ? GetMsgStr( TEXTMSG_GAME, STR_DESC_F_USUAL ) : ( male ? GetMsgStr( TEXTMSG_GAME, STR_DESC_M_USUAL ) : GetMsgStr( TEXTMSG_GAME, STR_DESC_USUAL ) ) );
	string look = "";

	hidelex = ( OpenArmor == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_DESC ) );
	bool hideopt = ( FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) );

	if( OpenArmor == 1 )
	{
		showface = !hideopt;
		showbody = false;
		usual = "";
	}
	else if( OpenArmor == 2 )
	{
		showface = false;
		showbody = false;
		usual = "";
	}
	else if( OpenArmor == 3 )
	{
		showface = ABS( cr.ParamBase[ QST_MEDIUM ] ) != 2;
		showbody = false;
		usual = "";
	}
	
	ItemCl@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		if( back.GetType() == ITEM_TYPE_ARMOR )
		{
			showface = !hideopt;
			showbody = false;
			usual = "";
		}
	}
	
	if( showface )
	{ 
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS );
	}

	string comma = " ";
	if( !showface && !showbody ) 
	{ 
		comma = ", ";
	}
	
	bool truecomma;
	if( showface )
	{
		truecomma = true;
		switch( cr.Stat[ ST_CHARISMA ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_IRRESISTIBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_IRRESISTIBLE );
				break;
			case( 9 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_MBEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_MBEAUTIFUL );
				break;
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_BEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_BEAUTIFUL );
				break;
			case( 7 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_ATTRACTIVE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_ATTRACTIVE );
				break;
			case( 3 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_UNPLEASANT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_UNPLEASANT );
				break;
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DISGUSTING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DISGUSTING );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SICKENING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SICKENING );
				break;
			default:
				truecomma = false;
		}
		
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = "";
		}
	}
	
	if( showbody )
	{
		truecomma = true;
		switch( cr.Stat[ ST_STRENGTH ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_VSTRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_VSTRONG );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_STRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_STRONG );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WEAK );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_QWEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_QWEAK );
				break;
			default:
				truecomma = false;
		}
		
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = ""; 
		}

		truecomma = true;
		switch( cr.Stat[ ST_ENDURANCE ] )
		{
			case( 10 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_TOUGH ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_TOUGH );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WBUILT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WBUILT );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SLIM ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SLIM );
				break;
			case( 1 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DELICATE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DELICATE );
				break;
			default:
				truecomma = false;
		}
		
		if( truecomma ) 
		{ 
			comma = ", "; 
			usual = "";
		}

		truecomma = true;
		switch( cr.Stat[ ST_AGILITY ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_AGILE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_AGILE );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_NIMBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_NIMBLE );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_GRACELESS ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_GRACELESS );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_CLUMSY ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_CLUMSY );
				break;
			default:
				truecomma = false;
		}
		
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = "";
		}
	}
	else
	{
		if( OpenArmor == 1 || ( valid( back ) && back.GetType() == ITEM_TYPE_ARMOR ) )
		{
			if( showface )
			{
				look += ". " + GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_APP );
			}
			else
			{
				look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_APP );
			}
		}
		else
		{
			if( showface )
			{
				look += ". " + GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_ARMOR );
			}
			else
			{
				look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_ARMOR );
			}
		}
	}
	
	result = ( look != "" ? ( " " + look + usual + "." ) : "" );

	bool ArmorLexem = valid( armor ) && !isOverridenDesc( armor );
	if( ( cr.Lexems != "" || ArmorLexem ) && !hidelex && cr.Param[ QST_MEDIUM ] != 3 ) 
	{ 
		if( ArmorLexem )
		{
			string desc = getLexDescRaw( armor );
			if( desc.length() > 0 )
			{
				result += " " + getLexDescRaw( armor ) + ".";
			}
		}
		
		if( showbody )
		{
			string signature = "_";
			int pos = findFirstOf( cr.Lexems, signature, 0 );
			string desc = ( pos != -1 ? substring( cr.Lexems, 0, pos ) : cr.Lexems );
			
			if( desc.length() > 0 )
			{
				result += " " + desc + ".";
			}
		}
	}
	
	return result;
}

string corpse_description( Item& corpse ) 
{
	string result = " ";

	string@ name = GetName( corpse.Val1 );

	int ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( CLAMP( corpse.Val3, GENDER_MALE, GENDER_FEMALE ), CLAMP( corpse.Val2, 0, 90 ) ) );

	if( corpse.Val1 <= BT_CHILDREN && ageStr != 0  )
	{
		result += "Corpse of " + GetMsgStr( TEXTMSG_GAME, ageStr );
	}
	else
	{
		string[] bt_description = { "male", "female", "human", "ghoul", "supermutant" };
		result += "Corpse of " + bt_description[ CLAMP( uint(corpse.Val0), 0, bt_description.length() - 1 ) ];
	}

	result += ". " + GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS );
	
	bool female = corpse.Val3 == GENDER_FEMALE;
	bool male = corpse.Val3 == GENDER_MALE;

	string usual = " " + ( female ? GetMsgStr( TEXTMSG_GAME, STR_DESC_F_USUAL ) : ( male ? GetMsgStr( TEXTMSG_GAME, STR_DESC_M_USUAL ) : GetMsgStr( TEXTMSG_GAME, STR_DESC_USUAL ) ) );

	string look = "";

	string comma = " ";
	bool truecomma;
	truecomma = true;
	switch( corpse.Val4 )
	{
		case( 10 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_IRRESISTIBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_IRRESISTIBLE );
			break;
		case( 9 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_MBEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_MBEAUTIFUL );
			break;
		case( 8 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_BEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_BEAUTIFUL );
			break;
		case( 7 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_ATTRACTIVE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_ATTRACTIVE );
			break;
		case( 3 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_UNPLEASANT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_UNPLEASANT );
			break;
		case( 2 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DISGUSTING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DISGUSTING );
			break;
		case( 1 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SICKENING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SICKENING );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", ";
		usual = "";
	}

	truecomma = true;
	switch( corpse.Val5 )
	{
		case( 10 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_VSTRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_VSTRONG );
			break;
		case( 9 ):
		case( 8 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_STRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_STRONG );
			break;
		case( 3 ):
		case( 2 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WEAK );
			break;
		case( 1 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_QWEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_QWEAK );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", ";
		usual = ""; 
	}

	truecomma = true;
	switch( corpse.Val6 )
	{
		case( 10 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_TOUGH ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_TOUGH );
			break;
		case( 9 ):
		case( 8 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WBUILT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WBUILT );
			break;
		case( 3 ):
		case( 2 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SLIM ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SLIM );
			break;
		case( 1 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DELICATE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DELICATE );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", "; 
		usual = "";
	}

	truecomma = true;
	switch( corpse.Val7 )
	{
		case( 10 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_AGILE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_AGILE );
			break;
		case( 9 ):
		case( 8 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_NIMBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_NIMBLE );
			break;
		case( 3 ):
		case( 2 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_GRACELESS ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_GRACELESS );
			break;
		case( 1 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_CLUMSY ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_CLUMSY );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", ";
		usual = "";
	}

	string full_name = corpse.Val1 == 0 ? "The body is beheaded" : "The body belongs to |0xFFFFFF " + ( valid( name ) ? name : "unidentified person" );

	return result += ( look == "" ? usual : look ) + ". " + full_name + "|0x00FF00 .";
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos

void _PlaySound( int pos, int repeat, int, string@ soundName, int[] @ )
{
    PlaySound( soundName );
}

void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& cr, CritterCl& npc, bool sell )
{
	return CalculateItemCost( item, cr, npc, sell );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate( int[]& data )
{
    CritterGenerate( data );
}

bool player_data_check( int[]& data )
{
    SetCrtype( data );

    return CritterGenerateCheck( data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
	uint8 mode = 0;
    const ProtoItem@ protoItem = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );

	if( cr.IsChosen() )
    {
		// Not process locally called actions
		if( !localCall )
		{
			switch( action )
			{
				case( ACTION_MOVE_ITEM ):
					return;
				case( ACTION_MOVE_ITEM_SWAP ):
					return;
				case( ACTION_USE_ITEM ):
				{
					if( actionExt == 0 )
					{
						return;
					}		
					
					uint16 protoPid = protoItem.ProtoId;
					string soundName = "ROBE.mp3";
					uint8 itemType = item.GetType();
					uint8 material = protoItem.Material;
					
					uint16[] drink_pids = { PID_ANTIDOTE, PID_JET_ANTIDOTE };
					uint16[] inhailer_pids = { PID_JET, PID_TREB, PID_VINT };
					uint16[] pills_pids = { PID_MENTATS, PID_BUFFOUT, PID_RAD_X, PID_RAD_LX, PID_ROTOR, PID_ASPIRIN, PID_MENTATS_FRUIT, PID_PAINKILLERS, PID_DESINFHN0, PID_PILLS, PID_HEART_PILLS };
					uint16[] injector_pids = { PID_PSYCHO};
					
					if( itemType == ITEM_TYPE_FOOD )
					{
						return;
						//soundName = "chewy.ogg";
					}
					else if( inhailer_pids.find( protoPid ) != -1 )
					{
						return;
						//soundName = "jet.ogg";
					}
					else if( injector_pids.find( protoPid ) != -1 )
					{
						return;
						//soundName = Random( 1, 2 ) == 1 ? "obj_braintank_steam_01.wav" : "obj_braintank_steam_02.wav";
					}
					else if( pills_pids.find( protoPid ) != -1 )
					{
						return;
						// soundName = "solopill.ogg";				
					}
					else if( drink_pids.find( protoPid ) != -1 || ( ( itemType == ITEM_TYPE_DRINK && find_opened_drinks( item ) == true && item.CritSlot == SLOT_HAND1 ) ) )
					{
						cr.Stat[ ST_GENDER ] == GENDER_MALE ? soundName = "water.wav" : soundName = "fem_drinking.ogg";
					}
					else if( itemType == ITEM_TYPE_FLASK && item.CritSlot == SLOT_HAND1 && item.Val0 > 0 )
					{
						cr.Stat[ ST_GENDER ] == GENDER_MALE ? soundName = "water.wav" : soundName = "fem_drinking.ogg";
					}
					else if( itemType == ITEM_TYPE_KEY )
					{
						soundName = "BLANK.mp3";
					}
					else if( itemType == ITEM_TYPE_ARMOR )
					{
						switch( material )
						{
							case( MATERIAL_FABRIC ):
								soundName = "ROBE.mp3";
								break;
							case( MATERIAL_LEATHER ):
							case( MATERIAL_ARMORED_LEATHER ):
								soundName = "LTHARMOR.mp3";
								break;
							case( MATERIAL_METAL ):
								soundName = "MTLARMOR.mp3";
								break;
							case( MATERIAL_POLYMER ):
								soundName = "CMBTFLX.mp3";
								break;
							case( MATERIAL_COMPOSITE ):
								soundName = "PWRARMOR.mp3";
								break;
							default:
								soundName = "ROBE.mp3";
								break;
						}
					}

					int[] radius = { 5 };
					__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
					break;
				}
				
				case( ACTION_DROP_ITEM ):
					return;
				case( ACTION_USE_WEAPON ):
				{
					if( FLAG( ( ( actionExt >> 12 ) & 0xF ), ACTION_FLAG_CHOSEN_INCLUSIVE ) )
					{
						break; // PROCESS IT !
					}
					return;
				}
				case( ACTION_RELOAD_WEAPON ):
					break;
				case( ACTION_USE_SKILL ):
					return;
				case( ACTION_PICK_ITEM ):
					return;
				case( ACTION_PICK_CRITTER ):
					break;
				case( ACTION_OPERATE_CONTAINER ):
					return;             // Skip processing
				case( ACTION_WINDUP ):
				{
					if( FLAG( ( ( actionExt >> 12 ) & 0xF), ACTION_FLAG_CHOSEN_INCLUSIVE ) )
					{
						break;
					}
					
					return;
				}
				default:
					break;
			}
		}
		else
		{
			switch( action )
			{
				case( ACTION_USE_WEAPON ):
				{
					if( GetProtoWindupTime( protoItem, actionExt, cr ) != 0 && cr.ParamBase[ CR_IS_WINDUPED ] != 1 )
					{
						if( _WeaponAnim2( protoItem, mode ) == ANIM2_AUTO )
						{
							cr.Wait( _GetProtoWaitTime( protoItem, mode ) );
						}
						else
						{							
							cr.Wait( GetProtoWindupTime( protoItem, actionExt, cr ) ); // wait here, on client, let server handle.
						}	
						
						if( protoItem.Weapon_IsUnarmed )
						{
							mode = cr.Stat[ ST_HANDS_ITEM_AND_MODE ];
							cr.Wait( _GetProtoWaitTime( protoItem, mode ) );
						}

						return;
					}
					break;
				}
				case( ACTION_PICK_CRITTER ):
					return;			
			}
		}
	}

    switch( action )
    {
		case( ACTION_TEST ):
		{
			Message( "TEST ACTION PERFORMED" );
			break;
		}
		
		case( ACTION_MOVE ):
		{
			// Not implemented
			// cr.Wait(move time);
			break;
		}
		
		case( ACTION_RUN ):
		{
			// Not implemented
			// cr.Wait(run time);
			break;
		}
		
		case( ACTION_MOVE_ITEM ):
		{
			if( cr.IsLife() )
			{
				//cr.Wait( GetActionTime( ACTION_MOVE_ITEM, cr ) );
				
				uint8 fromSlot = actionExt;
				uint8 toSlot = item.CritSlot;
				string soundName = "";
				uint8 material = protoItem.Material;
		
				cr.ClearAnim();
				
				if( toSlot == SLOT_HAND1 && protoItem.Type == ITEM_TYPE_WEAPON )
				{
					if( fromSlot == SLOT_HAND2 )
					{
						ItemCl@ prevItem = _CritGetItemHandExt( cr );
						if( valid( prevItem ) && GetProtoItem(prevItem.GetProtoId()).Type == ITEM_TYPE_WEAPON )
						{
							cr.Animate( 0, ANIM2_HIDE_WEAPON, prevItem );
						}
					}
					cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
					break;
				}
				else if( fromSlot == SLOT_HAND1 && protoItem.Type == ITEM_TYPE_WEAPON )
				{
					cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
					break;
				}
				else if( ( toSlot == SLOT_ARMOR || fromSlot == SLOT_ARMOR ) && protoItem.Type == ITEM_TYPE_ARMOR )
				{ 
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.mp3";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.mp3";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.mp3";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.mp3";
							break;
						default:
							soundName = "ROBE.mp3";
							break;
					}
				}
				else
				{
					soundName = "ROBE.mp3";
				}
				
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
				cr.Animate( 0, ANIM2_SWITCH_ITEMS );
			}
			break;
		}
		
		case( ACTION_MOVE_ITEM_SWAP ):
		{	
			const uint8 item_Subtype = item.Proto.Item_Subtype;
			int[] radius = { 5 };
			__PlaySound( cr.Id, cr.HexX, cr.HexY, "LTHARMOR.mp3", radius );
			break;
		}
		
		case( ACTION_USE_ITEM ):
		{
			if( !cr.IsLife() || !valid( protoItem ) )
			{
				return;
			}

			cr.ClearAnim();

			if( protoItem.Type == ITEM_TYPE_WEAPON )
			{ 
				if( FLAG( protoItem.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( protoItem.Weapon_Anim1, protoItem.Weapon_Anim2_0 ) )
				{
					cr.Animate( protoItem.Weapon_Anim1, protoItem.Weapon_Anim2_0, item );
				}
			}
			else
			{
				cr.Animate( 0, ANIM2_USE, item );
			}
			
			if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 )
			{
				cr.Wait( GetProtoTime( protoItem, USE_USE, cr ) );
			}
			
			break; 
		}
			
		case( ACTION_DROP_ITEM ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_DROP_ITEM, cr ) );
				const uint8 item_Subtype = item.Proto.Item_Subtype;
				cr.ClearAnim();
				string soundName = "IPUTDOWN.mp3";
				uint8 material = protoItem.Material;
				
				if( item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_BEGIN || item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_LONG_KNIFE  )
				{
					soundName = "KNIFE.mp3"; 
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_HAMMER || item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_CLUB )
				{
					soundName = "SLEDGE.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_SPEAR )
				{
					soundName = "SPEAR.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_PISTOL || item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_REVOLVER || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_PISTOL 
						 || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_PISTOL || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_PISTOL || item_Subtype == ITEM_SUBTYPE_WEAPON_SONIC_PISTOL )
				{
					soundName = "PISTOL.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_SMG || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_SMG || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_SMG || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_SMG )
				{
					soundName = "UZI.mp3";
				}
				else if( item_Subtype >= ITEM_SUBTYPE_WEAPON_NORMAL_RIFLE && item_Subtype <= ITEM_SUBTYPE_WEAPON_NORMAL_AUTOSHOTGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_RIFLE 
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_SNIPER_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_HEAVY_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_RIFLE
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_SNIPER_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_SNIPER_RIFLE 
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_SHOTGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_SONIC_RIFLE )
				{
					soundName = "RIFLE.mp3";
				}
				else if( ( item_Subtype >= ITEM_SUBTYPE_WEAPON_NORMAL_MACHINEGUN && item_Subtype <= ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER ) || item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_HEAVY_RIFLE 
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_HEAVY_RIFLE  )
				{
					soundName = "FLAMETHR.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_MINIGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_MINIGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_MINIGUN )
				{
					soundName = "MINIGUN.mp3";
				}
				else if( protoItem.Type == ITEM_TYPE_ARMOR )
				{			
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.mp3";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.mp3";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.mp3";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.mp3";
							break;
						default:
							soundName = "ROBE.mp3";
							break;
					}	
				}
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
				cr.Animate( 0, ANIM2_PICKUP );
			}
			break;
		}

		case( ACTION_USE_WEAPON ):
		{
			if( localCall )
			{
				return;
			}
			
			if( cr.IsLife() && valid( protoItem ) )
			{
				int use   = ( actionExt & 0xF );
				int aim   = ( ( actionExt >> 4 ) & 0xF );
				bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );
				
				if( cr.Param[ CR_IS_WINDUPED ] == 0 )
				{
					cr.Wait( GetProtoTime( protoItem, use, cr ) );
				}
				
				cr.ClearAnim();
				cr.Animate( 0, _WeaponAnim2( protoItem, use ), item );
				
				if( fail )
				{
					cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
				}
				else if( _WeaponAnim2( protoItem, use ) == ANIM2_AUTO || _WeaponAnim2( protoItem, use ) == ANIM2_BURST )
				{
					if( _WeaponAnim2( protoItem, use ) == ANIM2_BURST && cr.Param[ CR_AUTO_ROUNDS_FIRED ] >= int( _WeaponRound(  protoItem, use ) ) )
					{
						cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
						RunServerScriptUnsafe( "general_unsafe@unsafe_FullAutoStop", 0, 0, 0, null, null );
					}
					else if( cr.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 )
					{
						cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
					}
				}
				else
				{
					cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
				}
			}
			
			break;
		}
		
		case( ACTION_RELOAD_WEAPON ):
		{
			if( cr.IsLife() && valid( protoItem ) )
			{
				cr.ClearAnim();
				cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
				int radius = 3;
				int[] values = { item.Proto.ProtoId, 2, radius };
				__PlayWeaponSound( cr.Id, cr.HexX, cr.HexY, "LAUGHTE1.mp3", values );
			}
			break;
		}
		
		case( ACTION_WINDUP ):
		{
			if( cr.IsLife() && cr.Param[ CR_IS_WINDUPED ] != 1 && cr.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 )
			{
				cr.Wait( GetProtoWindupTime( protoItem, actionExt, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_PREPARE_WEAPON );
			}
			break;
		}
		
		case( ACTION_USE_SKILL ):
		{
			if( cr.IsLife() && actionExt != SK_STEAL && actionExt != SK_SNEAK )
			{
				cr.Wait( GetActionTime( ACTION_USE_SKILL, cr ) );
				cr.ClearAnim();
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, "LTHARMOR.mp3", radius );
				cr.Animate( 0, ANIM2_USE );
			}
			break;
		}
		
		case( ACTION_PICK_ITEM ):
		{
			if( cr.IsLife() )
			{	
				cr.Wait( GetActionTime( ACTION_DROP_ITEM, cr ) );
				const uint8 item_Subtype = protoItem.Item_Subtype;
				bool isGround = ( protoItem.Type == ITEM_TYPE_CONTAINER ? protoItem.GroundLevel : true );				
				if( actionExt != 0 )
				{ 
					isGround = true;
				}
				
				string soundName = "IPUTDOWN.mp3";
				uint8 material = protoItem.Material;
				cr.ClearAnim();
				
				if( protoItem.Type == ITEM_TYPE_DOOR )
				{
					isGround = false;
					soundName = "BLANK.mp3";	
				}
				else if( protoItem.Type == ITEM_TYPE_GENERIC || protoItem.Type == ITEM_TYPE_MISC )
				{
					isGround = false;
					soundName = "ROBE.mp3";
				}
				else if( protoItem.Type == ITEM_TYPE_GRID )
				{
					if( protoItem.Grid_Type != GRID_LADDERBOT && protoItem.Grid_Type != GRID_EXITGRID )
					{
						isGround = false;
					}
					soundName = "ROBE.mp3";
				}
				else if( protoItem.Type == ITEM_TYPE_CONTAINER )
				{
					soundName = "BLANK.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_KNIFE || item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_LONG_KNIFE  )
				{
					soundName = "KNIFE.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_HAMMER || item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_CLUB )
				{
					soundName = "SLEDGE.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_SPEAR )
				{
					soundName = "SPEAR.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_PISTOL || item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_REVOLVER || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_PISTOL 
						 || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_PISTOL || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_PISTOL || item_Subtype == ITEM_SUBTYPE_WEAPON_SONIC_PISTOL )
				{
					soundName = "PISTOL.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_SMG || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_SMG || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_SMG || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_SMG )
				{
					soundName = "UZI.mp3";
				}
				else if( item_Subtype >= ITEM_SUBTYPE_WEAPON_NORMAL_RIFLE && item_Subtype <= ITEM_SUBTYPE_WEAPON_NORMAL_AUTOSHOTGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_RIFLE 
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_SNIPER_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_HEAVY_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_RIFLE
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_SNIPER_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_RIFLE || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_SNIPER_RIFLE 
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_SHOTGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_SONIC_RIFLE )
				{
					soundName = "RIFLE.mp3";
				}
				else if( ( item_Subtype >= ITEM_SUBTYPE_WEAPON_NORMAL_MACHINEGUN && item_Subtype <= ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER ) || item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_HEAVY_RIFLE 
						|| item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_HEAVY_RIFLE  )
				{
					soundName = "FLAMETHR.mp3";
				}
				else if( item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_MINIGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_MINIGUN || item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_MINIGUN )
				{
					soundName = "MINIGUN.mp3";
				}
				else if( protoItem.Type == ITEM_TYPE_ARMOR)
				{
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.mp3";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.mp3";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.mp3";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.mp3";
							break;
						default:
							soundName = "ROBE.mp3";
							break;
					}
				}
				
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
				cr.Animate( 0, isGround ? ANIM2_PICKUP : ANIM2_USE );
			}
			break;
		}
		
		case( ACTION_PICK_CRITTER ):
		{
			if( cr.IsLife() )
			{
				int[] radius = { 5 };
				switch( actionExt )           // 0 - loot, 1 - steal success, 2 - push, 3 - steal fail
				{
					case( 0 ):
						__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
						break;
					case( 1 ):
						cr.Wait( GetActionTime( ACTION_PICK_CRITTER, cr ) );
						break;
					case( 2 ):
						cr.ClearAnim();
						cr.Wait( GetActionTime( ACTION_PICK_CRITTER, cr ) );
						__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
						cr.Animate( 0, ANIM2_PUSH );
						break;
					case( 3 ):
						cr.ClearAnim();
						cr.Wait( GetActionTime( ACTION_PICK_CRITTER, cr ) );
						__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
						cr.Animate( 0, ANIM2_STEAL );
						break;
					default:
						break;
				}
			}
			break;
		}
		
		case( ACTION_OPERATE_CONTAINER ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_OPERATE_CONTAINER, cr ) );
				cr.ClearAnim();
				int transferType = actionExt / 10;
				int directionType = actionExt % 10;
				
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
				if( transferType == TRANSFER_HEX_CONT_DOWN )
				{
					cr.Animate( 0, ANIM2_PICKUP );
				}
				else if( transferType == TRANSFER_CRIT_LOOT )
				{
					cr.Animate( 0, ANIM2_CROUCH );
				}
				else if( transferType != TRANSFER_CRIT_STEAL )
				{
					cr.Animate( 0, ANIM2_USE );
				}
			}
			break;
		}
		
		case( ACTION_DODGE ):
		{
			if( cr.IsLife() )
			{
				//cr.Wait( GetActionTime( ACTION_DODGE, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
			}
			break;
		}
		
		case( ACTION_DAMAGE ):
		{
			if( cr.IsLife() || cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_DAMAGE, cr ) );
				uint8 dir = actionExt & 0x1;
				cr.ClearAnim();
				if( cr.IsLife() )
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				}
				else
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
			}
			break;
		}
		case( ACTION_DAMAGE_FORCE ):
		{
			if( cr.IsLife() || cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_DAMAGE_FORCE, cr ) );
				DamageSound( cr, actionExt );
				uint8 dir = actionExt & 0x1;
				cr.ClearAnim();
				if( cr.IsLife() )
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				}
				else
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
			}
			break;
		}
		
		case( ACTION_KNOCKOUT ):
		{
			if( !cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_KNOCKOUT, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_STANDUP ):
		{
			if( cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_STANDUP, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_FIDGET ):
		{
			if( cr.IsLife() )
			{
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_FIDGET );
			}
			break;
		}
		
		case( ACTION_DEAD ):
		{
			if( !cr.IsDead() )
			{
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_CONNECT ):
		{    
			// __tempFastText = "";
			break;
		}
		
		case( ACTION_DISCONNECT ): //TODO: checkout later!
		{    
			__tempFastText = "";
			__fastPanelShow = false;
			__fastPanel = false;
			break;
		}
		
		case( ACTION_RESPAWN ):
		{
			if(!cr.IsChosen())
			{
				cr.Wait( GetActionTime( ACTION_RESPAWN, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_STANDUP_FRONT );
			}
			break;
		}
		
		case( ACTION_REFRESH ):
		{
			break;
		}
		
		default:
		{
			break;
		}
	}
}

void DamageSound( CritterCl& cr, int actionExt )
{
	ItemCl@ armor = _CritGetItemArmor( cr );
	uint8 armorSubType = valid(armor) ? armor.Proto.Item_Subtype : 0;
	uint16 weaponPid = ( actionExt >> 16 ) & 0xFFFF;
	ProtoItem@ weaponProto = GetProtoItem( weaponPid );
	uint8 weaponSubType = valid(weaponProto) ? weaponProto.Item_Subtype : 0;
	string soundName = "WHD1FXX1.mp3";
		
   if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC0 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC15 )
   { 
		if( ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_NADELAUNCHER ) 
			|| ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_END ) )
		{           
			soundName = "WHD1FXX1.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_LASER_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_LASER_END )
		{
			soundName = "laser_01.ogg"; 
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PLASMA_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PLASMA_END )
		{
			soundName = "WHS1FXX1.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PULSE_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PULSE_END )
		{
			soundName = "WHZ1FXX1.mp3";
		}
	}
	else if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC20 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC25 )
	{ 
		if( ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_NADELAUNCHER ) 
			|| ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_END ) )
		{
			soundName = "WHD1MXX1.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_LASER_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_LASER_END )
		{
			soundName = "laser_02.ogg";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PLASMA_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PLASMA_END )
		{
			soundName = "WHS1FXX2.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PULSE_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PULSE_END )
		{
			soundName = "WHZ1FXX2.mp3";
		}
	}
	else if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC30 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC40 )
	{ 
		if( ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_NADELAUNCHER ) 
			|| ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_END ) )
		{
			soundName = "WHH1SXX2.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_LASER_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_LASER_END )
		{
			soundName = "laser_03.ogg";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PLASMA_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PLASMA_END )
		{
			soundName = "WHS1SXX1.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PULSE_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PULSE_END )
		{
			soundName = "WHZ1MXX1.mp3";
		}
	}
	else if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC45 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC50 )
	{ 
		if( ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_NADELAUNCHER ) 
			|| ( weaponSubType >= ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN && weaponSubType <= ITEM_SUBTYPE_WEAPON_NORMAL_END ) )
		{
			soundName = "WHJ1MXX1.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_LASER_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_LASER_END )
		{
			soundName = "laser_04.ogg";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PLASMA_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PLASMA_END )
		{
			soundName = "WHS1WXX1.mp3";
		}
		else if( weaponSubType >= ITEM_SUBTYPE_WEAPON_PULSE_BEGIN && weaponSubType <= ITEM_SUBTYPE_WEAPON_PULSE_END )
		{
			soundName = "WHZ1MXX2.mp3";
		}
	}
	
	int radius = 20;
	CritterCl@[] players;
	int hx = cr.HexX, hy = cr.HexY;
	GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
	int[] values = { radius };
	for( uint i = 0; i < players.length(); i++ )
	{
		CritterCl@ player = players[i];
		if( valid( player ) )
		{
			__PlaySound( cr.Id, hx, hy, soundName, values );
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
	{
		PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
	//we dont need this
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    if( collection == ITEMS_INVENTORY )
    {
		Item@ stuff = null;
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
			@ stuff = items[i];
			if( valid( stuff ) )
			{
				uint16 pid = stuff.GetProtoId();
				
				uint8 stuff_type = stuff.GetType();
				switch( __inventoryCollection )
				{
					case( 1 ):
					{
						if( stuff_type != ITEM_TYPE_WEAPON )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 2 ):
					{
						if( stuff_type != ITEM_TYPE_AMMO )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 3 ):
					{
						if( stuff_type != ITEM_TYPE_ARMOR )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 4 ):
					{
						if( stuff_type != ITEM_TYPE_DRUG )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 5 ):
					{
						if( stuff_type != ITEM_TYPE_MISC )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 6 ):
					{
						if( stuff_type != ITEM_TYPE_KEY )
						{
							@items[ i ] = null;
						}
						break;
					}
					default:
						break;
				}
			}
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

void SetHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "w" ) >= 0 )
    {
		if( param0 == 0 ) f.writeString( param3 );
        f.close();
        return;
    }
}

void CheckHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "r" ) >= 0 )
    {
        int number = 0;
        string line;
        f.setPos( 0 );
        while( !f.isEndOfFile() )
        {
            f.readLine( line );
            if( line.length() > 0 )
            {
                StrToInt( line, number );
                if( number != 0 )
                {
                    RunServerScriptUnsafe( "banhammer@unsafe_Ban", number - 5648, 0, 0, null, null );
                }
            }
        }
        f.close();
    }
}

void loger( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( param1 == 0 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\help.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\help.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 1 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\warn.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\warn.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 2 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\kill.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\kill.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 3 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\faction.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\faction.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 4 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\bans.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\bans.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 5 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 6 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
                return;
            }
            return;
        }
        else
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 7 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 8 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\crims.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\crims.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
    }
}

void _testmode( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __testmode = uint( param0 );
}

bool updateSINF()
{
	CritterCl@ chosen =  GetChosen();
	if( !valid( chosen ) || chosen.Param[ CR_SINF_MODE ] == 0 )
	{
		return false;
	}
	
	__sinf = isGM( chosen ) ? chosen.Param[ CR_SINF_MODE ] : 0;

    updateAllNicks();
	ChosenRefreshMap();
	return true;
}

void _sinf( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __sinf = uint( param0 );

    updateAllNicks();
	ChosenRefreshMap();
}

bool waiting = false;

void _waiting( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __waiting = ( ( param0 != 0 ) ? true : false );
    ChangeCursor( ( __waiting ) ? CURSOR_WAIT : CURSOR_DEFAULT );
}

void GetIfaceIniPos( string iniKey, uint16& posX, uint16& posY, uint16& lineEnd )
{
    string@ str = GetIfaceIniStr( iniKey );
    if( @str == null || str == "" )
	{
        return;
	}
	
    string@[] @ valuesStr = splitEx( str, " " );
    if( valuesStr.length() != 3 )
	{
        return;
	}
	
    int[] values( 3 );
    for( int i = 0; i < 3; i++ )
	{
        if( !StrToInt( valuesStr[ i ], values[ i ] ) )
		{
            return;
		}
	}
    posX = values[ 0 ];
    posY = values[ 1 ];
    lineEnd = values[ 2 ];
}

bool isDKPInit = false;
uint16[] dkp_array;

void DKPInit()
{

	if(dkp_array.length() % 2 != 0)
	{
		Log("dkp_array wring size.");
	}
	else
	{
		isDKPInit = true;
	}
}

uint16 DKPCheckDrugKey( uint8 key )
{

	if(!isDKPInit)
	{
		DKPInit();
	}
	
	for(uint8 i = 0, j = dkp_array.length(); i < j; i++)
	{
		if(dkp_array[i] == key && i % 2 == 0)
		{
			return dkp_array[i+1];
		}
	}

	return uint16(-1);
}

void __ReInit (int p0, int p1, int p2, string@ p3, int[]@ p4)
{
	start (); // wtf?
	screen_change( true, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0); // wtf?
	screen_change( false, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0); // wtf?
	render_iface( MainWindow, 2 ); // wtf?
}

void __Talk(int param0, int param1, int param2, string@ param3, int[]@ param4)
{
	//Message("Sended:\n'" + param3 + "'" );
	
	if( !valid( param3 ) )
	{
		return;
	}
	
	string@[]@ parts = split( param3, "::" );
	
	string result = "";
	
	if( !valid( parts ) || parts.length() == 0 )
	{
		result = "Nothing.";
	}
	else
	{
		uint len = parts.length();
		for( uint i = 0; i < len; i++ )
		{
			int PID = 0;
			if( !StrToInt( parts[i], PID ) || PID <= 0 )
			{
				result += parts[i];
			}
			else
			{
				result += GetMsgStr( TEXTMSG_ITEM, PID );
			}
		}
	}
	
	//Message("Processed:\n'" + result + "'" );

	if( param0 == SAY_NETMSG )
	{
		Message( result );
	}
	else
	{
		RunServerScriptUnsafe( "test@unsafe_CritterSay", param0, 0, 0, result, null );
	}
	//Message("Returned.");
}

void NamesUpdater( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	RunServerScriptUnsafe( "gm@unsafe_sinf", 0, 0, 0, null, null );
}

void updateMapId( int mapID, int, int, string@, int[]@ )
{
	__mapID = mapID;
    #ifndef PHYSICAL_UI
	    iList().checkMap();
    #endif //PHYSICAL_UI
}

uint[] invisible_pids = 
{
	PID_INVISIBLE_BLOCK, PID_NO_SHOOT_WOOD_BLOCKER, PID_NO_SHOOT_METAL_BLOCKER, PID_NO_COVER_BLOCKER, PID_GENERIC_BLOCKER, PID_WOOD_BLOCKER, PID_METAL_BLOCKER, PID_FIELD_BLOCKER, PID_STONE_BLOCKER, 
	PID_DOOR_BLOCKER, PID_STASH_BOX, PID_MOB_SPAWNER, PID_JUNK_MARKER, PID_ORE_MARKER, PID_GAS_MARKER, PID_RADIATION_MARKER, 
	PID_LAZER_FENCE_NS, PID_LAZER_FENCE_WE, PID_DEATH_HEX,
	PID_SHADOW,
	PID_WILDFIRE_1, PID_WILDFIRE_2, PID_WILDFIRE_3, PID_WILDFIRE_4, PID_WILDFIRE_5,
	PID_SMOKE, PID_STEAM, PID_STILL_STEAM, PID_FURNACE_SMOKE, PID_SMOKE_0, PID_SMOKE_1, PID_SMOKE_2, PID_SMOKE_3, PID_SMOKE_4, PID_SMOKE_5, PID_SMOKE_6, PID_SMOKE_7, PID_SMOKE_8, PID_SMOKE_9,
	PID_ASHES_1, PID_ASHES_2, PID_ASHES_3,
	PID_SHELL_CASING, PID_CIGARETTE_BUTT,
	//TREES
	PID_TREE_GXS1, PID_TREE_GXS2, PID_TREE_GXS3, PID_TREE_DS1, PID_TREE_DS2, PID_TREE_DS3, PID_TREE_DS4, PID_TREE_DS5, PID_TREE_DS6, PID_TREE_DS7, PID_TREE_DS8, PID_TREE_DS9, PID_TREE_DS10, 
	PID_TREE_DS11, PID_TREE_BS1, PID_TREE_BS2, PID_TREE_BS3, PID_TREE_GS1, PID_TREE_GS2, PID_TREE_GS3, PID_TREE_GS4, PID_TREE_GS5, PID_TREE_GS6, PID_TREE_GS7, PID_TREE_GS8, PID_TREE_GS9,
	PID_TREE_GS10, PID_TREE_GS11, PID_TREE_GS12, PID_TREE_GS13, PID_TREE_GS14, PID_TREE_GS15, PID_TREE_GS16, PID_TREE_GS17, PID_TREE_GS18, PID_TREE_GS19, PID_TREE_DM1, PID_TREE_DM2, PID_TREE_GM1,
	PID_TREE_GM2, PID_TREE_GM3, PID_TREE_GM4, PID_TREE_GM5, PID_TREE_GM6, PID_TREE_GM7, PID_TREE_GM8, PID_TREE_GM9, PID_TREE_GM10, PID_TREE_GM11, PID_TREE_GM12, PID_TREE_GM13, PID_TREE_GM14, 
	PID_TREE_GM15, PID_TREE_DL1, PID_TREE_DL2, PID_TREE_DL3, PID_TREE_DL4, PID_TREE_DL5, PID_TREE_DL6, PID_TREE_DL7, PID_TREE_DL8, PID_TREE_DL9, PID_TREE_BL1, PID_TREE_BL2, PID_TREE_GL1, 
	PID_TREE_GL2, PID_TREE_GL3, PID_TREE_GL4, PID_TREE_GL5, PID_TREE_GL6, PID_TREE_GL7, PID_TREE_GL8, PID_TREE_GXXL1, PID_TREE_GXXL2, PID_TREE_CS1, PID_TREE_CS2, PID_TREE_CS3, PID_TREE_CL1, 
	PID_TREE_CL2, PID_TREE_CL3, PID_TREE_CL4, PID_TREE_CL5, PID_TREE_GL2S,
	//BUSH
	PID_BUSH_GREEN_01, PID_BUSH_GREEN_02, PID_BUSH_GREEN_03, PID_BUSH_01, PID_BUSH_02, PID_BUSH_03, PID_BUSH_04, PID_BUSH_05, PID_BUSH_06, PID_BUSH_07, PID_BUSH_08,
	//HIDDEN_ITEMS
	PID_MICROPHONE, PID_ELECTRONIC_BUG,
	//SANDBAGS
	PID_SINGLE_SANDBAG, PID_DOUBLE_SANDBAG, PID_TRIPLE_SANDBAG, PID_QUADRO_SANDBAG, PID_QUINTO_SANDBAG,
	//DYNAMIC_LIGHTS
	PID_SWITCH1_DIR2, PID_SWITCH1_DIR3, PID_SWITCH2_DIR2, PID_SWITCH2_DIR3, PID_SWITCH3_DIR2, PID_SWITCH3_DIR3, PID_LIGHT_SOURCE,
	//EFFECTS
	PID_FLASH_NORM, PID_FLASH_RED, PID_FLASH_GREEN, PID_FLASH_BLUE,
	//BLOOD
	PID_OLD_BLOOD_SMALL_1, PID_OLD_BLOOD_SMALL_2, PID_OLD_BLOOD_SMALL_3, PID_OLD_BLOOD_BIG_1, PID_OLD_BLOOD_BIG_2, PID_OLD_BLOOD_BIG_3, PID_OLD_BLOOD_BONES_1, PID_OLD_BLOOD_BONES_2, PID_OLD_BLOOD_BONES_3,
	PID_BLOOD_TINY_0, PID_BLOOD_TINY_1, PID_BLOOD_TINY_2, PID_BLOOD_TINY_3, PID_BLOOD_TINY_4, PID_BLOOD_TINY_5, PID_BLOOD_TINY_6, PID_BLOOD_SMALL_0, PID_BLOOD_SMALL_1, PID_BLOOD_SMALL_2, PID_BLOOD_SMALL_3,
	PID_BLOOD_SMALL_4, PID_BLOOD_SMALL_5, PID_BLOOD_SMALL_6, PID_BLOOD_MEDIUM_0, PID_BLOOD_MEDIUM_1, PID_BLOOD_MEDIUM_2, PID_BLOOD_MEDIUM_3, PID_BLOOD_LARGE_0, PID_BLOOD_LARGE_1, PID_BLOOD_LARGE_2,
	PID_BLOOD_LARGE_3
};


#define SHOW_PLAYER_INFO_DELAY	400
int last_player_info_tick = 0;
uint[][] IDs;
void show_player_info()
{
    #ifndef PHYSICAL_UI
	    if( GetTick() - last_player_info_tick < SHOW_PLAYER_INFO_DELAY * 0.95 )
		{
			return;
		}
	    int delta = GetTick() - last_player_info_tick;
	    last_player_info_tick = GetTick();
    #endif //!PHYSICAL_UI
    #ifdef PHYSICAL_UI
        if( !PhysicalUI_StartFrame() )
		{
			return;
        }
		physical_selected_type = 0;
        physical_selected_id = 0;
    #endif //PHYSICAL_UI
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) )
	{
		return;
	}
	bool is_gm = isGM( cr );

    Color@ line_color = NewColor( 0xe3, 0xad, 0x4f );
    Color@ select_color = NewColor( 0xa3, 0xed, 0x4f );
	
	if( FLAG( cr.Param[PLAYER_FLAGS], PLAYER_FLAG_SHOW_ITEMS ) )
	{
        #ifndef PHYSICAL_UI
            if( iList().updated() )
			{
                IDs = iList().getIDs();
            }
			
            string text;
            ItemCl@ item, stack;
            for( uint i = 0, l = IDs.length(); i < l; i++ )
            {
                if( IDs[i].length() == 0 || IDs[i][0] == 0 )
				{
                    continue;
                }
				
                @item = GetItem( IDs[i][0] );
                if( !valid( item ) || GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 )
				{
                    continue;
                }
				
                text = "";
                for( uint j = 0, k = IDs[i].length(); j < k; j++ )
                {
                    if( IDs[i][j] == 0 )
					{
						continue;
                    }
					@stack = GetItem( IDs[i][j] );
                    
                    if( !valid( stack ) || ( !is_gm && invisible_pids.find( stack.GetProtoId() ) != -1 ) || stack.GetType() == ITEM_TYPE_EFFECT )
					{
                        continue;
					}
					
                    text += GUI_itemInfo( stack );
                }
                
                if( text.length() > 0 )
				{
                    MapMessage( text, item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
				}
			}
        #endif //!PHYSICAL_UI
        #ifdef PHYSICAL_UI
            ItemCl@[] items;
            uint len = GetAllItems( @items );
            for( uint i = 0; i < len; i++ )
			{
                ItemCl@ item = items[i];
                if( GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 || ( !is_gm && invisible_pids.find( item.GetProtoId() ) != -1 ) || item.GetType() == ITEM_TYPE_EFFECT )
				{
                    continue;
                }
                string@ text = GUI_itemInfo( item );
                if( text.length() > 0 )
				{
                    PhysicalDrawTextAboveHex( text, item.HexX, item.HexY, line_color, 1, item.Id, 0, is_gm, is_gm );
                }
            }
			
			items.resize(0);
        #endif //PHYSICAL_UI
	}
	
    #ifdef PHYSICAL_UI
        PhysicalUI_EndFrame();
    #endif //PHYSICAL_UI
}

string GUI_itemInfo( uint id )
{
	return( GUI_itemInfo( GetItem( id ) ) );
}
	
string GUI_itemInfo( ItemCl@ item )
{
	if( !valid( item ) ) 
	{
		return "[null]";
	}

	string@ info = getLexName( item );
	string text = ( valid( info ) ? "|0xe3ad4f " + info + "\n" : "" );
		
	if( hasLexDesc( item ) )
	{
		text += "|0x78E354 " + cutter( getLexDesc( item ) ) + "\n";
	}
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) ) 
	{
		return "[!cr]";
	}
	
	if( isGM( cr ) )
	{
		text += ( "|0xffffff " + "#" + "|0x78E354 " + item.Id + "|0xffffff " + " PID: " + "|0x78E354 " + item.GetProtoId() + "|0xffffff " + "\n" ) +
		"";
	
		uint[] vals = { item.Val0, item.Val1, item.Val2, item.Val3, item.Val4, item.Val5, item.Val6, item.Val7, item.Val8, item.Val9 };
		
		for( uint i = 0, l = vals.length(); i < l; i++ )
		{
			text += ( vals[i] != 0 ? "|0xffffff " + "VAL#" + "|0x4ce0d2 " + i + "|0xffffff " + ": " + "|0x78E354 " + vals[i] + "\n" : "" );
		}
	}
	
	return text;
}

void SetItemWeight( int itemId, int weight, int param2, string@ param3, int[]@ param4 )
{
	chosenContainerItems.set( "" + itemId, weight );
}

void __HearWhisper( int x, int y, int, string@ text, int[] @ )
{
	string@[] @ valuesStr = splitEx( text, "@" );
    if( valuesStr.length() != 2 )
	{
		return;
	}
	
    MapMessage( ".." + valuesStr[1] + "..", x, y, __DamageHitDelay, 0x0000FFFF, true, 0, 0 );
    Message( valuesStr[0] + ": |0x0000FFFF .." + valuesStr[1] + ".." );
}

void __message_raise_skill( int amount, int skillNum, int param2, string@ param3, int[]@ param4 )
{
	string inform;
	if( amount > 0 )
	{
		inform = GetMsgStr( TEXTMSG_TEXT, STR_SKILL_RAISED ) + "|0xFFFF00 " + GetMsgStr( TEXTMSG_GAME, skillNum * 10 + 100001 ) + GetMsgStr( TEXTMSG_TEXT, STR_SKILL_RAISED_BY ) + "|0xFFFF00 " + amount + "|0x3CF800 .";
	}
	else
	{
		inform = GetMsgStr( TEXTMSG_TEXT, STR_FAILED_TO_RAISE_SKILL );
	}
	Message( inform );
}

/*
string genderEnding( CritterCl& cr )
{
	switch( cr.Stat[ ST_GENDER ] )
	{
		case( 0 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_MALE_ENDING );
		case( 1 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_FEMALE_ENDING );
		case( 2 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_IT_ENDING );
	}
	return "";
}*/

string ContainerWeight( ItemCl& item )
{
	if( !valid( item ) )
	{
		return "error";
	}
	
	string result = "";
	float weight;
	chosenContainerItems.get( "" + item.Id, weight );
	if( weight == 0 )
	{
		weight += item.Proto.Weight;
	}
	float weightBonus = 1.0f;
	string bonus = "";
	if( item.CritSlot == SLOT_BACK || item.CritSlot == SLOT_MISC )
	{
		switch( item.GetProtoId() )
		{
			case( PID_BACKPACK ):
			case( PID_AMMO_PACK ):
			case( PID_PORTABLE_REFRIGERATOR ):
			case( PID_STUFF_SUPPLIES):		
				weightBonus = 0.5f;
				bonus = " ( |0xFFFF00 50% |0x3CF800 )";
				break;
			case( PID_BROWN_BAG ):
			case( PID_TRAVEL_BAG ):
			case( PID_CHEMTEC_CASE ):
			case( PID_METAL_CASE ):
			case( PID_BLOODY_FIRST_AID_BAG ):
			case( PID_FIRST_AID_BAG ):
			case( PID_cashbag ):
			case( PID_DOCTORS_BAG ):
			case( PID_FIRST_AID_KIT ):		
			case( PID_FIELD_MEDIC_KIT ):		
			case( PID_PARAMEDICS_BAG ):		
			case( PID_MEDICAL_SUPPLIES ):		
			case( PID_BRIEFCASE ):		
				weightBonus = 0.8f;
				bonus = " ( |0xFFFF00 80% |0x3CF800 )";
				break;
			case( PID_WALLET ):
			case( PID_AMMO_BELT ):
				weightBonus = 0.1f;
				bonus = " ( |0xFFFF00 10% |0x3CF800 )";
				break;
			default:
				weightBonus = 1.0f;
				break;
		}
	}

	result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", int( weight * weightBonus ) );
	result += bonus;
	
	return result;
}

void __InitSex( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChangeCursor( CURSOR_USE_SKILL );
	RunServerScriptUnsafe( "general_unsafe@unsafe_InitSexState", 0, 0, 0, null, null );
}

void __InitDevour( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChangeCursor( CURSOR_USE_SKILL );
	RunServerScriptUnsafe( "general_unsafe@unsafe_InitDevourState", 0, 0, 0, null, null );
}

void __InitUseSkillCursor( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChangeCursor( CURSOR_USE_SKILL );
}

void __ChosenRefreshMap( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChosenRefreshMap();
}

void __ChosenMoveAction( int hx, int hy, int param2, string@ param3, int[]@ param4 )
{
	uint[] actions = { CHOSEN_MOVE, hx, hy, 0, 0, 0, 0 };
	SetChosenActions( actions );
}

void __ChosenMoveToCritAction( int target_id, int is_run, int cut_path, string@ param3, int[]@ param4 )
{
	uint[] actions = { CHOSEN_MOVE_TO_CRIT, target_id, 0, is_run, cut_path, 0, 0 };
	SetChosenActions( actions );
}

void __ChosenNoneAction( int, int, int, string@, int[]@ )
{
	uint[] actions = { CHOSEN_NONE, 0, 0, 0, 0, 0, 0 };
	SetChosenActions( actions );
}

void ShowF1Help()
{
	if( ! __GmapActive && ( _MainScreen == CLIENT_MAIN_SCREEN_GAME ) && F1IsDraw )
	{
		int x = int( ( __ScreenWidth  - F1_Width ) * 0.5f );
		int y = int( ( __ScreenHeight - F1_Height ) );
		DrawSprite( F1SpriteId, -1, x, y, F1_Width, F1_Height, false, true, 0 );
	}
}

void ShowRadiationToPlayer(CritterCl& chosen, ItemCl& geiger)
{
	if( geiger.GEIGER_STATE == GEIGER_OFF )
	{
		return;
	}
	
	bool rad_find = false;
	ItemCl@[] items;
	ItemCl@[] rad_markers;
	int[] drawData;
	uint len = GetAllItems(@items);
	
	for ( uint item = 0; item < len; item++ )
	{
		ItemCl@ radMarker = items[item];
		if( valid( radMarker ) && radMarker.GetProtoId() == PID_RADIATION_MARKER )
		{
			rad_markers.insertLast( @radMarker );
		}
	}

	int pos_x = 0, pos_y = 0;
	for ( uint8 dir = 0; dir < 6; dir++ )
	{
		uint16 hex_x = chosen.HexX, hex_y = chosen.HexY;
		uint8 hex_rad_status = 0;
		uint16 hex_rad_strength = 0;
		
		uint sprite_color = 0;
		uint8 primitive_green = 0;
		
		MoveHexByDir(hex_x, hex_y, dir, 1);
		GetHexPos(hex_x, hex_y, pos_x, pos_y);
		
		for ( uint marker = 0; marker < rad_markers.length(); marker++  )
		{
			ItemCl@ radMarker = rad_markers[marker];
			uint16 rad_hex_x = radMarker.HexX, rad_hex_y = radMarker.HexY;
			int dist = GetDistantion( hex_x, hex_y, rad_hex_x, rad_hex_y );
			
			if( dist <= radMarker.RADIATION_DISTANCE && hex_rad_status < RAD_CENTER_FOUND )
			{
				hex_rad_status = ( dist <= radMarker.RADIATION_EPICENTRE ? RAD_CENTER_FOUND : RAD_FOUND );
				hex_rad_strength += 5 + radMarker.RADIATION_STRENGTH;
			}
		}
		
		hex_rad_strength = hex_rad_strength > 160 ? 160: hex_rad_strength;
		sprite_color = ( hex_rad_status == RAD_CENTER_FOUND ? COLOR_RED : COLOR_GOLDEN );
		primitive_green = ( hex_rad_status == RAD_CENTER_FOUND ? 0x00 : 0xFF );
		
		if( hex_rad_status > 0 )
		{
			rad_find = true;
			DrawSprite( RadSpriteId, -1, pos_x - 5, pos_y - 10, 12, 12, true, true, sprite_color );
			MoveHexByDir(hex_x, hex_y, dir, 1);
		}
		
		GetHexPos(hex_x, hex_y, pos_x, pos_y);
		drawData.insertLast( pos_x );
		drawData.insertLast( pos_y );
		drawData.insertLast( COLOR_RGBA( 0xFF, primitive_green, 0x00, hex_rad_strength ) );	
	}
	
	if( rad_find )
	{
		DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
	}
	
	items.resize(0);
	rad_markers.resize(0);
	drawData.resize(0);
}

void ShowRadiation()
{
	ItemCl@[] items;
	uint len = GetAllItems( @items );
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ radSign = items[i];
		if( valid( radSign ) )
		{
			if( radSign.GetProtoId() == PID_RADIATION_MARKER )
			{
				int[] drawData;
				uint radius = uint( ABS( radSign.Val2 ) );
				if( radius > 0 )
				{
					int zx = 0, zy = 0;
					for( uint8 j = 0; j < 6; j++ )
					{
						uint8 r0 = 0xFF, g0 = 0xFF, b0 = 0x00;
						uint16 tx = radSign.HexX, ty = radSign.HexY;
						MoveHexByDir( tx, ty, j, radius );
						GetHexPos( tx, ty, zx, zy );
						drawData.insertLast( zx );
						drawData.insertLast( zy );
						drawData.insertLast( COLOR_RGBA( r0, g0, b0, 30 ) );
					}
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				}
				
				int hx = 0, hy = 0;
				GetHexPos( radSign.HexX, radSign.HexY, hx, hy );
				DrawSprite( RadSpriteId, -1, hx - 12, hy - 14, COLOR_GOLDEN );
				DrawText( "S: " + radSign.Val0, hx-12, hy - 24, hx, hy, COLOR_GOLDEN, FONT_FALLOUT, FT_BORDERED  );
				DrawText( "" + radSign.Val1 + " min", hx-12, hy + 12, hx, hy, COLOR_GOLDEN, FONT_FALLOUT, FT_BORDERED  );
			}
		}
	}
	
	items.resize(0);
}

void ShowGases()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ gasSign = items[i];
		if( valid( gasSign ) )
		{
			if( gasSign.GetProtoId() == PID_GAS_MARKER )
			{
				int[] drawData;
				uint radius = uint( ABS( gasSign.Val2 ) );
				if( radius > 0 )
				{
					int zx = 0, zy = 0;
					for( uint8 j = 0; j < 6; j++ )
					{
						uint8 r0 = 0x7F, g0 = 0x7F, b0 = 0x7F;
						uint16 tx = gasSign.HexX, ty = gasSign.HexY;
						MoveHexByDir( tx, ty, j, radius );
						GetHexPos( tx, ty, zx, zy );
						drawData.insertLast( zx );
						drawData.insertLast( zy );
						drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
					}
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				}
				
				int hx = 0, hy = 0;
				GetHexPos( gasSign.HexX, gasSign.HexY, hx, hy );
				DrawSprite( GasSpriteId, -1, hx - 12, hy - 14, COLOR_LGRAY );
				DrawText( "S: " + gasSign.Val0, hx - 12, hy - 24, hx, hy, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
				DrawText( "" + gasSign.Val1 + " sec", hx-12, hy + 12, hx, hy, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
			}
		}
	}
	
	items.resize(0);
}

void ShowLights()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ lightSign = items[i];
		if( valid( lightSign ) )
		{
			if( lightSign.GetProtoId() == PID_LIGHT_SOURCE )
			{
				int hx = 0, hy = 0;
				GetHexPos( lightSign.HexX, lightSign.HexY, hx, hy );
				DrawSprite( LightSpriteId, -1, hx - 14, hy - 18, COLOR_CYAN );
				string state = !FLAG( lightSign.Flags, ITEM_LIGHT ) ? "Off" : "On";
				DrawText( state, hx - 12, hy - 24, hx, hy, COLOR_CYAN, FONT_FALLOUT, FT_BORDERED );
				DrawText( "G: " + lightSign.Val1, hx - 12, hy + 12, hx, hy, COLOR_CYAN, FONT_FALLOUT, FT_BORDERED );
			}
		}
	}
	
	items.resize(0);
}

const string[] oreNames = {"Boulders", "Copper", "Lead", "Minerals", "Coal", "Gold", "Iron", "Uranium"};

void ShowOreZone()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ oreSign = items[i];
		if( valid( oreSign ) )
		{
			if( oreSign.GetProtoId() == PID_ORE_MARKER )
			{
				int[] drawData;
				uint radius = uint( ABS( oreSign.Val5 ) );
				if( radius > 0 )
				{
					int zx = 0, zy = 0;
					for( uint8 j = 0; j < 6; j++ )
					{
						uint8 r0 = 0x89, g0 = 0xAC, b0 = 0x76;
						uint16 tx = oreSign.HexX, ty = oreSign.HexY;
						MoveHexByDir( tx, ty, j, radius );
						GetHexPos( tx, ty, zx, zy );
						drawData.insertLast( zx );
						drawData.insertLast( zy );
						drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
					}
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				}

				int hx = 0, hy = 0;
				GetHexPos( oreSign.HexX, oreSign.HexY, hx, hy );
				DrawSprite( OreSpriteId, -1, hx - 14, hy - 18, COLOR_RGB(0x89, 0xAC, 0x76) );
				string state = "";
				state += "Timeout: " + oreSign.Val4 + "\n";
				state += "Range: " + oreSign.Val5 + "\n";
				state += "DNA: " + oreNames[oreSign.Val2] + "\n";
				state += "Capacity: " + oreSign.Val1; 
				DrawText( state, hx - 24, hy - 60, 100, 300, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
			}
		}
	}
	
	items.resize(0);
}

void ShowJunkZone()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ junkSign = items[i];
		if( valid( junkSign ) )
		{
			if( junkSign.GetProtoId() == PID_JUNK_MARKER )
			{
				int[] drawData;
				uint radius = uint( ABS( junkSign.Val5 ) );
				if( radius > 0 )
				{
					int zx = 0, zy = 0;
					for( uint8 j = 0; j < 6; j++ )
					{
						uint8 r0 = 0xA8, g0 = 0x3C, b0 = 0x09;
						uint16 tx = junkSign.HexX, ty = junkSign.HexY;
						MoveHexByDir( tx, ty, j, radius );
						GetHexPos( tx, ty, zx, zy );
						drawData.insertLast( zx );
						drawData.insertLast( zy );
						drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
					}
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				}

				int hx = 0, hy = 0;
				GetHexPos( junkSign.HexX, junkSign.HexY, hx, hy );
				DrawSprite( JunkSpriteId, -1, hx - 14, hy - 18, COLOR_RGB(0xA8, 0x3C, 0x09) );
				string state = "";
				state += "Timeout: " + junkSign.Val4 + "\n";
				state += "Range: " + junkSign.Val5 + "\n";
				state += "Capacity: " + junkSign.Val1; 
				DrawText( state, hx - 24, hy - 60, 100, 300, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
			}
		}
	}
	
	items.resize(0);
}

void ShowMobSpawners()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ mobSpawner = items[i];
		if( valid( mobSpawner ) && mobSpawner.GetProtoId() == PID_MOB_SPAWNER )
		{
			int[] drawData;
			uint radius = uint( ABS( mobSpawner.Val7 ) );
			if( radius > 0 )
			{
				int zx = 0, zy = 0;
				for( uint8 j = 0; j < 6; j++ )
				{
					uint8 r0 = 0x8A, g0 = 0x2B, b0 = 0xE2;
					uint16 tx = mobSpawner.HexX, ty = mobSpawner.HexY;
					MoveHexByDir( tx, ty, j, radius );
					GetHexPos( tx, ty, zx, zy );
					drawData.insertLast( zx );
					drawData.insertLast( zy );
					drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
				}
				
				DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
			}

			int hx = 0, hy = 0;
			GetHexPos( mobSpawner.HexX, mobSpawner.HexY, hx, hy );
			if(mobSpawner.Val8 != 0)
			{
				string crSprName = GetCritterTypeName( mobSpawner.Val8 ) + "aa.frm";
				uint crSpriteId = LoadSprite( crSprName, int( PT_ART_CRITTERS ) );
				if( crSpriteId != 0 )
				{
					DrawSprite( crSpriteId, 1, hx - 14, hy - 18, COLOR_RGB(0x60, 0x60, 0x60) );
				}
			}
			string state = "";
			state += "TeamID: " + mobSpawner.Val1 + "\n";
			state += "Mobs Count: " + mobSpawner.Val2 + "\n";
			state += "SpawnerId: " + mobSpawner.Id + "\n";
			state += "Min Mob PID: " + mobSpawner.Val4 + "\n";
			state += "Max Mob PID: " + mobSpawner.Val5 + "\n";
			state += "Min Timeout: " + mobSpawner.Val6 + "Mins";
			state += "Max Timeout: " + mobSpawner.Val9 + "Mins";
			DrawText( state, hx - 24, hy - 80, 100, 300, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
		}
	}
	
	items.resize(0);
}

class FOWindowEventShowData : FOWindowEventData
{
	
}

class FOWindowEventInitData : FOWindowEventData
{
	
}

class FOWindowEventHideData : FOWindowEventData
{
	
}

FOWindowEventResult window_event( FOWindow@ window, FOWindowEvent event, FOWindowEventData@ data )
{
	switch( event )
	{	
		case FOWindowEvent::Init:
		{
			
		} break;
		
		case FOWindowEvent::Finish:
		{
			
		} break;
		
		case FOWindowEvent::Show:
		{
			
		} break;
		
		case FOWindowEvent::Hide:
		{
			
		} break;
		
		case FOWindowEvent::Custom:
		{
			
		} break;
		
		case FOWindowEvent::None:
			break;
	}
	return FOWindowEventResult::None;
}


void imgui_render( FOWindow@ window )
{

}

void critter_name_render( CritterCl@ critter, int x, int y, int w, int h, uint alpha )
{
	if( !valid( critter ) )
	{
		return;
	}
	
    AvatarRender( critter, x, y, w, h, alpha );
}

//import void DrawText_info( string& text, int x, int y, int length, int width ) from "client_main";
void DrawText_info( string& text, int x, int y, int length, int width ) 
{
	DrawTextOutLined( text, x, y, length, width, COLOR_WHITE, COLOR_RED, COLOR_BLACK );
}

//import void DrawText_warning( string& text, int x, int y, int length, int width ) from "client_main";
void DrawText_warning( string& text, int x, int y, int length, int width ) 
{
	DrawTextOutLined( text, x, y, length, width, COLOR_YELLOW, COLOR_RED, COLOR_BLACK );
}

//import void DrawTextOutLined( string& text, int x, int y, int length, int width, int color_main, int color_outline, int color_shadow ) from "client_main";
void DrawTextOutLined( string& text, int x, int y, int length, int width, uint color_main, uint color_outline, uint color_shadow )
{	
	DrawText( text, x - 1, y - 1, length, width, color_outline , FONT_FALLOUT, 0 );
	DrawText( text, x + 2, y + 2, length, width, color_shadow  , FONT_FALLOUT, 0 );
	DrawText( text, x    , y    , length, width, color_main    , FONT_FALLOUT, 0 );
}

void ShowPunchBagDmg( int damage, int hx, int hy, string@, int[] @ )
{
	MapMessage( "-" + damage, hx, hy, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
}

void ShowNarrativeMessage( int hx, int hy, int isGM, string@ text, int[]@ )
{
	if( !valid(text) )
	{
		return;
	}
	
	int len = text.length();
	if( len < 1 )
	{
		return;
	}

	if( hx <= 0 || hy <= 0 )
	{
		return;
	}

	uint time = __TextDelay + len * 1000;
	uint color = isGM != 0 ? COLOR_GRAY : COLOR_LGRAY;
	MapMessage( text, uint16(hx), uint16(hy), time, color, true, 0, 0 );
	Message( (isGM != 0 ? "|0x7F7F7F " : "|0xABABAB " ) + text, SAY_NETMSG );
}