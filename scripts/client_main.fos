// Author: cvet, Atom
// Client main script
// Compile using fo_client.dll
#include "_client_defines.fos"
#include "_macros.fos"
#include "_msgstr.fos"
#include "sprite.fos"
#include "_colors.fos"
#include "_animation.fos"
#include "combat_h.fos"

// #include "client_call_sign.fos" //tnf radio

import void InitializeGame() from "config";
import void InitTestScreen() from "client_screen_test";
import void InitRadioScreen() from "radio";
import void GUI_Init() from "client_gui";
import void GUI_GetActiveScreens( int[]& result ) from "client_gui";
import void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_Render() from "client_gui";
import bool GUI_MouseDown( int click, int x, int y ) from "client_gui";
import bool GUI_MouseUp( int click, int x, int y ) from "client_gui";
import void GUI_MouseMove( int x, int y ) from "client_gui";
import bool GUI_KeyDown( uint8 key ) from "client_gui";
import bool GUI_KeyUp( uint8 key ) from "client_gui";
import void GUI_InputLost() from "client_gui";
import bool PerkCheck( CritterCl& cr, uint perk ) from "perks";
import void CritterGenerate( int[]& data ) from "parameters";
import bool CritterGenerateCheck( int[]& data ) from "parameters";
// import void InitNameColorizing() from "name_colorizing";
// import bool TryColorizeCritter(CritterCl& cr) from "name_colorizing";
import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";
// binyan - Hotkeys
import void SetHotkeysUse( bool use ) from "hotkeys";
// binyan - timeouts
import void show_timeouts() from "client_timeouts";
// ///////////////////////////////////////////////////////
import bool gm_msg( string& message ) from "client_gm";

#ifdef PLAYERS_3D
import void Init3DChaRegScreen() from "client_3d_cha_reg";
import void Set3DRegistrationGender( int gender ) from "client_3d_cha_reg";
import void Fill3DRegistrationParameters( int[]& params ) from "client_3d_cha_reg";
#endif
import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";

// qthree
import void    SaveNames() from "client_names";
import void    LoadNames() from "client_names";
import void    ClearNameCache() from "client_names";
import string@ GetName( uint id ) from "client_names";
import bool    updateNick( CritterCl& cr ) from "client_names";
import bool    updateAllNicks() from "client_names";

import void DrawMapTiles() from "qmap_client";
import void qmap_loop() from "qmap_client";


// @pm menu
import void InitContMenuScreen() from "client_screen_contmenu";     // Export
import void InitFastPanelScreen() from "client_screen_fastpanel";   // Export
import void InitFastPanelSkillbox() from "client_screen_fastpanel"; // export
import void InitFastPanelTextbox() from "client_screen_fastpanel";
// import void SaveFastPanel(bool save) from "client_screen_fastpanel";
import void InitHistoryViewScreen() from "client_screen_history";
import void InitHistoryAllScreen() from "client_screen_history";
import void HidePanel( bool show ) from "client_screen_fastpanel";
import void InitCodedoorScreen() from "client_screen_codedoor";
import void InitScreenAddiotional() from "client_screen_additional";
import void SetCrtype( int[]& params ) from "client_screen_additional";
import void InitTeachScreen() from "client_screen_teaching";
import void InitScreenDoc() from "client_screen_doc";
import void InitFirstAidScreen() from "client_screen_firstais";
import void InitOptMenuScreen() from "client_screen_options"; // Export
import void SetHivePos( int16 x, int16 y, int16 realX, int16 realY, int16 type, uint8 count ) from "client_screen_additional";
import void InitScreenInputbox() from "client_screen_inputbox";
import void InitInventoryTnfScreen() from "client_screen_inventory";
import void MoveHand() from "client_screen_copybool";
import void InitClockScreen() from "client_screen_copybool";
import void InitWaypointScreen() from "checkpoints";
// #pm menu

uint prevId = 0; // нужен для определения, когда загружать сохраненные имена
Sprite[] arrow;

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
bool start()
{
    InitializeGame();

    if( __ScreenWidth < 800 || __ScreenWidth > 1280 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
//		return false;
    }

    #ifdef PLAYERS_3D
    AppendIfaceIni( "players3d_chareg.ini" );
    # ifndef PLAYERS_3D_NO_HEAD
    AppendIfaceIni( "players3d_headinv.ini" );
    # endif
    #endif

    LoadFont( FONT_COURIER_NEW_SMALL, "CourierNewSmall" );
    // SetDefaultFont(FONT_COURIER_NEW_SMALL,COLOR_TEXT);
/*
        if(!LoadDataFile("longhairdude.dat")) Message("File longhairdude.dat with Long Hair Dude animations not found. Run Updater.exe.");
        if(!LoadDataFile("vaultboy.dat")) Message("File vaultboy.dat with Vault Boy animations not found. Run Updater.exe.");
        if(!LoadDataFile("cablack.dat")) Message("File cablack.dat with Black Combat Armor animations not found. Run Updater.exe.");
        if(!LoadDataFile("mirelurk.dat")) Message("File mirelurk.dat with Black Combat Armor animations not found. Run Updater.exe.");
        if(!LoadDataFile("balddude.zip")) Message("File balddude.zip not found. Run Updater.exe.");
        if(!LoadDataFile("sandrobe.zip")) Message("File sandrobe.zip not found. Run Updater.exe.");
 */
	Message( "Вы можете настроить произвольное разрешение экрана игры в файле FOConfig.exe" );
	//if( !LoadDataFile( "tnf.zip" ) )
	// { 
		// Message( "Не найден tnf.zip! Обновите клиент с репозитория http://svn3.xp-dev.com/svn/fo_cl_rp/" );
	// }
	// else 
	AppendIfaceIni( "rp_default.ini" );
	// {
		// Message( "Не найден rp_default.ini! Обновите клиент с репозитория http://svn3.xp-dev.com/svn/fo_cl_rp/" );
	// }
	// else
	// {
	// Message( "Файлы из tnf.zip успешно загружены, карта мира и интерфейс изменены для игры на Roleplay сервере." );
	// }
    GUI_Init();
    // InitNameColorizing();
// TMP  CallSignStart();
    // InitTestScreen();
    InitRadioScreen();
    InitChosenTabs();

    // @pm menu
    InitContMenuScreen();
    InitFastPanelScreen();
    InitFastPanelSkillbox();
    InitFastPanelTextbox();
    InitCodedoorScreen();
    InitScreenAddiotional();
    InitTeachScreen();
    InitScreenDoc();
    InitFirstAidScreen();
    InitOptMenuScreen();
    InitInventoryTnfScreen();
    InitScreenInputbox();
    InitClockScreen();
    InitWaypointScreen();

    ExpBarSetPos();

    // InitHistoryViewScreen();
    // InitHistoryAllScreen();
    arrow.resize( 8 );
    arrow[ 0 ].Load( "arrow0.png", int(PT_ART_INTRFACE) );
    arrow[ 1 ].Load( "arrow1.png", int(PT_ART_INTRFACE) );
    arrow[ 2 ].Load( "arrow2.png", int(PT_ART_INTRFACE) );
    arrow[ 3 ].Load( "arrow3.png", int(PT_ART_INTRFACE) );
    arrow[ 4 ].Load( "arrow4.png", int(PT_ART_INTRFACE) );
    arrow[ 5 ].Load( "arrow5.png", int(PT_ART_INTRFACE) );
    arrow[ 6 ].Load( "arrow6.png", int(PT_ART_INTRFACE) );
    arrow[ 7 ].Load( "arrow7.png", int(PT_ART_INTRFACE) );
    // #pm menu

    #ifdef PLAYERS_3D
    Init3DChaRegScreen();
    #endif

    __ShowPlayerNames = true;
    __ShowNpcNames = true;

    __global = CONF_GLOB_GRID | CONF_GLOB_WILD;

    if( !__FullScr )
        __MouseScroll = false;

    // 3d models preloading
    #ifdef PLAYERS_3D
    // Mobs
/*	Load3dFile("VbAnt.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbAntQueen.fo3d"      , PT_ART_CRITTERS);
        Load3dFile("VbBat.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbBeetle.fo3d"        , PT_ART_CRITTERS);
        Load3dFile("VbCentipede.fo3d"     , PT_ART_CRITTERS);
        Load3dFile("VbCougar.fo3d"        , PT_ART_CRITTERS);
        Load3dFile("VbCow.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbDeathclaw.fo3d"     , PT_ART_CRITTERS);
        Load3dFile("VbDesertStalker.fo3d" , PT_ART_CRITTERS);
        Load3dFile("VbDog.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbGila.fo3d"          , PT_ART_CRITTERS);
        Load3dFile("VbMantrap.fo3d"       , PT_ART_CRITTERS);
        Load3dFile("VbRadToad.fo3d"       , PT_ART_CRITTERS);
        Load3dFile("VbRat.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbThornSlinger.fo3d"  , PT_ART_CRITTERS);
        Load3dFile("VbAnt.fo3d"           , PT_ART_CRITTERS);
        Load3dFile("VbWaspGiant.fo3d"     , PT_ART_CRITTERS);
        Load3dFile("VbWeedling.fo3d"      , PT_ART_CRITTERS);*/
    // Critters
    Load3dFile( "VbFemaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleSkeleton.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleSkeleton.fo3d", PT_ART_CRITTERS );
    #endif
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.

uint loop_turn = 0;

uint loop()
{
/*	CritterCl@ cr = GetChosen();
        if(!valid(cr)) return 1000;
        cr.NameOnHead="|0xff77ff22 "+cr.Name+" |0xffff0000 (Id:"+cr.Id+")\n|0xffAA55BB HexX: "+cr.HexX+"\n|0xff11ffff HexY: "+cr.HexY;
        return 100;
 */
    if( __isClockActive /* && loop_turn % 100 == 0*/ )
    {
        MoveHand();
    }

    if( loop_turn % 5 == 0 )
        qmap_loop();

    if( loop_turn % 100 == 0 )
    {
        int[] result;
        GUI_GetActiveScreens( result );

        CritterCl@ ch = GetChosen();

        if( !(ch is null) && ( prevId == ch.Id ) && ( ( result.length() > 0 && result[ result.length() - 1 ] == CLIENT_MAIN_SCREEN_GAME ) || ( result.length() > 1 && result[ result.length() - 2 ] == CLIENT_MAIN_SCREEN_GAME ) ) )
        {
            SaveNames();
        }
    }
    loop_turn += 1;
    if( loop_turn > 100 )
        loop_turn = 0;

    return 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_GetActiveScreens( result );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Show/hide screen behaviour.
void screen_change( bool show, int screen, int p0, int p1, int p2 )
{
// qthree
    if( screen == CLIENT_MAIN_SCREEN_LOGIN )
    {
        prevId = 0;
        ClearNameCache();
    }

// binyan - Hotkeys
    if( screen == CLIENT_SCREEN_SAY || screen == CLIENT_SCREEN_TIMER || screen == CLIENT_SCREEN_INPUT_BOX || screen == CLIENT_SCREEN_SPLIT )
        __IsTextInput = show ? true : false;
// /////////////////////////////////////
    if( show )
        GUI_ShowScreen( screen, p0, p1, p2 );
    else
        GUI_HideScreen( screen, p0, p1, p2 );
}

int[] @ data_color = null;
int[] @ data_number = null;
int[] @ data_char = null;


int[] hive_data;

void SetHiveData( int[] hivedata )
{
    hive_data.resize( 0 );
    for( uint8 i = 0; i < hivedata.length(); i++ )
    {
        hive_data.insertLast( hivedata[ i ] );
    }
}

void _dr( int param0, int param1, int param2, string@ param3, int[] @ param4 ) // draw data
{
    switch( param0 )
    {
    case 1:
        @data_color = param4;
        break;
    case 2:
        @data_number = param4;
        break;
    case 3:
        @data_char = param4;
        break;
    default:
        break;
    }
}

uint8 localMapPid = 0;

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    0
// Game map, Global map, Login, Registration, Credits, Wait
//    1
// Game interface
//    2
// Console, Messbox
//    3
// Inventory, PickUp, MiniMap, Dialog/Barter, PipBoy, FixBoy, Options menu, Character, Aim
// Split, Timer, DialogBox, Elevator, Say, Character name, Character age, Character sex, Global map town, InputBox, SkillBox, Use, Perk
//    4
// PopUp menu, Cursor
//    5
//
// Extra layers:
// Global map
//    100, 101

void render_iface( uint layer )
{
	if( layer == 4 )
	{
		//int[] drawData = {0, 0, 0xFFFFFFFF, 5, 5, 0xFFFF00FF};
		//DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
		TestDirect3d(0);
	}
	//return;
	
    if( layer == 3 )
    {
        DrawChosenTabs();
        GUI_Render();

        // if(!__GmapActive && )DrawExpBar();

        if( GetCurrentCursor() == CURSOR_MOVE )     // pm map arrows
        {
            ItemCl @ item = GetMonitorItem( __MouseX, __MouseY );
            if( item !is null )
            {


                if( item.GetProtoId() >= EXIT_GRID_PID && item.GetProtoId() <= EXIT_GRID_PID + 8 )
                {
                    CritterCl @ choo = GetChosen();

                    if( ABS( int(choo.HexX - item.HexX) ) <= 16 && ABS( int(choo.HexY - item.HexY) ) <= 16 )
                    {
                        // Message(""+item.Val7+" "+item.Val8+" "+item.Val9+" "+item.Val1+" "+item.Val0);
                        int value = GetScenParam( item.HexX, item.HexY, item.GetProtoId(), 0 );                      // item.Param0;//item.Val1;
                        // Message("value1 "+value);
                        int x = 0, y = 0;
                        switch( value )
                        {
                        case 0:
                            x = -100;
                            y = -80;
                            break;
                        case 1:
                            x = -120;
                            y = -110;
                            break;
                        case 2:
                            x = -120;
                            y = -120;
                            break;
                        case 3:
                            x = -120;
                            y = -100;
                            break;
                        case 4:
                            x = -90;
                            y = -110;
                            break;
                        case 5:
                            x = -100;
                            y = -110;
                            break;
                        case 6:
                            x = -60;
                            y = -125;
                            break;
                        case 7:
                            x = -120;
                            y = -120;
                            break;
                        default:
                            break;
                        }

                        arrow[ value ].Draw( __MouseX + x, __MouseY + y );


                        localMapPid = choo.StatBase[ ST_LOCALMAP_PID ];

                        if( value != choo.StatBase[ ST_LOCALMAP_DIR ] )
                            RunServerScriptUnsafe( "globalmap_group@unsafe_GetMapPid", item.HexX, item.HexY, item.GetProtoId(), null, null );

                        string mapName = GetMsgStr( TEXTMSG_GM, ( localMapPid + 1 ) * 10 + 8 );
						bool isRed = ( mapName == "error" ) || ( localMapPid == 0 );
						if( mapName == "error" ) mapName = "Недоступно";
                        DrawText( localMapPid != 0 ? mapName : "Пустошь", __MouseX - ( localMapPid != 0 ? mapName.length() * 7 : 45 ), __MouseY + 20, 400, 20, isRed ? COLOR_RED : COLOR_LGREEN, FONT_BIG, 0 );
                        // Message(""+GetChosen().StatBase[ST_LOCALMAP_PID]);
                    }


                }
            }

        }
        // binyan - Hex attack
        if( __IsHexAttack )
        {
            int tohit = to_hit_hex();
            if( tohit > 0 )
                DrawText( tohit + "%", __MouseX + 7, __MouseY + 8, ( ( tohit / 10 >= 1 ? 2 : 1 ) + 2 ) * 10, 10, COLOR_RED, FONT_FALLOUT, 0 );
        }
        if( __ShowTimeouts )
            show_timeouts();
    }
    else if( layer == 100 && __GmapActive )
    {
        // Here you can draw on global map

        // bool  __GmapActive - активна ли глобальная карта и все ли следующие нижеприведенные переменные корректны;
        // bool  __GmapWait   - включен режим ожидания ответа о подтверждении энкаунтера;
        // float __GmapZoom   - текущий масштаб, не забывайте учитывать его при рисовании на карте;
        // int   __GmapOffsetX/Y   - смещение карты от нулевой координаты (верхний-левый угол);
        // int   __GmapGroupCurX/Y - координаты группы игрока;
        // int   __GmapGroupToX/Y  - координаты точки назначения;
        // float __GmapGroupSpeed  - текущая скорость передвижения.
        // Для примера, расчет текущего пикселя группы:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.

        CritterCl@ ch = GetChosen();

        // SetHivePos(__GmapOffsetX, __GmapOffsetY, 5);
        if( @ch != null && ch.Param[ QST_GAMEMODE ] == GAME_ARCADE )
        {
            // Message(""+hive_data.length());
            for( uint8 i = 0; i < hive_data.length(); i++ )
            {
                int16 x = ( hive_data[ i ] ) & 0x3FF;
                int16 y = ( hive_data[ i ] >> 10 ) & 0x3FF;
                int16 type = ( hive_data[ i ] >> 20 ) & 0xFFF;

                SetHivePos( x / __GmapZoom + __GmapOffsetX, y / __GmapZoom + __GmapOffsetY, x, y, type, i );

                // Message("i "+i+" type "+type+" x "+x+" offX "+__GmapOffsetX+" y "+y+" offY "+__GmapOffsetY);
            }

            // GUI_Render(100);
        }


        int flags = ( FT_NOBREAK | FT_CENTERX | FT_CENTERY | FT_BORDERED ),
            font = FONT_FALLOUT;

        float  size = 10 / __GmapZoom;

        uint16 chx = __GmapGroupCurX / 10, chy = __GmapGroupCurY / 10;

        if( @data_color != null && __global & CONF_GLOB_WILD != 0 )
        {
            uint len = data_color.length();

            if( len > 0 && len % 2 == 0 )
            {
                // int color = 0x44772222;

                int[] drawData( len / 2*18 );

                for( uint i = 0, j = 0; i < len / 2; j++ )
                {
                    float x = ( data_color[ j * 2 ] & 0xFFFF ),
                          y = ( ( data_color[ j * 2 ] >> 16 ) );

                    // if(x0==chx && y0==chy) {len-=2; continue;}

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;

                    int a = data_color[ j * 2 + 1 ];

                    /*if(a==0x33773333)
                       {
                            len-=2; continue;
                       }*/

                    uint k = i * 18;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;

                    /*for(uint k=0, p=i*18; k<4; k++)
                       {
                            drawData[p++]=x+size*(k&1);
                            drawData[p++]=y+size*(k>>1);
                            drawData[p++]=a;
                       }*/

                    i++;
                }
                drawData.resize( len / 2 * 18 );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLELIST, drawData );
            }
        }

        if( size > 10 && __global & CONF_GLOB_GRID != 0 )
        {
            uint8 alpha = CLAMP( ( size - 5 ) * 20, 0, 0xAA );
            // int r=0x66, g=0xBB, b=0x44;
            int   r = 0x22, g = 0x22, b = 0x22;
            // float t=2/__GmapZoom-2; t=MIN(t, 1);
            // r*=t*t*t; g*=t; b*=t*t*t;
            r = CLAMP( r, 0, 0xFF );
            g = CLAMP( g, 0, 0xFF );
            b = CLAMP( b, 0, 0xFF );
            int   color = ( ( alpha ) << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );

            float x0 = __GmapOffsetX,
                  y0 = __GmapOffsetY,
                  x = ( ZONE_COUNT_X * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetX,
                  y = ( ZONE_COUNT_Y * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetY;

            uint w = ZONE_COUNT_X * ZONE_LENGTH / 10,
                 h = ZONE_COUNT_Y * ZONE_LENGTH / 10;

            int[] drawData( ( w + h + 2 )*6 );

            for( uint i = 0; i <= h; i++ )
            {
                drawData[ i * 6 ] = x0;
                drawData[ i * 6 + 1 ] = y0 + size * i;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x;
                drawData[ i * 6 + 4 ] = y0 + size * i;
                drawData[ i * 6 + 5 ] = color;
            }
            for( uint j = 0; j <= w; j++ )
            {
                uint i = h + 1 + j;
                drawData[ i * 6 ] = x0 + size * j;
                drawData[ i * 6 + 1 ] = y0;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x0 + size * j;
                drawData[ i * 6 + 4 ] = y;
                drawData[ i * 6 + 5 ] = color;
            }

            DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
        }

        if( size >= 5 /*&& ((ch !is null and ch.Param[QST_GAMEMODE]==GAME_ARCADE) || __sinf&SINF_GRID!=0 || __sinf&SINF_GLOBAL!=0)*/ )
        {
            float x = ( chx * 10 ) / __GmapZoom + __GmapOffsetX,
                  y = ( chy * 10 ) / __GmapZoom + __GmapOffsetY;

            // int[]  drawData = {x, y, color, x+size, y, color, x+size, y+size, color, x, y+size, color, x, y, color};
            // if(size<=10)
            {
                int color = 0xAA00FFFF;

                int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + size - 1, y + size - 1, color, x + 1, y + size - 1, color, x + 1, y + 1, color };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }
            /*else
               {
                    uint8 alpha = MIN((2000.0f/size), 0x88);
                    int color = 0x0000FFFF|((alpha)<<24);

                    int[]  drawData = {x+1, y+1, color, x+size-1, y+1, color, x+1, y+size-1, color, x+size-1, y+size-1, color};
                    DrawPrimitive(DRAW_PRIMITIVE_TRIANGLESTRIP, drawData);
               }*/
        }

        if( @data_number != null )
        {
            uint len = data_number.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0; i < len / 2; i++ )
                {
                    float x = ( data_number[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_number[ i * 2 ] >> 16 ) );

                    // bool drawTriangle=true;
                    // if(uint16(x/10)==chx && uint16(y/10)==chy) drawTriangle=false;

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    int a = data_number[ i * 2 + 1 ] & 0xFFFF,
                        b = data_number[ i * 2 + 1 ] >> 16;
                    ;
                    // if(x<0 || y<0 || x>)
                    string str = a;
                    if( b > 0 )
                        str += "+" + ( b - a );

                    /*if(size<=10 || !drawTriangle)
                       {
                            int color = 0xAAFFAA00;

                            int[]  drawData = {x+1, y+1, color, x+size-1, y+1, color, x+size-1, y+size-1, color, x+1, y+size-1, color, x+1, y+1, color};
                            DrawPrimitive(DRAW_PRIMITIVE_LINESTRIP, drawData);
                       }
                       else*/
                    {
                        uint8 alpha = MIN( ( 2000.0f / size ), 0x88 );
                        int   color = 0x00FFAA00 | ( ( alpha ) << 24 );

                        int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + 1, y + size - 1, color, x + size - 1, y + size - 1, color };
                        DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
                    }
                    // void GetTextInfo(string& text, int w, int h, int font, int flags, int& tw, int& th, int& lines)
                    // string& text – текст;
                    // int w, h, font, flags – высота, ширина, шрифт, флаги;
                    // int& tw, int& th, int& lines – итоговые ширина, высота и количество строк данного текста.
                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, 0xFF22AAFF, font, flags );
                }
            }
        }

        if( @data_char != null )
        {
            uint len = data_char.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0; i < len / 2; i++ )
                {
                    float x = ( data_char[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_char[ i * 2 ] >> 16 ) );

                    // bool drawTriangle=true;
                    // if(uint16(x/10)==chx && uint16(y/10)==chy) drawTriangle=false;

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    uint a = ( data_char[ i * 2 + 1 ] & 0x00FFFFFF ) | 0xFF000000,
                         b = data_char[ i * 2 + 1 ] >> 24;

                    string str = " ";
                    str[ 0 ] = b;

                    // void GetTextInfo(string& text, int w, int h, int font, int flags, int& tw, int& th, int& lines)
                    // string& text – текст;
                    // int w, h, font, flags – высота, ширина, шрифт, флаги;
                    // int& tw, int& th, int& lines – итоговые ширина, высота и количество строк данного текста.
                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, a, font, flags );
                }
            }
        }

        /*if(__sinf&SINF_GLOBAL!=0)*/
        {
            float x = ( __MouseX - __GmapOffsetX ) * __GmapZoom,
                  y = ( __MouseY - __GmapOffsetY ) * __GmapZoom;

            x -= x % 10;
            y -= y % 10;

            string str = floor( x / 10 ) + " : " + floor( y / 10 );

            x = x / __GmapZoom + __GmapOffsetX;
            y = y / __GmapZoom + __GmapOffsetY;

            if( size >= 5 )
            {
                int[]  drawData = { x + 1, y + 1, COLOR_RED, x + size - 1, y + 1, COLOR_RED, x + size - 1, y + size - 1, COLOR_RED, x + 1, y + size - 1, COLOR_RED, x + 1, y + 1, COLOR_RED };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }

            int tw = 0, th = 0, lines = 0;
            /*GetTextInfo(str, 0, 0, font, flags, tw, th, lines);
               DrawText(str, x-(tw>>1), y-(tw>>1), size+tw, size+tw, 0xFFAA66EE, font, flags);*/

            GetTextInfo( str, 0, 0, font, FT_NOBREAK, tw, th, lines );
            DrawText( str, __MouseX + 30, __MouseY + 10, tw, th, COLOR_LGREEN, font, FT_NOBREAK );
        }
    }
	
	if( layer == 5 )
    {
		//TestDirect3d(0);
		//DrawText( "d3d draw: "+TestDirect3d(0), 30, 30, 100, 20, COLOR_LGREEN, FONT_FALLOUT, FT_NOBREAK );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    DrawMapTiles();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down( int click )
{ 
    return GUI_MouseDown( click, __MouseX, __MouseY );
}

bool mouse_up( int click )
{
    return GUI_MouseUp( click, __MouseX, __MouseY );
}

void mouse_move( int x, int y )
{
    // x == __MouseX
    // y == __MouseY
    GUI_MouseMove( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.
bool AltDown = false;
bool key_down( uint8 key )
{
    if( __waiting )
    {
        CritterCl@ ch = GetChosen();
        if( @ch != null )
        {
            if( key == DIK_ESCAPE || key == DIK_SPACE )
            {
                if( ch.Param[ ST_VAR5 ] > 0 )
                {
                    Message( "Antiflood." );
                }
                else
                    RunServerScriptUnsafe( "ltp@unsafe_StopProcess",  0, 0, 0, null, null );
            }
            return true;
        }
        else
            __waiting = false;
    }

    // Effect example, temporary
    if( key == DIK_LMENU || key == DIK_RMENU )
        AltDown = true;
    if( AltDown && key == DIK_Q )
        SetEffect( EFFECT_2D, -1, "2D_Default.fx" );
    if( AltDown && key == DIK_W )
        SetEffect( EFFECT_2D, -1, "2D_BlackWhite.fx" );
    /*if(AltDown && key==DIK_E) SetEffect(EFFECT_2D, EFFECT_2D_TILE,"2D_DesGen.fx");
       if(AltDown && key==DIK_R) SetEffect(EFFECT_2D, EFFECT_2D_TILE,"2D_Default.fx");*/

    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
        __ctrlDown = true;                                                // @pm menu

    if( key == DIK_Z )
        __MapZooming = true;
    
    if(key >= DIK_F1 && key <= DIK_F12){
	uint16 drugPid = DKPCheckDrugKey(key);
	if(drugPid != uint16(-1)){
			DKPUnsafeRun(drugPid);
		}
      }

    return GUI_KeyDown( key );
}

bool key_up( uint8 key )
{
    if( key == DIK_LMENU || key == DIK_RMENU )
        AltDown = false;
    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
        __ctrlDown = false;                                                // @pm menu

    if( __waiting )
        return true;

    if( key == DIK_Z )
        __MapZooming = false;

    return GUI_KeyUp( key );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost()
{
    AltDown = false;
    __MapZooming = false;

    GUI_InputLost();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in( CritterCl& cr )
{
    CritterCl@ ch = GetChosen();
    if( !(ch is null) && ( ch.Id == cr.Id ) && ( prevId != cr.Id ) )
    {
        @data_number = null;
        @data_color = null;
        @data_char = null;
        LoadNames();
        prevId = cr.Id;
    }

    updateNick( cr );

    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED );
    if( cr.Param[ QST_GAMEMODE ] == GAME_ARCADE )
        cr.ContourColor = COLOR_CONTOUR_RED;

    // Try colorize from file
    // if(TryColorizeCritter(cr)) return;

    // Karma voting
    // cr.NameColor=COLOR_LIGHT(COLOR_CRITTER_NAME,cr.Stat[ST_PLAYER_KARMA]/10);

    // Good / Evil system (not used)
    // Also see _GoodEvilListChanged in parameters.fos
    /*CritterCl@ chosen=GetChosen();
       if(cr.IsPlayer() && not cr.IsChosen() && valid(chosen))
       {
            int crId=int(cr.Id);
            for(uint i=GOOD_EVIL_LIST_BEGIN;i<=GOOD_EVIL_LIST_END;i++)
            {
                    int id=chosen.GoodEvilList[i];
                    bool isEvil=FLAG(id,0x80000000);
                    if(isEvil) id^=0x80000000;

                    if(id==crId)
                    {
                            cr.NameColor=(isEvil?COLOR_RED:COLOR_GREEN);
                            cr.ContourColor=(isEvil?COLOR_CONTOUR_RED:COLOR_CONTOUR_GREEN);
                            break;
                    }
            }
       }*/
    if( __fastPanel )
        HidePanel( true );
    // SaveFastPanel(false); //@pm menu
}

void critter_out( CritterCl& cr )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{}

void item_map_out( ItemCl& item )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{
    // indefine bullshit
    /*
       Message("in");
       CritterCl @ choo = GetChosen();
       if(choo is null) return;
       if(!item.IsCanUseByIndefine(choo))
       {
            item.SetInvPic(GetIndefineSpriteHash(item, choo));
       }
     */
}

void item_inv_out( ItemCl& item )
{
    // indefine bullshit
    /*
       Message("out");
       CritterCl @ choo = GetChosen();
       if(choo is null) return;
       if(!item.IsCanUseByIndefine(choo))
       {
            item.SetInvPic(GetIndefineSpriteHash(item, choo));
       }
     */
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop( ItemCl& item )
{
    // indefine bullshit
    /*
       Message("drag");
       CritterCl @ choo = GetChosen();
       if(choo is null) return;
       if(!item.IsCanUseByIndefine(choo))
       {
            item.SetInvPic(GetIndefineSpriteHash(item, choo));
       }
     */
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    // Detect radio
    if( color == 0xFFFFFFFE )
        message = ".." + message + "..";
		
	if( color == COLOR_GRAY )
        Message("|0xD3D3D3 " + message );
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{
	if( sayType == SAY_NORM )
    {
        if( findFirst( message, "*" ) != -1 )
        {
            uint countfirst = findFirst( message, "*" );
            if( findFirst( message, "*", countfirst ) != -1 )
            {
				while (findFirst( message, "**", 0 ) != -1)
				{
					message = ReplaceText(message, "**", "*");
				}
                string@[] strs;
                strs = split( message, "*" );
				for(uint i = 1; i < strs.length(); ++i )
				{
					strs[ i ] = "|0xFFBB33CC **" + strs[ i ] + "**|0xF8F993 ";
					++i;
				}
                message = join( strs, "" );
            }
        }
    }
	
	
    if( sayType >= SAY_RADIO )
        return true;                          // for work radio and service messages

    if( ( __sinf & SINF_CRID_CHAT ) != 0 && critterId != 0 && sayType <= SAY_WHISP_ON_HEAD )
    {
        message = "[" + critterId + "] " + message;
    }
    if( ( __sinf & SINF_INSIGHT ) != 0 )
        return true;

    // binyan - Language barrier
    CritterCl@ sender = GetCritter( critterId );
    if( sender is null )
        return false;

    if( sender.IsNpc() )
        return true;

    CritterCl@ receiver = GetChosen();
    if( !(receiver is null) && receiver.Param[ QST_MEDIUM ] == 0 && sender.Param[ QST_MEDIUM ] == 0 )
    {
        int bs = sender.Stat[ ST_BODY_TYPE ];
        int br = receiver.Stat[ ST_BODY_TYPE ];
        if( message.length() > 1 )
        {
            if( ( bs == br && bs != BT_PLANT ) ||
                ( ( ( bs >= BT_MEN && bs < BT_BRAHMIN ) || bs == BT_ROBOT || bs == BT_BIG_BAD_BOSS ) && ( ( br >= BT_MEN && br < BT_BRAHMIN ) || br == BT_ROBOT || br == BT_BIG_BAD_BOSS ) ) ||
                ( ( bs == BT_MANTI || bs == BT_RADSCORPION || bs == BT_GIANT_ANT || bs == BT_GIANT_BEETLE || bs == BT_GIANT_WASP ) && ( br == BT_MANTI || br == BT_RADSCORPION || br == BT_GIANT_ANT || br == BT_GIANT_BEETLE || br == BT_GIANT_WASP ) ) )
                return true;
        }

        if( bs == BT_ZOMBIE )
        {
            if( sender.IsDead() )
                return false;
            string@ msg = GenerateZombieSpeech( sayType );
            if( msg !is null && msg.length() > 0 )
                message = msg;
        }
        else
        {
            sayType = SAY_EMOTE;
            switch( bs )
            {
            case BT_MEN:
                message = "Говорит";
                break;
            case BT_WOMEN:
                message = "Говорит";
                break;
            case BT_CHILDREN:
                message = "Говорит";
                break;
            case BT_SUPER_MUTANT:
                message = "Говорит";
                break;
            case BT_GHOUL:
                message = "Говорит";
                break;
            case BT_BRAHMIN:
                message = "Мычит";
                break;
            case BT_RADSCORPION:
                message = "Щелкает клешнями";
                break;
            case BT_RAT:
                message = "Пищит";
                break;
            case BT_FLOATER:
                message = "Хрипение";
                break;
            case BT_CENTAUR:
                message = "Хрипение";
                break;
            case BT_ROBOT:
                message = "Попикивает";
                break;
            case BT_DOG:
                message = "Лает";
                break;
            case BT_MANTI:
                message = "Стрекочет";
                break;
            case BT_DEADCLAW:
                message = "Рычит";
                break;
            case BT_PLANT:
                message = "";
                break;
            case BT_GECKO:
                message = "Шипит";
                break;
            case BT_ALIEN:
                message = "Хрипит";
                break;
            case BT_GIANT_ANT:
                message = "Стрекочет";
                break;
            case BT_BIG_BAD_BOSS:
                message = "Говорит";
                break;
            case BT_GIANT_BEETLE:
                message = "Стрекочет";
                break;
            case BT_GIANT_WASP:
                message = "Жужит";
                break;
            case MAX_BODY_TYPES:
                message = "";
                break;
            }
        }
    }
    return true;
}

import void DrawHives( uint8 hiveCount ) from "client_screen_additional";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message( string& message, int& sayType )
{
    /*
	if( findFirst( message, "$arcade" ) == 0 )
        RunServerScriptUnsafe( "arcade_menu@unsafe_arcade", 0, 0, 0, null, null );
	*/
    // binyan - Hotkyes
	
    if( __MessagePrefix != "" )
    {
        message = __MessagePrefix + " " + message;
        __MessagePrefix = "";
    }

    if( __IsHotkeysUse )
        __IsTextInput = true;

    if( findFirst( message, "~hotkeys" ) == 0 )
    {
        string@[] @ msg = split( message, " " );
        if( msg.length() == 1 )
            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        else
        {
            if( msg[ 1 ] == "on" )
                SetHotkeysUse( true );
            else if( msg[ 1 ] == "off" )
                SetHotkeysUse( false );

            if( __IsHotkeysUse )
                __IsTextInput = true;
            ;

            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        }
        return false;
    }
    // /////////////////////////////////////////////


    if( message[ 0 ] == '%' ) // Command
	{
		string@[] @ valuesStr = splitEx( message, " " );
		int p0 = 0, p1 = 2, p2 = 6;
		if( valuesStr.length() == 2 ) 
		{
			if( !StrToInt( valuesStr[ 1 ], p0 ) )
			{
				string[] letters = { "S", "P", "E", "C", "I", "A", "L" };
				p0 = letters.find( valuesStr[ 1 ] ) + 1;
			}
		}
		if( valuesStr.length() == 3 ) 
		{
			StrToInt( valuesStr[ 1 ], p1 );
			StrToInt( valuesStr[ 2 ], p2 );
		}

		RunServerScriptUnsafe( "test@unsafe_rolling", p0, p1, p2, null, null );
		return false;
	}
	
	if( message[ 0 ] == '~' ) // Command
    {
		if( message == "~naked" )
		{
            RunServerScriptUnsafe( "map_start@unsafe_getNaked", 0, 0, 0, "", null );
            return false;
		}
		
         if( message == "~gmhot" )
        {
            __mobhotkeys = ( __mobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __mobhotkeys ? "On" : "Off" ) );
            return false;
        }

		string@[]@ parts = split( message, " " );

		if( parts[0] == "~desc" ) 
		{
			string text = "";
			int l = parts[0].length();
			if( parts.length() > 1 && message.length() > 5) text = substring( message, 5, message.length() - 5 );
			RunServerScriptUnsafe( "general_unsafe@unsafe_newPopup", 0, 0, 0, text, null ); 
			return false; 
		}
			
		if( parts[0] == "~lex" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 ) text = substring( message, 5, message.length() - 5 );
			RunServerScriptUnsafe( "general_unsafe@unsafe_selfLex", 0, 0, 0, text, null ); 
			return false; 
		}

		if( message == "~sf" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 1, 0, 0, "", null );
            return false;
        }

        if( message == "~sb" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 0, 0, 0, "", null );
            return false;
        }

        if( message == "~mobhot" )
        {
            __usermobhotkeys = ( __usermobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __usermobhotkeys ? "On" : "Off" ) );
            return false;
        }

/*		//Выпилил от греха подальше.
        if( message == "~teach" )
        {
            CritterCl @ choo = GetChosen();
            if( @choo == null || choo.Param[ QST_GAMEMODE ] == GAME_ARCADE )
            {
                Message( "Запрещено аркадным игрокам." );
                return false;
            }
            else if( choo.Param[ QST_GAMEMODE ] == GAME_SURVIVAL )
            {
                Message( "Запрещено для режима выживания." );
                return false;
            }
            else if( choo.Param[ QST_GAMEMODE ] == GAME_START )
            {
                Message( "Запрещено до выбора режима игры." );
                return false;
            }
            ShowScreen( CLIENT_SCREEN_TEACH, 0, 0, 0 );
            return false;
        }
*/
/*		
        if(message == "~gmmenu")
		{
			uint16    x = __MouseX, y = __MouseY;
			CritterCl @cr = GetMonitorCritter( x, y );
			ItemCl    @it = GetMonitorItem( x, y );
			if( @cr != null )
			{
				if( cr.IsPlayer() )
					RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_CRITTER_PLAYER", cr.Id, 0, 0, null, null );                     // панель действий с игроком
				else
					RunServerScriptUnsafe( "gm@GM_PANNEL_CRITTER_NPC", cr.Id, 0, 0, null, null );                        // панель действий с нпц
				return true;
			}
			else if( @it != null )
			{
				RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_ITEM", it.Id, 0, 0, null, null );                       // панель действий с итемом
				return true;
			}
			else
			{
				uint16 hexX = 0, hexY = 0;
				GetMonitorHex( x, y, hexX, hexY );
				RunServerScriptUnsafe( "gm@unsafe_GM_PANNEL_HEX", hexX, hexY, 0, null, null );                       // панель действий с гексом
				return true;
			}
		}
*/
        return true;
    }

    if( message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' ) // tnf commands
    {
	RunServerScriptUnsafe("general_unsafe@unsafe_log", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " - " + message, null);
        return gm_msg( message );
    }


    CritterCl@ chosen = GetChosen();
    if( chosen !is null and sayType< SAY_NETMSG and chosen.IsDead() and chosen.Anim2Dead > ANIM2_DEAD_BACK )
    {
        Message( "Мертвые не разговаривают." );
        return false;
    }

    if( sayType == SAY_NORM )
    {
        if( message.length() > 2 && ( message[ 0 ] == '/' || message[ 0 ] == '.' ) )
        {
            int  eraseCount = 1;
            int8 ch = message[ 1 ];
            if(     ch == 'к' || ch == 'К' || ch == 's' || ch == 'S' )
                sayType = SAY_SHOUT;
            else if( ch == 'э' || ch == 'Э' || ch == 'e' || ch == 'E' )
                sayType = SAY_EMOTE;
            else if( ch == 'ш' || ch == 'Ш' || ch == 'w' || ch == 'W' )
                sayType = SAY_WHISP;
            else if( ch == 'с' || ch == 'С' || ch == '$'           )
                sayType = SAY_SOCIAL;
            else if( ch == 'р' || ch == 'Р' || ch == 'r' || ch == 'R' )
                sayType = SAY_RADIO;

            if( sayType != SAY_NORM )
            {
                eraseCount++;
                if( message[ 2 ] == ' ' )
                    eraseCount++;
            }

            message = substring( message, eraseCount, message.length() - eraseCount );
        }
        else if(         // RegExp: [*]([^*].*[^*])[*]
            message.length() >= 4 && message[ 0 ] == '*' && message[ 1 ] != '*' &&
            message[ message.length() - 2 ] != '*' && message[ message.length() - 1 ] == '*' )
        {
            sayType = SAY_EMOTE;
            message = substring( message, 1, message.length() - 2 );
        }
    }

    if( sayType >= SAY_NORM && sayType <= SAY_RADIO )
    {
        for( uint i = 0, len = message.length(); i < len; i++ )
        {
            uint8 chr = message[ i ];
            if( chr < 32 || ( chr > 34 && chr < 42 ) || ( chr > 42 && chr < 44 ) || chr == 47 || ( chr > 57 && chr < 63 ) || chr == 64 || ( chr > 90 && chr < 97 ) || ( chr > 122 && chr < 192 && chr != 168 && chr != 184 ) )
            {
                Message( "В сообщениии есть запрещенные символы." );
                return false;
            }
        }
    }
	
	if( sayType == SAY_NORM ){ RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " - " + message, null); }
	if( sayType == SAY_EMOTE ){ RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " **" + message + "**", null); }
	if( sayType == SAY_WHISP )
	{ 
		RunServerScriptUnsafe("test@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null); 
		RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " ..." + message + "...", null); 
	}
	if( sayType == SAY_RADIO )
	{ 
		RunServerScriptUnsafe("test@unsafe_GM_Hear_Radio", 0, 0, 0, message, null); 
		RunServerScriptUnsafe( "test@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );
		RunServerScriptUnsafe( "general_unsafe@unsafe_radioHead", 0, 0, 0, null, null );
		RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " ..." + message + "...", null); 
	}
	if( sayType == SAY_SOCIAL ){ RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " ..." + message + "...", null); }
	if( sayType == SAY_SHOUT ){ RunServerScriptUnsafe("general_unsafe@unsafe_log_1", 0, 0, 0, GetChosen().Name + " " + GetChosen().Id + " !!!" + message + "!!!", null); }
	
/*	if(sayType==SAY_RADIO)
        {
                bool result=false;
                if (CallSignHook1(message, sayType, result)) return result;  //radio sign
                CritterCl@ chosen=GetChosen();
                if(not valid(chosen)) return false;
                ItemCl@ hand1=_CritGetItemHand(chosen);
                ItemCl@ hand2=_CritGetItemHandExt(chosen);
                if((not valid(hand1) || hand1.GetProtoId()!=PID_RADIO) && (not valid(hand2) || hand2.GetProtoId()!=PID_RADIO))
                {
                        Message(TEXTMSG_GAME,STR_RADIO_NOITEM);
                        return false;
                }

                if (CallSignHook2(message, sayType, result)) return result; //radio sign
        }
 */
    bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != ' ' )
        {
            result = true;
            break;
        }
    }

    return result;
}

// binyan - Hex attack
int to_hit_hex()
{
    // Used only on empty hex and throwing weapon and rocket launchers
    CritterCl@ chosen = GetChosen();
    if( !chosen.IsLife() )
        return 0;
    CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
    if( valid( target ) )
        return 0;

    uint8      mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( weapon is null )
        return 0;
    uint    skillNum = _WeaponSkill( weapon, mode );
    int     dmgType = _WeaponDmgType( weapon, mode );

    ItemCl@ realWeapon = _CritGetItemHand( chosen );

    bool    isFlareGun = ( realWeapon.AmmoPid == PID_FLARE_GUN_AMMO ) && ( _WeaponModeUse( mode ) == 1 ); // pm added flare gun check

    bool    isRocket = false;
    if( valid( realWeapon ) )
        isRocket = ( realWeapon.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( realWeapon.AmmoPid == PID_ROCKET_AP ) || ( realWeapon.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( realWeapon.AmmoPid == PID_GRENADELAUNCHER_AMMO );

    if( !isFlareGun && !isRocket && skillNum != SK_THROWING && !( dmgType == DAMAGE_PLASMA || dmgType == DAMAGE_EMP || dmgType == DAMAGE_EXPLODE ) )
        return 0;

    if( valid( realWeapon ) && skillNum != SK_THROWING )
        if( realWeapon.AmmoCount == 0 )
            return 0;

    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );
    if( tx == 0 && ty == 0 )
        return 0;

    int    dist = GetDistantion( chosen.HexX, chosen.HexY, tx, ty );

    uint16 toHx = tx, toHy = ty;
    GetHexCoord( chosen.HexX,  chosen.HexY, toHx, toHy,  0.0f, dist );
    if( ( tx != toHx ) || ( ty != toHy ) )
        return 0;



    int wpnMaxDist = _WeaponMaxDist( weapon, mode );
    if( skillNum == SK_THROWING )
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );


    if( dist > wpnMaxDist )
        return 0;

    int toHit = int(chosen.Skill[ skillNum ]);
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;


    int distmod1 = 2; // used for initial weapon bonus
    int distmod2 = 0; // minimal distance
    if( weaponPerk == WEAPON_PERK_LONG_RANGE )
        distmod1 = 4;
    else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = chosen.Stat[ ST_PERCEPTION ];
    int acc = dist;

    if( dist < distmod2 )
        acc += distmod2;
    else
    {
        if( chosen.IsPlayer() )
            acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
        else
            acc -= perception * distmod1;
    }

    if( -2 * perception > acc )
        acc = -2 * perception;

    acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

    if( acc >= 0 )
    {
        if( chosen.Damage[ DAMAGE_EYE ] != 0 )
            acc *= -12;
        else
            acc *= -4;
    }
    else
        acc *= -4;

    toHit += acc;
    blockers = GetCrittersPath( chosen.HexX, chosen.HexY, tx, ty, 0.0f, dist, FIND_LIFE, null ); // + map
    toHit -= 10 * blockers;


    if( chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;


    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;

}
// //////////////////////////////////////////////////////////////////////////////////////////////////

int getFullSkill( CritterCl& cr, CritterCl@ target, int skillNum, uint8 weaponSubtype )
{
    int   skillVal = cr.Skill[ skillNum ];

    if( cr.IsPlayer() )
    {
        if( weaponSubtype == WS_GUN )
        {
            // Log("Тип оружия - стрелковое. Используется " + skillNum + " скилл (200 - лёгкое, 201 - тяжелое, 202 - энерго)");
            // Log("Скилл стреляющего " + skillVal + ", а номер скилла - " + skillNum);
            if( skillNum == SK_SMALL_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - лёгкое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 2;
                // Log("Добавляем энергооружие, поделенное на 2, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }

            if( skillNum == SK_BIG_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - тяжелое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 3;
                // Log("Добавляем скилл лёгкого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 3;
                // Log("Добавляем энергооружие, поделенное на 3, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }

            if( skillNum == SK_ENERGY_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                // Log("Скилл для текущего оружия - энергетическое оружие, навык криттера - " + cr.Skill[skillNum]);
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 2;
                // Log("Добавляем скилл лёгкого оружия, поделенный на 2, к вычислению, теперь скилл " + skillVal);
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                // Log("Добавляем скилл тяжелого оружия, поделенный на 3, к вычислению, теперь скилл " + skillVal);
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;                                          /* Log("Устанавливаем кап на " + SECONDARY_SKILLS_BONUS_CAP +", чтобы не получалось слишком круто. Значение после установки - " + skillVal); */
                }
                // Log("Итоговый скилл для рассчётов " + skillVal);
            }
        }
        else
        {
            // Log("Тип оружия - нестрелковое. Используется " + skillNum + " скилл (203 - рукопашка, 204 - холодное, 205 - метательное)");
            if( skillNum == SK_UNARMED && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }

            if( skillNum == SK_MELEE_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 2;
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }

            if( skillNum == SK_THROWING && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
            }
        }
    }
    // Roleplay

	if( cr.IsPlayer() && valid( target ) && target.IsPlayer() )
	{
		/*
		Если [маньяк, обычный, мирный] хочешь БЕЗ ШТРАФА
		 атаковать:  маньяка, обычного, мирного
		1) маньяк:   всегда,   всегда, цель в бою
		2) обычный:  всегда,    в бою, цель в бою
		3) мирный:    в бою,    в бою, ты и цель в бою
		*/
		//Если вне боя, и ты мирный, и вы оба НЕ маньяки..
		if( ( cr.Timeout[ TO_BATTLE ] == 0 && ( cr.Trait[ TRAIT_GOOD_NATURED ] != 0 || ( cr.Trait[ TRAIT_BLOODY_MESS ] == 0  && target.Trait[ TRAIT_BLOODY_MESS ] == 0 ) ) ) 
			|| ( target.Trait[ TRAIT_GOOD_NATURED ] != 0 && target.Timeout[ TO_BATTLE ] == 0 ) ) { //Либо цель - мирный НЕ в бою.
			skillVal /= 2; //Навык делим пополам.
		}
	}
	
	return skillVal;
}
// To-hit chance.
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int use = _WeaponModeUse( weaponMode );
    int hitLocation = _WeaponModeAim( weaponMode );
    if( use > 2 )
        return 0;

    if( target.IsDead() )
        return 0;
    if( !chosen.IsLife() )
        return 0;

    ItemCl@    realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
    {
        if( realWeapon.AmmoCount == 0 )
            return 0;
        @ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    uint skillNum = _WeaponSkill( weapon, use );
	
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
    int  skillVal = getFullSkill( chosen, target, skillNum, weaponSubtype );
    int  wpnMaxDist = _WeaponMaxDist( weapon, use );

    // Roleplay
    int dist = GetCrittersDistantion( chosen, target );
    if( dist > wpnMaxDist )
        return 0;

    int toHit = skillVal;
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        // cr.Say(SAY_NETMSG, "Applying range modifiers.");
        // ranged attack modifiers
        int distmod1 = 2; // used for initial weapon bonus
        int distmod2 = 0; // minimal distance
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
            distmod1 = 4;
        else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
            acc += distmod2;
        else
        {
            if( chosen.IsPlayer() )
                acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            else
                acc -= perception * distmod1;
        }

        if( -2 * perception > acc )
            acc = -2 * perception;

        acc -= 2 * chosen.Perk[ PE_SHARPSHOOTER ];

        if( acc >= 0 )
        {
            if( chosen.Damage[ DAMAGE_EYE ] != 0 )
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;

        // Map@ map = chosen.GetMap();
        blockers = GetCrittersPath( chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null ); // + map
        if( !target.IsKnockout() )
            blockers--;
        toHit -= 10 * blockers;
    } // end range modifiers

    if( !( weapon.Weapon_IsUnarmed ) && chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;
    if( chosen.Perk[ PE_WEAPON_HANDLING ] != 0 )
        handlingStrength += 3;
    if( handlingStrength < reqStrength )
        toHit -= ( reqStrength - handlingStrength ) * 20;
    if( weaponPerk == WEAPON_PERK_ACCURATE )
        toHit += 20;

    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
        acmod += ammo.Ammo_ACMod;
    if( acmod > 0 )
        toHit -= acmod;
    // TODO: tohit+=15 if target is multihex
    // TODO: light penalty

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
        toHit -= 25;
    if( target.IsKnockout() )
        toHit += 40;
    toHit += target.GetMultihex() * 15;

    int hitMod = GetHitAim( hitLocation );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
        hitMod /= 2;
    toHit -= hitMod;
	
	if( valid(target) && target.IsBusy() )
	{
		if( ( chosen.Dir + 3 ) % 6 == target.Dir )
			toHit += 20;
		else if( ( chosen.Dir ) % 6 != target.Dir )
		{
			toHit -= acmod / 2;
			if( hitLocation == HIT_LOCATION_HEAD )
				toHit -= acmod / 2;
		}
	}
	// advanced aiming
	if( hitLocation == HIT_LOCATION_HEAD )
		toHit *= 0.5;
	else if( hitLocation == HIT_LOCATION_LEFT_ARM || hitLocation == HIT_LOCATION_RIGHT_ARM || hitLocation == HIT_LOCATION_RIGHT_LEG || hitLocation == HIT_LOCATION_LEFT_LEG )
		toHit *= 0.7;

    toHit = CLAMP( toHit, 5, 95 );

    return toHit;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void combat_result( uint[]& data )
{
    uint datalen = data.length();
    if( datalen == 0 )
        return;
    if( data[ 0 ] != datalen )
        return;

    uint current = 1;

    while( current < datalen )
    {
        int        damage = -1;
        uint       effect = 0;
        uint       loc = 0;
        int        message = -1;

        uint       mode = data[ current++ ];
        uint       who = data[ current++ ];
        uint       who2;
        CritterCl@ originalTarget;

        CritterCl@ cr = GetCritter( who );
        CritterCl@ chosen = GetChosen();
        CritterCl@ trueTarget = null;

        bool       self = ( who == GetChosen().Id );

        string     name = "error0";
        if( valid( cr ) )
        {
            if( !self )
                name = cr.Name;
            else
                name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
        }

        uint offset;
        if( self )
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 506;
            else
                offset = 556;
        }
        else
        {
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
                offset = 606;
            else
                offset = 706;
        }

        string result;

        // reading and preparing the data:
        switch( mode )
        {
        case CMSG_CRIT_MISS:
            effect = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_CRIT_MISS_DAMAGE:
            effect = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_HIT:
        case CMSG_HIT_DEAD:
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_AIMED_HIT:
        case CMSG_AIMED_HIT_DEAD:
            loc = data[ current++ ];
            damage = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT:
            damage = data[ current++ ];
            effect = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT:
            loc = data[ current++ ];
            damage = data[ current++ ];
            effect = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_HIT_DEAD:
            damage = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
            result = ReplaceText( result, "%s", name );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_CRIT_AIMED_HIT_DEAD:
            loc = data[ current++ ];
            damage = data[ current++ ];
            message = data[ current++ ];
            result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
            result = ReplaceText( result, "%s", name );
            result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
            if( damage > 1 )
                result = ReplaceText( result, "%d", damage );
            break;
        case CMSG_OOPS:
            who2 = data[ current++ ]; // who2 was hit instead of who
            // +2 "... was hit instead of you!"
            // +3 "... was hit instead of ...!"
            @trueTarget = GetCritter( who2 );
            if( self )
            {
                // It was original target
                result = GetMsgStr( TEXTMSG_COMBAT, cr.Stat[ ST_GENDER ] == GENDER_MALE ? 608 : 708 );
                string nameTrue = "error1";
                if( valid( trueTarget ) )
                    nameTrue = trueTarget.Name;
                result = ReplaceText( result, "%s", nameTrue );
            }
            else
            {
                // It was not original target
                result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
                if( who2 == GetChosen().Id )
                {
                    result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
                }
                else
                {
                    string nameTrue = "error1";
                    if( valid( trueTarget ) )
                        nameTrue = trueTarget.Name;
                    result = ReplaceText( result, "%s", nameTrue );
                }
                result = ReplaceText( result, "%s", name );
            }
            break;
        case CMSG_MISS:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            break;
        case CMSG_HIT_RANDOMLY:
            result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
            result = ReplaceText( result, "%s", name );
            result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
        default:
            break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;

        if( message != -1 && isVerbose )       // Must be critical hit
        {
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
        else if( effect != 0 )
        {
            offset -= 306;
            if( mode > CMSG_CRIT_MISS_DAMAGE )           // Hit flags
            {
                if( FLAG( effect, HF_KNOCKOUT ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 0 ) );
                if( FLAG( effect, HF_KNOCKDOWN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 1 ) );
                if( FLAG( effect, HF_CRIPPLED_LEFT_LEG ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 2 ) );
                if( FLAG( effect, HF_CRIPPLED_RIGHT_LEG ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 3 ) );
                if( FLAG( effect, HF_CRIPPLED_LEFT_ARM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 4 ) );
                if( FLAG( effect, HF_CRIPPLED_RIGHT_ARM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 5 ) );
                if( FLAG( effect, HF_BLINDED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 6 ) );
                // if(FLAG(effect, HF_DEATH))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset     )); // This is handled elsewhere
                // if(FLAG(effect, HF_ON_FIRE))            ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
                if( FLAG( effect, HF_BYPASS_ARMOR ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 11 ) );
                if( FLAG( effect, HF_DROPPED_WEAPON ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 14 ) );
                if( FLAG( effect, HF_LOST_NEXT_TURN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 15 ) );
                if( FLAG( effect, HF_RANDOM ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 21 ) );
            }
            else
            {
                if( FLAG( effect, MF_KNOCKED_DOWN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 1 ) );
                // if(FLAG(effect, MF_ON_FIRE))              ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 10)); // Not used
                if( FLAG( effect, MF_WEAPON_EXPLODED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 12 ) );
                if( FLAG( effect, MF_WEAPON_DESTROYED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 13 ) );
                if( FLAG( effect, MF_WEAPON_DROPPED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 14 ) );
                if( FLAG( effect, MF_LOST_NEXT_TURN ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 15 ) );
                if( FLAG( effect, MF_HIT_SELF ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 16 ) );
                if( FLAG( effect, MF_LOST_REST_OF_AMMO ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 17 ) );
                if( FLAG( effect, MF_FIRED_DUD_SHOT ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 18 ) );
                if( FLAG( effect, MF_HURT_SELF ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 19 ) );
                // if(FLAG(effect, MF_HIT_RANDOMLY))         ext.insertLast(@GetMsgStr(TEXTMSG_COMBAT, offset + 20)); // This is handled elsewhere
                if( FLAG( effect, MF_CRIPPLED_RANDOM_LIMB ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 21 ) );
                if( FLAG( effect, MF_WAS_KILLED ) )
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 7 ) );
            }
            offset += 306;
        }

        if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + 7 - 306 ) );

        for( uint m = 0, n = ext.length(); m < n; m++ )
        {
            if( m == n - 1 )
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            else
                result += ", ";

            result += ext[ m ];
        }

        result += ".";

        Message( result, FOMB_COMBAT_RESULT );

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + 7 - 306 ) + ".", FOMB_COMBAT_RESULT );

        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) )
        return "";
    string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += chosen.Name + "\n";
        result += "---------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) ) + "\n";
        result += "---------------------\n";

        ItemCl@ weaponMain = chosen.GetItem( 0, SLOT_HAND1 );
        if( valid( weaponMain ) )
        {
            int use = _WeaponModeUse( weaponMain.Mode );
            if( use > 2 )
                use = 0;

            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( weaponMain ) ) + "\n";

            if( weaponMain.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
                result += _WeaponDmgMin( weaponMain.Proto, use ) + "-";
                int wpnMaxDmg = _WeaponDmgMax( weaponMain.Proto, use );
                if( _WeaponIsHtHAttack( weaponMain.Proto, use ) )
                    wpnMaxDmg += chosen.Stat[ ST_MELEE_DAMAGE ];
                result += wpnMaxDmg;

                if( _WeaponMaxDist( weaponMain.Proto, use ) > 1 )
                {
                    result += " " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
                    int wpnMaxDist = _WeaponMaxDist( weaponMain.Proto, use );
                    if( _WeaponSkill( weaponMain.Proto, use ) == SK_THROWING )
                        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
                    result += wpnMaxDist;
                }
                result += "\n";

                if( weaponMain.Proto.Weapon_MaxAmmoCount > 0 )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
                    result += weaponMain.AmmoCount            + "/";
                    result += weaponMain.Proto.Weapon_MaxAmmoCount  + " ";
                    result += GetMsgStr( TEXTMSG_GAME, STR_CALIBER( weaponMain.Proto.Weapon_Caliber ) );
                }
                result += "\n";
            }
            else
            {
                result += "\n\n";
            }
        }
        else
        {
            // Unarmed
            uint8      mode = 0;
            ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND1, mode );
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + "\n";
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
            result += _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + "-";
            result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + chosen.Stat[ ST_MELEE_DAMAGE ] );
            result += "\n\n";
        }
        result += "---------------------\n";

        ItemCl@ weaponExt = chosen.GetItem( 0, SLOT_HAND2 );
        if( valid( weaponExt ) )
        {
            int use = _WeaponModeUse( weaponExt.Mode );
            if( use > 2 )
                use = 0;

            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( weaponExt ) ) + "\n";

            if( weaponExt.GetType() == ITEM_TYPE_WEAPON )
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
                result += _WeaponDmgMin( weaponExt.Proto, use ) + "-";
                int wpnMaxDmg = _WeaponDmgMax( weaponExt.Proto, use );
                if( _WeaponIsHtHAttack( weaponExt.Proto, use ) )
                    wpnMaxDmg += chosen.Stat[ ST_MELEE_DAMAGE ];
                result += wpnMaxDmg;
                if( _WeaponMaxDist( weaponExt.Proto, use ) > 1 )
                {
                    result += " " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
                    int wpnMaxDist = _WeaponMaxDist( weaponExt.Proto, use );
                    if( _WeaponSkill( weaponExt.Proto, use ) == SK_THROWING )
                        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] + 2 * chosen.Perk[ PE_HEAVE_HO ] ) );
                    result += wpnMaxDist;
                }
                result += "\n";

                if( weaponExt.Proto.Weapon_MaxAmmoCount > 0 )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
                    result += weaponExt.AmmoCount             + "/";
                    result += weaponExt.Proto.Weapon_MaxAmmoCount   + " ";
                    result += GetMsgStr( TEXTMSG_GAME, STR_CALIBER( weaponExt.Proto.Weapon_Caliber ) );
                }
                result += "\n";
            }
            else
            {
                result += "\n\n";
            }
        }
        else
        {
            // Unarmed
            uint8      mode = 0;
            ProtoItem@ unarmed = chosen.GetSlotProto( SLOT_HAND2, mode );
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + "\n";
            result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + " ";
            result += _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + "-";
            result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + chosen.Stat[ ST_MELEE_DAMAGE ] );
            result += "\n\n";
        }

        result += GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + " ";
        result += ( chosen.ItemsWeight() / 1000 ) + "/";
        result += ( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000 ) + ".";
    }
    else if( descType == DESC_INVENTORY_SPECIAL )
    {
        offsX = 23;
        result += "\n\n";
        result += chosen.Stat[ ST_STRENGTH ] + "\n";
        result += chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += chosen.Stat[ ST_ENDURANCE ] + "\n";
        result += chosen.Stat[ ST_CHARISMA ] + "\n";
        result += chosen.Stat[ ST_INTELLECT ] + "\n";
        result += chosen.Stat[ ST_AGILITY ] + "\n";
        result += chosen.Stat[ ST_LUCK ];
    }
    else if( descType == DESC_INVENTORY_STATS )
    {
        offsX = 39;
        result += "\n\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += chosen.Stat[ ST_CURRENT_HP ] + "/" + chosen.Stat[ ST_MAX_LIFE ] + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_AC ) + " ";
        result += chosen.Stat[ ST_ARMOR_CLASS ] + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_LASER ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE );
    }
    else if( descType == DESC_INVENTORY_RESIST )
    {
        offsX = 103;
        result += "\n\n\n\n";
        result += chosen.Stat[ ST_NORMAL_ABSORB ] + "/" + chosen.Stat[ ST_NORMAL_RESIST ] + "%\n";
        result += chosen.Stat[ ST_LASER_ABSORB ] + "/" + chosen.Stat[ ST_LASER_RESIST ] + "%\n";
        result += chosen.Stat[ ST_FIRE_ABSORB ] + "/" + chosen.Stat[ ST_FIRE_RESIST ] + "%\n";
        result += chosen.Stat[ ST_PLASMA_ABSORB ] + "/" + chosen.Stat[ ST_PLASMA_RESIST ] + "%\n";
        result += chosen.Stat[ ST_EXPLODE_ABSORB ] + "/" + chosen.Stat[ ST_EXPLODE_RESIST ] + "%";
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
    // Default error text
    if( not IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );

    string result;

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
        result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
        if( item.Lexems != "" )
        {
            string lex = "" + item.Lexems;
            for( uint i = 0, len = lex.length(); i < len; i++ )
            {
                uint8 chr = lex[ i ];
                if( chr == 36 )
                {
                    lex = "";
                    break;
                }
            }
            if( lex != "" )
                result += " " + lex;
        }
        if( ( ( __sinf & SINF_ITEMID ) != 0 ) && item.GetType() > 1 && item.GetType() < 13 )
        {
            result += " |0xffff0000 id: " + item.Id + " pid: " + item.GetProtoId();
        }
    }
    // Full info
    else
    {
        if( lookType == ITEM_LOOK_INVENTORY )
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + ".\n";

        if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
            result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
        else
            result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + 1 );

        if( item.Lexems != "" )
        {
            string lex = "" + item.Lexems;
            for( uint i = 0, len = lex.length(); i < len; i++ )
            {
                uint8 chr = lex[ i ];
                if( chr == 36 )
                {
                    lex = "";
                    break;
                }
            }
            if( lex != "" )
                result += " " + lex + "\n";
        }

        if( lookType != ITEM_LOOK_MAP )
        {
            uint16 pid = item.GetProtoId();

			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );

            // Ammo load
            if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
            {
                result += "\n";
                string str = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
                str = ReplaceText( str, "VALUE",     item.AmmoCount );
                str = ReplaceText( str, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
                str = ReplaceText( str, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
                result += str;
            }

            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8  brokenFlags    = item.BrokenFlags;
                uint8  brokenCount = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                else
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );

                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );

                // Broken count
                CritterCl@ chosen = GetChosen();
                if( valid( chosen ) && chosen.Perk[ PE_MR_FIXIT ] != 0 )
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
            }

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );
            // indefine bullshit
            /*
               }else
               {
                    result = "\nМусор.";
               }
             */
        }
    }

    // Format tags
    if( item.Lexems != "" )
        return FormatTags( result, item.Lexems );
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result;
    int    gender = cr.Stat[ ST_GENDER ];
    int    crType = cr.CrType;

    // Player
    if( cr.IsPlayer() )
    {
        // Only name
        if( lookType == CRITTER_ONLY_NAME )
        {
            // result="|0xff77ff22 "+cr.Name+" |0xffff0000 (Id:"+cr.Id+")\n|0xffAA55BB HexX: "+cr.HexX+"\n|0xff11ffff HexY: "+cr.HexY;		//cr.Name; // No change
            result = cr.Name;           // No change
        }
        // Short info
        else if( lookType == CRITTER_LOOK_SHORT )
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK1( gender ) );
            if( cr.Param[ QST_GAMEMODE ] != GAME_ARCADE || ( ( __sinf & SINF_LOGIN ) != 0 ) )
            {
                if( cr.Name != "" )
                    result += cr.Name + ".";
                else
                    result += "???";
            }
            else
            {
				result += GetMsgStr( TEXTMSG_GAME, 10950 ); //монстра, т.е. персонажа-аркаду
				/*
                if( crType == 20 || crType == 21 || crType == 114 )
                    result += GetMsgStr( TEXTMSG_GAME, 10950 );
                else if( crType == 28 || crType == 29 || crType == 79 )
                    result += GetMsgStr( TEXTMSG_GAME, 10953 );
                else if( crType == 22 || crType == 59 )
                    result += GetMsgStr( TEXTMSG_GAME, 10952 );
                else if( crType == 25 )
                    result += GetMsgStr( TEXTMSG_GAME, 10951 );
                else if( crType == 15 )
                    result += GetMsgStr( TEXTMSG_GAME, 10954 );
                else if( crType == 19 )
                    result += GetMsgStr( TEXTMSG_GAME, 10955 );
                else if( crType == 23 )
                    result += GetMsgStr( TEXTMSG_GAME, 10956 );
                else if( crType == 70 || crType == 75 )
                    result += GetMsgStr( TEXTMSG_GAME, 10957 );
                else if( crType == 16 )
                    result += GetMsgStr( TEXTMSG_GAME, 10958 );
                else if( crType == 52 )
                    result += GetMsgStr( TEXTMSG_GAME, 10959 );
                else if( crType == 51 || crType == 60 || crType == 100 )
                    result += GetMsgStr( TEXTMSG_GAME, 10960 );
                else if( crType == 65 )
                    result += GetMsgStr( TEXTMSG_GAME, 10961 );
                else if( crType == 67 )
                    result += GetMsgStr( TEXTMSG_GAME, 10962 );
                else if( crType == 80 )
                    result += GetMsgStr( TEXTMSG_GAME, 10963 );
                else if( crType == 97 )
                    result += GetMsgStr( TEXTMSG_GAME, 10964 );
                else if( crType == 17 )
                    result += GetMsgStr( TEXTMSG_GAME, 10965 );
                else if( crType == 53 )
                    result += GetMsgStr( TEXTMSG_GAME, 10966 );
                else if( crType == 54 )
                    result += GetMsgStr( TEXTMSG_GAME, 10967 );
                else if( crType == 66 )
                    result += GetMsgStr( TEXTMSG_GAME, 10968 );
                else if( crType == 101 )
                    result += GetMsgStr( TEXTMSG_GAME, 10969 );
                else if( crType == 24 )
                    result += GetMsgStr( TEXTMSG_GAME, 10970 );
                else if( crType == 55 )
                    result += GetMsgStr( TEXTMSG_GAME, 10971 );
                else if( crType == 76 )
                    result += GetMsgStr( TEXTMSG_GAME, 10972 );
                else if( crType == 68 )
                    result += GetMsgStr( TEXTMSG_GAME, 10973 );
                else if( crType == 81 )
                    result += GetMsgStr( TEXTMSG_GAME, 10974 );
                else if( crType == 86 )
                    result += GetMsgStr( TEXTMSG_GAME, 10975 );
				*/
                result += ".";
            }
        }
        // Full info
        else
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK1( gender ) );
            if( crType == 127 )
				result += "дикого болотника";
			else if( crType == 20 || crType == 21 || crType == 114 )
                result += GetMsgStr( TEXTMSG_GAME, 10950 );
            else if( crType == 28 || crType == 29 || crType == 79 )
                result += GetMsgStr( TEXTMSG_GAME, 10953 );
            else if( crType == 22 || crType == 59 )
                result += GetMsgStr( TEXTMSG_GAME, 10952 );
            else if( crType == 25 )
                result += GetMsgStr( TEXTMSG_GAME, 10951 );
            else if( crType == 15 )
                result += GetMsgStr( TEXTMSG_GAME, 10954 );
            else if( crType == 19 )
                result += GetMsgStr( TEXTMSG_GAME, 10955 );
            else if( crType == 23 )
                result += GetMsgStr( TEXTMSG_GAME, 10956 );
            else if( crType == 70 || crType == 75 )
                result += GetMsgStr( TEXTMSG_GAME, 10957 );
            else if( crType == 16 )
                result += GetMsgStr( TEXTMSG_GAME, 10958 );
            else if( crType == 52 )
                result += GetMsgStr( TEXTMSG_GAME, 10959 );
            else if( crType == 51 || crType == 60 || crType == 100 )
                result += GetMsgStr( TEXTMSG_GAME, 10960 );
            else if( crType == 65 )
                result += GetMsgStr( TEXTMSG_GAME, 10961 );
            else if( crType == 67 )
                result += GetMsgStr( TEXTMSG_GAME, 10962 );
            else if( crType == 80 )
                result += GetMsgStr( TEXTMSG_GAME, 10963 );
            else if( crType == 97 )
                result += GetMsgStr( TEXTMSG_GAME, 10964 );
            else if( crType == 17 )
                result += GetMsgStr( TEXTMSG_GAME, 10965 );
            else if( crType == 53 )
                result += GetMsgStr( TEXTMSG_GAME, 10966 );
            else if( crType == 54 )
                result += GetMsgStr( TEXTMSG_GAME, 10967 );
            else if( crType == 66 )
                result += GetMsgStr( TEXTMSG_GAME, 10968 );
            else if( crType == 101 )
                result += GetMsgStr( TEXTMSG_GAME, 10969 );
            else if( crType == 24 )
                result += GetMsgStr( TEXTMSG_GAME, 10970 );
            else if( crType == 55 )
                result += GetMsgStr( TEXTMSG_GAME, 10971 );
            else if( crType == 76 )
                result += GetMsgStr( TEXTMSG_GAME, 10972 );
            else if( crType == 68 )
                result += GetMsgStr( TEXTMSG_GAME, 10973 );
            else if( crType == 81 )
                result += GetMsgStr( TEXTMSG_GAME, 10974 );
            else if( crType == 86 )
                result += GetMsgStr( TEXTMSG_GAME, 10975 );
            else
            {
                uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( gender, cr.Stat[ ST_AGE ] ) );
                if( ageStr != 0 )
                    result += GetMsgStr( TEXTMSG_GAME, ageStr );
                else if( cr.Name == "" )
                    result += "???";
                else
                {
                    result += cr.Name;
                    result += ".";
                }
            }


/*			// Condition
                        if(IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_COND(gender,cr.Cond,cr.CondExt)))
                        {
                                result+=", ";
                                result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_COND(gender,cr.Cond,cr.CondExt));
                        }

                        // Special
                        uint[] special;
                        for(uint i = 0; i < 7 ; i++)
                        {
                                if(not IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_SPEC(gender,i,cr.Stat[ST_STRENGTH+i]))) continue;
                                special.insertLast(i);
                        }

                        if(special.length()>0)
                        {
                                result+=". ";
                                result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK2(gender));

                                for(uint i=0,j=special.length();i<j;i++)
                                {
                                        uint sp=special[i];
                                        result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_SPEC(gender,sp,cr.Stat[ST_STRENGTH+sp]));

                                        if(i==j-1) break;
                                        else if(i==j-2) result+=GetMsgStr(TEXTMSG_GAME,STR_AND);
                                        else result+=", ";
                                }
                        }

                        // Damage
                        uint[] damage;
                        for(uint i=0;i<7;i++)
                        {
                                if(cr.GetPerk(PE_DAMAGE_POISONED+i)!=0 && IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_DMG(gender,i)))
                                        damage.insertLast(i);
                        }

                        if(damage.length()>0)
                        {
                                result+=". ";
                                result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK3(gender));

                                for(uint i=0,j=damage.length();i<j;i++)
                                {
                                        uint dmg=damage[i];
                                        result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_DMG(gender,dmg));

                                        if(i==j-1) break;
                                        else if(i==j-2) result+=GetMsgStr(TEXTMSG_GAME,STR_AND);
                                        else result+=", ";
                                }
                                result+=".";
                        }

                        // Perks
                        for(uint i = 0; i <= PE_SEPARATED_KARMA; i++)
                        {
                                if(cr.GetPerk(i)!=0 && IsMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_PERK(gender,i)))
                                {
                                        result+=" ";
                                        result+=GetMsgStr(TEXTMSG_GAME,STR_CRIT_LOOK_PERK(gender,i));
                                }
                        }
                        if(result.length()>0 && result[result.length()-1]!='.') result+=".";*/
        }
    }
    // Npc
    else
    {
        uint   dlgId = cr.Stat[ ST_DIALOG_ID ];
        uint16 npcPid = cr.Pid;
        bool   defaultText = false;

        if( lookType == CRITTER_ONLY_NAME )
        {
            result = GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) );
        }
        // Short info
        else if( lookType == CRITTER_LOOK_SHORT )
        {
            if( cr.IsLife() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_LIFE( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_LIFE( dlgId, npcPid ) );
            else if( cr.IsKnockout() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_KO( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_KO( dlgId, npcPid ) );
            else if( cr.IsDead() && IsMsgStr( TEXTMSG_DLG, STR_NPC_INFO_DEAD( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_INFO_DEAD( dlgId, npcPid ) );
            else
                defaultText = true;
        }
        // Full info
        else
        {
            if( cr.IsLife() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_LIFE( dlgId, npcPid ) );
            else if( cr.IsKnockout() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_KO( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_KO( dlgId, npcPid ) );
            else if( cr.IsDead() && IsMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD( dlgId, npcPid ) ) )
                result += GetMsgStr( TEXTMSG_DLG, STR_NPC_FULL_INFO_DEAD( dlgId, npcPid ) );
            else
                defaultText = true;
        }

        if( defaultText )
        {
            // Check standart text
            if( IsMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) )
            {
                if( cr.IsLife() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIFE ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
                else if( cr.IsKnockout() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_KO ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
                else if( cr.IsDead() )
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_DEAD ), "NAME", GetMsgStr( TEXTMSG_DLG, STR_NPC_NAME( dlgId, npcPid ) ) );
            }
            // Set default text
            else
            {
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
            }
        }
    }

    // Additional description
    if( lookType == CRITTER_LOOK_FULL )
    {
        if( result.length() > 0 && result[ result.length() - 1 ] != '.' )
            result += ".";
        result += " ";

        CritterCl@ chosen = GetChosen();
        ItemCl@    item = cr.GetItem( 0, SLOT_HAND1 );
        ItemCl@    item2 = cr.GetItem( 0, SLOT_HAND2 );
        ItemCl@    item3 = cr.GetItem( 0, SLOT_ARMOR );
        if( valid( chosen ) && chosen.Perk[ PE_AWARENESS ] >= 2 ) // GM AWARNESS
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_HP( gender ) );
            result = ReplaceText( result, "CUR", cr.Stat[ ST_CURRENT_HP ] );
            result = ReplaceText( result, "MAX", cr.Stat[ ST_MAX_LIFE ] );

            if( _CritIsInjured( cr ) )
            {
				bool needComa = false;

				int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
				result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) ) + ": ";
				
                if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
				{
                    result += "глаза";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "правая рука";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "левая рука";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "правая нога";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "левая нога";
					needComa = true;
				}
				
            }


            if( valid( item ) )
            {
				result += ". ";
                if( item.GetType() == ITEM_TYPE_WEAPON )
                {
                    if( item.Proto.Weapon_MaxAmmoCount == 0 )
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                    }
                    else
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP_AMMO );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                        result = ReplaceText( result, "CUR", item.AmmoCount );
                        result = ReplaceText( result, "MAX", item.Proto.Weapon_MaxAmmoCount );
                        result = ReplaceText( result, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
                    }
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
            }
            if( valid( item2 ) )
            {
				result += ". ";
                if( item2.GetType() == ITEM_TYPE_WEAPON )
                {
                    if( item2.Proto.Weapon_MaxAmmoCount == 0 )
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) ) );
                    }
                    else
                    {
                        result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP_AMMO );
                        result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) ) );
                        result = ReplaceText( result, "CUR", item2.AmmoCount );
                        result = ReplaceText( result, "MAX", item2.Proto.Weapon_MaxAmmoCount );
                        result = ReplaceText( result, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item2.Proto.Weapon_Caliber ) ) );
                    }
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) ) );
                }
            }
            if( valid( item3 ) )
            {
                if( gender == GENDER_FEMALE )
                    result += ". На ней ";
                else
                    result += ". На нем ";
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item3 ) );
            }
        }

        else if( valid( chosen ) && chosen.Perk[ PE_AWARENESS ] == 1 ) // Awareness
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_HP( gender ) );
            result = ReplaceText( result, "CUR", cr.Stat[ ST_CURRENT_HP ] );
            result = ReplaceText( result, "MAX", cr.Stat[ ST_MAX_LIFE ] );

            if( _CritIsInjured( cr ) )
            {
				bool needComa = false;

				int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
				result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) ) + ": ";
				
                if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
				{
                    result += "глаза";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "правая рука";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "левая рука";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "правая нога";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "левая нога";
					needComa = true;
				}
				
            }

                
            if( valid( item ) )
            {
				result += ". ";
                if( item.GetType() == ITEM_TYPE_WEAPON )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                    result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
            }

            if( valid( item2 ) )
            {
                result += ". ";
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item2 ) );
            }
            if( valid( item3 ) )
            {
                if( gender == GENDER_FEMALE )
                    result += ". На ней ";
                else
                    result += ". На нем ";
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item3 ) );
            }
        }
        else         // Simple
        {
            result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );

            int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
            if( cr.IsDead() )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) );
            else if( hp_proc < 34 )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) );
            else if( hp_proc < 67 )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) );
            else if( hp_proc < 100 )
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) );
            else
                result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) );

            if( _CritIsInjured( cr ) )
            {
				bool needComa = false;

				int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
				result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) ) + ": ";
				
                if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
				{
                    result += "глаза";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "правая рука";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "левая рука";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "правая нога";
					needComa = true;
				}
                if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
				{
					if( needComa ) result += ", ";
                    result += "левая нога";
					needComa = true;
				}
				
            }


            if( valid( item ) )
            {
				result += ". ";
                if( item.GetType() == ITEM_TYPE_WEAPON )
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WEAP );
                    result = ReplaceText( result, "WEAPON", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
                else
                {
                    result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC );
                    result = ReplaceText( result, "MISC", GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) );
                }
            }
        }
        if( valid( item3 ) && ( item3.GetProtoId() == PID_SANDROBE ) )
            result += ". Лицо скрыто капюшоном";
        else
        {
            if( chosen.Trait[ TRAIT_BLOODY_MESS ] != 0 && chosen.Id != cr.Id )
            {
                switch( Random( 0, 9 ) )
                {
                case 0:
                    result += ", смотрит зло на тебя";
                    break;
                case 1:
                    result += ", бормочет что-то нехорошее о тебе";
                    break;
                case 2:
                    result += ", смотрит с ненавистью";
                    break;
                case 3:
                    result += ", насмехается над тобой";
                    break;
                case 4:
                    result += ", смотрит презрительно";
                    break;
                case 5:
                    result += ", выглядит уродливо";
                    break;
                case 6:
                    result += ", коситься в твою сторону";
                    break;
                case 7:
                    result += ", кажется хочет напасть";
                    break;
                case 8:
                    result += ", скалится на тебя";
                    break;
                case 9:
                    result += ", шепчет сдохни";
                    break;
                }
            }
            else if( cr.IsPlayer() )
            {
                if( cr.StatBase[ ST_STRENGTH ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", мощная";
                    else
                        result += ", мощный";
                }
                else if( cr.StatBase[ ST_STRENGTH ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", сильна";
                    else
                        result += ", силен";
                }
                else if( cr.StatBase[ ST_STRENGTH ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", немощная";
                    else
                        result += ", немощный";
                }
                else if( cr.StatBase[ ST_STRENGTH ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", слабая";
                    else
                        result += ", слабый";
                }
                if( cr.StatBase[ ST_ENDURANCE ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", крепко сбита";
                    else
                        result += ", крепко сбит";
                }
                else if( cr.StatBase[ ST_ENDURANCE ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", крепкая";
                    else
                        result += ", крепкий";
                }
                else if( cr.StatBase[ ST_ENDURANCE ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", хрупкая";
                    else
                        result += ", хрупкий";
                }
                else if( cr.StatBase[ ST_ENDURANCE ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", хилая";
                    else
                        result += ", хилый";
                }
                if( cr.StatBase[ ST_CHARISMA ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", харизматична";
                    else
                        result += ", харизматичен";
                }
                else if( cr.StatBase[ ST_CHARISMA ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", притягательна";
                    else
                        result += ", притягателен";
                }
                else if( cr.StatBase[ ST_CHARISMA ] >= 7 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", привлекает внимание";
                    else
                        result += ", привлекает внимание";
                }
                else if( cr.StatBase[ ST_CHARISMA ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", отвратительна";
                    else
                        result += ", отвратителен";
                }
                else if( cr.StatBase[ ST_CHARISMA ] <= 2 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", отталкивающа";
                    else
                        result += ", отталкивающ";
                }
                else if( cr.StatBase[ ST_CHARISMA ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", неприятна";
                    else
                        result += ", неприятен";
                }
                if( cr.StatBase[ ST_AGILITY ] >= 10 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", проворна";
                    else
                        result += ", проворен";
                }
                else if( cr.StatBase[ ST_AGILITY ] >= 8 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", ловкая";
                    else
                        result += ", ловкий";
                }
                else if( cr.StatBase[ ST_AGILITY ] <= 1 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", неповоротливая";
                    else
                        result += ", неповоротливый";
                }
                else if( cr.StatBase[ ST_AGILITY ] <= 3 )
                {
                    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
                        result += ", неуклюжая";
                    else
                        result += ", неуклюжий";
                }
            }
            if( cr.Lexems != "" && cr.Param[ QST_MEDIUM ] != 3 )
            {
                result += ". "+ cr.Lexems;
            }
        }
        result += ".";
    }

    if( lookType == CRITTER_LOOK_SHORT && ( __sinf & SINF_CRID ) != 0 )
    {
        result += " |0xffff0000 ";
        result += cr.Id;
    }

    // Format tags
    if( cr.Lexems != "" )
        return FormatTags( result, cr.Lexems );

    return result;

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos

void _PlaySound( int pos, int repeat, int, string@ soundName, int[] @ )
{
    PlaySound( soundName );
}

void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& cr, CritterCl& npc, bool sell )
{
    uint8  itemType = item.GetType();
    uint16 pid = item.GetProtoId();
    uint   cost = item.Proto.Cost;

    if( pid == PID_BOTTLE_CAPS || pid == PID_REAL_BOTTLE_CAPS )
        return 1;
		
	if( pid == PID_KOKOWEEF_MINE_SCRIP )
		return 100;

    if( itemType == ITEM_TYPE_ARMOR || itemType == ITEM_TYPE_WEAPON ) //Интересноу
    {
        uint8 brokenCount = item.BrokenCount;
        uint8 brokenFlags = item.BrokenFlags;

        if( FLAG( brokenFlags, BI_NOTRESC ) || FLAG( brokenFlags, BI_BROKEN ) )
            cost *= 0.01;
        else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
            cost /= 3;
        else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
            cost /= 2;
        else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
            cost /= 1.4;
        else if( brokenCount > 0 )
            cost *= brokenCount != 100 ? brokenCount * 0.01 : 0.01;

        if( itemType == ITEM_TYPE_WEAPON && !item.IsStackable() )
        {
            cost += GetProtoItem( item.AmmoPid ).Cost * item.AmmoCount;
        }
    }

    int  skMod = cr.SkillBase[ SK_BARTER ] - npc.SkillBase[ SK_BARTER ] - 50;
    bool skipByZero = false;
    if( skMod == 0 )
    {
        skMod = 1;
        skipByZero = true;
    }
    if( skMod > 0 && !skipByZero )
    {
        cost -= cost * ( skMod * 0.001 );
    }
    else
    {
        cost += cost + ABS( skMod ) * 0.1;
    }

    cost = CLAMP( cost, 1, cost );

    return sell ? ( cost * 0.15 > 1 ? cost * 0.15 : 1 )  : cost;

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate( int[]& data )
{
    CritterGenerate( data );

    #ifdef PLAYERS_3D
    Set3DRegistrationGender( data[ ST_GENDER ] );
    #endif
}

bool player_data_check( int[]& data )
{
    SetCrtype( data );
    #ifdef PLAYERS_3D
    Fill3DRegistrationParameters( data );
    #endif

    return CritterGenerateCheck( data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
    // Not process locally called actions
    if( cr.IsChosen() && not localCall )
    {
        switch( action )
        {
        case ACTION_MOVE_ITEM:
        case ACTION_MOVE_ITEM_SWAP:
        // case ACTION_USE_ITEM: binyan - правка для действий по хоткеям
        case ACTION_DROP_ITEM:
        // case ACTION_USE_WEAPON:   binyan - правка для мяча
        // case ACTION_RELOAD_WEAPON: binyan - правка для действий по хоткеям
        case ACTION_USE_SKILL:
        // case ACTION_PICK_ITEM:
        // case ACTION_PICK_CRITTER:
        case ACTION_OPERATE_CONTAINER:
            return;             // Skip processing
        default:
            break;              // Processing
        }
    }

    uint8            mode = 0;
    const ProtoItem@ proto = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );

    if( ( action >= ACTION_MOVE_ITEM && action <= ACTION_OPERATE_CONTAINER ) || action == ACTION_STANDUP )
        cr.Wait( __Breaktime );

    switch( action )
    {
    case ACTION_MOVE:
        // Not implemented
        // cr.Wait(move time);
        break;
    case ACTION_RUN:
        // Not implemented
        // cr.Wait(run time);
        break;
    case ACTION_MOVE_ITEM:
        if( cr.IsLife() )
        {
            if( proto.ProtoId == 585 )
                return;                        // Игнорируем перекладывание мяча в руку. binyan

            uint8 fromSlot = actionExt;
            uint8 toSlot = item.CritSlot;

            cr.ClearAnim();

            if( toSlot == SLOT_HAND1 )
                cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
            else if( fromSlot == SLOT_HAND1 )
                cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
            else
                cr.Animate( 0, ANIM2_SWITCH_ITEMS );
        }
        break;
    case ACTION_MOVE_ITEM_SWAP:
        break;
    case ACTION_USE_ITEM:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();

            if( proto.Type == ITEM_TYPE_WEAPON && FLAG( proto.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( proto.Weapon_Anim1, proto.Weapon_Anim2_0 ) )
                cr.Animate( proto.Weapon_Anim1, proto.Weapon_Anim2_0, item );
            else
                cr.Animate( 0, ANIM2_USE, item );
        }
        break;
    case ACTION_DROP_ITEM:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_PICKUP );
        }
        break;
    case ACTION_USE_WEAPON:
        // Log("Use weapon procedure (client)");
        if( localCall )
            return;
        if( cr.IsLife() && valid( proto ) )
        {
            int  use   = ( actionExt & 0xF );
            int  aim   = ( ( actionExt >> 4 ) & 0xF );
            bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );

            cr.ClearAnim();

            cr.Animate( 0, ANIM2_PREPARE_WEAPON );

            PlaySound( 'W', SOUND_WEAPON_USE, _WeaponSoundId( proto, use ), use != 1 ? '1' : '2' );
            cr.Animate( 0, _WeaponAnim2( proto, use ), item );

            if( fail )
                cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
            else
                cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
        }
        break;
    case ACTION_RELOAD_WEAPON:
        if( cr.IsLife() && valid( proto ) )
        {
            cr.ClearAnim();
            PlaySound( 'W', SOUND_WEAPON_RELOAD, proto.Weapon_SoundId_0, '1' );
            cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
        }
        break;
    case ACTION_USE_SKILL:
        if( cr.IsLife() && actionExt != SK_SNEAK && actionExt != SK_STEAL )
        {
            cr.ClearAnim();
            cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_PICK_ITEM:
        if( cr.IsLife() )
        {
            cr.ClearAnim();

            bool isGround = ( actionExt != 0 );

            if( !isGround )
            {
                if( !valid( proto ) )
                    break;
                isGround = proto.GroundLevel;
            }

            cr.Animate( 0, isGround ? ANIM2_PICKUP : ANIM2_USE );
        }
        break;
    case ACTION_PICK_CRITTER:
        if( cr.IsLife() )
        {
            cr.ClearAnim();

            switch( actionExt )           // 0 - loot, 1 - steal, 2 - push
            {
            case 0:
                cr.Animate( 0, ANIM2_LOOT );
                break;
            // case 1: cr.Animate(0, ANIM2_STEAL); break;
            case 2:
                cr.Animate( 0, ANIM2_PUSH );
                break;
            case 3:
                cr.Animate( 0, ANIM2_STEAL );
                break;
            default:
                break;
            }
        }
        break;
    case ACTION_OPERATE_CONTAINER:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            int transferType = actionExt / 10;
            int directionType = actionExt % 10;

            if( transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT )
                cr.Animate( 0, ANIM2_PICKUP );
            else
                cr.Animate( 0, ANIM2_USE );
        }
        break;
    case ACTION_DODGE:
        if( not cr.IsAnimPlaying() && cr.IsLife() )
        {
            cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
        }
        break;
    case ACTION_DAMAGE:
        if( not cr.IsAnimPlaying() )
        {
            if( cr.IsLife() )
                cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
            else if( cr.IsKnockout() )
                cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
        }
        else
        {
            // Todo:
            // ANIM2_WALK_DAMAGE_FRONT
            // ANIM2_WALK_DAMAGE_BACK
            // ANIM2_LIMP_DAMAGE_FRONT
            // ANIM2_LIMP_DAMAGE_BACK
            // ANIM2_RUN_DAMAGE_FRONT
            // ANIM2_RUN_DAMAGE_BACK
        }
        break;
    case ACTION_DAMAGE_FORCE:
        if( cr.IsLife() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
        }
        else if( cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
        }
        break;
    case ACTION_KNOCKOUT:
        if( not cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_STANDUP:
        if( cr.IsKnockout() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_FIDGET:
        if( cr.IsLife() && not cr.IsAnimPlaying() )
        {
            cr.Animate( 0, ANIM2_FIDGET );
        }
        break;
    case ACTION_DEAD:
        if( not cr.IsDead() )
        {
            cr.ClearAnim();
            cr.Animate( 0, actionExt );
        }
        break;
    case ACTION_CONNECT:
        // __tempFastText = "";
        break;
    case ACTION_DISCONNECT:
        __tempFastText = "";
        __fastPanelShow = false;
        __fastPanel = false;
        break;
    case ACTION_RESPAWN:
        break;
    case ACTION_REFRESH:
        if( __tempFastText != "" )
            LoadPanel( 2, 0, 0, "", null );
        break;
    default:
        break;
    }
}

import void LoadPanel( int p0, int p1, int p2, string@ word2, int[] @ p4 ) from "client_screen_fastpanel";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );

// #ifdef PLAYERS_3D
    // You must implement this pids
    #define PID_STRAWHAT             uint( -1 )      // Head slot
    #define PID_ARMIN_CAP            uint( -2 )      // Head slot
    #define PID_POWER_HELMET         uint( -3 )      // Head slot
    #define PID_MOTORCYCLE_HELMET    uint( -4 )      // Head slot
    #define PID_TIBBETS_PRISON       uint( -5 )      // Armor slot
    #define PID_VAULT_SUIT           uint( -6 )      // Armor slot

    // Change values
    uint8   mode = 0;
    uint16  armorPid   = ( valid( cr.GetSlotProto( SLOT_ARMOR, mode ) ) ? cr.GetSlotProto( SLOT_ARMOR, mode ).ProtoId : 0 );
    uint16  weapPid    = ( valid( item ) ? item.GetProtoId() : cr.GetSlotProto( SLOT_HAND1, mode ).ProtoId );
    uint16  weapExPid  = ( valid( cr.GetSlotProto( SLOT_HAND2, mode ) ) ? cr.GetSlotProto( SLOT_HAND2, mode ).ProtoId : 0 );
    ItemCl@ armorItem = cr.GetItem( 0, SLOT_ARMOR );
    ItemCl@ headItem  = null;

    #ifndef PLAYERS_3D_NO_HEAD
    uint16 headPid    = ( valid( cr.GetSlotProto( SLOT_HEAD,  mode ) ) ? cr.GetSlotProto( SLOT_HEAD,  mode ).ProtoId : 0 );
    @headItem         = cr.GetItem( 0, SLOT_HEAD );
    #endif
    #ifdef PLAYERS_3D_NO_HEAD
    uint16 headPid    = 0;
    #endif

    bool weapBigGun = false;
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }
    else
    {
        ItemCl@ weap = cr.GetItem( 0, SLOT_HAND1 );
        if( valid( weap ) && FLAG( weap.Flags, ITEM_BIG_GUN ) )
            weapBigGun = true;
    }

    int rhandleAtr = 0;
    int lhandleAtr  = 0;
    int handsAtr = 0;
    int bodyAtr = 0;
    int feetAtr = 0;
    int headAtr = 0;
    int eyeAtr      = 0;
    int shoulderAtr = 0;
    int backAtr     = 0;
    int backpackAtr = 0;

    /*switch(armorPid)
       {
       case PID_LEATHER_JACKET:
            bodyAtr=ATTRIBUTE_Body_LeatherOutfit;
            handsAtr=ATTRIBUTE_Hands_LeatherOutfit; // ATTRIBUTE_Hands_LeatherOutfitGauntlet
            feetAtr=ATTRIBUTE_Feet_LeatherOutfit;
            shoulderAtr=ATTRIBUTE_Shoulderpieces_LeatherOutfit;
            break;
       case PID_POWERED_ARMOR:
       case PID_HARDENED_POWER_ARMOR:
            bodyAtr=ATTRIBUTE_Body_PowerArmor;
            handsAtr=ATTRIBUTE_Hands_PowerArmor;
            feetAtr=ATTRIBUTE_Feet_PowerArmor;
            shoulderAtr=ATTRIBUTE_Shoulderpieces_PowerArmor;
            headAtr     = ATTRIBUTE_Head_ArmingCap;
       #ifdef PLAYERS_3D_NO_HEAD
            headAtr     = ATTRIBUTE_Head_PowerArmor;
       #endif
            break;
       case PID_TIBBETS_PRISON:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            backAtr     = armorItem.Val5;
            break;
       case PID_VAULT_SUIT:
            bodyAtr     = ATTRIBUTE_Body_VaultSuit;
            feetAtr     = ATTRIBUTE_Feet_VaultSuit;
            backAtr     = armorItem.Val5;
            break;
            // Missed models, set some default clothes
       case PID_LEATHER_ARMOR:
       case PID_LEATHER_ARMOR_MK_II:
       case PID_CURED_LEATHER_ARMOR:
       case PID_METAL_ARMOR:
       case PID_METAL_ARMOR_MK_II:
       case PID_TESLA_ARMOR:
       case PID_COMBAT_ARMOR:
       case PID_COMBAT_ARMOR_MK_II:
       case PID_BROTHERHOOD_COMBAT_ARMOR:
       case PID_ADVANCED_POWER_ARMOR:
       case PID_ADVANCED_POWER_ARMOR_MK2:
       case PID_PURPLE_ROBE:
       case PID_KEEPBRIGE_ROBE:
            bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
            feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
            break;
       default:
            break;
       }*/

    // Temporary sets, mostly intended for work with PLAYERS_3D_NO_HEAD
    // Will be corrected as the development of the missing content
    switch( armorPid )
    {
    case PID_LEATHER_JACKET:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfit;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        break;

    case PID_POWERED_ARMOR:
    case PID_HARDENED_POWER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    case PID_TIBBETS_PRISON:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_JUMPSUIT:
    case PID_FAKE_JUMPSUIT:
    case PID_VAULT_SUIT:
        bodyAtr     = ATTRIBUTE_Body_VaultSuit;
        feetAtr     = ATTRIBUTE_Feet_VaultSuit;
        backAtr     = armorItem.Val5;
        break;

    case PID_LEATHER_ARMOR:
    case PID_LEATHER_ARMOR_MK_II:
    case PID_CURED_LEATHER_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_LeatherOutfit;
        handsAtr    = ATTRIBUTE_Hands_LeatherOutfitGauntlet;
        feetAtr     = ATTRIBUTE_Feet_LeatherOutfit;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_LeatherOutfit;
        break;

    case PID_METAL_ARMOR:
    case PID_METAL_ARMOR_MK_II:
    case PID_TESLA_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        break;

    case PID_COMBAT_ARMOR:
    case PID_COMBAT_ARMOR_MK_II:
    case PID_BROTHERHOOD_COMBAT_ARMOR:
    case PID_MIRELURK_ARMOR:
    case PID_BLACK_COMBAT_ARMOR:
        bodyAtr     = ATTRIBUTE_Body_CombatArmor;
        handsAtr    = ATTRIBUTE_Hands_CombatArmor;
        feetAtr     = ATTRIBUTE_Feet_CombatArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_CombatArmor;
        #ifdef PLAYERS_3D_NO_HEAD
        headAtr     = ATTRIBUTE_Head_CombatArmor;
        #endif
        break;

    case PID_ADVANCED_POWER_ARMOR:
    case PID_ADVANCED_POWER_ARMOR_MK2:
        bodyAtr     = ATTRIBUTE_Body_PowerArmor;
        handsAtr    = ATTRIBUTE_Hands_PowerArmor;
        feetAtr     = ATTRIBUTE_Feet_PowerArmor;
        shoulderAtr = ATTRIBUTE_Shoulderpieces_PowerArmor;
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;

    case PID_PURPLE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        break;
    case PID_KEEPBRIGE_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_BLACK_ROBE:
        bodyAtr     = ATTRIBUTE_Body_PrisonSuit;
        feetAtr     = ATTRIBUTE_Feet_PrisonSuit;
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;

    default:
        break;
    }

    // Head
    switch( headPid )
    {
    case PID_STRAWHAT:
        headAtr     = ATTRIBUTE_Head_StrawHat;
        break;
    case PID_ARMIN_CAP:
        headAtr     = ATTRIBUTE_Head_ArmingCap;
        break;
    case PID_POWER_HELMET:
        headAtr     = ATTRIBUTE_Head_PowerArmor;
        break;
    case PID_MOTORCYCLE_HELMET:
        headAtr     = ( headItem.Val5 != 0 ? headItem.Val5 : ATTRIBUTE_Head_Motorcycle_White );
        break;
    default:
        break;
    }

    // Backpack
    if(     weapPid   == PID_BAG || weapPid   == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapPid   == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;
    else if( weapExPid == PID_BAG || weapExPid == PID_BROWN_BAG )
        backpackAtr = ATTRIBUTE_Backpack_PaLg01;
    else if( weapExPid == PID_BACKPACK )
        backpackAtr = ATTRIBUTE_Backpack_PaSm01;

    // Hands
    if( weapPid == PID_POWER_FIST || weapPid == PID_MEGA_POWER_FIST )
    {
        handsAtr = ATTRIBUTE_Hands_PowerFist;
    }
    else if( weapBigGun )
    {
        rhandleAtr = GetHandleValue( weapPid );
    }
    else
    {
        rhandleAtr = GetHandleValue( weapPid );
        lhandleAtr = GetHandleValue( weapExPid );
    }

    #ifdef PLAYERS_3D_VAULT_SUITE
    bool isSkeleton = ( cr.CrType == CRTYPE_3D_MALE_SKELETON || cr.CrType == CRTYPE_3D_FEMALE_SKELETON );
    if( bodyAtr == 0 && !isSkeleton )
        bodyAtr = ATTRIBUTE_Body_VaultSuit;
    #endif

    cr.Anim3dLayer[ ANIM3D_LAYER_RHANDLE ] = rhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_LHANDLE ] = lhandleAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BODY ] = bodyAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_FEET ] = feetAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HANDS ] = handsAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_HEAD ] = headAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_SHOULDER ] = shoulderAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_EYE     ] = eyeAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACK    ] = backAtr;
    cr.Anim3dLayer[ ANIM3D_LAYER_BACKPACK ] = backpackAtr;

    // Set custom values
    for( uint i = ANIM3D_LAYER_SKIN; i <= ANIM3D_LAYER_BACKPACK; i++ )
        if( cr.Stat[ ST_ANIM3D_LAYERS + i ] != 0 )
            cr.Anim3dLayer[ i ] = cr.Stat[ ST_ANIM3D_LAYERS + i ];
// #endif
}

// #ifdef PLAYERS_3D
int GetHandleValue( uint16 pid )
{
    if( pid == 0 || ( pid >= 1000 && pid <= 1100 ) )
        return 0;

    int handle = 0;
    switch( pid )
    {
    case PID_ZIP_GUN:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_9MM_MAUSER:
        handle = ATTRIBUTE_Handle_Weapon_9mmAutoloader;
        break;
    case PID_10MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_14MM_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_DESERT_EAGLE:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader;
        break;
    case PID_DESERT_EAGLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_45Autoloader_GunExtClip;
        break;
    case PID_223_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_223Autoloader;
        break;
    case PID_44_MAGNUM_REVOLVER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_44_MAGNUM_SPEEDLOADER:
        handle = ATTRIBUTE_Handle_Weapon_44Revolver;
        break;
    case PID_NEEDLER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_22Autoloader;
        break;
    case PID_PK12_GAUSS_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SCOPED_HUNTING_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SPRINGER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_ASSAULT_RIFLE_EXT_MAG:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SNIPER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_NIGHT_SCOPE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_FN_FAL_HPFA:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_RED_RYDER_LE_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_JONNY_BB_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_INDEPENDENT:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_M72_GAUSS_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_SAWED_OFF_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_COMBAT_SHOTGUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_CAWS:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_PANCOR_JACKHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_10MM_SMG:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_P90C:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_TOMMY_GUN:
        handle = ATTRIBUTE_Handle_Weapon_SawedOffShotgun;
        break;
    case PID_HK_G11:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_HK_G11E:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_GREASE_GUN:
        handle = ATTRIBUTE_Handle_Weapon_9mmMachinePistol;
        break;
    case PID_FLAMER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_IMPROVED_FLAMETHROWER:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower_FlamerExtTank;
        break;
    case PID_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_15mmArtemisRailGun;
        break;
    case PID_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_AVENGER_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_VINDICATOR_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_BOZAR:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LIGHT_SUPPORT_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_M60:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_MAGNETO_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_SOLAR_SCORCHER:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_LASER_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_LASER_RIFLE_EXT_CAP:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_GATLING_LASER:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_ALIEN_LASER_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_APOLLOLaserPistol;
        break;
    case PID_PLASMA_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_PISTOL_EXT_CART:
        handle = ATTRIBUTE_Handle_Weapon_LaserPistol;
        break;
    case PID_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_TURBO_PLASMA_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_YK32_PULSE_PISTOL:
        handle = ATTRIBUTE_Handle_Weapon_2mmGaussPistol;
        break;
    case PID_YK42B_PULSE_RIFLE:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_MOLOTOV_COCKTAIL:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_FRAG_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    case PID_PLASMA_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadePlasma;
        break;
    case PID_PULSE_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeEMP;
        break;
    case PID_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_ACTIVE_FLARE:
        handle = ATTRIBUTE_Handle_Weapon_Flare;
        break;
    case PID_PLANT_SPIKE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_THROWING_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_ThrowingKnife;
        break;
    case PID_ROCK:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_GOLD_NUGGET:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_URANIUM_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_REFINED_ORE:
        handle = ATTRIBUTE_Handle_Weapon_Rock;
        break;
    case PID_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_COMBAT_KNIFE:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_LIL_JESUS_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_CombatKnife;
        break;
    case PID_SHIV:
        handle = ATTRIBUTE_Handle_Weapon_Shiv;
        break;
    case PID_SWITCHBLADE:
        handle = ATTRIBUTE_Handle_Weapon_Switchblade;
        break;
    case PID_WAKIZASHI_BLADE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARP_SPEAR:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_SHARPENED_POLE:
        handle = ATTRIBUTE_Handle_Weapon_Spear;
        break;
    case PID_AXE:
        handle = ATTRIBUTE_Handle_Weapon_Hatchet;
        break;
    case PID_CLUB:
        handle = ATTRIBUTE_Handle_Weapon_NightStick;
        break;
    case PID_CROWBAR:
        handle = ATTRIBUTE_Handle_Weapon_Crowbar;
        break;
    case PID_WRENCH:
        handle = ATTRIBUTE_Handle_Weapon_HeavyWrench;
        break;
    case PID_SLEDGEHAMMER:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_LOUISVILLE_SLUGGER:
        handle = ATTRIBUTE_Handle_Weapon_Baseballbat;
        break;
    case PID_SUPER_SLEDGE:
        handle = ATTRIBUTE_Handle_Weapon_Sledgehammer;
        break;
    case PID_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_SUPER_CATTLE_PROD:
        handle = ATTRIBUTE_Handle_Weapon_CattleProd;
        break;
    case PID_RIPPER:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_RING_PLATED_BOXING_GLOVES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_BRASS_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_SPIKED_KNUCKLES:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeBio;
        break;
    case PID_DYNAMITE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_PLASTIC_EXPLOSIVES:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    case PID_MINE:
        handle = ATTRIBUTE_Handle_Weapon_Dynamite;
        break;
    // Player will never have this weapons anyway
    case PID_ROBO_ROCKET_LAUNCHER:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_PHAZER:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DEATHCLAW_CLAW_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_FIRE_GECKO_FLAME_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_Flamethrower;
        break;
    case PID_SPECIAL_BOXER_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_GUN_TURRET_WEAPON:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_EYEBALL_FIST_1:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_EYEBALL_FIST_2:
        handle = ATTRIBUTE_Handle_Weapon_45Revolver;
        break;
    case PID_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_HEAVY_DUAL_MINIGUN:
        handle = ATTRIBUTE_Handle_Weapon_223Minigun;
        break;
    case PID_END_BOSS_KIFE:
        handle = ATTRIBUTE_Handle_Weapon_Machete;
        break;
    case PID_END_BOSS_PLASMA_GUN:
        handle = ATTRIBUTE_Handle_Weapon_LaserArraygun;
        break;
    case PID_HOLY_HAND_GRENADE:
        handle = ATTRIBUTE_Handle_Weapon_GrenadeFrag;
        break;
    // Other items
    case PID_STIMPAK:
    case PID_RADAWAY:
    case PID_SUPER_STIMPAK:
    case PID_HYPO:
    case PID_PSYCHO:
    case PID_HYPO_POISON:
        handle = ATTRIBUTE_Handle_Item_FirstAidKit;
        break;
    case PID_LOCKPICKS:
    case PID_EXP_LOCKPICK_SET:
    case PID_ELECTRONIC_LOCKPICKS:
    case PID_ELEC_LOCKPICK_MKII:
        handle = ATTRIBUTE_Handle_Item_SecurityKit;
        break;
    case PID_MULTI_TOOL:
    case PID_SUPER_TOOL_KIT:
    case PID_OIL_CAN:
        handle = ATTRIBUTE_Handle_Item_Toolkit;
        break;
    // No handle
    case PID_POWER_FIST:
    case PID_MEGA_POWER_FIST:
    case PID_BAG:
    case PID_BROWN_BAG:
    case PID_BACKPACK:
        handle = 0;
        break;
    // Generic item
    default:
        handle = 0;
        break;
    }

    return handle;
}
// #endif

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    // Example
    // Disable showing of all weapons in USE mode:
    /*if(collection==ITEMS_BARTER_OPPONENT)
       {
            for(uint i=0,j=items.length();i<j;i++)
                    if(items[i].GetType()==ITEM_TYPE_WEAPON)
                            @items[i]=null;
       }*/

    if( collection == ITEMS_INVENTORY )
    {
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
            switch( __inventoryCollection )
            {
            case 0:
                break;
            case 1:
                if( items[ i ].GetType() != ITEM_TYPE_WEAPON )
                    @items[ i ] = null;
                break;
            case 2:
                if( items[ i ].GetType() != ITEM_TYPE_AMMO )
                    @items[ i ] = null;
                break;
            case 3:
                if( items[ i ].GetType() != ITEM_TYPE_ARMOR )
                    @items[ i ] = null;
                break;
            case 4:
                if( items[ i ].GetType() != ITEM_TYPE_DRUG )
                    @items[ i ] = null;
                break;
            case 5:
                if( items[ i ].GetType() != ITEM_TYPE_MISC )
                    @items[ i ] = null;
                break;
            case 6:
                if( items[ i ].GetType() != ITEM_TYPE_KEY )
                    @items[ i ] = null;
                break;
            default:
                break;
            }
            // if(!items[i].IsCanUseByIndefine(choo)) @items[i] = null;
        }
    }

    // ShowItemByIndefineValue(items);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

void SetHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "w" ) >= 0 )
    {
		if( param0 == 0 ) f.writeString( param3 );
        f.close();
        return;
    }
}

void CheckHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "r" ) >= 0 )
    {
        int number = 0;
        string line;
        f.setPos( 0 );
        while( !f.isEndOfFile() )
        {
            f.readLine( line );
            if( line.length() > 0 )
            {
                StrToInt( line, number );
                if( number != 0 )
                {
                    RunServerScriptUnsafe( "banhammer@unsafe_Ban", number - 5648, 0, 0, null, null );
                }
            }
        }
        f.close();
    }
}

void loger( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( param1 == 0 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\help.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\help.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 1 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\warn.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\warn.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 2 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\kill.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\kill.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 3 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\faction.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\faction.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 4 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\bans.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\bans.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 5 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 6 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
                return;
            }
            return;
        }
        else
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 7 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 8 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\crims.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\crims.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
    }
}


void _sinf( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __sinf = uint( param0 );

    string red = "|0xFFAA0000 ",
           green = "|0xFF008800 ";

    Message( "Информационные опции:" );
    Message( ( ( ( __sinf & SINF_LOGIN ) != 0 ) ? green : red ) + "Показывать логины игроков" );
    Message( ( ( ( __sinf & SINF_CRID ) != 0 ) ? green : red ) + "Показывать Id криттеров в <<Вы видите>>" );
    Message( ( ( ( __sinf & SINF_CRID_ON_HEAD ) != 0 ) ? green : red ) + "Показывать Id криттеров над головами" );
    Message( ( ( ( __sinf & SINF_CRID_CHAT ) != 0 ) ? green : red ) + "Показывать Id криттеров в сообщениях чата" );
    Message( ( ( ( __sinf & SINF_ITEMID ) != 0 ) ? green : red ) + "Показывать Id итемов" );
    Message( ( ( ( __sinf & SINF_HEX ) != 0 ) ? green : red ) + "Показывать координаты гекса" );
    Message( ( ( ( __sinf & SINF_INSIGHT ) != 0 ) ? green : red ) + "Показывать сообщения аркады" );
    Message( ( ( ( __sinf & SINF_SPRITES ) != 0 ) ? green : red ) + "Показывать информацию о спрайтах под курсором" );
    // Message((((__sinf&SINF_GLOBAL)!=0)?green:red)+"Показывать на глобале квадратный курсор.");
    // Message((((__sinf&SINF_GRID)!=0)?green:red)+"Показывать на глобале сетку.");

    updateAllNicks();
}

bool waiting = false;

void _waiting( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __waiting = ( ( param0 != 0 ) ? true : false );
    ChangeCursor( ( __waiting ) ? CURSOR_WAIT : CURSOR_DEFAULT );
}

// indefine bullshit
/*
   void ShowItemByIndefineValue(ItemCl@[]@ items)
   {
        CritterCl @ choo = GetChosen();
        if(choo is null) return;

        for(uint16 i = 0, len = items.length(); i < len; ++i)
        {
                if(items[i] is null) continue;

                ItemCl @ item = items[i];

                //Message("pid "+item.GetProtoId()+" id "+item.Id+" val "+item.GetIndefineValue());

                uint hash = GetIndefineSpriteHash(item, choo);
                if(hash != 0)	item.SetInvPic(hash);


        }

   }

   uint GetIndefineSpriteHash(ItemCl& item, CritterCl& cr)
   {
        if(!item.IsCanUseByIndefine(cr))
        {
                uint16  stat = item.GetIndefineStat(),
                        value = item.GetIndefineValue();
                string spriteName = "art\\inven\\pump2.frm";

                if(cr.Param[stat] - (value * 0.5) >= value)
                {
                        switch(stat)
                        {
                                case SK_SMALL_GUNS : spriteName = "art\\inven\\hrifle.frm"; break;
                                case SK_MELEE_WEAPONS : spriteName = "art\\inven\\oknife.frm"; break;
                                //case SK_BARTER : spri
                                default : break;
                        }
                }
                return GetStrHash(spriteName);
        }
   return 0;
   }
 */

#include "client_zomb.fos"

#define EXPBAR_POS_X       ( expbarPosX )
#define EXPBAR_POS_Y       ( expbarPosY )
#define EXPBAR_LINE_END    ( expbarLineEnd )

Sprite expbar,
       expbar_;

uint16 expbarPosX = 0, expbarPosY = 0, expbarLineEnd = 0;

void ExpBarSetPos()
{
    GetIfaceIniPos( "ExpBar", expbarPosX, expbarPosY, expbarLineEnd );

    expbar.Load( "bar1.png", int(PT_ART_INTRFACE) );
    expbar_.Load( "bar1_e.png", int(PT_ART_INTRFACE) );
}

void DrawExpBar()
{
    int[] drawData;

    CritterCl @ choo = GetChosen();
    if( choo is null )
        return;

    uint8  level = choo.StatBase[ ST_LEVEL ];
    uint   levelExp = NUMERICAL_NUMBER( level - 1 ) * 1000;

    uint16 exp = choo.StatBase[ ST_EXPERIENCE ] - levelExp,
           toLevelExp = NUMERICAL_NUMBER( level ) * 1000 - levelExp;

    float  expMod = exp * 100 / ( toLevelExp > 100 ? toLevelExp : 100 );

    uint16 time = choo.StatBase[ ST_EXPERIENCE_MULTIPLIER_TIME ];
    uint8  allTime = ( time ) & 0xFF,
           elapsedTime = ( time >> 8 ) & 0xFF;

    float  timeMod = elapsedTime * 100 / ( allTime > 0 ? allTime : 1 );

    uint16 r0 = 0x15,
           g0 = 0x1F,
           b0 = 0x00,

           r1 = 0x67,
           g1 = 0x60,
           b1 = 0x00;
/*
        switch(choo.StatBase[ST_EXPERIENCE_MULTIPLIER])
        {
                case 2: r0 = 0x14;
                        g0 = 0x1F;
                        b0 = 0x00;

                        r1 = 0x35;
                        g1 = 0x39;
                        b1 = 0x00;
                        break;
                case 3: r0 = 0x8F;
                        g0 = 0x6F;
                        b0 = 0x0;
                        break;
                case 4: r0 = 0x0;
                        g0 = 0x0;
                        b0 = 0xC8;
                        break;
                case 5: r0 = 0xC8;
                        g0 = 0x0;
                        b0 = 0x0;
                        break;
                default:break;
        }*/

/*
        for(uint16 i = 0; i < EXPBAR_LINE_HEIGH; ++i)
        {
                //uint8 k = i;

                uint16 tempY = EXPBAR_POS_Y - ((EXPBAR_POS_Y - EXPBAR_LINE_END) * (allTime > 0 ? timeMod * 0.01 :  expMod * 0.01));

                drawData.insertLast(982+i);
                drawData.insertLast(EXPBAR_LINE_START);
                drawData.insertLast(COLOR_RGB(r,g,b));

                drawData.insertLast(982+i);
                drawData.insertLast(tempY);
                drawData.insertLast(COLOR_RGB(r,g,b));


        }
 */

    uint16 tempY = ( ( EXPBAR_POS_Y - EXPBAR_LINE_END ) * ( allTime > 0 ? timeMod * 0.01 :  expMod * 0.01 ) );

    for( uint16 i = 0; i < tempY; ++i )
    {
        i += 3;

        drawData.insertLast( EXPBAR_POS_X );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 8 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );


    }

    DrawSprite( expbar.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
    DrawSprite( expbar_.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawText( "0" + choo.StatBase[ ST_EXPERIENCE_MULTIPLIER ], EXPBAR_POS_X - 20, EXPBAR_POS_Y + 30, 70, 10, COLOR_RGB( r1, g1, b1 ), FONT_NUM, 0 );
}

void GetIfaceIniPos( string iniKey, uint16& posX, uint16& posY, uint16& lineEnd )
{
    string@ str = GetIfaceIniStr( iniKey );
    if( @str == null || str == "" )
        return;

    string@[] @ valuesStr = splitEx( str, " " );
    if( valuesStr.length() != 3 )
        return;

    int[] values( 3 );
    for( int i = 0; i < 3; i++ )
        if( not StrToInt( valuesStr[ i ], values[ i ] ) )
            return;

    posX = values[ 0 ];
    posY = values[ 1 ];
    lineEnd = values[ 2 ];
}

/*
   bool IsMouseOnGrid(int x, int y)
   {
      uint16 hexX = 0, hexY = 0, entHexX = 0, entHexY = 0;

      GetChosen().GetMap().GetEntireCoords(255, 0, entHexX, entHexY);
      GetMonitorHex(x, y, hexX, hexY);

      //if(
   }*/
bool isDKPInit = false;
uint16[] dkp_array;

void DKPInit(){

/*	dkp_array.insertLast(DIK_F1);
	dkp_array.insertLast(PID_SUPER_STIMPAK);

	dkp_array.insertLast(DIK_F2);
	dkp_array.insertLast(PID_STIMPAK);

	dkp_array.insertLast(DIK_F3);
	dkp_array.insertLast(PID_PSYCHO);*/

	
	if(dkp_array.length() % 2 != 0) Log("dkp_array wring size.");
		else isDKPInit = true;
}

uint16 DKPCheckDrugKey(uint8 key){

	if(!isDKPInit) DKPInit();

	for(uint8 i = 0, j = dkp_array.length(); i < j; i++){
		if(dkp_array[i] == key && i % 2 == 0) return dkp_array[i+1];
	}

return uint16(-1);
}

void ShowPopup( int popup_id, int param1, int param2, string@ default_text, int[] @ param4 ) {
	CritterCl@ chosen = GetChosen();
	if(!valid(chosen)) return;
    ItemCl@ popup = GetItem(popup_id);
	if(!valid(popup)) Message( default_text );
	string lexems(popup.Lexems);
	if( chosen.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER )
		RunServerScriptUnsafe( "main@unsafe_ShowFullPopupInfo", popup_id, 0, 0, lexems, null );
    else
		RunServerScriptUnsafe( "main@unsafe_ShowPopup", popup_id, 0, 0, lexems, null );
}

void DKPUnsafeRun(uint16 drugPid){

	if(GetChosen().IsBusy()){Message("choo are busy."); return;}
	if(_CritCountItem(GetChosen(), drugPid) <= 0){Message("need more drugs."); return;}
	RunServerScriptUnsafe("main@unsafe_DKP", drugPid, 0, 0, null, null);
}

void __ReInit (int p0, int p1, int p2, string@ p3, int[]@ p4) {
	start ();
	screen_change( true, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0);
	screen_change( false, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0);
	render_iface (2);
}
