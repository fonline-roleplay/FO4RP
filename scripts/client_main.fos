// comment this out to disable physical ui and enable "visible_items.fos"
#define PHYSICAL_UI

// Client main script
// Compile using fo_client.dll
#include "_utils.fos"
#include "sprite.fos"
#include "combat_h.fos"
#include "client_names_h.fos"
#include "wait_time_h.fos"
#include "fofmod_h.fos"
#include "perks_h.fos"
#include "parameters_h.fos"
#include "handcuffs_h.fos"
#include "radio_h.fos"
#include "client_gui_h.fos"
#include "firestarter_h.fos"

import void InitializeGame() from "config";

import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";

import void show_timeouts() from "client_timeouts";

import bool gm_msg( string& message ) from "client_gm";

import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";

import void DrawMapTiles() from "qmap_client";
import void qmap_loop() from "qmap_client";

//import void overlay_loop(bool show) from "overlay";
//import void overlay_connect() from "overlay";
//import void overlay_disconnect() from "overlay";
//import void overlay_visibility() from "overlay";
//import void overlay_message(string& message, int& sayType, uint& critterId, uint& delay) from "overlay";

import void InitContMenuScreen() from "client_screen_contmenu";

import void InitCodedoorScreen() from "client_screen_codedoor";

import void InitNumpadScreen() from "client_screen_numberpad";

import void InitScreenAddiotional() from "client_screen_additional";
import void SetCrtype( int[]& params ) from "client_screen_additional";

import void InitScreenInputbox() from "client_screen_inputbox";

import void WASDInputLoop() from "input_wasd";
import bool WASDInputKeyState(int key, bool state) from "input_wasd";
import void WASDInputLost() from "input_wasd";

import void FactionGuiInit() from "factions_gui";

import bool OutMessage(string& message, int& sayType) from "chat";
import bool InMessage(string& message, int& sayType, uint& senderCritterID, uint& delay) from "chat";
import bool MapMessage(string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay) from "chat";

dictionary chosenContainerItems;

uint prevId = 0; // required for loading saved names
Sprite[] arrow;

Sprite F1_arrows, F1_tabs, F1_text, TabPic;
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
uint F1SpriteId = 0;
uint RadSpriteId = 0;
uint GasSpriteId = 0;
uint LightSpriteId = 0;
int F1_Width;
int F1_Height;
bool F1IsDraw = false;
bool start()
{
    bool result = true;
    InitializeGame();

    result = result && FOFMOD_Initialize();

    if( __ScreenWidth < 800 || __ScreenWidth > 1920 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
    }

    #ifdef PLAYERS_3D
		AppendIfaceIni( "players3d_chareg.ini" );
		# ifndef PLAYERS_3D_NO_HEAD
			AppendIfaceIni( "players3d_headinv.ini" );
		# endif
    #endif

	AppendIfaceIni( "rp_default.ini" );
	Message( GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_INFO) );
		
	string legacyGUI;
	legacyGUI = GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_LEGACY );
	string newGUI;
	newGUI    = GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_NEW);
	string errorGUI;
	errorGUI  = GetMsgStr(TEXTMSG_GAME, STR_INFO_WELCOME_ERROR);
	
	if( AppendIfaceIni( "rp_default.ini" ) )
    {
        Message( "" + newGUI ); 
    }
    else if ( AppendIfaceIni( "default.ini" ) )
    {
        Message( "" + legacyGUI ); 
    }
	else
	{
		Message ( "" + errorGUI );
	}
	
    GUI_Init();

    InitRadioScreen();
    InitChosenTabs();
	FactionGuiInit();

    // @pm menu
    InitContMenuScreen();
   // InitFastPanelScreen();
   // InitFastPanelSkillbox();
    //InitFastPanelTextbox();
    InitCodedoorScreen();
	InitNumpadScreen();
    InitScreenAddiotional();
    InitScreenInputbox();

    //InitHotKeys();

    arrow.resize( 8 );
    arrow[ 0 ].Load( "arrow0.png", int(PT_ART_INTRFACE) );
    arrow[ 1 ].Load( "arrow1.png", int(PT_ART_INTRFACE) );
    arrow[ 2 ].Load( "arrow2.png", int(PT_ART_INTRFACE) );
    arrow[ 3 ].Load( "arrow3.png", int(PT_ART_INTRFACE) );
    arrow[ 4 ].Load( "arrow4.png", int(PT_ART_INTRFACE) );
    arrow[ 5 ].Load( "arrow5.png", int(PT_ART_INTRFACE) );
    arrow[ 6 ].Load( "arrow6.png", int(PT_ART_INTRFACE) );
    arrow[ 7 ].Load( "arrow7.png", int(PT_ART_INTRFACE) );
    // #pm menu
	
	__MouseScroll = true;

    __ShowPlayerNames = true;
    __ShowNpcNames = true;

	TabPic.LoadByIni( "ChosenTabPic", PT_ART_INTRFACE );

    __global = CONF_GLOB_GRID | CONF_GLOB_WILD;

	F1SpriteId = LoadSprite( "F1Pic.png", int( PT_ART_INTRFACE ) );
	F1_Width = GetSpriteWidth( F1SpriteId, 0 );
	F1_Height = GetSpriteHeight( F1SpriteId, 0 );

	RadSpriteId = LoadSprite( "RadIcon.png", int( PT_ART_INTRFACE ) );
	GasSpriteId = LoadSprite( "GasIcon.png", int( PT_ART_INTRFACE ) );
	LightSpriteId = LoadSprite( "LightIcon.png", int( PT_ART_INTRFACE ) );
	
	array<Sprite@> avatarsPlaceholder =
	{
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderNone.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderNoFound.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderDownload.png" ), 0 ),
		CreateSprite( GetStrHash( "Avatars\\AvatarPlaceholderGood.png" ), 0 )
	};
	@AvatarPlaceholders = avatarsPlaceholder;
	
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.

uint loop_turn = 0;

uint loop()
{
    FOFMOD_Update();
    WASDInputLoop();

    if( loop_turn % 4 == 0 )
	{
		SelectionBarUpdate();
		updateAllNicks();
			
		if( !last_radio_message_recieved )
		{
			Message( "|0xFFFFFF " + last_radio_message );
			last_radio_message_recieved = true;
		}
    }

    if( loop_turn % 5 == 0 )
	{
        qmap_loop();
    }

    if( loop_turn % 100 == 0 )
    {
        int[] result;
        GUI_GetActiveScreens( result );

        CritterCl@ ch = GetChosen();

        if( !(ch is null) && ( prevId == ch.Id ) && ( ( result.length() > 0 && result[ result.length() - 1 ] == CLIENT_MAIN_SCREEN_GAME ) || ( result.length() > 1 && result[ result.length() - 2 ] == CLIENT_MAIN_SCREEN_GAME ) ) )
        {
            SaveNames();
        }
    }
    loop_turn += 1;
    if( loop_turn > 100 )
	{
        loop_turn = 0;
	}
    return 100;
}

void SelectionBarUpdate() 
{
	if( !isLMB_on() )
	{
		return;
	}
	
	if( GetCurrentCursor() == CURSOR_RTSA )
	{
		checkSelectionBarALL();
	}
	else if( GetCurrentCursor() == CURSOR_RTS )
	{
		checkSelectionBarNPC();
	}
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_GetActiveScreens( result );
}

// Show/hide screen behaviour.
int _MainScreen = CLIENT_SCREEN_NONE;
int _LastMainScreen = CLIENT_SCREEN_NONE;
void screen_change( bool show, int screen, int p0, int p1, int p2 )
{ 
    // qthree: sorry for the trash
    //debug_screen_change(show, screen, p0, p1, p2);
    if ( show )
	{
        //if new screen - main or global and last is Login - connect to overlay
        if(
            ( screen == CLIENT_MAIN_SCREEN_GAME || screen == CLIENT_MAIN_SCREEN_GLOBAL_MAP ) &&
            ( _LastMainScreen == CLIENT_MAIN_SCREEN_LOGIN || _LastMainScreen == CLIENT_SCREEN_NONE )
        )
		{
            //Message("BINGO");
            //overlay_connect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }
        //if new screen - login and last main or global - disconnect overlay and reset names
        else if( screen == CLIENT_MAIN_SCREEN_LOGIN && (_LastMainScreen == CLIENT_MAIN_SCREEN_GAME || _LastMainScreen == CLIENT_MAIN_SCREEN_GLOBAL_MAP) )
		{
            prevId = 0;
            ClearNameCache();
            //overlay_disconnect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }

        if(screen>=CLIENT_MAIN_SCREEN_LOGIN && screen<=CLIENT_MAIN_SCREEN_WAIT)
		{
            _MainScreen = screen;
            if(screen != CLIENT_MAIN_SCREEN_WAIT)
			{
                _LastMainScreen = screen;
            }
        }
    }

// binyan - Hotkeys
    if( screen == CLIENT_SCREEN_SAY || screen == CLIENT_SCREEN_TIMER || screen == CLIENT_SCREEN_INPUT_BOX || screen == CLIENT_SCREEN_SPLIT )
        __IsTextInput = show ? true : false;
// /////////////////////////////////////
    if( show )
        GUI_ShowScreen( screen, p0, p1, p2 );
    else
        GUI_HideScreen( screen, p0, p1, p2 );
}

int[] @ data_color = null;
int[] @ data_number = null;
int[] @ data_char = null;

void _dr( int param0, int param1, int param2, string@ param3, int[] @ param4 ) // draw data
{
    switch( param0 )
    {
    case 1:
        @data_color = param4;
        break;
    case 2:
        @data_number = param4;
        break;
    case 3:
        @data_char = param4;
        break;
    default:
        break;
    }
}

// Render interface function. You can use Draw* functions only there.
// Layer specification:
//    1
// Game map
//    2
// Console, Messbox
//    3
// PopUp menu, Cursor
//    4
//
// Extra layers:
// Global map
//    100 (over map), 101 (over all)
void render_iface( FOWindow@ window, uint layer )
{
	if( window !is MainWindow )
	{
		return;
	}
	
	CritterCl@ choo = GetChosen();
	
    if( layer == 1 )
    {
        show_player_info();
    }
    else if( layer == 2 )
    {
		ShowF1Help();
		
		if( ( __sinf & SINF_RAD_SIGN ) != 0 )
		{
			ShowRadiation();
		}
		
		if( ( __sinf & SINF_GAS_SIGN ) != 0 )
		{
			ShowGases();
		}
		
		if( ( __sinf & SINF_LIGHT_SIGN ) != 0 )
		{
			ShowLights();
		}
	}
    else if( layer == 3 )
    {
		DrawChosenTabs();
		GUI_Render();

		ItemCl @ item = GetMonitorItem( __MouseX, __MouseY );
		if( item !is null )
		{
			if( GetCurrentCursor() == CURSOR_MOVE && item.GetProtoId() >= EXIT_GRID_PID && item.GetProtoId() <= EXIT_GRID_PID + 8 )
			{
				if( ABS( int(choo.HexX - item.HexX) ) <= 16 && ABS( int(choo.HexY - item.HexY) ) <= 16 )
				{

					uint16 hexX = 0, hexY = 0;
					GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
					int value = GetDirection( choo.HexX, choo.HexY, hexX, hexY );

					//Exit grig powered magic - TO REVISE:
					if( value == 0 ) value = 1;
					if( value == 4 || value == 5 ) value = 7;
					if( value == 3 ) value = 5;
					if( value == 2 ) value = 3;
					
					// Message( "Value: " + value );
					int x = 0, y = 0;
					switch( value )
					{
					case 0:
						x = -100;
						y = -80;
						break;
					case 1:
						x = -120;
						y = -110;
						break;
					case 2:
						x = -120;
						y = -120;
						break;
					case 3:
						x = -120;
						y = -100;
						break;
					case 4:
						x = -90;
						y = -110;
						break;
					case 5:
						x = -100;
						y = -110;
						break;
					case 6:
						x = -60;
						y = -125;
						break;
					case 7:
						x = -120;
						y = -120;
						break;
					default:
						break;
					}

					arrow[ value ].Draw( __MouseX + x, __MouseY + y );

					uint localMapPid = choo.StatBase[ ST_LOCALMAP_PID ];

					if( value != choo.StatBase[ ST_LOCALMAP_DIR ] )
					{
						RunServerScriptUnsafe( "globalmap_group@unsafe_GetMapPid", item.HexX, item.HexY, item.GetProtoId(), null, null );
					}
					
					localMapPid++;
					
					string mapName = GetMsgStr( TEXTMSG_GM, localMapPid * 10 + 8 );
					bool isRed = ( mapName == "error" ) || ( localMapPid == 0 );
					if( mapName == "error" ) 
					{
						mapName = GetMsgStr( TEXTMSG_GAME, STR_MAP_UNAVAILABLE );
					}
					DrawText( localMapPid != 0 ? mapName : GetMsgStr( TEXTMSG_GAME, STR_MAP_WASTELAND ), __MouseX - ( localMapPid != 0 ? mapName.length() * 7 : 45 ), __MouseY + 20, 400, 20, isRed ? COLOR_RED : COLOR_LGREEN, FONT_BIG, 0 );
				}
			}
        }
        // Hex attack
        if( __IsHexAttack && GetCurrentCursor() == CURSOR_USE_WEAPON )
        {
			int tohit = to_hit_hex( __ctrlDown );
            if( tohit > 0 )
			{
                DrawText( tohit + "%", __MouseX + 6, __MouseY + 6, ( ( tohit / 10 >= 1 ? 2 : 1 ) + 2 ) * 10, 10, COLOR_RED, FONT_FALLOUT, 0 );
			}
			
			CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
			if( valid( target ) && isGM( choo ) )
			{
				string sub_info;
				sub_info = target.Stat[ ST_CURRENT_HP ] + " / " + target.Stat[ ST_MAX_LIFE ];
				DrawText( sub_info, __MouseX + 6, __MouseY - 18, sub_info.length() * 10, 10, COLOR_GREEN, FONT_FALLOUT, FT_BORDERED );
				
				sub_info = target.Stat[ ST_CURRENT_AP ] + " / " + target.Stat[ ST_ACTION_POINTS ];
				DrawText( sub_info, __MouseX + 12, __MouseY - 6, sub_info.length() * 10, 10, COLOR_LBLUE, FONT_FALLOUT, FT_BORDERED );
			}
        }
        if( __ShowTimeouts )
		{
            show_timeouts();
		}
	}
    else if( layer == 4 )
	{
	}
    else if( layer == 5 )
    {
        int active_screen = GUI_GetActiveScreen();
        bool show = !__IsTextInput && active_screen == CLIENT_MAIN_SCREEN_GAME; //&& !__ConsoleActive
        //send positions of players' sprites, send empty if gui is active
        //overlay_loop(show);
    }
    else if( layer == 100 && __GmapActive )
    {
        render_global_map();
    }
}

void render_global_map()
{
    CritterCl@ ch = GetChosen();
    if( valid( ch ) )
    {
        // Here you can draw on global map

        // bool  __GmapActive - is global map active and all coords below are correct?
        // bool  __GmapWait   - encounter reply mode is active
        // float __GmapZoom   - current zoom, dont forget to accont for it whie drawing map
        // int   __GmapOffsetX/Y   - offset from 0 coodinate (top-left corner);
        // int   __GmapGroupCurX/Y - player group coordinates;
        // int   __GmapGroupToX/Y  - destination coordinates;
        // float __GmapGroupSpeed  - current group speed.
        // example of current group pixel calculation:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.

        int flags = ( FT_NOBREAK | FT_CENTERX | FT_CENTERY | FT_BORDERED );
        int font = FONT_FALLOUT;

        float size = 10 / __GmapZoom;

        uint16 chx = __GmapGroupCurX / 10, chy = __GmapGroupCurY / 10;

        if( @data_color != null && __global & CONF_GLOB_WILD != 0 )
        {
            int len = data_color.length();

            if( len > 0 && len % 2 == 0 )
            {
                int[] drawData( len * 18 / 2 );

                for( int i = 0, j = 0; i < len / 2; j++ )
                {
                    int x = ( data_color[ j * 2 ] & 0xFFFF );
					int y = ( ( data_color[ j * 2 ] >> 16 ) );

                    x = int( x * 10 / __GmapZoom + __GmapOffsetX );
                    y = int( y * 10 / __GmapZoom + __GmapOffsetY );

                    int a = data_color[ j * 2 + 1 ];

                    int k = i * 18;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = int( x + size );
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = int( y + size );
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = int( y + size );
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = int( x + size );
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = int( x + size );
                    drawData[ k++ ] = int( y + size );
                    drawData[ k++ ] = a;

                    i++;
                }
                drawData.resize( len * 18 / 2 );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLELIST, drawData );
            }
        }

        if( size > 10 && __global & CONF_GLOB_GRID != 0 )
        {
            int alpha = CLAMP( int( ( size - 5 ) * 20 ), 0, 0xAA );
            int r = 0x22, g = 0x22, b = 0x22;
            r = CLAMP( r, 0, 0xFF );
            g = CLAMP( g, 0, 0xFF );
            b = CLAMP( b, 0, 0xFF );
            int color = ( ( alpha ) << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );

            int x0 = __GmapOffsetX;
            int y0 = __GmapOffsetY;
            int x = int( ZONE_COUNT_X * ZONE_LENGTH / __GmapZoom + __GmapOffsetX );
            int y = int( ZONE_COUNT_Y * ZONE_LENGTH / __GmapZoom + __GmapOffsetY );

            int w = ZONE_COUNT_X * ZONE_LENGTH / 10;
            int h = ZONE_COUNT_Y * ZONE_LENGTH / 10;

            int[] drawData( ( w + h + 2 ) * 6 );

            for( int i = 0; i <= h; i++ )
            {
                drawData[ i * 6 ] = x0;
                drawData[ i * 6 + 1 ] = int( y0 + size * i );
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x;
                drawData[ i * 6 + 4 ] = int( y0 + size * i );
                drawData[ i * 6 + 5 ] = color;
            }
			
            for( int j = 0; j <= w; j++ )
            {
                int i = h + 1 + j;
                drawData[ i * 6 ] = int( x0 + size * j );
                drawData[ i * 6 + 1 ] = y0;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = int( x0 + size * j );
                drawData[ i * 6 + 4 ] = y;
                drawData[ i * 6 + 5 ] = color;
            }
            DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
        }

        if( size >= 5 )
        {
            int x = int( ( chx * 10 ) / __GmapZoom + __GmapOffsetX );
			int y = int( ( chy * 10 ) / __GmapZoom + __GmapOffsetY );
			int color = int( 0xAA00FFFF );

			int[]  drawData =
			{ 
				x + 1, y + 1, color,
				int( x + size - 1 ), y + 1, color,
				int( x + size - 1 ), int( y + size - 1 ), color,
				x + 1, int( y + size - 1 ), color,
				x + 1, y + 1, color
			};
			DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
        }

        if( @data_number != null )
        {
            int len = data_number.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( int i = 0; i < len / 2; i++ )
                {
                    int x = data_number[ i * 2 ] & 0xFFFF;
                    int y = data_number[ i * 2 ] >> 16;

                    x = int( x * 10 / __GmapZoom + __GmapOffsetX );
                    y = int( y * 10 / __GmapZoom + __GmapOffsetY );
                    int a = data_number[ i * 2 + 1 ] & 0xFFFF;
                    int b = data_number[ i * 2 + 1 ] >> 16;

                    string str = a;
                    if( b > 0 )
					{
                        str += "+" + ( b - a );
					}
					
					int alpha = MIN( int( 2000.0f / size ), 0x88 );
					int color = 0x00FFAA00 | ( ( alpha ) << 24 );

					int[]  drawData =
					{
						x + 1, y + 1, color,
						int( x + size - 1 ), y + 1, color,
						x + 1, int( y + size - 1 ), color,
						int( x + size - 1 ), int( y + size - 1 ), color
					};
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
                    
					int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), int( size + tw ), int( size + tw ), 0xFF22AAFF, font, flags );
                }
            }
        }

        if( @data_char != null )
        {
            int len = data_char.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( int i = 0; i < len / 2; i++ )
                {
                    int x = ( data_char[ i * 2 ] & 0xFFFF );
                    int y = ( ( data_char[ i * 2 ] >> 16 ) );

                    x = int( x * 10 / __GmapZoom + __GmapOffsetX );
                    y = int( y * 10 / __GmapZoom + __GmapOffsetY );
                    int a = ( data_char[ i * 2 + 1 ] & 0x00FFFFFF ) | 0xFF000000;
                    int b = data_char[ i * 2 + 1 ] >> 24;

                    string str = " ";
                    str[ 0 ] = b;

                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), int( size + tw ), int( size + tw ), a, font, flags );
                }
            }
        }

		int x = int( ( __MouseX - __GmapOffsetX ) * __GmapZoom );
		int y = int( ( __MouseY - __GmapOffsetY ) * __GmapZoom );

		x -= x % 10;
		y -= y % 10;

		string str = floor( x / 10 ) + " : " + floor( y / 10 );

		x = int( x / __GmapZoom + __GmapOffsetX );
		y = int( y / __GmapZoom + __GmapOffsetY );

		if( size >= 5 )
		{
			int[] drawData =
			{
				x + 1, y + 1, int( COLOR_RED ),
				int( x + size - 1 ), y + 1, int( COLOR_RED ),
				int( x + size - 1 ), int( y + size - 1 ), int( COLOR_RED ),
				x + 1, int( y + size - 1 ), int( COLOR_RED ),
				x + 1, y + 1, int( COLOR_RED )
			};
			DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
		}

		int tw = 0, th = 0, lines = 0;

		GetTextInfo( str, 0, 0, font, FT_NOBREAK, tw, th, lines );
		DrawText( str, __MouseX + 30, __MouseY + 10, tw, th, COLOR_LGREEN, font, FT_NOBREAK );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    DrawMapTiles();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down( FOWindow@ window, int click )
{
	if( window !is MainWindow )
		return false;
		
    return GUI_MouseDown( click, __MouseX, __MouseY );
}

bool mouse_up( FOWindow@ window, int click )
{
	if( window !is MainWindow )
		return false;
		
    return GUI_MouseUp( click, __MouseX, __MouseY );
}

void mouse_move( FOWindow@ window, int x, int y )
{
	if( window !is MainWindow )
		return;
		
    GUI_MouseMove( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.

bool AltDown = false;
bool key_down( FOWindow@ window, uint8 key )
{
	if( window !is MainWindow )
	{
		return false;
	}
	
	//F1 help
	if( key == DIK_F1 )
	{
		F1IsDraw = !F1IsDraw;
	}
	
	//F9 item countour
	if( key == DIK_F9 )
	{
		if( __ShowContourItems )
		{
			__ShowContourContainer = false;
			__ShowContourItems = false;
		}
		else
		{
			__ShowContourContainer = true;
			__ShowContourItems = true;
		}
		ChosenRefreshMap();
	}	
	
	CritterCl@ chosen = GetChosen();
	if( chosen !is null )
	{
		//F10 wall + roof transparency
		if( key == DIK_F10 )
		{
			if( __WallAlpha <= 200 )
			{
				__WallAlpha = 255;
				__ShowWall = true;
			}
			else
			{
				__WallAlpha = chosen.Param[ WALL_ALPHA ];
				__ShowWall = __WallAlpha > 0 ? true : false;
			}
			
			__RoofAlpha = __WallAlpha;
			__ShowRoof = __ShowWall;
			ChosenRefreshMap();
		}
		
		if( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys && !__ConsoleActive )
		{
			if( !__ctrlDown )
			{
				switch( key )
				{
					case( DIK_C ):
					case( DIK_F ):
					case( DIK_I ):
					case( DIK_O ):
					case( DIK_P ):
					case( DIK_S ):
						return true;
				}
			}
		}

		if( !( FLAG( chosen.Param[ PLAYER_FLAGS ], PLAYER_FLAG_RTS ) && __mobhotkeys ) && !__ConsoleActive && WASDInputKeyState( key, true ) )
		{
			return true;
		}
		
		/*if( __ctrlDown && key == DIK_O )
		{
			//show or hide overlay
			overlay_visibility();
			return true;
		}*/
		
		if( __ConsoleActive )
		{
			if( valid( chosen ) )
			{
				if( key != DIK_RETURN )
				{
					if( chosen.Param[CR_TYPING_TIME] < int( __FullSecond + __TypingDelay ) )
					{
						RunServerScriptUnsafe( "rp_chat@unsafe_ShowTyping", 0, 0, 0, null, null );
					}
				}
				else
				{
					if( chosen.Param[CR_TYPING_TIME] > int( __FullSecond + __TypingDelay ) )
					{
						RunServerScriptUnsafe( "rp_chat@unsafe_stopTyping", 0, 0, 0, null, null );
					}
				}
			}
		} 

		if( __waiting )
		{
			if( valid( chosen ) )
			{
				if( __ConsoleActive ) 
				{
					bool key_disallowed = ( key == DIK_ESCAPE );
					return key_disallowed;
				}
				else
				{
					if( key == DIK_RETURN )
					{
						__ConsoleActive = true;
						return true;
					}
				}

				if( key == DIK_ESCAPE || key == DIK_SPACE )
				{
					RunServerScriptUnsafe( "ltp@unsafe_StopProcess",  0, 0, 0, null, null );
				}
				
				return true;
			}
			else
			{
				__waiting = false;
			}
		}
	}

    // Effect example, temporary
    if( key == DIK_LMENU || key == DIK_RMENU )
	{
        AltDown = true;
	}
	
    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
	{
        __ctrlDown = true;
	}
	
    if( key == DIK_Z && !__ctrlDown && !AltDown )
	{
        __MapZooming = true;
    }
	
	if( GUI_KeyDown( key ) )
	{
		// Hotkey consumed
		return true;
	}
	else
	{
		// disable hardcoded date and time hotkey
		if( key == DIK_SLASH && _MainScreen==CLIENT_MAIN_SCREEN_GAME && !__ConsoleActive && !__IsTextInput && !__ctrlDown && !AltDown )
		{
			RunServerScriptUnsafe( "time@unsafe_getIngameTime", 0, 0, 0, null, null );
			return true;
		}
	}
    return false;
}

bool key_up( FOWindow@ window, uint8 key )
{
	if( window !is MainWindow )
		return false;
		
    if( WASDInputKeyState( key, false ) )
	{
        return true;
    }

    if( key == DIK_LMENU || key == DIK_RMENU )
	{
        AltDown = false;
    }
	
	if( key == DIK_LCONTROL || key == DIK_RCONTROL )
	{
        __ctrlDown = false;   
	}
	
    if( __waiting )
	{
        return !__ConsoleActive;
	}
	
    if( key == DIK_Z && !__ctrlDown && !AltDown )
	{
        __MapZooming = false;
	}
    return GUI_KeyUp( key );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost( FOWindow@ window )
{
	if( window !is MainWindow )
		return;
		
    AltDown = false;
    __ctrlDown = false;
    __MapZooming = false;

    GUI_InputLost();
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in( CritterCl& cr )
{
	if( !valid( cr ) )
	{
		return;
	}
	
    CritterCl@ ch = GetChosen();
    if( valid( ch ) && ch.Id == cr.Id && prevId != cr.Id )
    {
        @data_number = null;
        @data_color = null;
        @data_char = null;
        LoadNames();
        prevId = cr.Id;

		updateNick( cr );
		
		updateSINF();
		initControlPanel();
    }

    updateNick( cr );

    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED );

	if( valid( ch ) && SameFaction( ch, cr ) )
	{
		cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_GREEN : COLOR_CONTOUR_BLUE );
	}
	
	checkCritterControl( cr );

   // if( __fastPanel )
	//{
       // HidePanel( true );
   // }
}

void critter_out( CritterCl& cr )
{
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{
	#ifndef PHYSICAL_UI
        iList().add( item );
    #endif //PHYSICAL_UI
}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{
    #ifndef PHYSICAL_UI
	    iList().change( itemNow, itemBefore );
    #endif //PHYSICAL_UI
}

void item_map_out( ItemCl& item )
{
    #ifndef PHYSICAL_UI
	    iList().remove( item );
    #endif //PHYSICAL_UI
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{
	if( item.GetType() == ITEM_TYPE_CONTAINER )
	{
		RunServerScriptUnsafe( "main@unsafe_ItemsWeight", item.Id, 0, 0, null, null );
  	}
}

void item_inv_out( ItemCl& item )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop( ItemCl& item )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
string last_radio_message = "";
bool last_radio_message_recieved = true;
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    if(message == "")
	{
		return false;
	}
	
    // Detect radio
    if( color == 0xFFFFFFFE )
	{
        MapMessage(message, hexX, hexY, color, delay);
        message = ".." + message + "..";
		
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			if( !last_radio_message_recieved )
			{
				Message( "|0xFFFFFF " + last_radio_message );
            }
			else
			{
				last_radio_message_recieved = false;
			}
			last_radio_message = message;
		}
	}
		
	if( color == COLOR_GRAY )
	{
        Message("|0x8F8F8F " + message );
	}
	
	if( color == COLOR_LGRAY )
	{
        Message("|0xD3D3D3 " + message );
	}
	
	if( color == COLOR_TEXT || color == COLOR_CHAT_SHOUT )
	{
        MapMessage(message, hexX, hexY, color, delay);
		Message( "???: " + message );
	}

    if (message == "")
	{
		return false;
	}
	
	return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{
    if(message == "")
	{
		return false;
	}
	
    if( sayType > SAY_RADIO )
	{
		return true;
	}

    if(!InMessage(message, sayType, critterId, delay))
	{
        return false;
    }

	CritterCl@ receiver = GetChosen();

    //send message to overlay, for logging and avatar position adjustment
    //overlay_message(message, sayType, critterId, delay);
	
    if( sayType == SAY_RADIO )
	{
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			last_radio_message = ".." + message + "..";
		}
		else
		{
			last_radio_message_recieved = true;
		}
		
        return true;	// for work radio and service messages
	}

    if( ( __sinf & SINF_CRID_CHAT ) != 0 && critterId != 0 && sayType <= SAY_WHISP_ON_HEAD )
    {
        message = "[" + critterId + "] " + message;
    }
	
    if( ( __sinf & SINF_INSIGHT ) != 0 )
	{
        return true;
	}

	return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message( string& message, int& sayType )
{
    if(message == "")
	{
		return false;
	}
	
	bool result = OutMessage(message, sayType);
    if(message == "")
	{
		return false;
    }
	return result;
}

bool out_command( string& message, int& sayType )
{
	
    if( __MessagePrefix != "" )
    {
        message = __MessagePrefix + " " + message;
        __MessagePrefix = "";
    }

    if( __IsHotkeysUse )
	{
        __IsTextInput = true;
	}

    if( message[ 0 ] == '%' ) // Command
	{
		string@[] @ valuesStr = splitEx( message, " " );
		int p0 = 0, p1 = 2, p2 = 6;
		if( valuesStr.length() == 2 ) 
		{
			if( !StrToInt( valuesStr[ 1 ], p0 ) )
			{
				string[] letters = { "S", "P", "E", "C", "I", "A", "L" };
				p0 = letters.find( valuesStr[ 1 ] ) + 1;
			}
		}
		
		if( valuesStr.length() == 3 ) 
		{
			StrToInt( valuesStr[ 1 ], p1 );
			StrToInt( valuesStr[ 2 ], p2 );
		}
		
		CritterCl@ chosen = GetChosen();
		CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
		if( isGM( chosen ) && valid( target ) )
		{
			int[] vals = { p0, p1, p2, target.Id };
			RunServerScriptUnsafe( "general_unsafe@unsafe_rolling_GM", 0, 0, 0, null, vals );
			return false;
		}
		RunServerScriptUnsafe( "general_unsafe@unsafe_rolling", p0, p1, p2, null, null );
		return false;
	}
	
	if( message[ 0 ] == '~' ) // Command
    {
		CritterCl@ chosen = GetChosen();
		if( findFirst( message, "~ilex" ) != -1 )
		{
			if( !chosen.IsLife() )
			{
				return false;
			}
			
			ItemCl@ hand = _CritGetItemHand( chosen );
			if( !valid( hand ) )
			{
				return false;
			}
			
			string current_lexem = hand.Lexems;
			if( current_lexem.length() >= 27 )
			{
				uint remaining = 127 - current_lexem.length();
				Message( "|0xFFFF00" + GetMsgStr( TEXTMSG_GAME, STR_ITM_LEX_WARN ) + remaining + GetMsgStr( TEXTMSG_GAME, STR_SYMBOLS ) );
			}
			
			string new_lexem = "";
			
			if( message.length() > 5 )
			{
				new_lexem = substring( message, 6, message.length() - 6 );
			}
			
			if( new_lexem.length() != 0 )
			{
				new_lexem = current_lexem + new_lexem;
			}
			RunServerScriptUnsafe( "general_unsafe@unsafe_addLexem", 0, 0, 0, new_lexem, null );
			return false;
		}
		
		if( message == "~sex" )
		{
			__InitSex( 0, 0, 0, null, null );
			return false;
		}
		
		if( message == "~eat" )
		{
			CritterCl@ choo = GetChosen();
			if( choo.Stat[ ST_BODY_TYPE ] != BT_MEN && choo.Stat[ ST_BODY_TYPE ] != BT_WOMEN && choo.Stat[ ST_BODY_TYPE ] != BT_CHILDREN )
			{
				__InitDevour( 0, 0, 0, null, null );
			}
			
			return false;
		}
		
		if( message == "~toglobal" ) //move to GM
		{
			if( isGM( chosen ) ) 
			{
				RunServerScriptUnsafe( "general_unsafe@unsafe_toglobal", 0, 0, 0, null, null );
				return false;
			}
		} 
		
		if( message == "~suicide" )
        {
            RunServerScriptUnsafe( "suicide@unsafe_killself", 0, 0, 0, "", null );
            return false;
        }
		
		if( message == "~naked" )
		{
            RunServerScriptUnsafe( "general_unsafe@unsafe_getNaked", 0, 0, 0, "", null );
            return false;
		}

		string@[]@ parts = split( message, " " );

		if( parts[0] == "~name" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 6 )
			{
				text = substring( message, 6, message.length() - 6 );
			}
			
			CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
			if( valid( target ) )
			{
				RememberName( target.Id, text );
			}
			return false; 
		}

		if( parts[0] == "~lex" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 )
			{
				text = substring( message, 5, message.length() - 5 );
			}
			RunServerScriptUnsafe( "general_unsafe@unsafe_selfLex", 0, 0, 0, text, null ); 
			return false; 
		}

		if( parts[0] == "~afk" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 )
			{
				text = substring( message, 5, message.length() - 5 );
			}
			RunServerScriptUnsafe( "general_unsafe@unsafe_setAFK", 0, 0, 0, text, null ); 
			return false; 
		}

		if( message == "~sf" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 1, 0, 0, "", null );
            return false;
        }

        if( message == "~sb" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 0, 0, 0, "", null );
            return false;
        }
		
        if( parts[0] == "~roofs" )
        {
            if( parts.length() > 1 )
            {
                int alpha = -1;
                if( StrToInt ( parts [ 1 ], alpha ) )
                {
                    if( alpha > -1 )
                    {
                        alpha = MIN( alpha, 255 );
                        __RoofAlpha = alpha;
                    }
                }
            }
            return false;
        }

        return true;
    }

    if( message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' ) // tnf commands
    {
		CritterCl @target = GetMonitorCritter( __MouseX, __MouseY );
		string targetInfo = valid( target ) ? "[" + target.Name + " #" + target.Id + "]" : "";
        RunServerScriptUnsafe("general_unsafe@unsafe_log", 0, 0, 0, GetChosen().Name + " #" + GetChosen().Id + " " + targetInfo + " - " + message, null);
        return gm_msg(message);
    }

    Message( "|0xFFFF00" + GetMsgStr( TEXTMSG_GAME, STR_COMMAND_NOT_FOUND ) );
    return false;
}

bool out_speak( string& message, int& sayType )
{
    CritterCl@ chosen = GetChosen();
    if( chosen.IsDead() && sayType != SAY_NARATIVE )
    {
        Message( GetMsgStr( TEXTMSG_GAME, STR_DEAD_CANT_TALK ) );
        return false;
    }

    //Check for chars other than space
	bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != ' ' )
        {
            result = true;
            break;
        }
    }
	if( result == false )
	{
		return false;
	}
	
  	//Shaman radio listeners
    if( chosen !is null && ( SAY_NORM == sayType || SAY_SHOUT == sayType || SAY_WHISP == sayType || SAY_RADIO == sayType ) )
	{
        RunServerScriptUnsafe( "radio@unsafe_OutMessage", sayType, 0, 0, message, null );
    }
	
	switch( sayType )
	{
		case( SAY_NORM ): 	
		case( SAY_EMOTE ): 	
		case( SAY_NARATIVE ):
			break;
		case( SAY_WHISP ):
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );
			break;
		case( SAY_SHOUT ):
			RunServerScriptUnsafe( "rp_chat@unsafe_shout_all", 0, 0, 0, message, null);
			break;
		case( SAY_RADIO ):
		{
			RunServerScriptUnsafe( "general_unsafe@unsafe_radioHead", 0, 0, 0, message, null );
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Radio", 0, 0, 0, message, null ); 
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );
			break;
		}
		default: Message( "Unhandled sayType: " + sayType ); return false;
	}

	int[] controlled_npcs = control();
	//Gray text and ability to speak for targeted crit
	if( sayType != SAY_RADIO && ( controlled_npcs.length() > 0 || sayType == SAY_NARATIVE ) )
	{
		uint16 hexX = 0, hexY = 0;
		GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
		RunServerScriptUnsafe( "rp_chat@unsafe_SayChatMessage", sayType, hexX, hexY, message, controlled_npcs );
		return false; //does not send standard way, script intercept message
	}

	//Serverside - record into SayLog.txt
	RunServerScriptUnsafe( "rp_chat@unsafe_SayLog", sayType, 0, 0, message, null );

	if( chosen.IsKnockout() && sayType < SAY_NARATIVE ) 
	{
		RunServerScriptUnsafe( "general_unsafe@unsafe_KnockSay", sayType, 0, 0, message, null ); 
		return false; 
	}

	return true;
}

bool to_hit_hex_enable()
{
    CritterCl@ chosen = GetChosen();
    if( !chosen.IsLife() )
	{
        return false;
	}
	
    CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
    if( valid( target ) && !target.IsDead() ) //there are other methods doing this
	{
        return false;
	}
	
    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );
    if( tx == 0 && ty == 0 )
	{
        return false;
	}
	
	ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
	if( valid( item ) && ( item.HexX != tx && item.HexY != ty ) )
	{
		return false;
	}
	return true;
}

// Hex attack
int to_hit_hex( bool anyway )
{
	if( !anyway && !to_hit_hex_enable() )
	{
		return 0;
	}
	
	CritterCl@ chosen = GetChosen();

	CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );

    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );

	ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
	
    ItemCl@ realWeapon = _CritGetItemHand( chosen );

    uint8 mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) && valid( realWeapon ) )
	{
        @weapon = GetProtoItem( realWeapon.Proto.ProtoId );
	}
	
	if( !valid( weapon ) )
	{
		return 0;
	}
	
    uint skillNum = _WeaponSkill( weapon, mode );
    int dmgType = _WeaponDmgType( weapon, mode );

    bool isRocket = valid( realWeapon ) && ( ( realWeapon.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( realWeapon.AmmoPid == PID_ROCKET_AP ) || ( realWeapon.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( realWeapon.AmmoPid == PID_GRENADELAUNCHER_AMMO ) );

    int dist = GetDistantion( chosen.HexX, chosen.HexY, tx, ty );
	
    uint16 toHx = tx, toHy = ty;
    GetHexCoord( chosen.HexX,  chosen.HexY, toHx, toHy,  0.0f, dist );
    if( ( tx != toHx ) || ( ty != toHy ) )
	{
        return 0;
	}
	
    int wpnMaxDist = _WeaponMaxDist( weapon, mode );
    if( skillNum == SK_THROWING )
	{
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
	}
	
    if( dist > wpnMaxDist )
	{
        return 0;
	}
	
    int use = _WeaponModeUse( mode );

	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );

    int toHit = getFullSkill( chosen, null, skillNum, weaponSubtype ) - chosen.Param[ ST_PARALYSIS_LEVEL ] * 3 + 2 * _WeaponMaxDist( weapon, use ) - chosen.Param[ ST_DRUNK ];
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;


    int distmod1 = 2; // used for initial weapon bonus
    int distmod2 = 0; // minimal distance
    if( weaponPerk == WEAPON_PERK_LONG_RANGE )
	{
        distmod1 = 4;
    }
	else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = chosen.Stat[ ST_PERCEPTION ];
    int acc = dist;

    if( dist < distmod2 )
	{
        acc += distmod2;
    }
	else
    {
        if( chosen.IsPlayer() )
		{
            acc -= ( perception - 2 ) * distmod1; 
        }
		else
		{
            acc -= perception * distmod1;
		}
	}

    if( -2 * perception > acc )
	{
        acc = -2 * perception;
	}
	
    if( acc >= 0 )
    {
        if( chosen.Damage[ DAMAGE_EYE ] != 0 )
		{
            acc *= -12;
        }
		else
		{
            acc *= -4;
		}
	}
    else
	{
        acc *= -4;
	}
	
    toHit += acc;
    blockers = GetCrittersPath( chosen.HexX, chosen.HexY, tx, ty, 0.0f, dist, FIND_LIFE, null ); // + map
    toHit -= 10 * blockers;

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;

    if( handlingStrength < reqStrength )
	{
        toHit -= ( reqStrength - handlingStrength ) * 20;
    }
	
	if( weaponPerk == WEAPON_PERK_ACCURATE )
	{
        toHit += 20;
	}
	
	int aim = _WeaponModeAim( mode );
	if( aim == HIT_LOCATION_NONE && _WeaponAim( weapon, mode & 0x0F ) )
	{
		aim = chosen.ParamBase[CR_AUTO_AIM];
	}
	
    uint16 ammoRound = _WeaponRound( weapon, use );
	bool isBurst = ammoRound > 1;
	if( isBurst )
	{
		aim = HIT_LOCATION_UNCALLED;
	}
	
    int hitMod = GetHitAim( aim );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
	{
        hitMod /= 2;
    }
	toHit -= hitMod;

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
	{
        toHit -= 25;
    }
	toHit = CLAMP( toHit, 5, 95 );

    return toHit;

}
// //////////////////////////////////////////////////////////////////////////////////////////////////
//REVISE - MAKE MUTUAL MODULE
int getFullSkill( CritterCl& cr, CritterCl@ target, int skillNum, uint8 weaponSubtype )
{
    int   skillVal = cr.Skill[ skillNum ];

    if( cr.IsPlayer() )
    {
        if( weaponSubtype == WS_GUN )
        {
            if( skillNum == SK_SMALL_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
                }
            }

            if( skillNum == SK_BIG_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 3;
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP; 
                }
            }

            if( skillNum == SK_ENERGY_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 2;
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
                }
            }
        }
        else
        {
            if( skillNum == SK_UNARMED && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
				{
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
				}
			}

            if( skillNum == SK_MELEE_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 2;
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
				{
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
				}
			}

            if( skillNum == SK_THROWING && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
				{
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
				}
			}
        }
    }
	
	return skillVal;
}

// To-hit chance. REVISE - MAKE MUTUAL MODULE
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int hitLocation = _WeaponModeAim( weaponMode );
	if( hitLocation == HIT_LOCATION_NONE && _WeaponAim( weapon, weaponMode & 0x0F ) )
	{
		hitLocation = chosen.ParamBase[CR_AUTO_AIM];
	}
	
    int use = _WeaponModeUse( weaponMode );
    uint16 ammoRound = _WeaponRound( weapon, use );
	bool isBurst = ammoRound > 1;
	if( isBurst )
	{
		hitLocation = HIT_LOCATION_UNCALLED;
	}
    if( use > 2 )
	{
        return 0;
	}
	
    if( target.IsDead() )
	{
        return 0;
	}
	
    if( !chosen.IsLife() )
	{
        return 0;
	}
	
    ItemCl@ realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
	{
        if( realWeapon.AmmoCount == 0 )
		{
            return 0;
        }
		@ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    uint skillNum = _WeaponSkill( weapon, use );
	
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
    int skillVal = getFullSkill( chosen, target, skillNum, weaponSubtype ) - chosen.Param[ ST_PARALYSIS_LEVEL ] * 3 + 2 * _WeaponMaxDist( weapon, use ) -  chosen.Param[ ST_DRUNK ];
    int wpnMaxDist = _WeaponMaxDist( weapon, use );

    // Roleplay
    int dist = GetCrittersDistantion( chosen, target );
    if( dist > wpnMaxDist )
	{
        return 0;
	}
	
    int toHit = skillVal;
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        int distmod1 = 2;
        int distmod2 = 0;
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
		{
            distmod1 = 4;
        }
		else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
		{
            acc += distmod2;
		}
		else
        {
            if( chosen.IsPlayer() )
			{
                acc -= ( perception - 2 ) * distmod1; 
            }
			else
			{
                acc -= perception * distmod1;
			}
		}

        if( -2 * perception > acc )
		{
            acc = -2 * perception;
		}

        if( acc >= 0 )
        {
            if( chosen.Damage[ DAMAGE_EYE ] != 0 )
			{
                acc *= -12;
            }
			else
			{
                acc *= -4;
			}
		}
        else
		{
            acc *= -4;
		}
		
        toHit += acc;

        blockers = GetCrittersPath( chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null );
        if( !target.IsKnockout() )
		{
            blockers--;
        }
		toHit -= 10 * blockers;
    }

    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;

    if( handlingStrength < reqStrength )
	{
        toHit -= ( reqStrength - handlingStrength ) * 20;
    }
	if( weaponPerk == WEAPON_PERK_ACCURATE )
	{
        toHit += 20;
	}
	
    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
	{
        acmod += ammo.Ammo_AcMod;
    }
	
	if( acmod > 0 )
	{
        toHit -= acmod;
	}

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
	{
        toHit -= 25;
	}   
	
    if( target.IsKnockout() )
	{
        toHit += 40;
	}
	
    int hitMod = GetHitAim( hitLocation );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
	{
        hitMod /= 2;
    }
	toHit -= hitMod;
	
	if( valid(target) && target.IsBusy() )
	{
		if( ( chosen.Dir ) % 6 != target.Dir )
		{
			toHit -= acmod / 2;
			if( hitLocation == HIT_LOCATION_HEAD )
				toHit -= acmod / 2;
		}
	}

	if( hitLocation == HIT_LOCATION_HEAD || hitLocation == HIT_LOCATION_EYES )
	{
		toHit = toHit * 50 / 100;
	}
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
		case HIT_LOCATION_NONE:
			break;
		case HIT_LOCATION_UNCALLED:
			break;
		case HIT_LOCATION_TORSO:
			return __HitAimTorso;
		case HIT_LOCATION_EYES:
			return __HitAimEyes;
		case HIT_LOCATION_HEAD:
			return __HitAimHead;
		case HIT_LOCATION_LEFT_ARM:
		case HIT_LOCATION_RIGHT_ARM:
			return __HitAimArms;
		case HIT_LOCATION_GROIN:
			return __HitAimGroin;
		case HIT_LOCATION_RIGHT_LEG:
		case HIT_LOCATION_LEFT_LEG:
			return __HitAimLegs;
		default:
			break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results. REVISE - MAKE MUTUAL MODULE
void combat_result( uint[]& data )
{
    CritterCl@ chosen = GetChosen();

	testInfo( CR_TEST_MODE_COMBAT, "Data: " + enlistUINT(data) );

    uint datalen = data.length();
    if( datalen < 4 )
	{
        return;
	}
	
    if( data[ 0 ] != datalen )
	{
        return;
	}
    uint current = 1;

    while( current < datalen )
	{
        int damage = -1;
        uint effect = 0;
        uint loc = 0;
        int message = -1;

        uint mode = data[ current++ ];
        uint who = data[ current++ ];
        uint who2;
        CritterCl@ originalTarget;

        CritterCl@ cr = GetCritter( who );
		CritterCl@ trueTarget = null;

        bool self = ( who == GetChosen().Id );
		
		bool isDead = true;

        string name = "error0";
        if( valid( cr ) )
		{
			if( !self )
			{
				name = cr.Name;
			}
			else
			{
				name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
			}
			isDead = !cr.IsPlayer();
        }

        uint offset;
        if( self )
		{
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
			{
                offset = 506;
			}
			else
			{
                offset = 556;
			}
		}
		else
		{
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
			{
                offset = 606;
			}
			else if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
			{
                offset = 656;
			}
			else
			{
				offset = 706;
			}
		}

        string result;

        // reading and preparing the data:
        switch( mode )
        {
			case( CMSG_CRIT_MISS ):
			{
				effect = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
				result = ReplaceText( result, "%s", name );
				break;
			}
			case( CMSG_CRIT_MISS_DAMAGE ):
			{
				effect = data[ current++ ];
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 ) {
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_HIT ):
			case( CMSG_HIT_DEAD ):
			{
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
				
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_AIMED_HIT ):
			case( CMSG_AIMED_HIT_DEAD ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );

				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_HIT ):
			{
				damage = data[ current++ ];
				effect = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_AIMED_HIT ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				effect = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_HIT_DEAD ):
			{
				damage = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_AIMED_HIT_DEAD ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_OOPS ):
			{
				who2 = data[ current++ ]; // who2 was hit instead of who
				@trueTarget = GetCritter( who2 );
				if( self )
				{
					// It was original target
					uint gender_info = CLAMP( cr.Stat[ ST_GENDER ], GENDER_MALE, GENDER_IT ) * 100;
					result = GetMsgStr( TEXTMSG_COMBAT, 608 + gender_info );
					string nameTrue = "error1";
					if( valid( trueTarget ) )
					{
						nameTrue = trueTarget.Name;
					}
					result = ReplaceText( result, "%s", nameTrue );
				}
				else
				{
					// It was not original target
					result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
					if( who2 == GetChosen().Id )
					{
						result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
					}
					else
					{
						string nameTrue = "error1";
						if( valid( trueTarget ) )
						{
							nameTrue = trueTarget.Name;
						}
						result = ReplaceText( result, "%s", nameTrue );
					}
					result = ReplaceText( result, "%s", name );
				}
				break;
			}
			case( CMSG_MISS ):
			{			
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
				result = ReplaceText( result, "%s", name );
				break;
			}
			case( CMSG_HIT_RANDOMLY ):
			{
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
				result = ReplaceText( result, "%s", name );
				result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
			}
			default:
				break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;
		uint[] exts;

        if( message != -1 && isVerbose )       // Must be critical hit
		{
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
		else if( effect != 0 )
		{
            offset -= 306;
			uint[] flags = { HF_KNOCKOUT, HF_KNOCKDOWN, HF_CRIPPLED_LEFT_LEG, HF_CRIPPLED_RIGHT_LEG, HF_CRIPPLED_LEFT_ARM, HF_CRIPPLED_RIGHT_ARM, HF_BLINDED, 
								0, 0, 0, 0, HF_BYPASS_ARMOR, 0, 0, HF_DROPPED_WEAPON, HF_STUNNED, 0, 0, 0, 0, 0, HF_RANDOM };
			uint len = flags.length();
            if( mode > CMSG_CRIT_MISS_DAMAGE )
			{         // Hit flags
            	for( uint x = 0; x < len; x++ )
				{
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
				}
			}
			else
			{
				for( uint x = 0; x < len; x++ )
				{
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
				}
				
                if( FLAG( effect, MF_WAS_KILLED ) )
				{
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) ) );
					exts.insertLast( offset + ( isDead ? 7 : 0 ) );
				}
            }
            offset += 306;
        }

		if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
		{
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) );
			exts.insertLast( offset + ( isDead ? 7 : 0 ) - 306 );
		}

		uint n = ext.length();
		testInfo( CR_TEST_MODE_COMBAT, "Ext.length = " + n );

        for( uint m = 0; m < n; m++ )
		{
            if( m == n - 1 )
			{
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            }
			else
			{
                result += ", ";
			}
			
            result += valid( ext[m] ) ? ext[m] : "[" + m + "#" + exts[m] + "]" ;
			
			testInfo( CR_TEST_MODE_COMBAT, "#" + m + ":" + exts[m] + ": " + checkNull(ext[m]) + ";" );
        }

        result += ".";

		bool MyHit = chosen.Id == data[++current]; current++;
        Message( ( MyHit ? "|0xF5D742 " : "" ) + result, FOMB_COMBAT_RESULT );

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
		{
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) + ".", FOMB_COMBAT_RESULT );
		}
        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
		{
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
		}
	}
}

string generic_description_slot_maker( int slot )
{
	string result;
	string[] lines = generic_description_slot( slot );
	int l = lines.length();
	for( int i = 0; i < 6; i++ )
	{
		if( i < l && valid( lines[i] ) )
		{
			result += lines[i];
		}
		
		result += "\n";
	}
	return result;
}

string[] generic_description_slot( int slot )
{
	CritterCl@ chosen = GetChosen();

	string line;
	string[] result;

	result.insertLast( "|0x3CF800 -----------------------" );
	
	ItemCl@ item = null; 
	if( slot == SLOT_HAND1 )
	{
		@item = _CritGetItemHand( chosen );
	}
	else
	{
		@item = _CritGetItemHandExt( chosen );
	}
	
	if( !valid( item ) )
	{
		uint8 mode = 0;
		int bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
		ProtoItem@ unarmed = chosen.GetSlotProto( slot, mode );
		result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) );
		result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + "|0xFFFF00  "
							+ ( _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + bonus ) + "|0x3CF800  - " + "|0xFFFF00 "
							+ ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + bonus ) 
						);

		return result;
	}
	
	int use = _WeaponModeUse( item.Mode );
	if( use > 2 )
	{
		use = 0;
	}
	
	result.insertLast( getItemTextName( itemText( item ) ) );

	if( item.GetType() != ITEM_TYPE_WEAPON )
	{
		if( item.GetType() == ITEM_TYPE_TRAP )
		{
			result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + "|0xFFFF00  " + item.Proto.Weapon_DmgMin_0 
				+  "|0x3CF800  - |0xFFFF00 " + item.Proto.Weapon_DmgMax_0 );
			result.insertLast( "|0x3CF800 " + ( item.Proto.Blast_Radius > 0 ? 
				( GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS_TRAP ) + "|0xFFFF00 " + item.Proto.Blast_Radius + "|0x3CF800  " ) : "" ) );
			
			result.insertLast( GetMsgStr( TEXTMSG_GAME, STR_INV_DAMAGE ) + GetMsgStr( TEXTMSG_GAME, STR_INV_DAMAGE_TYPE( item.Proto.Weapon_DmgType_0 ) ) );
		}
		else if( item.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
		{
			switch( item.BONDAGE_STATE )
			{
				case( BONDAGE_STATE_ON ):
					line = GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_BONDS );
					break;
				case( BONDAGE_STATE_BROKEN ):
					line = GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
					break;
				default:
					line = GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_READY );
					break;
			}
			result.insertLast( line + "|0x3CF800 " );
		}
		
		if( item.GetCount() > 1 )
		{
			result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE ) + "|0xFFFF00 " + item.GetCount() ); 
		}

		return result;
	}

	bool isAmmoRegen = ( item.GetProtoId() == PID_SOLAR_SCORCHER ) || ( item.GetProtoId() == PID_SUN ) || ( item.GetProtoId() == PID_SUN2 ) || ( item.GetProtoId() == PID_SUN3 )
						|| ( item.GetProtoId() == PID_FIRE_GECKO_FLAME_WEAPON );
	uint DmgMult = 1;
	uint DmgDiv = 1;
	uint16 ammoRound = _WeaponRound( item.Proto, use );
	bool isBurst = ammoRound > 1;
	uint16 AmmoPid;
	
	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		if( !isAmmoRegen )
		{
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( valid ( AmmoProto ) )
			{
				DmgMult = AmmoProto.Ammo_DmgMult;
				DmgDiv = AmmoProto.Ammo_DmgDiv;
			}
		}
	}
	
	int bonus = 0;
	uint skill = _WeaponSkill( item.Proto, use );
	
	if( skill == SK_UNARMED || skill == SK_MELEE_WEAPONS )
	{
		bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
	}
	
	uint8 weapon_Subtype = item.Proto.Item_Subtype;
	if( skill == SK_THROWING && ( weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) )
	{
        bonus = chosen.Stat[ ST_MELEE_DAMAGE ] / 2;
	}
	
	line = GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
	
	if( ( ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_MELEE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_MELEE_END ) 
			|| ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END ) )
			&& item.IsDeteriorable() )
	{
		int deterioration = item.Deterioration * 100 / MAX_DETERIORATION;
		int penalty = deterioration == 0 ? 1 : int( ( _WeaponDmgMin( item.Proto, use ) + bonus ) * deterioration * 0.01f ); 
		line += "|0xFFFF00 " + int( ( _WeaponDmgMin( item.Proto, use ) + bonus ) - penalty );
	}
	else
	{
		line += "|0xFFFF00 " + ( ( _WeaponDmgMin( item.Proto, use ) + bonus ) * DmgMult / DmgDiv );
	}
	line += "|0x3CF800  - ";
	
	if( isBurst )
	{ 
        string column = "|0xFFFF00 " +  ( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * DmgMult / DmgDiv );
        while ( column.length() < 5 ) column += " ";
        line += column + "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BURST );
		result.insertLast( line + "|0xFFFF00 " + ammoRound );
    }
	else if( ( ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_MELEE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_MELEE_END ) 
			|| ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END ) )
			&& item.IsDeteriorable() )
	{
		int deterioration = item.Deterioration * 100 / MAX_DETERIORATION;
		int penalty = deterioration == 0 ? 1 : int( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * deterioration * 0.01f ); 
		
		string damageType = "";
		int dt = _WeaponDmgType(item.Proto, use);
		damageType = GetMsgStr( TEXTMSG_GAME, STR_DAMAGE_TYPE_DESCRIPTION ) + GetMsgStr( TEXTMSG_GAME, STR_DAMAGE_TYPE_NONE + dt );

		result.insertLast( line + "|0xFFFF00 " + int( ( _WeaponDmgMax( item.Proto, use ) + bonus ) - penalty ) + damageType );
		result.insertLast( ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", item.Deterioration * 100 / MAX_DETERIORATION ) );
	}
	else
	{
		string damageType = "";
		int dt = _WeaponDmgType(item.Proto, use);

		if( item.Proto.Weapon_MaxAmmoCount > 0 )
		{
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid );
			if( FireAmmo.find( item.AmmoPid ) != -1 )
			{
				dt = DAMAGE_FIRE;
			}
		}

		damageType = GetMsgStr( TEXTMSG_GAME, STR_DAMAGE_TYPE_DESCRIPTION ) + GetMsgStr( TEXTMSG_GAME, STR_DAMAGE_TYPE_NONE + dt );
		
        result.insertLast( line + "|0xFFFF00 " + ( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * DmgMult / DmgDiv ) + damageType );
    }
		
	if( _WeaponMaxDist( item.Proto, use ) > 1 )
	{
		line = "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST );
		
		int wpnMaxDist = _WeaponMaxDist( item.Proto, use );
		if( skill == SK_THROWING )
		{
			wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
		}
		result.insertLast( line + "|0xFFFF00  " + wpnMaxDist );
	}
	
	if( _GetWeaponBlastRadius( item.Proto ) > 0 )
	{
		result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS ) + "|0xFFFF00 " + item.Proto.Blast_Radius );
	}

	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		if( !isAmmoRegen )
		{
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( _GetAmmoBlastRadius( AmmoProto ) > 0 )
			{
				result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS ) + "|0xFFFF00 " + AmmoProto.Blast_Radius );
			}
		}
		
		result.insertLast(
			  "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO )
			+ "|0xFFFF00 " + item.AmmoCount
			+ "|0x3CF800  / "
			+ "|0xFFFF00 " + item.Proto.Weapon_MaxAmmoCount );
		
		if( !isAmmoRegen )
		{
			AmmoPid = item.AmmoPid;
			result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_LOADED_AMMO ) + "|0xFFFF00 " +_GetAmmoShortDisc( AmmoPid ) );
		}
		else
		{
			result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_LOADED_AMMO ) + "|0xFFFF00 " + GetMsgStr( TEXTMSG_GAME, STR_RECHARGABLE_AMMO ) );
		}
	}
	else if( item.GetCount() > 1 )
	{
		result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE ) += "|0xFFFF00 " + item.GetCount() );
	}
	else if( ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_MELEE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_MELEE_END ) 
			|| ( weapon_Subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && weapon_Subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END ) )
	{
		uint count = chosen.CountItem( item.Proto.ProtoId );
		ItemCl@ belt = chosen.GetItem( PID_AMMO_BELT, SLOT_MISC );
		//if( valid( belt ) )
		//{
		//	count += thrownAmmoCount( belt, item.Proto.ProtoId );
		//}
		result.insertLast( "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE ) + "|0xFFFF00 " + count );
	}

	return result;
}

#define DESCRIPTION_DEFAULT_DELAY	( 33 )
int[] description_tick_delays = { 0, 0, 0, 0 };
string[] generic_descriptions = { "DESC_INVENTORY_MAIN", "DESC_INVENTORY_SPECIAL", "DESC_INVENTORY_STATS", "DESC_INVENTORY_RESIST" };

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
	
    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) || descType < 0 || descType >= int(generic_descriptions.length()) )
	{
        return "";
	}
	//Message( "" + description_tick_delays[descType] );//DEBUG ONLY
	
	if( description_tick_delays[descType] <= 0 )
	{
		description_tick_delays[descType] = DESCRIPTION_DEFAULT_DELAY;
		generic_descriptions[descType] = update_generic_description( descType );
	}
	else
	{
		description_tick_delays[descType]--;
	}

	update_generic_description_offsets( descType, offsX, offsY );
	return generic_descriptions[descType];
}

void update_generic_description_offsets( int descType, int& offsX, int& offsY )
{
	switch( descType )
	{
		case( DESC_INVENTORY_MAIN ):
			offsY = -2;
			break;
		case( DESC_INVENTORY_SPECIAL ):
			offsX = 23;
			offsY = -12;
			break;
		case( DESC_INVENTORY_STATS ):
			offsX = -8;
			offsY = -12;
			break;
		case( DESC_INVENTORY_RESIST ):
			offsX = 35;
			offsY = 120;
			break;
	}
}

string update_generic_description( int descType )
{
	CritterCl@ chosen = GetChosen();
	
	string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += COLOR_CRITTER + chosen.Name + "\n";
        result += "|0x3CF800 -----------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) ) + "\n";
		result += "\n\n\n\n\n\n\n\n"; // FoRP Inventory 2020 adjustment

		result += generic_description_slot_maker( SLOT_HAND1 );
		result += generic_description_slot_maker( SLOT_HAND2 );
	
		// Additional slots
        result += "\n\n|0x3CF800 "+ GetMsgStr( TEXTMSG_GAME, STR_INV_EXTRA_SLOTS ) + "\n";
		result += "-----------------------\n";
		
		ItemCl@ headwear = _CritGetItemHead( chosen );
		if( valid( headwear ) ) 
		{ 
			result += getItemTextName( itemText( headwear ) ) + "\n";
			switch( headwear.Proto.HeadItem_Perk )
			{
				case( HEAD_PERK_COOL ):
					result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_COOL ) + "\n";
					break;
				case( HEAD_PERK_GLASSES ):
				{
					if( chosen.StatBase[ ST_PERCEPTION ] > 4 )
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_GLASSES );
					}
					else if( chosen.StatBase[ ST_PERCEPTION ] == 4 )
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_GLASSES_PE1 );
					}
					else 
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_GLASSES_PE2 );
					}
					break;
				}
				case( HEAD_PERK_VERY_COOL ):
					result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_VERY_COOL ) + "\n";
					break;
				case( HEAD_PERK_LUCKY_CHARM ):
					result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_LUCKY_CHARM ) + "\n";
					break;
				case( HEAD_PERK_COOL_LUCKY_CHARM ):
					result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_COOL_LUCKY_CHARM );
					break;
				//case(HEAD_PERK_NO_KNOCKOUT): not implemented
				//	break;
				//case( HEAD_PERK_BASEBALL_FAN ): not implemented
				//	break;
				case( HEAD_PERK_COOL_GLASSES ):
				{
					if( chosen.StatBase[ ST_PERCEPTION ] > 4 )
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_COOL_GLASSES );
					}
					else if( chosen.StatBase[ ST_PERCEPTION ] == 4 )
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_COOL_GLASSES_PE1 );
					}
					else
					{
						result += GetMsgStr( TEXTMSG_GAME, STR_HEAD_PERK_COOL_GLASSES_PE2 );
					}
					break;
				}
				//case( HEAD_PERK_FLASHBANG_PROTECTION ): not implemented
				//	break;
				default:
					result += "\n\n\n";
					break;
			}
        } 
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_HEAD_EMPTY ) + "\n\n\n\n";
		}
		result += "\n|0x3CF800 -----------------------\n";
		
		ItemCl@ backpack = _CritGetItemBack( chosen );
		if( valid( backpack ) ) 
		{
			if( backpack.GetType() == ITEM_TYPE_CONTAINER )
			{
				result += getItemTextName( itemText( backpack ) );
				result += ContainerWeight( backpack ) + "\n\n\n";
			}
			else
			{
				result += getItemTextName( itemText( backpack ) ) + "\n\n\n";
			}
		}
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_BACK_EMPTY ) + "\n\n\n\n";
		}
		result += "\n|0x3CF800 -----------------------\n";
		
		ItemCl@ misc = _CritGetItemMisc( chosen );
		if( valid( misc ) ) 
		{ 
			if( misc.GetType() == ITEM_TYPE_CONTAINER )
			{
				result += getItemTextName( itemText( misc ) );
				result += ContainerWeight( misc );
			}
			else if( misc.GetProtoId() == PID_RUBBER_BOOTS || misc.GetProtoId() == PID_LEATHER_SHOES )
			{
				result += getItemTextName( itemText( misc ) ) + "\n";
				result += GetMsgStr( TEXTMSG_GAME, STR_ACID_PROOF_SHOES );
			}
			else
			{
				result += getItemTextName( itemText( misc ) );
			}
        }
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_MISC_EMPTY );
		}
    }
	
    if( descType == DESC_INVENTORY_SPECIAL )
    {
        result += "\n\n\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_STRENGTH ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_ENDURANCE ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_CHARISMA ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_INTELLECT ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_AGILITY ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_LUCK ];
    }
	
    if( descType == DESC_INVENTORY_STATS )
    {
        result += "\n\n\n";
		// Hit Points
        result += "               "  + GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += "|0xFFFF00 " + chosen.Stat[ ST_CURRENT_HP ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_MAX_LIFE ] + "\n";
		// AP Regen
		string apregen = GetMsgStr( TEXTMSG_GAME, STR_INV_APREGEN );
		string thatap = "|0xFFFF00 " + floor(chosen.Stat[ ST_APREGEN ] / 100.0f) + "." + ( chosen.Stat[ ST_APREGEN ] % 100 ); // + "\n"
		
        float current_weight = cutLesserDigits( chosen.Param[ CR_ITEMS_WEIGHT ] / 1000.0 );
		float max_weight = cutLesserDigits( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000.0 );
		string current_volume = chosen.ItemsVolume();
		// Armor Class
		string arclass = GetMsgStr( TEXTMSG_GAME, STR_INV_AC );
		string thatac = "|0xFFFF00 " + ( chosen.Stat[ ST_ARMOR_CLASS ] );
		result += "|0x3CF800                " + ReplaceText(arclass, "VALUE", thatac)  + "\n";
		// String calls
		result += "|0x3CF800                " + ReplaceText(apregen, "VALUE", thatap)  + "\n"; // Action Points Renegeration
		result += "|0x3CF800                " + GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + "|0xFFFF00 \n               " + current_weight + "|0x3CF800  / " + "|0xFFFF00 " + max_weight + "|0x3CF800  " + GetMsgStr( TEXTMSG_GAME, STR_INV_KG ) +"\n";
		result += "|0x3CF800                " + GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_VOLUME ) + "|0xFFFF00 \n               " + current_volume + "|0x3CF800  / " + "|0xFFFF00 1000\n";
		// Resistance type names
		result += "|0x3CF800   -----------------------\n";
		
		ItemCl@ armor = _CritGetItemArmor(chosen);
		if( valid( armor ) )
		{
			result += "  " + getItemTextName( itemText( armor ) ) + ":\n";
		}
		else
		{
			result += "|0x3CF800   " + GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + ": \n";
		}
		result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL )     + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_LASER )      + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE )       + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA )     + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE )    + "\n";
		result += "|0x3CF800   " + GetMsgStr( TEXTMSG_GAME, STR_INV_ELECTRO );
    }
	
    if( descType == DESC_INVENTORY_RESIST )
    {
        result += "|0xFFFF00      " + chosen.Stat[ ST_NORMAL_ABSORB ]  + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_NORMAL_RESIST ]  + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_LASER_ABSORB ]   + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_LASER_RESIST ]   + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_FIRE_ABSORB ]    + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_FIRE_RESIST ]    + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_PLASMA_ABSORB ]  + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_PLASMA_RESIST ]  + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_EXPLODE_ABSORB ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_EXPLODE_RESIST ] + "|0x3CF800  %\n";
		result += "|0xFFFF00      " + chosen.Stat[ ST_ELECTRO_ABSORB ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_ELECTRO_RESIST ] + "|0x3CF800  %";
    }
    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
	RunServerScriptUnsafe( "general_unsafe@unsafe_store_last_checked_item", item.Id, lookType, 0, null, null ); //Gm shift+q look hack
	
	CritterCl@ chosen = GetChosen();
    // Default error text
    if( not IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
	{
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );
	}
    string result;

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
		string lex;
		if( item.Lexems != "" )
		{
			lex = "" + item.Lexems;
			for( uint i = 0, len = lex.length(); i < len; i++ )
			{
				uint8 chr = lex[ i ];
				if( chr == 36 )
				{
					lex = "";
					break;
				}
			}
		}
		
		if( lex != "" )
		{
			if( item.Info != 0 && item.Val9 == PID_POPUP )
			{ //"Name == Lex"
				result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", lex );
			}
			else
			{ //"Name + Lex"
				result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + COLOR_NETMSG );
				result += " " + lex;
			}
		}
		else
		{
			result = ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + COLOR_NETMSG );
		}
		
		if( ( ( __sinf & SINF_ITEMID ) != 0 ) && item.GetType() > 1 && item.GetType() < 13 )
		{
			result += " |0xffff0000 id: " + item.Id + " pid: " + item.GetProtoId();
		}
    }
    // Full info
    else
    {
        if( item.Info != 0 && item.Val9 == PID_POPUP )
		{
            string name = getItemTextName( item.Lexems );
            if ("" != name)
			{
                result += name;
            }

            string description = getItemTextDescription( item.Lexems );
            if ("" != description)
			{
                result += "\n-----------------------\n";
                result += description;
            }
        }
        else
		{
            if( lookType == ITEM_LOOK_INVENTORY )
			{
                result += itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + "|0x3CF800 \n-----------------------\n";
			}
			
            if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
			{
                result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
			}
			else
			{
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + 1 );
			}
			
            if( item.Lexems != "" )
            {
                string lex = "" + item.Lexems;
                for( uint i = 0, len = lex.length(); i < len; i++ )
                {
                    uint8 chr = lex[ i ];
                    if( chr == 36 )
                    {
                        lex = "";
                        break;
                    }
                }
                if( lex != "" )
				{
                    result += " " + lex + "\n";
				}
			}
			
			if( item.GetProtoId() == PID_VAULT_DWELLER_BONES || item.GetProtoId() == PID_BONES )
			{
				result += corpse_description( item );
			}
        }

        if( lookType != ITEM_LOOK_MAP )
		{
            uint16 pid = item.GetProtoId();
			if( item.GetType() == ITEM_TYPE_WEAPON )
			{
				// Strength Requirement
				if( item.GetType() == ITEM_TYPE_WEAPON )
				{
					result += "\n-----------------------\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_STR_REQ );
					str = ReplaceText( str, "VALUE", item.Proto.Weapon_MinStrength  );
					result += str;
				}
				//  Custom object speed
				if( FLAG( item.Flags, ITEM_CAN_USE ) || FLAG( item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON )
				{
					result += "\n";
					uint8 aim = ( item.Mode >> 4 ) & 0x0F;
					string str2;
					str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_WAIT_TIME );
					uint val = _GetProtoWindupTime( item.Proto );
					if( chosen.ParamBase[CR_AUTO_AIM] == HIT_LOCATION_NONE && ( _WeaponAim( item.Proto, item.Mode ) && ( aim == HIT_LOCATION_NONE ) ) )
					{
						val = val / 2;
					}						
					str2 = ReplaceText( str2, "VALUE", val );
					result += str2;
				}
				//  Custom AP cost
				if( FLAG(item.Flags, ITEM_CAN_USE) || FLAG(item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON && item.Mode != USE_RELOAD )
				{
					result += "\n";
					uint8 aim = ( item.Mode >> 4 ) & 0x0F;
					uint val =  GetUseApCost( chosen, item, item.Mode);
					if( chosen.ParamBase[CR_AUTO_AIM] != HIT_LOCATION_NONE && ( _WeaponAim( item.Proto, item.Mode ) && ( aim == HIT_LOCATION_NONE ) ) )
					{
						val += val * 20 / 100;
					}
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_AP_COST );					
					str = ReplaceText( str, "VALUE", val );
					result += str;
				}
				// Ammo & Reload info
				if( item.Proto.Weapon_MaxAmmoCount > 0 )
				{
					// Custom Reload AP cost
					result += "\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_RELOAD_COST );
					str = ReplaceText( str, "VALUE", item.Proto.Weapon_ReloadAp );
					// Ammo load
					string str2;
					str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
					str2 = ReplaceText( str2, "VALUE",     item.AmmoCount );
					str2 = ReplaceText( str2, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
					// Caliber
					string str3;
					str3 = GetMsgStr(TEXTMSG_GAME, STR_INV_CALIBER_MSG);
					str3 = ReplaceText( str3, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
					result += str + "\n" + str2 + "\n" + str3;
				}
			}
			else if( item.GetType() == ITEM_TYPE_ARMOR )
			{
				result += "\n\n-----------------------";
			}
			// Armor Class Mod
			if( item.Proto.Armor_AC > 0 )
			{
				string str;
				str = GetMsgStr ( TEXTMSG_GAME, STR_INV_ARMOR_AC);
				str = ReplaceText (str, "VALUE", item.Proto.Armor_AC);
				result += str;
			}
		    
			else if( item.GetType() == ITEM_TYPE_AMMO )
			{
				// Ammo stats
				result += "\n-----------------------";
				string ammoACMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_POWER );
				ammoACMod = ReplaceText( ammoACMod, "ACMOD", item.Proto.Ammo_AcMod);
				string ammoMult  = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_MULT  );
				ammoMult  = ReplaceText( ammoMult,  "MULT",  item.Proto.Ammo_DmgMult );
				ammoMult  = ReplaceText( ammoMult,  "DIV",   item.Proto.Ammo_DmgDiv  );
				string ammoDRMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DRMOD );
				ammoDRMod = ReplaceText( ammoDRMod, "DRMOD", item.Proto.Ammo_DrMod );
				string ammoCal = GetMsgStr( TEXTMSG_GAME, STR_INV_CALIBER_MSG );
				ammoCal = ReplaceText( ammoCal, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Ammo_Caliber ) ) );

				result += "\n" + ammoACMod + "\n" + ammoMult + "\n" + ammoDRMod + "\n" + ammoCal;
			}
            
            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8  brokenFlags = item.BrokenFlags;
                uint8  brokenCount = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
				}
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                }
				else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                }
				else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                }
				else
				{
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );
				}
				
                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
				{
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );
				}

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
				{
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );
				}
				
                // Broken count
				if( valid( chosen ) )
				{
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
				}
			}

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
			{
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );
			}
			else if( item.Proto.Item_Subtype == ITEM_SUBTYPE_KEYCARD )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEYCARD_NUMBER ), "KEY_ID", item.Id );
			}
			result += "\n-----------------------";
			
			// Partial_Item
			if( item.Proto.Partial_Item > 0 && item.Val0 > 0 )
			{ 
				string partial_info = GetMsgStr( TEXTMSG_GAME, STR_ITEM_USES_LEFT ) + "|0xE5C62B VALUE ";
				result += "\n" + ReplaceText( partial_info, "VALUE", item.Val0 );
			}

			// Weight
			uint16 container = item.GetProtoId();
			uint8 itemType = item.GetType();
			if( container == PID_POT_ALCO || item.Proto.Type == ITEM_TYPE_FLASK )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight + item.Val2 );
			}
			else if( glass_bottles[2].find(  container ) != -1 )
			{
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight - ( item.Proto.Partial_Item * 100 - item.Val2 ) );
			}
			else if( itemType == ITEM_TYPE_CONTAINER )
			{
				result += ContainerWeight( item );
			}
			else if( itemType == ITEM_TYPE_ARMOR && item.CritSlot == SLOT_ARMOR )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * 75 / 100 );
				result += " (|0xFFFF00  75%|0x3CF800  )";
			}
			else
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );
			}
			
			// Volume
			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_VOLUME ), "VALUE", item.Proto.Volume * item.GetCount() );
			// Material
			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_MATERIAL ), "VALUE", GetMsgStr( TEXTMSG_GAME, item.Proto.Material + 170 ) );
			// Flashlight charge
			if( item.GetProtoId() == PID_FLASHLIGHT_OFF || item.GetProtoId() == PID_FLASHLIGHT_ON || item.GetProtoId() == PID_10MM_PISTOL_FLASHLIGHT || item.GetProtoId() == PID_TAPE_RECORDER )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_TEXT, STR_RECORDER_MENU_PROCESS_CHARGED ), "@lex charge@", "|0xFFFF00 " + item.Val1 * 100 / 480 + "|0x3CF800 %" );
			}
			// Homebrew Taste
			uint[] taste_pids = { PID_HOMEBREW_PRT };
			int m = taste_pids.find( item.GetProtoId() );
			if( m != -1 )
			{
				result += "\n-----------------------";
				item.Val8 > 0 ? result += GetMsgStr( TEXTMSG_TEXT, STR_HOMEBREW_TASTE ) + ReplaceText( GetMsgStr( TEXTMSG_TEXT, STR_HOMEBREW_TASTE_BEGIN + item.Val8 ), ".", "" ) : result;
			}
			// Flask Taste
			if( item.Proto.Type == ITEM_TYPE_FLASK )
			{
				result += "\n-----------------------";
				item.Val1 > 0 ? result += GetMsgStr( TEXTMSG_TEXT, STR_SMELL_CANTEEN ) + "|0xFFFF00  " + ReplaceText( GetMsgStr( TEXTMSG_ITEM, item.Val1*100 ) , ".", "|0x3CF800 " ) : result;
			}
			// Bondage Items with Lock
			uint[] bondage_items = { PID_HANDCUFFS, PID_SHACKLES, PID_SLAVE_COLLAR };
			int mm = bondage_items.find( item.GetProtoId() );
			if( mm != -1 )
			{
				result += "\n-----------------------";
				result += GetMsgStr( TEXTMSG_TEXT, STR_SERIAL_NUMBER ) + "|0xFFFF00 " + item.Id + "|0x3CF800 .";
				switch( item.BONDAGE_STATE )
				{
					case( BONDAGE_STATE_ON ):
						result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_BONDS );
						break;
					case( BONDAGE_STATE_BROKEN ):
						result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
						break;
					default:
						result += "\n" + GetMsgStr( TEXTMSG_TEXT, STR_INV_BOND_READY );
						break;
				}
			}
			// Bondage key items
			uint[] bondage_key = { PID_HANDCUFFS_KEY, PID_SHACKLES_KEY, PID_SLAVE_COLLAR_SWITCH };
			int mmm = bondage_key.find( item.GetProtoId() );
			if( mmm != -1 && item.KEY_BONDAGE_ID != 0 )
			{
				result += "\n-----------------------";
				result += GetMsgStr( TEXTMSG_TEXT, STR_SERIAL_NUMBER ) + "|0xFFFF00 " + item.KEY_BONDAGE_ID + "|0x3CF800 .";
			}
		}
    }

    // Format tags
    if( item.Lexems != "" )
	{
        return FormatTags( result, item.Lexems );
    }
	return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result = critter_description_maker( cr, lookType );

	if( lookType == CRITTER_LOOK_FULL )
    {
        critter_description_full( cr, result );
	}

    if( lookType == CRITTER_LOOK_SHORT && ( __sinf & SINF_CRID ) != 0 )
    {
        result += COLOR_CRITTER + cr.Id;
    }

    // Format tags
    if( cr.Lexems != "" )
	{
        return FormatTags( result, cr.Lexems );
	}
	
    return result;

}

string critter_description_full( CritterCl& cr, string& result )
{
	result += "" + COLOR_NETMSG + critter_description_health( cr ) + critter_description_hand( cr ) + critter_description_slots( cr ) + critter_description_stats( cr );
			
	return result;
}

string critter_description_maker( CritterCl& target, int lookType )
{
	CritterCl@ chosen = GetChosen();
	
	return critter_description_maker( lookType, target.Id, target.Stat[ ST_AGE ], target.Stat[ ST_GENDER ], target.CrType, target.Stat[ ST_BODY_TYPE ], target.IsPlayer(), target.Name, target.Pid, target.IsLife(), target.IsKnockout(), target.IsDead() );
}

string critter_description_maker( int lookType, int target_id, int age, int gender, int crType, int bodyType, bool isPlayer, string name, uint16 npcPid, bool isLife, bool isKnockout, bool isDead )
{
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
	
	CritterCl@ chosen = GetChosen();

	if( lookType == CRITTER_ONLY_NAME )
	{
		CritterCl@ cr = GetCritter( target_id );
		if( !valid( cr ) )
		{
			return "[null]";
		}
		
		if( cr.Param[ QST_MEDIUM ] != 0 )
		{
			if( ABS( cr.Param[ QST_MEDIUM ] ) == 2 && !isGM( GetChosen() ) )
			{
				name = "";
			}
			
			if( cr.Param[ QST_MEDIUM ] == 3 )
			{
				string@ s_temp = cr.Lexems;
				if( !(s_temp is null) )
				{
					name = s_temp;
				}
			}
			
			if( cr.Param[ QST_MEDIUM ] >= 4 )
			{
				string@ s_temp = GetName( cr.Param[ QST_MEDIUM ] );
				if( !(s_temp is null) )
				{
					cr.Name = s_temp;
					name = s_temp;
				}
			}
		}
		else 
		{
			if( !isPlayer )
			{
				name = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
			}
		}
		result = name;
    }
	
	if( lookType == CRITTER_LOOK_SHORT )
	{
		if( name != "" || ( __sinf & SINF_LOGIN ) != 0 )
		{
			result = GetMsgStr( TEXTMSG_GAME, STR_YOU_SEE ) + COLOR_CRITTER + name + "|0x3CF800 .";
		}
		else
		{
			lookType = CRITTER_LOOK_FULL;
		}
	}
	
	if( lookType == CRITTER_LOOK_FULL )
	{
		CritterCl@ cr = GetCritter( target_id );
		string view_name = "";
		string view_age = "";
		bool hasAge = false;
		bool isMale = gender == GENDER_MALE;
		bool isFemale = gender == GENDER_FEMALE;
		uint skin = cr.Stat[ ST_BASE_CRTYPE ];
		switch( bodyType )
		{
			case( BT_MEN ): 
			case( BT_WOMEN ):
			{
				uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( CLAMP( gender, GENDER_MALE, GENDER_FEMALE ), CLAMP( age, 0, 90 ) ) );
				if( ageStr != 0 )
				{
					view_name = GetMsgStr( TEXTMSG_GAME, ageStr );
				}
				else if( name == "" )
				{
					view_name = "???";
				}
				else
				{
					view_name = name;
					view_name = ".";
				}
				break;
			}
			case( BT_CHILDREN ):
				view_name = GetMsgStr( TEXTMSG_GAME, isMale ? STR_SEE_BOY : STR_SEE_GIRL );
				break;
			case( BT_SUPER_MUTANT ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SUPER_MUTANT );
				break;
			case( BT_GHOUL ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_GHOUL );
				break;
			case( BT_BRAHMIN ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_BRAHMIN );
				break;
			case( BT_RADSCORPION ):
			{
				switch( skin )
				{
					case( CRTYPE_RADSCORPION_BLC_HUGE ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_BLACK_SCORPION );
						break;
					case( CRTYPE_RADSCORPION_CAVE ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CAVE_SCORPION );
						break;
					default:
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_RAD_SCORPION );
						break;
				}
				break;
			}
			case( BT_RAT ):
			{	
				switch( skin )
				{
					case( CRTYPE_RAT_PIGRAT ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_PIG_RAT );
						break;
					case( CRTYPE_RAT_MOLERAT ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MOLERAT );
						break;
					case( CRTYPE_RAT_MOLERAT_MUTANT ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MUTANT_MOLE );
						break;
					default:
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_RAT );
						break;
				}
				break;
			}
			case( BT_FLOATER ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_FLOATER );
				break;
			case( BT_CENTAUR ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CENTAUR );
				break;
			case( BT_ROBOT ):
			{
				switch( skin )
				{
					case( CRTYPE_ROBOT_HANDY ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_HANDY );
						break;
					case( CRTYPE_ROBOT_PROTECTRON ):	
					case( CRTYPE_ROBOT_PROTECTRON2 ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_PROTECTRON );
						break;	
					case( CRTYPE_ROBOBRAIN ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_ROBOBRAIN );
						break;
					case( CRTYPE_ROBODOG ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CYBER_DOG );
						break;
					case( CRTYPE_ROBOEYE ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_ROBOEYE );
						break;
					case( CRTYPE_ROBOT ):						
					case( CRTYPE_ROBOT_BLUE ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SENTURY_BOT );
						break;	
					default:
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_TURRET );
						break;
				}
				break;
			}	
			case( BT_DOG ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_DOG );
				break;
			case( BT_MANTI ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MANTIS );
				break;
			case( BT_DEATHCLAW ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_DEATHCLAW );
				break;
			case( BT_PLANT ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_PLANT );
				break;
			case( BT_GECKO ):
			{
				switch( skin )
				{
					case( CRTYPE_GECKO_SILV ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SILVER_GECKO );
						break;
					case( CRTYPE_GECKO_GOLD_SMALL ):	
					case( CRTYPE_GECKO_GOLD ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_GOLDEN_GECKO );
						break;	
					case( CRTYPE_GECKO_CAVE ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_CAVE_GECKO );
						break;
					case( CRTYPE_GECKO_FIRE ):
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_FIRE_GECKO );
						break;
					default:
						view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MONSTER );
						break;
				}
				break;				
			}
			case( BT_ALIEN ):
				view_name = GetMsgStr( TEXTMSG_GAME, skin == CRTYPE_ALIEN_QUEEN ? STR_SEE_ALIEN_QUEEN : ( skin == CRTYPE_ALIEN_REG ? STR_SEE_ALIEN : STR_SEE_EGG ) );
				break;		
			case( BT_GIANT_ANT ):
				view_name = GetMsgStr( TEXTMSG_GAME, skin == CRTYPE_GIANT_ANT_LION ? STR_SEE_ANT_LION : STR_SEE_ANT );
				break;
			case( BT_BIG_BAD_BOSS ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MONSTER );
				break;		
			case( BT_GIANT_BEETLE ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_BEETLE );
				break;
			case( BT_GIANT_WASP ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_WASP );
				break;
			case( BT_YAO ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_YAO );
				break;
			case( BT_SWAMP_LURKER ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MIREURKER );
				break;
			case( BT_CROCS ):
				view_name = GetMsgStr( TEXTMSG_GAME, skin == CRTYPE_CROCS_SHADOW ? STR_SEE_SHADOW_CROC : STR_SEE_CROC );
				break;
			case( BT_MILLEPEDE ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MILLEPEDE );
				break;	
			case( BT_LAVASH ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_LAVASH );
				break;
			case( BT_SPIDER ):
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_SPIDER );
				break;
			default:
				view_name = GetMsgStr( TEXTMSG_GAME, STR_SEE_MONSTER );
				break;
		}
		
		string description = view_name + view_age ;
		description = strupr( substring ( description, 0, 1 ) ) + substring( description, 1, description.length() - 1 );
		uint line_type = isLife ? STR_CRIT_LOOK_LIFE : ( isKnockout ? STR_CRIT_LOOK_KO : ( isDead ? STR_CRIT_LOOK_DEAD : STR_CRIT_LOOK_NOTHING ) );

		if( line_type != STR_CRIT_LOOK_NOTHING )
		{
			if( !isPlayer )
			{
				description = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
				if( valid( GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_DESC( npcPid ) ) ) )
				{
					description += "|0x3CF800 . " + GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_DESC( npcPid ) );
				}
			}
			result = ReplaceText( GetMsgStr( TEXTMSG_GAME, line_type ), "NAME", COLOR_CRITTER + description );
		}
	}
	return result;
}

string critter_description_health( CritterCl& cr )
{
	int gender = cr.Stat[ ST_GENDER ];
	if( cr.Stat[ ST_BODY_TYPE ] > BT_GHOUL )
	{
		gender = GENDER_IT;
	}
	
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );
	
	int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
	if( cr.IsDead() )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) ); //+ genderEnding( cr );
	}
	else if( cr.Stat[ ST_CURRENT_HP ] < 0 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) ); //+ genderEnding( cr );
	}
	else if( hp_proc <= 30 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) ); //+ genderEnding( cr );
	}
	else if( hp_proc <= 50 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) ); //+ genderEnding( cr );
	}
	else if( hp_proc <= 70 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) ); //+ genderEnding( cr );
	}
	else if( hp_proc <= 90 )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 5 ) ); //+ genderEnding( cr );
	}
	else
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 6 ) ); //+ genderEnding( cr );
	}
	
	if( _CritIsInjured( cr ) )
	{
		bool needComa = false;

		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) ) + ": ";
		
		uint lineNum = 0;
		switch( cr.Stat[ ST_BODY_TYPE ] ) //Take line from FOCOMBAT.MSG based on CritterType Allias from CritterTypes.cfg
		{
			case( BT_BRAHMIN ):
				lineNum = 1150;
				break;
			case( BT_DOG ):
				lineNum = 1160;
				break;
			case( BT_SUPER_MUTANT ):
				lineNum = 1180;
				break;			
			case( BT_RAT ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_RAT_MOLERAT ):
						lineNum = 1190;
						break;	
					case( CRTYPE_RAT_PIGRAT ):
						lineNum = 1550;
						break;		
					default:  // CRTYPE_RAT
						lineNum = 1240;
						break;	
				}
				break;
			}	
			case( BT_RADSCORPION ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_RADSCORPION ):
						lineNum = 1570;
						break;
					case( CRTYPE_RADSCORPION_SMALL ):
						lineNum = 1590;
						break;
					default: // CRTYPE_RADSCORPION_HUGE, CRTYPE_RADSCORPION_BLC_HUGE, CRTYPE_RADSCORPION_CAVE
						lineNum = 1220;
						break;
				}
			}
			case( BT_FLOATER ):
				lineNum = 1230;
				break;
			case( BT_CENTAUR ):
				lineNum = 1250;
				break;
			case( BT_ROBOT ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_ROBOEYE ):
						lineNum = 1540;
						break;
					case( CRTYPE_TURRET_PLASMA ): 
					case( CRTYPE_TURRET_MINIGUN ):
					case( CRTYPE_TURRET_LASER_TOWER ):
					case( CRTYPE_TURRET_LASER ):
						lineNum = 1900;
						break;
					case( CRTYPE_ROBOT ):
					case( CRTYPE_ROBOT_BLUE ): 
						lineNum = 1660;
						break;
					case( CRTYPE_ROBOT_HANDY ): 
						lineNum = 1170;
						break;
					default: // CRTYPE_ROBOBRAIN
						lineNum = 1530;
						break;
				}
				break;
			}
			case( BT_MANTI ):
				lineNum = 1520;
				break;
			case( BT_DEATHCLAW ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_DEADCLAW_SMALL ):
						lineNum = 1600;
						break;
					case( CRTYPE_DEADCLAW_BEAST ):
						lineNum = 1310;
						break;
					default: // CRTYPE_DEADCLAW, CRTYPE_DEADCLAW_GREY
						lineNum = 1510;
						break;
				}
				break;
			}
			case( BT_PLANT ):
				lineNum = 1650;
				break;
			case( BT_GECKO ):
				lineNum = 1670;
				break;
			case( BT_ALIEN ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_ALIEN_EGG ):
						lineNum = 1580;
						break;
					default: // CRTYPE_ALIEN_REG, CRTYPE_ALIEN_QUEEN
						lineNum = 1800;
						break;
				}
				break;
			}
			case( BT_GIANT_ANT ):
				lineNum = 1970;
				break;
			case( BT_BIG_BAD_BOSS ):
				lineNum = 1850;
				break;
			case( BT_GIANT_BEETLE ):
				lineNum = 4030;
				break;
			case( BT_GIANT_WASP ):
				lineNum = 4150;
				break;
			case( BT_YAO ):
				lineNum = 4170;
				break;
			case( BT_SWAMP_LURKER ):
				lineNum = 3470;
				break;
			case( BT_CROCS ):
				lineNum = 4160;
				break;
			case( BT_MILLEPEDE ):
				lineNum = 4180;
				break;	
			case( BT_LAVASH ):
				lineNum = 4190;
				break;
			case( BT_SPIDER ):
				lineNum = 4200;
				break;
			default: // BT_MEN, BT_WOMEN, BT_CHILDREN, BT_GHOUL
				lineNum = 1110;
				break;
		}
		
		if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
		{
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 6 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 2 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
		{
			if( needComa )
			{				
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 1 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 4 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 5 );
			needComa = true;
		}
	}
	return result + "|0x3CF800 ."; 
}

string critter_description_hand( CritterCl& cr )
{
	ItemCl@ item  = _CritGetItemHand(cr);
	if( !valid( item ) ) return "";

	int bodyType = cr.Stat[ ST_BODY_TYPE ];
	int crType = cr.CrType;

	bool twoHanded = valid( item ) ? FLAG( item.Flags, ITEM_TWO_HANDS ) : false;
	bool determined = true;
	
	string hands;
	switch( crType )
	{
		case( CRTYPE_TURRET_PLASMA ): 
		case( CRTYPE_TURRET_MINIGUN ):
		case( CRTYPE_TURRET_LASER_TOWER ):
		case( CRTYPE_TURRET_LASER ):
		case( CRTYPE_ROBOEYE ):
			hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMAMENT );
			break;
		default:
			determined = false;
			break;
	}
	
	if( !determined )
	{
		switch( bodyType )
		{
			case( BT_BRAHMIN ):
			case( BT_LAVASH ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMAMENT );
				break;
			case( BT_RAT ):
			case( BT_DOG ):
			case( BT_PLANT ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CHAPS );
				break;
			case( BT_GIANT_ANT ):
			case( BT_GIANT_BEETLE ):
			case( BT_GIANT_WASP ):
			case( BT_SPIDER ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANDIBLES );
				break;
			case( BT_RADSCORPION ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_PINCERS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_PINCER );
				break;
			case( BT_FLOATER ):
			case( BT_ALIEN ):
			case( BT_CENTAUR ):
			case( BT_MILLEPEDE ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_TENTACLES ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_TENTACLE );
				break;
			case( BT_ROBOT ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANIPULATORS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANIPULATOR );
				break;
			case( BT_GECKO ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CHAPS );
				break;
			case( BT_MANTI ):
			case( BT_YAO ):
			case( BT_DEATHCLAW ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CLAWS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CLAW );
				break;
			default: //regular characters
				hands = twoHanded ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_HAND1_2H ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HAND1_1H );
				break;
		}
	}					
	return " " + hands + " " + getItemTextName( itemText( item ) ) + ".";
}

string critter_description_slots( CritterCl& cr )
{
	string result;
	
	ItemCl@ offhand = _CritGetItemHandExt( cr );
	if( valid( offhand ) )
	{
		result += " " + GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC ) + ".";
		result = ReplaceText( result, "MISC", getItemTextName( itemText( offhand ) ) );
	}
	
	bool hasPrefix = false;
	bool female = cr.Stat[ ST_GENDER ] == GENDER_FEMALE;
	
	ItemCl@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		result += ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_FEMALE_ARMOR ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_MALE_ARMOR ) ) + getItemTextName( itemText( armor ) );
		hasPrefix = true;
	}

	ItemCl@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		result += ( hasPrefix ? ", " : ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_FEMALE_ARMOR ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_MALE_ARMOR ) ) ) + getItemTextName( itemText( head ) );
		hasPrefix = true;
	}

	ItemCl@ misc = _CritGetItemMisc( cr );
	if( valid( misc ) )
	{
		result += ( hasPrefix ? GetMsgStr( TEXTMSG_GAME, STR_AND ) : ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_SHE_HEAD ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HE_HEAD ) ) ) + getItemTextName( itemText( misc ) );
		hasPrefix = true;
	}

	if( hasPrefix )
	{
		result += ".";
	}
	
	ItemCl@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK ) + getItemTextName( itemText( back ) ) + ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK_SHE_ENDLINE ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK_HE_ENDLINE ) );
	}
	
	return result;
}

//descriptions based on appearence and stats
string critter_description_stats( CritterCl& cr )
{
	if( cr.Stat[ ST_BODY_TYPE ] >= BT_BRAHMIN && cr.IsNpc() ) 
	{
		return "";
	}
	
	CritterCl@ chosen = GetChosen();

	ItemCl@ item2 = _CritGetItemHandExt( cr );
	ItemCl@ item3 = _CritGetItemArmor( cr );

	// Hide face and features armor lists
	uint16[][] OpenArmorList =
	{
		{   // Can be toggled - hoods
			PID_PURPLE_ROBE, PID_BLACK_ROBE, PID_SANDROBE, PID_BROWN_ROBE, PID_DARK_GREEN_ROBE, PID_RED_RITUAL_ROBE, PID_BLACK_RITUAL_ROBE, PID_DARK_BLACK_ROBE, 
			PID_DARK_RED_ROBE, PID_RED_ROBE, PID_DARK_BROWN_ROBE, PID_DARK_BLUE_ROBE, PID_ATOM_CHILD_ROBE

		},{ // hides everything, cant be toggled
			 PID_EKZO, PID_OXIDENED_POWER_ARMOR, PID_HYDROID, PID_EKZO_2, PID_POWERED_ARMOR_NEVADA, PID_HYDROID_MK_II, PID_RAIDER_PA,
			 PID_PA_CLAW, PID_HYENA_PA, PID_HYENA_PA_MK2, PID_ADVANCED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR_MK2
		},{ // helmet can be taken off
			 PID_POWERED_ARMOR, PID_HARDENED_POWER_ARMOR
		}
	};

	uint8 OpenArmor = 0;
	if( valid( item3 ) )
	{
		uint16 PID = item3.GetProtoId();
		for( uint8 i = 0, l = OpenArmorList.length(); i < l; i++ )
		{
			for( uint8 ii = 0, ll = OpenArmorList[ i ].length(); ii < ll; ii++ )
			{
				if( PID == OpenArmorList[ i ][ ii ] ) 
				{ 
					OpenArmor = i+1;
					break;
				}
			}
		}
	}

	bool hidelex = false;
	bool showface = true;
	bool showbody = true;
	bool female = cr.Stat[ ST_GENDER ] == GENDER_FEMALE;
	bool male = cr.Stat[ ST_GENDER ] == GENDER_MALE;
	
	string usual = " " + ( female ? GetMsgStr( TEXTMSG_GAME, STR_DESC_F_USUAL ) : ( male ? GetMsgStr( TEXTMSG_GAME, STR_DESC_M_USUAL ) : GetMsgStr( TEXTMSG_GAME, STR_DESC_USUAL ) ) );
	string look = "";

	hidelex = ( OpenArmor == 1 && FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_DESC ) );
	bool hideopt = ( FLAG( cr.Param[ PLAYER_FLAGS ], PLAYER_FLAG_HIDE_FACE ) );

	if( OpenArmor == 1 && hideopt )
	{
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_HOOD );
		showface = false;
		usual = "";
	}
	else if( OpenArmor == 2 )
	{
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_ARMOR );
		showface = false;
		showbody = false;
		usual = "";
	}
	else if( OpenArmor == 3 )
	{
		if( hideopt )
		{
			look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_APP );
			showface = false;
		}
		else 
		{
			look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_ARMOR );
		}
		showbody = false;
		usual = "";
	}
	else 
	{ 
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS );
	}

	string comma = " ";
	if( !showface || !showbody ) 
	{ 
		comma = ", ";
	}
	bool truecomma;
	if( showface )
	{
		truecomma = true;
		switch( cr.Stat[ ST_CHARISMA ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_IRRESISTIBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_IRRESISTIBLE );
				break;
			case( 9 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_MBEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_MBEAUTIFUL );
				break;
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_BEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_BEAUTIFUL );
				break;
			case( 7 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_ATTRACTIVE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_ATTRACTIVE );
				break;
			case( 3 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_UNPLEASANT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_UNPLEASANT );
				break;
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DISGUSTING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DISGUSTING );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SICKENING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SICKENING );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = "";
		}
	}

	if( showbody )
	{
		truecomma = true;
		switch( cr.Stat[ ST_STRENGTH ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_VSTRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_VSTRONG );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_STRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_STRONG );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WEAK );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_QWEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_QWEAK );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = ""; 
		}

		truecomma = true;
		switch( cr.Stat[ ST_ENDURANCE ] )
		{
			case( 10 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_TOUGH ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_TOUGH );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WBUILT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WBUILT );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SLIM ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SLIM );
				break;
			case( 1 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DELICATE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DELICATE );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", "; 
			usual = "";
		}

		truecomma = true;
		switch( cr.Stat[ ST_AGILITY ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_AGILE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_AGILE );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_NIMBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_NIMBLE );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_GRACELESS ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_GRACELESS );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_CLUMSY ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_CLUMSY );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = "";
		}
	}

	string result = ( look != "" ? ( " " + look + usual + "." ) : "" );

	ItemCl@ armor = cr.GetItem( 0, SLOT_ARMOR );
	bool ArmorLexem = ( valid(armor) && armor.Lexems != "" );
	
	if( valid(armor) && ( armor.Val9 == PID_POPUP || armor.GetProtoId() == PID_POPUP ) )
	{
		ArmorLexem = false;
	}
	
	if( ( cr.Lexems != "" || ArmorLexem ) && !hidelex && cr.Param[ QST_MEDIUM ] != 3 ) 
	{ 
		result += " ";
		if( ArmorLexem )
		{
			result += armor.Lexems;
		}
		else
		{			
			string signature = "_";
			int pos = findFirstOf( cr.Lexems, signature, 0 );
			result += pos != -1 ? substring( cr.Lexems, 0, pos ) : cr.Lexems;
		}		
		result += "."; 
	}
	return result;
}

string corpse_description( Item& corpse ) 
{
	string result;

	string@ name = GetName( corpse.Val1 );

	int ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( CLAMP( corpse.Val3, GENDER_MALE, GENDER_FEMALE ), CLAMP( corpse.Val2, 0, 90 ) ) );

	if( corpse.Val1 <= BT_CHILDREN && ageStr != 0  )
	{
		result += "Corpse of " + GetMsgStr( TEXTMSG_GAME, ageStr );
	}
	else
	{
		string[] bt_description = { "male", "female", "human", "ghoul", "supermutant" };
		result += "Corpse of " + bt_description[ CLAMP( uint(corpse.Val0), 0, bt_description.length() - 1 ) ];
	}

	result += ". " + GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS );
	
	bool female = corpse.Val3 == GENDER_FEMALE;
	bool male = corpse.Val3 == GENDER_MALE;

	string usual = " " + ( female ? GetMsgStr( TEXTMSG_GAME, STR_DESC_F_USUAL ) : ( male ? GetMsgStr( TEXTMSG_GAME, STR_DESC_M_USUAL ) : GetMsgStr( TEXTMSG_GAME, STR_DESC_USUAL ) ) );

	string look = "";

	string comma = " ";
	bool truecomma;
	truecomma = true;
	switch( corpse.Val4 )
	{
		case( 10 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_IRRESISTIBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_IRRESISTIBLE );
			break;
		case( 9 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_MBEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_MBEAUTIFUL );
			break;
		case( 8 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_BEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_BEAUTIFUL );
			break;
		case( 7 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_ATTRACTIVE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_ATTRACTIVE );
			break;
		case( 3 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_UNPLEASANT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_UNPLEASANT );
			break;
		case( 2 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DISGUSTING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DISGUSTING );
			break;
		case( 1 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SICKENING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SICKENING );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", ";
		usual = "";
	}

	truecomma = true;
	switch( corpse.Val5 )
	{
		case( 10 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_VSTRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_VSTRONG );
			break;
		case( 9 ):
		case( 8 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_STRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_STRONG );
			break;
		case( 3 ):
		case( 2 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WEAK );
			break;
		case( 1 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_QWEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_QWEAK );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", ";
		usual = ""; 
	}

	truecomma = true;
	switch( corpse.Val6 )
	{
		case( 10 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_TOUGH ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_TOUGH );
			break;
		case( 9 ):
		case( 8 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WBUILT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WBUILT );
			break;
		case( 3 ):
		case( 2 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SLIM ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SLIM );
			break;
		case( 1 ):
			look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DELICATE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DELICATE );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", "; 
		usual = "";
	}

	truecomma = true;
	switch( corpse.Val7 )
	{
		case( 10 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_AGILE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_AGILE );
			break;
		case( 9 ):
		case( 8 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_NIMBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_NIMBLE );
			break;
		case( 3 ):
		case( 2 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_GRACELESS ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_GRACELESS );
			break;
		case( 1 ):
			look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_CLUMSY ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_CLUMSY );
			break;
		default:
			truecomma = false;
	}
	if( truecomma ) 
	{ 
		comma = ", ";
		usual = "";
	}

	string full_name = corpse.Val1 == 0 ? "The body is beheaded" : "The body belongs to |0xFFFFFF " + ( valid( name ) ? name : "unidentified person" );

	return result += ( look == "" ? usual : look ) + ". " + full_name + "|0x00FF00 .";
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos

void _PlaySound( int pos, int repeat, int, string@ soundName, int[] @ )
{
    PlaySound( soundName );
}

void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& cr, CritterCl& npc, bool sell )
{
	return CalculateItemCost( item, cr, npc, sell );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate( int[]& data )
{
    CritterGenerate( data );
}

bool player_data_check( int[]& data )
{
    SetCrtype( data );

    return CritterGenerateCheck( data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.
void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
	uint8 mode = 0;
    const ProtoItem@ proto = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );

	if( cr.IsChosen() )
    {
		// Not process locally called actions
		if( !localCall )
		{
			switch( action )
			{
				case( ACTION_MOVE_ITEM ):
					return;
				case( ACTION_MOVE_ITEM_SWAP ):
					return;
				case( ACTION_USE_ITEM ):
				{
					if( actionExt == 0 )
					{
						return;
					}		
					
					uint16 protoPid = proto.ProtoId;
					string soundName = "ROBE.mp3";
					uint8 itemType = item.GetType();
					uint8 material = proto.Material;
					
					uint16[] drink_pids = { PID_ANTIDOTE, PID_JET_ANTIDOTE };
					uint16[] inhailer_pids = { PID_JET, PID_TREB, PID_VINT };
					uint16[] pills_pids = { PID_MENTATS, PID_BUFFOUT, PID_RAD_X, PID_RAD_XL, PID_PILLEN, PID_ASPIRIN, PID_MENTATS_FRUIT, PID_PAINKILLERS2, PID_DESINFHN0, PID_PILLS, PID_HEART_PILLS };
					uint16[] injector_pids = { PID_PSYCHO};
					
					if( itemType == ITEM_TYPE_FOOD )
					{
						soundName = "chewy.ogg";
					}
					else if( inhailer_pids.find( protoPid ) != -1 )
					{
						soundName = "jet.ogg";
					}
					else if( injector_pids.find( protoPid ) != -1 )
					{
						soundName = Random( 1, 2 ) == 1 ? "obj_braintank_steam_01.wav" : "obj_braintank_steam_02.wav";
					}
					else if( pills_pids.find( protoPid ) != -1 )
					{
						soundName = "solopill.ogg";				
					}
					else if( drink_pids.find( protoPid ) != -1 || ( ( itemType == ITEM_TYPE_DRINK && find_opened_drinks( item ) == true && item.CritSlot == SLOT_HAND1 ) ) )
					{
						cr.Stat[ ST_GENDER ] == GENDER_MALE ? soundName = "water.wav" : soundName = "fem_drinking.ogg";
					}
					else if( itemType == ITEM_TYPE_FLASK && item.CritSlot == SLOT_HAND1 && item.Val0 > 0 )
					{
						cr.Stat[ ST_GENDER ] == GENDER_MALE ? soundName = "water.wav" : soundName = "fem_drinking.ogg";
					}
					else if( itemType == ITEM_TYPE_KEY )
					{
						soundName = "BLANK.mp3";
					}
					else if( itemType == ITEM_TYPE_ARMOR )
					{
						switch( material )
						{
							case( MATERIAL_FABRIC ):
								soundName = "ROBE.mp3";
								break;
							case( MATERIAL_LEATHER ):
							case( MATERIAL_ARMORED_LEATHER ):
								soundName = "LTHARMOR.mp3";
								break;
							case( MATERIAL_METAL ):
								soundName = "MTLARMOR.mp3";
								break;
							case( MATERIAL_POLYMER ):
								soundName = "CMBTFLX.mp3";
								break;
							case( MATERIAL_COMPOSITE ):
								soundName = "PWRARMOR.mp3";
								break;
							default:
								soundName = "ROBE.mp3";
								break;
						}
					}

					int[] radius = { 5 };
					__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
					break;
				}
				
				case ACTION_DROP_ITEM:
					return;
				case ACTION_USE_WEAPON:
				{
					if( FLAG( ( ( actionExt >> 12 ) & 0xF ), ACTION_FLAG_CHOSEN_INCLUSIVE ) )
					{
						break; // PROCESS IT !
					}
					return;
				}
				case ACTION_RELOAD_WEAPON:
					break;
				case ACTION_USE_SKILL:
					return;
				case ACTION_PICK_ITEM:
					return;
				case ACTION_PICK_CRITTER:
					break;
				case ACTION_OPERATE_CONTAINER:
					return;             // Skip processing
				case ACTION_WINDUP:
				{
					if( FLAG( ( ( actionExt >> 12 ) & 0xF), ACTION_FLAG_CHOSEN_INCLUSIVE ) )
					{
						break;
					}
					return;
				}
				default:
					break;
			}
		}
		else
		{
			switch(action)
			{
				case ACTION_USE_WEAPON:
				{
					if( GetProtoWindupTime( proto, actionExt, cr ) != 0 && cr.ParamBase[ CR_IS_WINDUPED ] != 1 )
					{
						cr.Wait( GetProtoWindupTime( proto, actionExt, cr ) ); // wait here, on client, let server handle.
						return;
					}
					break;
				}	
			}
		}
	}

    switch( action )
    {
		case( ACTION_TEST ):
		{
			Message("TEST ACTION PERFORMED");
			break;
		}
		
		case( ACTION_MOVE ):
		{
			// Not implemented
			// cr.Wait(move time);
			break;
		}
		
		case( ACTION_RUN ):
		{
			// Not implemented
			// cr.Wait(run time);
			break;
		}
		
		case( ACTION_MOVE_ITEM ):
		{
			if( cr.IsLife() )
			{
				//cr.Wait( GetActionTime( ACTION_MOVE_ITEM, cr ) );
				
				uint8 fromSlot = actionExt;
				uint8 toSlot = item.CritSlot;
				string soundName = "";
				uint8 material = proto.Material;
		
				cr.ClearAnim();
				
				if( toSlot == SLOT_HAND1 && proto.Type == ITEM_TYPE_WEAPON )
				{
					cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
					break;
				}
				else if( fromSlot == SLOT_HAND1 && proto.Type == ITEM_TYPE_WEAPON )
				{
					cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
					break;
				}
				else if( ( toSlot == SLOT_ARMOR || fromSlot == SLOT_ARMOR ) && proto.Type == ITEM_TYPE_ARMOR )
				{ 
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.mp3";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.mp3";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.mp3";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.mp3";
							break;
						default:
							soundName = "ROBE.mp3";
							break;
					}
				}
				else
				{
					soundName = "ROBE.mp3";
				}
				
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
				cr.Animate( 0, ANIM2_SWITCH_ITEMS );
			}
			break;
		}
		
		case( ACTION_MOVE_ITEM_SWAP ):
		{	
			const uint8 item_Subtype = item.Proto.Item_Subtype;
			int[] radius = { 5 };
			__PlaySound( cr.Id, cr.HexX, cr.HexY, "LTHARMOR.mp3", radius );
			break;
		}
		
		case( ACTION_USE_ITEM ):
		{
			if( !cr.IsLife() || !valid( proto ) )
			{
				return;
			}

			cr.ClearAnim();

			if( proto.Type == ITEM_TYPE_WEAPON )
			{ 
				if( FLAG( proto.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( proto.Weapon_Anim1, proto.Weapon_Anim2_0 ) )
				{
					cr.Animate( proto.Weapon_Anim1, proto.Weapon_Anim2_0, item );
				}
			}
			else
			{
				cr.Animate( 0, ANIM2_USE, item );
			}
			
			if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 )
			{
				cr.Wait( GetProtoTime( proto, USE_USE, cr ) );
			}
			
			break; 
		}
			
		case( ACTION_DROP_ITEM ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_DROP_ITEM, cr ) );
				const uint8 item_Subtype = item.Proto.Item_Subtype;
				cr.ClearAnim();
				string soundName = "IPUTDOWN.mp3";
				uint8 material = proto.Material;
				
				if( item_Subtype == 55 || item_Subtype == 56  )
				{
					soundName = "KNIFE.mp3"; 
				}
				else if( item_Subtype == 58 || item_Subtype == 60 )
				{
					soundName = "SLEDGE.mp3";
				}
				else if( item_Subtype == 57 || item_Subtype == 61 )
				{
					soundName = "SPEAR.mp3";
				}
				else if( item_Subtype == 1 || item_Subtype == 2 || item_Subtype == 15 || item_Subtype == 25 || item_Subtype == 35 || item_Subtype == 41 )
				{
					soundName = "PISTOL.mp3";
				}
				else if( item_Subtype == 3 || item_Subtype == 17 || item_Subtype == 27 || item_Subtype == 37 )
				{
					soundName = "UZI.mp3";
				}
				else if( item_Subtype >= 4 && item_Subtype <= 8 || item_Subtype == 16 || item_Subtype == 18 || item_Subtype == 19 
					|| item_Subtype == 26 || item_Subtype == 28 || item_Subtype == 29 || item_Subtype == 36 || item_Subtype == 38 || item_Subtype == 39 || item_Subtype == 42 )
				{
					soundName = "RIFLE.mp3";
				}
				else if( item_Subtype == 10 || item_Subtype == 11 || item_Subtype == 12 || item_Subtype == 14 )
				{
					soundName = "FLAMETHR.mp3";
				}
				else if( item_Subtype == 13 || item_Subtype == 20 || item_Subtype == 30 || item_Subtype == 40 )
				{
					soundName = "MINIGUN.mp3";
				}
				else if( proto.Type == ITEM_TYPE_ARMOR )
				{			
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.mp3";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.mp3";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.mp3";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.mp3";
							break;
						default:
							soundName = "ROBE.mp3";
							break;
					}	
				}
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
				cr.Animate( 0, ANIM2_PICKUP );
			}
			break;
		}

		case( ACTION_USE_WEAPON ):
		{
			if( localCall )
			{
				return;
			}
			
			if( cr.IsLife() && valid( proto ) )
			{
				int use   = ( actionExt & 0xF );
				int aim   = ( ( actionExt >> 4 ) & 0xF );
				bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );
				
				if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 )
				{
					cr.Wait( GetProtoTime( proto, use, cr ) );
				}
				
				cr.ClearAnim();
				uint8 weaponSubtype = proto.Item_Subtype;
				uint8 n = 4;
				if( weaponSubtype == ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN || weaponSubtype == ITEM_SUBTYPE_WEAPON_LASER_MINIGUN || weaponSubtype == ITEM_SUBTYPE_WEAPON_PLASMA_MINIGUN || weaponSubtype == ITEM_SUBTYPE_WEAPON_PULSE_MINIGUN )
				{
					n = 5;
				}
				
				if( proto.Weapon_MaxAmmoCount > 0 )
				{
					uint8 rounds = _WeaponRound( proto, use );
					//Message( "proto: " + proto.ProtoId + " use " + use + " Weapon_Anim2_0: " + proto.Weapon_Anim2_0 + " Weapon_Anim2_1: " + proto.Weapon_Anim2_1 + " Weapon_Anim2_2: " + proto.Weapon_Anim2_2 );
					for( uint8 i = 0; i < rounds; i += n )
					{
						cr.Animate( 0, _WeaponAnim2( proto, use ), item );
					}
				}
				else
				{
					cr.Animate( 0, _WeaponAnim2( proto, use ), item );
				}
				
				if( fail )
				{
					cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
				}
				else
				{
					cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
				}
			}
			break;
		}
		
		case( ACTION_RELOAD_WEAPON ):
		{
			if( cr.IsLife() && valid( proto ) )
			{
				cr.ClearAnim();
				cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
				int radius = 3;
				int[] values = { item.Proto.ProtoId, 2, radius };
				__PlayWeaponSound( cr.Id, cr.HexX, cr.HexY, "LAUGHTE1.mp3", values );
			}
			break;
		}
		
		case( ACTION_WINDUP ):
		{
			if(cr.IsLife() && cr.ParamBase[ CR_IS_WINDUPED ] != 1 )
			{
				cr.Wait( GetProtoWindupTime( proto, actionExt, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_PREPARE_WEAPON );
			}
			break;
		}
		
		case( ACTION_USE_SKILL ):
		{
			if( cr.IsLife() && actionExt != SK_STEAL )
			{
				cr.Wait( GetActionTime( ACTION_USE_SKILL, cr ) );
				cr.ClearAnim();
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, "LTHARMOR.mp3", radius );
				cr.Animate( 0, ANIM2_USE );
			}
			break;
		}
		
		case( ACTION_PICK_ITEM ):
		{
			if( cr.IsLife() )
			{	
				cr.Wait( GetActionTime( ACTION_DROP_ITEM, cr ) );
				const uint8 item_Subtype = proto.Item_Subtype;
				bool isGround = ( proto.Type == ITEM_TYPE_CONTAINER ? proto.GroundLevel : true );				
				if( actionExt != 0 )
				{ 
					isGround = true;
				}
				
				string soundName = "IPUTDOWN.mp3";
				uint8 material = proto.Material;
				cr.ClearAnim();
				
				if( proto.Type == ITEM_TYPE_DOOR )
				{
					isGround = false;
					soundName = "BLANK.mp3";	
				}
				else if( proto.Type == ITEM_TYPE_GENERIC || proto.Type == ITEM_TYPE_MISC )
				{
					isGround = false;
					soundName = "ROBE.mp3";
				}
				else if( proto.Type == ITEM_TYPE_GRID )
				{
					if( proto.Grid_Type != GRID_LADDERBOT && proto.Grid_Type != GRID_EXITGRID )
					{
						isGround = false;
					}
					soundName = "ROBE.mp3";
				}
				else if( proto.Type == ITEM_TYPE_CONTAINER )
				{
					soundName = "BLANK.mp3";
				}
				else if( item_Subtype == 55 || item_Subtype == 56  )
				{
					soundName = "KNIFE.mp3";
				}
				else if( item_Subtype == 58 || item_Subtype == 60 )
				{
					soundName = "SLEDGE.mp3";
				}
				else if( item_Subtype == 57 || item_Subtype == 61 )
				{
					soundName = "SPEAR.mp3";
				}
				else if( item_Subtype == 1 || item_Subtype == 2 || item_Subtype == 15 || item_Subtype == 25 || item_Subtype == 35 || item_Subtype == 41 )
				{
					soundName = "PISTOL.mp3";
				}
				else if( item_Subtype == 3 || item_Subtype == 17 || item_Subtype == 27 || item_Subtype == 37 )
				{
					soundName = "UZI.mp3";
				}
				else if( item_Subtype >= 4 && item_Subtype <= 8 || item_Subtype == 16 || item_Subtype == 18 || item_Subtype == 19 
					|| item_Subtype == 26 || item_Subtype == 28 || item_Subtype == 29 || item_Subtype == 36 || item_Subtype == 38 || item_Subtype == 39 || item_Subtype == 42 )
				{
					soundName = "RIFLE.mp3";
				}
				else if( item_Subtype == 10 || item_Subtype == 11 || item_Subtype == 12 || item_Subtype == 14 )
				{
					soundName = "FLAMETHR.mp3";
				}
				else if( item_Subtype == 13 || item_Subtype == 20 || item_Subtype == 30 || item_Subtype == 40 )
				{
					soundName = "MINIGUN.mp3";
				}
				else if( proto.Type == ITEM_TYPE_ARMOR)
				{
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.mp3";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.mp3";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.mp3";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.mp3";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.mp3";
							break;
						default:
							soundName = "ROBE.mp3";
							break;
					}
				}
				
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, soundName, radius );
				cr.Animate( 0, isGround ? ANIM2_PICKUP : ANIM2_USE );
			}
			break;
		}
		
		case( ACTION_PICK_CRITTER ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_PICK_CRITTER, cr ) );
				cr.ClearAnim();
				int[] radius = { 5 };
				
				switch( actionExt )           // 0 - loot, 1 - steal success, 2 - push, 3 - steal fail
				{
					case( 0 ):
						__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
						cr.Animate( 0, ANIM2_LOOT );
						break;
					case( 1 ):
						break;
					case( 2 ):
						__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
						cr.Animate( 0, ANIM2_PUSH );
						break;
					case( 3 ):
						__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
						cr.Animate( 0, ANIM2_STEAL );
						break;
					default:
						break;
				}
			}
			break;
		}
		
		case( ACTION_OPERATE_CONTAINER ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_OPERATE_CONTAINER, cr ) );
				cr.ClearAnim();
				int transferType = actionExt / 10;
				int directionType = actionExt % 10;
				
				int[] radius = { 5 };
				__PlaySound( cr.Id, cr.HexX, cr.HexY, "ROPE.mp3", radius );
				if( transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT )
				{
					cr.Animate( 0, ANIM2_PICKUP );
				}
				else if( transferType != TRANSFER_CRIT_STEAL )
				{
					cr.Animate( 0, ANIM2_USE );
				}
			}
			break;
		}
		
		case( ACTION_DODGE ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_DODGE, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
			}
			break;
		}
		
		case( ACTION_DAMAGE ):
		{
			if( cr.IsLife() || cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_DAMAGE, cr ) );
				uint8 dir = actionExt & 0x1;
				cr.ClearAnim();
				if( cr.IsLife() )
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				}
				else
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
			}
			break;
		}
		case( ACTION_DAMAGE_FORCE ):
		{
			if( cr.IsLife() || cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_DAMAGE_FORCE, cr ) );
				DamageSound( cr, actionExt );
				uint8 dir = actionExt & 0x1;
				cr.ClearAnim();
				if( cr.IsLife() )
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				}
				else
				{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
			}
			break;
		}
		
		case( ACTION_KNOCKOUT ):
		{
			if( !cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_KNOCKOUT, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_STANDUP ):
		{
			if( cr.IsKnockout() )
			{
				cr.Wait( GetActionTime( ACTION_STANDUP, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_FIDGET ):
		{
			if( cr.IsLife() )
			{
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_FIDGET );
			}
			break;
		}
		
		case( ACTION_DEAD ):
		{
			if( !cr.IsDead() )
			{
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_CONNECT ):
		{    
			// __tempFastText = "";
			break;
		}
		
		case( ACTION_DISCONNECT ): //TODO: checkout later!
		{    
			__tempFastText = "";
			__fastPanelShow = false;
			__fastPanel = false;
			break;
		}
		
		case( ACTION_RESPAWN ):
		{
			if(!cr.IsChosen())
			{
				cr.Wait( GetActionTime( ACTION_RESPAWN, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_STANDUP_FRONT );
			}
			break;
		}
		
		case( ACTION_REFRESH ):
		{
			break;
		}
		
		default:
		{
			break;
		}
	}
}

void DamageSound( CritterCl& cr, int actionExt )
{
	ItemCl@ armor = _CritGetItemArmor( cr );
	uint8 armorSubType = valid(armor) ? armor.Proto.Item_Subtype : 0;
	uint16 weaponPid = ( actionExt >> 16 ) & 0xFFFF;
	ProtoItem@ weaponProto = GetProtoItem( weaponPid );
	uint8 weaponSubType = valid(weaponProto) ? weaponProto.Item_Subtype : 0;
	string soundName = "WHD1FXX1.mp3";
		
   if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC0 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC15 )
   { 
		if( ( weaponSubType >= 1 && weaponSubType <= 11 ) || (weaponSubType >= 13 && weaponSubType <= 14 ) )
		{           
			soundName = "WHD1FXX1.mp3";
		}
		else if( weaponSubType >= 15 && weaponSubType <= 24 )
		{
			soundName = "laser_01.ogg"; 
		}
		else if( weaponSubType >= 25 && weaponSubType <= 34 )
		{
			soundName = "WHS1FXX1.mp3";
		}
		else if( weaponSubType >= 35 && weaponSubType <= 40 )
		{
			soundName = "WHZ1FXX1.mp3";
		}
	}
	else if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC20 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC25 )
	{ 
		if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
		{
			soundName = "WHD1MXX1.mp3";
		}
		else if( weaponSubType >= 15 && weaponSubType <= 24 )
		{
			soundName = "laser_02.ogg";
		}
		else if( weaponSubType >= 25 && weaponSubType <= 34 )
		{
			soundName = "WHS1FXX2.mp3";
		}
		else if( weaponSubType >= 35 && weaponSubType <= 40 )
		{
			soundName = "WHZ1FXX2.mp3";
		}
	}
	else if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC30 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC40 )
	{ 
		if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
		{
			soundName = "WHH1SXX2.mp3";
		}
		else if( weaponSubType >= 15 && weaponSubType <= 24 )
		{
			soundName = "laser_03.ogg";
		}
		else if( weaponSubType >= 25 && weaponSubType <= 34 )
		{
			soundName = "WHS1SXX1.mp3";
		}
		else if( weaponSubType >= 35 && weaponSubType <= 40 )
		{
			soundName = "WHZ1MXX1.mp3";
		}
	}
	else if( armorSubType >= ITEM_SUBTYPE_ARMOR_AC45 && armorSubType <= ITEM_SUBTYPE_ARMOR_AC50 )
	{ 
		if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) )
		{
			soundName = "WHJ1MXX1.mp3";
		}
		else if( weaponSubType >= 15 && weaponSubType <= 24 )
		{
			soundName = "laser_04.ogg";
		}
		else if( weaponSubType >= 25 && weaponSubType <= 34 )
		{
			soundName = "WHS1WXX1.mp3";
		}
		else if( weaponSubType >= 35 && weaponSubType <= 40 )
		{
			soundName = "WHZ1MXX2.mp3";
		}
	}
	
	int radius = 20;
	CritterCl@[] players;
	int hx = cr.HexX, hy = cr.HexY;
	GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
	int[] values = { radius };
	for( uint i = 0; i < players.length(); i++ )
	{
		CritterCl@ player = players[i];
		if( valid( player ) )
		{
			__PlaySound( cr.Id, hx, hy, soundName, values );
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
	{
		PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
	//we dont need this
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    if( collection == ITEMS_INVENTORY )
    {
		Item@ stuff = null;
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
			@ stuff = items[i];
			if( valid( stuff ) )
			{
				uint16 pid = stuff.GetProtoId();
				if( pid == PID_WORKBENCH_TOKEN || pid == PID_FIREPLACE_TOKEN || pid == PID_AMMOBENCH_TOKEN ) // Delete this shit once refactor of crafting module is done!!!
				{
					@items[i] = null;
				}
				
				uint8 stuff_type = stuff.GetType();
				switch( __inventoryCollection )
				{
					case( 1 ):
					{
						if( stuff_type != ITEM_TYPE_WEAPON )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 2 ):
					{
						if( stuff_type != ITEM_TYPE_AMMO )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 3 ):
					{
						if( stuff_type != ITEM_TYPE_ARMOR )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 4 ):
					{
						if( stuff_type != ITEM_TYPE_DRUG )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 5 ):
					{
						if( stuff_type != ITEM_TYPE_MISC )
						{
							@items[ i ] = null;
						}
						break;
					}
					case( 6 ):
					{
						if( stuff_type != ITEM_TYPE_KEY )
						{
							@items[ i ] = null;
						}
						break;
					}
					default:
						break;
				}
			}
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

void SetHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "w" ) >= 0 )
    {
		if( param0 == 0 ) f.writeString( param3 );
        f.close();
        return;
    }
}

void CheckHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "r" ) >= 0 )
    {
        int number = 0;
        string line;
        f.setPos( 0 );
        while( !f.isEndOfFile() )
        {
            f.readLine( line );
            if( line.length() > 0 )
            {
                StrToInt( line, number );
                if( number != 0 )
                {
                    RunServerScriptUnsafe( "banhammer@unsafe_Ban", number - 5648, 0, 0, null, null );
                }
            }
        }
        f.close();
    }
}

void loger( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( param1 == 0 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\help.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\help.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 1 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\warn.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\warn.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 2 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\kill.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\kill.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 3 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\faction.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\faction.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 4 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\bans.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\bans.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 5 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 6 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
                return;
            }
            return;
        }
        else
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 7 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 8 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\crims.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\crims.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
    }
}

void _testmode( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __testmode = uint( param0 );
}

bool updateSINF()
{
	CritterCl@ chosen =  GetChosen();
	if( !valid( chosen ) || chosen.Param[ CR_SINF_MODE ] == 0 )
	{
		return false;
	}
	
	__sinf = isGM( chosen ) ? chosen.Param[ CR_SINF_MODE ] : 0;

    updateAllNicks();
	ChosenRefreshMap();
	return true;
}

void _sinf( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __sinf = uint( param0 );

    updateAllNicks();
	ChosenRefreshMap();
}

bool waiting = false;

void _waiting( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __waiting = ( ( param0 != 0 ) ? true : false );
    ChangeCursor( ( __waiting ) ? CURSOR_WAIT : CURSOR_DEFAULT );
}

void GetIfaceIniPos( string iniKey, uint16& posX, uint16& posY, uint16& lineEnd )
{
    string@ str = GetIfaceIniStr( iniKey );
    if( @str == null || str == "" )
	{
        return;
	}
	
    string@[] @ valuesStr = splitEx( str, " " );
    if( valuesStr.length() != 3 )
	{
        return;
	}
	
    int[] values( 3 );
    for( int i = 0; i < 3; i++ )
	{
        if( not StrToInt( valuesStr[ i ], values[ i ] ) )
		{
            return;
		}
	}
    posX = values[ 0 ];
    posY = values[ 1 ];
    lineEnd = values[ 2 ];
}

bool isDKPInit = false;
uint16[] dkp_array;

void DKPInit()
{

	if(dkp_array.length() % 2 != 0)
	{
		Log("dkp_array wring size.");
	}
	else
	{
		isDKPInit = true;
	}
}

uint16 DKPCheckDrugKey( uint8 key )
{

	if(!isDKPInit)
	{
		DKPInit();
	}
	
	for(uint8 i = 0, j = dkp_array.length(); i < j; i++)
	{
		if(dkp_array[i] == key && i % 2 == 0)
		{
			return dkp_array[i+1];
		}
	}

	return uint16(-1);
}

void __ReInit (int p0, int p1, int p2, string@ p3, int[]@ p4)
{
	start (); // wtf?
	screen_change( true, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0); // wtf?
	screen_change( false, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0); // wtf?
	render_iface( MainWindow, 2 ); // wtf?
}

void __Talk(int param0, int param1, int param2, string@ param3, int[]@ param4)
{
	//Message("Sended:\n'" + param3 + "'" );
	
	if( !valid( param3 ) )
	{
		return;
	}
	
	string@[]@ parts = split( param3, "::" );
	
	string result = "";
	
	if( !valid( parts ) || parts.length() == 0 )
	{
		result = "Nothing.";
	}
	else
	{
		uint len = parts.length();
		for( uint i = 0; i < len; i++ )
		{
			int PID = 0;
			if( !StrToInt( parts[i], PID ) || PID <= 0 )
			{
				result += parts[i];
			}
			else
			{
				result += GetMsgStr( TEXTMSG_ITEM, PID );
			}
		}
	}
	
	//Message("Processed:\n'" + result + "'" );

	if( param0 == SAY_NETMSG )
	{
		Message( result );
	}
	else
	{
		RunServerScriptUnsafe( "test@unsafe_CritterSay", param0, 0, 0, result, null );
	}
	//Message("Returned.");
}

void NamesUpdater( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	RunServerScriptUnsafe( "gm@unsafe_sinf", 0, 0, 0, null, null );
}

void updateMapId( int mapID, int, int, string@, int[]@ )
{
	__mapID = mapID;
    #ifndef PHYSICAL_UI
	    iList().checkMap();
    #endif //PHYSICAL_UI
}

uint[] invisible_pids = 
{
	PID_INVISIBLE_BLOCK, PID_NO_SHOOT_WOOD_BLOCKER, PID_NO_SHOOT_METAL_BLOCKER, PID_NO_COVER_BLOCKER, PID_GENERIC_BLOCKER, PID_WOOD_BLOCKER, PID_METAL_BLOCKER, PID_FIELD_BLOCKER, PID_STONE_BLOCKER, 
	PID_DOOR_BLOCKER,
	PID_LAZER_FENCE_NS, PID_LAZER_FENCE_WE, PID_DEATH_HEX,
	PID_SHADOW,
	PID_WILDFIRE_1, PID_WILDFIRE_2, PID_WILDFIRE_3, PID_WILDFIRE_4, PID_WILDFIRE_5,
	PID_SMOKE, PID_STEAM, PID_STILL_STEAM, PID_FURNACE_SMOKE,
	PID_ASHES_1, PID_ASHES_2, PID_ASHES_3,
	PID_SHELL_CASING,
	//TREES
	PID_TREE_GXS1, PID_TREE_GXS2, PID_TREE_GXS3, PID_TREE_DS1, PID_TREE_DS2, PID_TREE_DS3, PID_TREE_DS4, PID_TREE_DS5, PID_TREE_DS6, PID_TREE_DS7, PID_TREE_DS8, PID_TREE_DS9, PID_TREE_DS10, 
	PID_TREE_DS11, PID_TREE_BS1, PID_TREE_BS2, PID_TREE_BS3, PID_TREE_GS1, PID_TREE_GS2, PID_TREE_GS3, PID_TREE_GS4, PID_TREE_GS5, PID_TREE_GS6, PID_TREE_GS7, PID_TREE_GS8, PID_TREE_GS9,
	PID_TREE_GS10, PID_TREE_GS11, PID_TREE_GS12, PID_TREE_GS13, PID_TREE_GS14, PID_TREE_GS15, PID_TREE_GS16, PID_TREE_GS17, PID_TREE_GS18, PID_TREE_GS19, PID_TREE_DM1, PID_TREE_DM2, PID_TREE_GM1,
	PID_TREE_GM2, PID_TREE_GM3, PID_TREE_GM4, PID_TREE_GM5, PID_TREE_GM6, PID_TREE_GM7, PID_TREE_GM8, PID_TREE_GM9, PID_TREE_GM10, PID_TREE_GM11, PID_TREE_GM12, PID_TREE_GM13, PID_TREE_GM14, 
	PID_TREE_GM15, PID_TREE_DL1, PID_TREE_DL2, PID_TREE_DL3, PID_TREE_DL4, PID_TREE_DL5, PID_TREE_DL6, PID_TREE_DL7, PID_TREE_DL8, PID_TREE_DL9, PID_TREE_BL1, PID_TREE_BL2, PID_TREE_GL1, 
	PID_TREE_GL2, PID_TREE_GL3, PID_TREE_GL4, PID_TREE_GL5, PID_TREE_GL6, PID_TREE_GL7, PID_TREE_GL8, PID_TREE_GXXL1, PID_TREE_GXXL2, PID_TREE_CS1, PID_TREE_CS2, PID_TREE_CS3, PID_TREE_CL1, 
	PID_TREE_CL2, PID_TREE_CL3, PID_TREE_CL4, PID_TREE_CL5, PID_TREE_GL2S,
	//BUSH
	PID_BUSH_GREEN_01, PID_BUSH_GREEN_02, PID_BUSH_GREEN_03, PID_BUSH_01, PID_BUSH_02, PID_BUSH_03, PID_BUSH_04, PID_BUSH_05, PID_BUSH_06, PID_BUSH_07, PID_BUSH_08,
	//HIDDEN_ITEMS
	PID_MICROPHONE, PID_ELECTRONIC_BUG,
	//SANDBAGS
	PID_SINGLE_SANDBAG, PID_DOUBLE_SANDBAG, PID_TRIPLE_SANDBAG, PID_QUADRO_SANDBAG, PID_QUINTO_SANDBAG,
	//DYNAMIC_LIGHTS
	PID_SWITCH1_DIR2, PID_SWITCH1_DIR3, PID_SWITCH2_DIR2, PID_SWITCH2_DIR3, PID_SWITCH3_DIR2, PID_SWITCH3_DIR3, PID_LIGHT_SOURCE,
	//EFFECTS
	PID_FLASH_NORM, PID_FLASH_RED, PID_FLASH_GREEN, PID_FLASH_BLUE,
	//BLOOD
	PID_BLOOD_SMALL_1, PID_BLOOD_SMALL_2, PID_BLOOD_SMALL_3, PID_BLOOD_BIG_1, PID_BLOOD_BIG_2, PID_BLOOD_BIG_3, PID_BLOOD_BONES_1, PID_BLOOD_BONES_2, PID_BLOOD_BONES_3
};


#define SHOW_PLAYER_INFO_DELAY	400
int last_player_info_tick = 0;
uint[][] IDs;
void show_player_info()
{
    #ifndef PHYSICAL_UI
	    if( GetTick() - last_player_info_tick < SHOW_PLAYER_INFO_DELAY * 0.95 )
		{
			return;
		}
	    int delta = GetTick() - last_player_info_tick;
	    last_player_info_tick = GetTick();
    #endif //!PHYSICAL_UI
    #ifdef PHYSICAL_UI
        if( !PhysicalUI_StartFrame() )
		{
			return;
        }
		physical_selected_type = 0;
        physical_selected_id = 0;
    #endif //PHYSICAL_UI
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) )
	{
		return;
	}
	bool is_gm = isGM( cr );

    Color@ line_color = NewColor( 0xe3, 0xad, 0x4f );
    Color@ select_color = NewColor( 0xa3, 0xed, 0x4f );
	
	if( FLAG( cr.Param[PLAYER_FLAGS], PLAYER_FLAG_SHOW_ITEMS ) )
	{
        #ifndef PHYSICAL_UI
            if( iList().updated() )
			{
                IDs = iList().getIDs();
            }
			
            string text;
            ItemCl@ item, stack;
            for( uint i = 0, l = IDs.length(); i < l; i++ )
            {
                if( IDs[i].length() == 0 || IDs[i][0] == 0 )
				{
                    continue;
                }
				
                @item = GetItem( IDs[i][0] );
                if( !valid( item ) || GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 )
				{
                    continue;
                }
				
                text = "";
                for( uint j = 0, k = IDs[i].length(); j < k; j++ )
                {
                    if( IDs[i][j] == 0 )
					{
						continue;
                    }
					@stack = GetItem( IDs[i][j] );
                    
                    if( !valid( stack ) || ( !is_gm && invisible_pids.find( stack.GetProtoId() ) != -1 ) || stack.GetType() == ITEM_TYPE_EFFECT )
					{
                        continue;
					}
					
                    text += GUI_itemInfo( stack );
                }
                
                if( text.length() > 0 )
				{
                    MapMessage( text, item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
				}
			}
        #endif //!PHYSICAL_UI
        #ifdef PHYSICAL_UI
            ItemCl@[] items;
            uint len = GetAllItems( @items );
            for( uint i = 0; i < len; i++ )
			{
                ItemCl@ item = items[i];
                if( GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 || ( !is_gm && invisible_pids.find( item.GetProtoId() ) != -1 ) || item.GetType() == ITEM_TYPE_EFFECT )
				{
                    continue;
                }
                string@ text = GUI_itemInfo( item );
                if( text.length() > 0 )
				{
                    PhysicalDrawTextAboveHex( text, item.HexX, item.HexY, line_color, 1, item.Id, 0, is_gm, is_gm );
                }
            }
			
			items.resize(0);
        #endif //PHYSICAL_UI
	}
	
    #ifdef PHYSICAL_UI
        PhysicalUI_EndFrame();
    #endif //PHYSICAL_UI
}

string GUI_itemInfo( uint id )
{
	return( GUI_itemInfo( GetItem( id ) ) );
}
	
string GUI_itemInfo( ItemCl@ item )
{
	if( !valid( item ) ) 
	{
		return "[null]";
	}

	string@ info = itemText( item );
	string text = ( valid( info ) ? "|0xe3ad4f " + info + "\n" : "" );
		
	if( item.Val9 != PID_POPUP && item.GetProtoId() != PID_POPUP )
	{
		string itemLex = "";
		string sub0 = "";
		string sub1 = "";
		string sub2 = "";
		string sub3 = "";
		string sub4 = "";
		string sub5 = "";
		
		if( valid( item.Lexems ) )
		{
			uint len = item.Lexems.length();
			if( len > 1 )
			{
				text += "'" + cutter( item.Lexems ) + "'\n";
			}
		}
	}
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) ) 
	{
		return "[!cr]";
	}
	
	if( isGM( cr ) )
	{
		text += ( "|0xffffff " + "#" + "|0x78E354 " + item.Id + "|0xffffff " + " PID: " + "|0x78E354 " + item.GetProtoId() + "|0xffffff " + "\n" ) +
		"";
	
		uint[] vals = { item.Val0, item.Val1, item.Val2, item.Val3, item.Val4, item.Val5, item.Val6, item.Val7, item.Val8, item.Val9 };
		
		for( uint i = 0, l = vals.length(); i < l; i++ )
		{
			text += ( vals[i] != 0 ? "|0xffffff " + "VAL#" + "|0x4ce0d2 " + i + "|0xffffff " + ": " + "|0x78E354 " + vals[i] + "\n" : "" );
		}
	}
	
	return text;
}

void SetItemWeight( int itemId, int weight, int param2, string@ param3, int[]@ param4 )
{
	chosenContainerItems.set( "" + itemId, weight );
}

void __HearWhisper( int x, int y, int, string@ text, int[] @ )
{
	string@[] @ valuesStr = splitEx( text, "@" );
    if( valuesStr.length() != 2 )
	{
		return;
	}
	
    MapMessage( ".." + valuesStr[1] + "..", x, y, __DamageHitDelay, 0x0000FFFF, true, 0, 0 );
    Message( valuesStr[0] + ": |0x0000FFFF .." + valuesStr[1] + ".." );
}

void __message_raise_skill( int amount, int skillNum, int param2, string@ param3, int[]@ param4 )
{
	string inform;
	if( amount > 0 )
	{
		inform = GetMsgStr( TEXTMSG_TEXT, STR_SKILL_RAISED ) + "|0xFFFF00 " + GetMsgStr( TEXTMSG_GAME, skillNum * 10 + 100001 ) + GetMsgStr( TEXTMSG_TEXT, STR_SKILL_RAISED_BY ) + "|0xFFFF00 " + amount + "|0x3CF800 .";
	}
	else
	{
		inform = GetMsgStr( TEXTMSG_TEXT, STR_FAILED_TO_RAISE_SKILL );
	}
	Message( inform );
}

/*
string genderEnding( CritterCl& cr )
{
	switch( cr.Stat[ ST_GENDER ] )
	{
		case( 0 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_MALE_ENDING );
		case( 1 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_FEMALE_ENDING );
		case( 2 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_IT_ENDING );
	}
	return "";
}*/

string ContainerWeight( ItemCl& item )
{
	if( !valid( item ) )
	{
		return "error";
	}
	
	string result = "";
	float weight;
	chosenContainerItems.get( "" + item.Id, weight );
	weight += item.Proto.Weight;
	float weightBonus = 1.0f;
	string bonus = "";
	if( item.CritSlot == SLOT_BACK || item.CritSlot == SLOT_MISC )
	{
		switch( item.GetProtoId() )
		{
			case( PID_BACKPACK ):
			case( PID_AMMO_PACK ):
			case( PID_PORTABLE_REFRIGERATOR ):
			case( PID_STUFF_SUPPLIES):		
				weightBonus = 0.5f;
				bonus = " ( |0xFFFF00 50% |0x3CF800 )";
				break;
			case( PID_BROWN_BAG ):
			case( PID_TRAVEL_BAG ):
			case( PID_CHEMTEC_CASE ):
			case( PID_METAL_CASE ):
			case( PID_BLOODY_FIRST_AID_BAG ):
			case( PID_FIRST_AID_BAG ):
			case( PID_cashbag ):
			case( PID_DOCTORS_BAG ):
			case( PID_FIRST_AID_KIT ):		
			case( PID_FIELD_MEDIC_KIT ):		
			case( PID_PARAMEDICS_BAG ):		
			case( PID_MEDICAL_SUPPLIES ):		
			case( PID_BRIEFCASE ):		
				weightBonus = 0.8f;
				bonus = " ( |0xFFFF00 80% |0x3CF800 )";
				break;
			case( PID_WALLET ):
			case( PID_AMMO_BELT ):
				weightBonus = 0.1f;
				bonus = " ( |0xFFFF00 10% |0x3CF800 )";
				break;
			default:
				weightBonus = 1.0f;
				break;
		}
	}

	result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", int( weight * weightBonus ) );
	result += bonus;
	
	return result;
}

void __InitSex( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChangeCursor( CURSOR_USE_SKILL );
	RunServerScriptUnsafe( "general_unsafe@unsafe_InitSexState", 0, 0, 0, null, null );
}

void __InitDevour( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChangeCursor( CURSOR_USE_SKILL );
	RunServerScriptUnsafe( "general_unsafe@unsafe_InitDevourState", 0, 0, 0, null, null );
}

void __InitUseSkillCursor( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChangeCursor( CURSOR_USE_SKILL );
}

void __ChosenRefreshMap( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	ChosenRefreshMap();
}

void __ChosenMoveAction( int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	uint[] actions = { CHOSEN_MOVE, param0, param1, 0, 0, 0, 0 };
	SetChosenActions( actions );
}

void ShowF1Help()
{
	if( ! __GmapActive && ( _MainScreen == CLIENT_MAIN_SCREEN_GAME ) && F1IsDraw )
	{
		int x = int( ( __ScreenWidth  - F1_Width ) * 0.5f );
		int y = int( ( __ScreenHeight - F1_Height ) );
		DrawSprite( F1SpriteId, -1, x, y, F1_Width, F1_Height, false, true, 0 );
	}
}

void ShowRadiation()
{
	ItemCl@[] items;
	uint len = GetAllItems( @items );
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ radSign = items[i];
		if( valid( radSign ) )
		{
			if( radSign.GetProtoId() == PID_RADIATION_MARKER )
			{
				int[] drawData;
				uint radius = uint( ABS( radSign.Val2 ) );
				if( radius > 0 )
				{
					int zx = 0, zy = 0;
					for( uint8 j = 0; j < 6; j++ )
					{
						uint8 r0 = 0xFF, g0 = 0xFF, b0 = 0x00;
						uint16 tx = radSign.HexX, ty = radSign.HexY;
						MoveHexByDir( tx, ty, j, radius );
						GetHexPos( tx, ty, zx, zy );
						drawData.insertLast( zx );
						drawData.insertLast( zy );
						drawData.insertLast( COLOR_RGBA( r0, g0, b0, 30 ) );
					}
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				}
				
				int hx = 0, hy = 0;
				GetHexPos( radSign.HexX, radSign.HexY, hx, hy );
				DrawSprite( RadSpriteId, -1, hx - 12, hy - 14, COLOR_GOLDEN );
				DrawText( "S: " + radSign.Val0, hx-12, hy - 24, hx, hy, COLOR_GOLDEN, FONT_FALLOUT, FT_BORDERED  );
				DrawText( "" + radSign.Val1 + " min", hx-12, hy + 12, hx, hy, COLOR_GOLDEN, FONT_FALLOUT, FT_BORDERED  );
			}
		}
	}
	
	items.resize(0);
}

void ShowGases()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ gasSign = items[i];
		if( valid( gasSign ) )
		{
			if( gasSign.GetProtoId() == PID_GAS_MARKER )
			{
				int[] drawData;
				uint radius = uint( ABS( gasSign.Val2 ) );
				if( radius > 0 )
				{
					int zx = 0, zy = 0;
					for( uint8 j = 0; j < 6; j++ )
					{
						uint8 r0 = 0x7F, g0 = 0x7F, b0 = 0x7F;
						uint16 tx = gasSign.HexX, ty = gasSign.HexY;
						MoveHexByDir( tx, ty, j, radius );
						GetHexPos( tx, ty, zx, zy );
						drawData.insertLast( zx );
						drawData.insertLast( zy );
						drawData.insertLast( COLOR_RGBA( r0, g0, b0, 100 ) );
					}
					DrawPrimitive( DRAW_PRIMITIVE_TRIANGLEFAN, drawData );
				}
				
				int hx = 0, hy = 0;
				GetHexPos( gasSign.HexX, gasSign.HexY, hx, hy );
				DrawSprite( GasSpriteId, -1, hx - 12, hy - 14, COLOR_LGRAY );
				DrawText( "S: " + gasSign.Val0, hx - 12, hy - 24, hx, hy, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
				DrawText( "" + gasSign.Val1 + " sec", hx-12, hy + 12, hx, hy, COLOR_LGRAY, FONT_FALLOUT, FT_BORDERED );
			}
		}
	}
	
	items.resize(0);
}

void ShowLights()
{
	ItemCl@[] items;
	uint len = GetAllItems(@items);
	for( uint i = 0; i < len; i++ )
	{
		ItemCl@ lightSign = items[i];
		if( valid( lightSign ) )
		{
			if( lightSign.GetProtoId() == PID_LIGHT_SOURCE )
			{
				int hx = 0, hy = 0;
				GetHexPos( lightSign.HexX, lightSign.HexY, hx, hy );
				DrawSprite( LightSpriteId, -1, hx - 14, hy - 18, COLOR_CYAN );
				string state = !FLAG( lightSign.Flags, ITEM_LIGHT ) ? "Off" : "On";
				DrawText( state, hx - 12, hy - 24, hx, hy, COLOR_CYAN, FONT_FALLOUT, FT_BORDERED );
				DrawText( "G: " + lightSign.Val1, hx - 12, hy + 12, hx, hy, COLOR_CYAN, FONT_FALLOUT, FT_BORDERED );
			}
		}
	}
	
	items.resize(0);
}

class FOWindowEventShowData : FOWindowEventData
{
	
}

class FOWindowEventInitData : FOWindowEventData
{
	
}

class FOWindowEventHideData : FOWindowEventData
{
	
}

FOWindowEventResult window_event(FOWindow@ window, FOWindowEvent event, FOWindowEventData@ data )
{
	switch( event )
	{	
		case FOWindowEvent::Init:
		{
			
		} break;
		
		case FOWindowEvent::Finish:
		{
			
		} break;
		
		case FOWindowEvent::Show:
		{
			
		} break;
		
		case FOWindowEvent::Hide:
		{
			
		} break;
		
		case FOWindowEvent::Custom:
		{
			
		} break;
		
		case FOWindowEvent::None:
			break;
	}
	return FOWindowEventResult::None;
}


void imgui_render( FOWindow@ window )
{

}

// Avatar@ TestAvatar = Avatar( "TestAvatar.png" );
dictionary AvatarLib;

const array<Sprite@>@ AvatarPlaceholders = null;

enum AvatarState
{
	AvatarStateNone,
	AvatarStateNoFound,
	AvatarStateDownload,
	AvatarStateGood	
}

class Avatar : Sprite
{
	AvatarState State;
	
	Avatar( uint hash )
	{
		State = Load( hash, 0 ) ? AvatarState::AvatarStateGood : AvatarState::AvatarStateNoFound;
	}
}

Sprite@ LoadAvatar( uint hash )
{
	Avatar@ result = Avatar( hash );
	AvatarLib.set( "" + hash, @result );
	return result;
}

Sprite@ GetAvatar( uint hash )
{
	if( hash == 0 )
		return AvatarPlaceholders[AvatarState::AvatarStateNone];
	Avatar@ result = null;
	if( !AvatarLib.get( "" + hash, @result ) )
		@result = cast<Avatar@>(LoadAvatar( hash ));
	if(result is null)
		return AvatarPlaceholders[AvatarState::AvatarStateNone];
	if( result.State != AvatarState::AvatarStateGood )
		return AvatarPlaceholders[result.State];
	return result;
}

Sprite@ GetAvatar( CritterCl@ critter )
{
	return GetAvatar( uint( critter.Stat[ST_AVATAR_HASH] ) );
}

void critter_name_render( CritterCl@ critter, int x, int y, int w, int h, uint alpha )
{
	auto avatar = GetAvatar( critter );
	if( avatar.Id == 0 )
		return;
	y = h;		
	x += int( ( w - x ) * 0.5 );
	x -= int(32/__SpritesZoom);
	y -= int(64/__SpritesZoom) + 20;

	DrawSprite( avatar.Id, 0, x, y, int(64/__SpritesZoom), int(64/__SpritesZoom), true, false, 0 );
}


//import void DrawText_info( string& text, int x, int y, int length, int width ) from "client_main";
void DrawText_info( string& text, int x, int y, int length, int width ) 
{
	DrawTextOutLined( text, x, y, length, width, COLOR_WHITE, COLOR_RED, COLOR_BLACK );
}

//import void DrawText_warning( string& text, int x, int y, int length, int width ) from "client_main";
void DrawText_warning( string& text, int x, int y, int length, int width ) 
{
	DrawTextOutLined( text, x, y, length, width, COLOR_YELLOW, COLOR_RED, COLOR_BLACK );
}

//import void DrawTextOutLined( string& text, int x, int y, int length, int width, int color_main, int color_outline, int color_shadow ) from "client_main";
void DrawTextOutLined( string& text, int x, int y, int length, int width, uint color_main, uint color_outline, uint color_shadow )
{	
	DrawText( text, x - 1, y - 1, length, width, color_outline , FONT_FALLOUT, 0 );
	DrawText( text, x + 2, y + 2, length, width, color_shadow  , FONT_FALLOUT, 0 );
	DrawText( text, x    , y    , length, width, color_main    , FONT_FALLOUT, 0 );
}