// comment this out to disable physical ui and enable "visible_items.fos"
#define PHYSICAL_UI

// Author: cvet, Atom
// Client main script
// Compile using fo_client.dll
#include "_utils.fos"
#include "_client_defines.fos"
#include "sprite.fos"
#include "_animation.fos"
#include "combat_h.fos"
#include "wait_time_h.fos"
#include "fofmod_h.fos"
#include "perks_h.fos"
#include "gathering_h.fos"
#include "sgui/module.fosh"

import void InitializeGame() from "config";

import void InitTestScreen() from "client_screen_test";

import void InitRadioScreen() from "radio";

import void GUI_Init() from "client_gui";
import void GUI_GetActiveScreens( int[]& result ) from "client_gui";
import void GUI_ShowScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_HideScreen( int screenIndex, int p0, int p1, int p2 ) from "client_gui";
import void GUI_Render() from "client_gui";
import bool GUI_MouseDown( int click, int x, int y ) from "client_gui";
import bool GUI_MouseUp( int click, int x, int y ) from "client_gui";
import void GUI_MouseMove( int x, int y ) from "client_gui";
import bool GUI_KeyDown( uint8 key ) from "client_gui";
import bool GUI_KeyUp( uint8 key ) from "client_gui";
import void GUI_InputLost() from "client_gui";
import int GUI_GetActiveScreen() from "client_gui";

import void CritterGenerate( int[]& data ) from "parameters";
import bool CritterGenerateCheck( int[]& data ) from "parameters";

import void InitChosenTabs() from "chosen_tabs";
import void DrawChosenTabs() from "chosen_tabs";

import void SetHotkeysUse( bool use ) from "hotkeys";

import void show_timeouts() from "client_timeouts";

import bool gm_msg( string& message ) from "client_gm";

#ifdef PLAYERS_3D
import void Init3DChaRegScreen() from "client_3d_cha_reg";
import void Set3DRegistrationGender( int gender ) from "client_3d_cha_reg";
import void Fill3DRegistrationParameters( int[]& params ) from "client_3d_cha_reg";
#endif
import void PlayAnimSound( uint crType, int gender, uint anim1, uint anim2 ) from "animation";

import void SaveNames() from "client_names";
import void LoadNames() from "client_names";
import void ClearNameCache() from "client_names";
import string@ GetName( uint id ) from "client_names";
import bool updateNick( CritterCl& cr ) from "client_names";
import bool updateAllNicks() from "client_names";

import void DrawMapTiles() from "qmap_client";
import void qmap_loop() from "qmap_client";

import void overlay_loop(bool show) from "overlay";
import void overlay_connect() from "overlay";
import void overlay_disconnect() from "overlay";
import void overlay_visibility() from "overlay";
import void overlay_message(string& message, int& sayType, uint& critterId, uint& delay) from "overlay";

import void InitContMenuScreen() from "client_screen_contmenu";

import void InitFastPanelScreen() from "client_screen_fastpanel";
import void InitFastPanelSkillbox() from "client_screen_fastpanel";
import void InitFastPanelTextbox() from "client_screen_fastpanel";
import void HidePanel( bool show ) from "client_screen_fastpanel";
import void LoadPanel( int p0, int p1, int p2, string@ word2, int[] @ p4 ) from "client_screen_fastpanel";

import void InitCodedoorScreen() from "client_screen_codedoor";

import void InitNumpadScreen() from "client_screen_numberpad";

import void InitScreenAddiotional() from "client_screen_additional";
import void SetCrtype( int[]& params ) from "client_screen_additional";

import void InitScreenDoc() from "client_screen_doc";

import void InitFirstAidScreen() from "client_screen_firstais";

import void InitOptMenuScreen() from "client_screen_options";

import void InitScreenInputbox() from "client_screen_inputbox";

import void InitInventoryTnfScreen() from "client_screen_inventory";

import void MoveHand() from "client_screen_copybool";
import void InitClockScreen() from "client_screen_copybool";

import void WASDInputLoop() from "input_wasd";
import bool WASDInputKeyState(int key, bool state) from "input_wasd";
import void WASDInputLost() from "input_wasd";

import void FactionGuiInit() from "factions_gui";

import bool OutMessage(string& message, int& sayType) from "chat";
import bool InMessage(string& message, int& sayType, uint& senderCritterID, uint& delay) from "chat";
import bool MapMessage(string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay) from "chat";

dictionary chosenContainerItems;

uint prevId = 0; // нужен для определения, когда загружать сохраненные имена
Sprite[] arrow;

Sprite F1_arrows, F1_tabs, F1_text, TabPic;
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on client loaded or new client_main.fos script received.
bool start()
{
    bool result = true;
    InitializeGame();

    result = result && FOFMOD_Initialize();

    if( __ScreenWidth < 800 || __ScreenWidth > 1280 || __ScreenHeight < 600 || __ScreenHeight > 1024 )
    {
        // Recomendation message
        Message( GetMsgStr( TEXTMSG_GAME, STR_INVALID_RESOLUTION ) );
//		return false;
    }

    #ifdef PLAYERS_3D
		AppendIfaceIni( "players3d_chareg.ini" );
		# ifndef PLAYERS_3D_NO_HEAD
			AppendIfaceIni( "players3d_headinv.ini" );
		# endif
    #endif

	AppendIfaceIni( "rp_default.ini" );
	Message( GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_INFO) ); // "Вы можете настроить произвольное разрешение экрана игры в файле FOConfig.exe"
		
	string legacyGUI;
	legacyGUI = GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_LEGACY );
	string newGUI;
	newGUI    = GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_NEW);
	string errorGUI;
	errorGUI  = GetMsgStr (TEXTMSG_GAME, STR_INFO_WELCOME_ERROR);
	
	if( AppendIfaceIni( "rp_default.ini" ) )
    {
        Message( "" + newGUI ); 
    }
    else if ( AppendIfaceIni( "default.ini" ) )
    {
        Message( "" + legacyGUI ); 
    }
	else
	{
		Message ( "" + errorGUI );
	}
	
    GUI_Init();

    InitRadioScreen();
    InitChosenTabs();
	FactionGuiInit();

    // @pm menu
    InitContMenuScreen();
    InitFastPanelScreen();
    InitFastPanelSkillbox();
    InitFastPanelTextbox();
    InitCodedoorScreen();
	InitNumpadScreen();
    InitScreenAddiotional();
    InitScreenDoc();
    InitFirstAidScreen();
    InitOptMenuScreen();
    InitInventoryTnfScreen();
    InitScreenInputbox();
    InitClockScreen();

    ExpBarSetPos();

    arrow.resize( 8 );
    arrow[ 0 ].Load( "arrow0.png", int(PT_ART_INTRFACE) );
    arrow[ 1 ].Load( "arrow1.png", int(PT_ART_INTRFACE) );
    arrow[ 2 ].Load( "arrow2.png", int(PT_ART_INTRFACE) );
    arrow[ 3 ].Load( "arrow3.png", int(PT_ART_INTRFACE) );
    arrow[ 4 ].Load( "arrow4.png", int(PT_ART_INTRFACE) );
    arrow[ 5 ].Load( "arrow5.png", int(PT_ART_INTRFACE) );
    arrow[ 6 ].Load( "arrow6.png", int(PT_ART_INTRFACE) );
    arrow[ 7 ].Load( "arrow7.png", int(PT_ART_INTRFACE) );
    // #pm menu
	
	__MouseScroll = true;

    #ifdef PLAYERS_3D
    Init3DChaRegScreen();
    #endif

    __ShowPlayerNames = true;
    __ShowNpcNames = true;
	
	__ShowF1Help = false;
	F1_arrows.Load( "Arrows.png", int(PT_ART) );
	F1_tabs.Load( "Tabs.png", int(PT_ART) );
	F1_text.Load( "Text.png", int(PT_ART) );
	TabPic.LoadByIni( "ChosenTabPic", PT_ART_INTRFACE );

    __global = CONF_GLOB_GRID | CONF_GLOB_WILD;

    Load3dFile( "VbFemaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbFemaleSkeleton.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleFat.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleNormal.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleStrong.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleWiry.fo3d", PT_ART_CRITTERS );
    Load3dFile( "VbMaleSkeleton.fo3d", PT_ART_CRITTERS );
    #endif

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Main loop function. Returned time of next call in milliseconds.

uint loop_turn = 0;

uint loop()
{
    FOFMOD_Update();
    WASDInputLoop();

    if( __isClockActive )
    {
        MoveHand();
    }

    if( loop_turn % 4 == 0 )
	{
        updateAllNicks();
		
		if( !last_radio_message_recieved )
		{
			Message( "|0xFFFFFF " + last_radio_message );
			last_radio_message_recieved = true;
		}
    }

    if( loop_turn % 5 == 0 )
	{
        qmap_loop();
    }

    if( loop_turn % 100 == 0 )
    {
        int[] result;
        GUI_GetActiveScreens( result );

        CritterCl@ ch = GetChosen();

        if( !(ch is null) && ( prevId == ch.Id ) && ( ( result.length() > 0 && result[ result.length() - 1 ] == CLIENT_MAIN_SCREEN_GAME ) || ( result.length() > 1 && result[ result.length() - 2 ] == CLIENT_MAIN_SCREEN_GAME ) ) )
        {
            SaveNames();
        }
    }
    loop_turn += 1;
    if( loop_turn > 100 )
	{
        loop_turn = 0;
	}
    return 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Say to engine what screens is active.
void get_active_screens( int[]& result )
{
    GUI_GetActiveScreens( result );
}

// Show/hide screen behaviour.
int _MainScreen = CLIENT_SCREEN_NONE;
int _LastMainScreen = CLIENT_SCREEN_NONE;
void screen_change( bool show, int screen, int p0, int p1, int p2 )
{ 
    // qthree: sorry for the trash
    //debug_screen_change(show, screen, p0, p1, p2);
    if ( show ) {
        //если новый экран - основной экран игры или глобал, а последний значимый экран - логин, то подключаемся к оверлею
        if(
            ( screen == CLIENT_MAIN_SCREEN_GAME || screen == CLIENT_MAIN_SCREEN_GLOBAL_MAP ) &&
            ( _LastMainScreen == CLIENT_MAIN_SCREEN_LOGIN || _LastMainScreen == CLIENT_SCREEN_NONE )
        ){
            //Message("BINGO");
            overlay_connect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }
        //если новый экран - логин, а последний значимый экран - основной игровой или глобал, то отключаемся от оверлея и сбрасываем запомненные имена
        else if ( screen == CLIENT_MAIN_SCREEN_LOGIN && (_LastMainScreen == CLIENT_MAIN_SCREEN_GAME || _LastMainScreen == CLIENT_MAIN_SCREEN_GLOBAL_MAP) ) {
            prevId = 0;
            ClearNameCache();
            overlay_disconnect();
            #ifdef PHYSICAL_UI
                PhysicalUI_Reset();
            #endif //PHYSICAL_UI
        }

        if(screen>=CLIENT_MAIN_SCREEN_LOGIN && screen<=CLIENT_MAIN_SCREEN_WAIT) {
            _MainScreen = screen;
            if(screen != CLIENT_MAIN_SCREEN_WAIT) {
                _LastMainScreen = screen;
            }
        }
    }

// binyan - Hotkeys
    if( screen == CLIENT_SCREEN_SAY || screen == CLIENT_SCREEN_TIMER || screen == CLIENT_SCREEN_INPUT_BOX || screen == CLIENT_SCREEN_SPLIT )
        __IsTextInput = show ? true : false;
// /////////////////////////////////////
    if( show )
        GUI_ShowScreen( screen, p0, p1, p2 );
    else
        GUI_HideScreen( screen, p0, p1, p2 );
}

int[] @ data_color = null;
int[] @ data_number = null;
int[] @ data_char = null;

void _dr( int param0, int param1, int param2, string@ param3, int[] @ param4 ) // draw data
{
    switch( param0 )
    {
    case 1:
        @data_color = param4;
        break;
    case 2:
        @data_number = param4;
        break;
    case 3:
        @data_char = param4;
        break;
    default:
        break;
    }
}

#include "disp_tests.fos"

void render_iface( uint layer )
{
	SGUI.Draw(layer);

    if( layer == 1 )
    {
        show_player_info();
    }
    else if( layer == 3 )
    {
		DrawChosenTabs();
		GUI_Render();

		if( __sinf & SINF_DISP != 0 )
		{
			if( __ConsoleActive )
			{
				clearLine();
				generateLine( 10, 150 );
				Info_About_Line( __MouseX, __MouseY );
			}
			else
			{
				clearLine();
			}
			
			Draw_Test_Line();
		}
		
		ItemCl @ item = GetMonitorItem( __MouseX, __MouseY );
		if( item !is null )
		{
			if( GetCurrentCursor() == CURSOR_MOVE && item.GetProtoId() >= EXIT_GRID_PID && item.GetProtoId() <= EXIT_GRID_PID + 8 )
			{
				CritterCl @ choo = GetChosen();

				if( ABS( int(choo.HexX - item.HexX) ) <= 16 && ABS( int(choo.HexY - item.HexY) ) <= 16 )
				{

					uint16 hexX = 0, hexY = 0;
					GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
					int value = GetDirection( choo.HexX, choo.HexY, hexX, hexY );

					//Костыли:
					if( value == 0 ) value = 1;
					if( value == 4 || value == 5 ) value = 7;
					if( value == 3 ) value = 5;
					if( value == 2 ) value = 3;
					
					// Message( "Value: " + value );
					int x = 0, y = 0;
					switch( value )
					{
					case 0:
						x = -100;
						y = -80;
						break;
					case 1:
						x = -120;
						y = -110;
						break;
					case 2:
						x = -120;
						y = -120;
						break;
					case 3:
						x = -120;
						y = -100;
						break;
					case 4:
						x = -90;
						y = -110;
						break;
					case 5:
						x = -100;
						y = -110;
						break;
					case 6:
						x = -60;
						y = -125;
						break;
					case 7:
						x = -120;
						y = -120;
						break;
					default:
						break;
					}

					arrow[ value ].Draw( __MouseX + x, __MouseY + y );

					uint localMapPid = choo.StatBase[ ST_LOCALMAP_PID ];

					if( value != choo.StatBase[ ST_LOCALMAP_DIR ] )
					{
						RunServerScriptUnsafe( "globalmap_group@unsafe_GetMapPid", item.HexX, item.HexY, item.GetProtoId(), null, null );
					}
					
					localMapPid++;
					
					string mapName = GetMsgStr( TEXTMSG_GM, localMapPid * 10 + 8 );
					bool isRed = ( mapName == "error" ) || ( localMapPid == 0 );
					if( mapName == "error" ) 
					{
						mapName = GetMsgStr( TEXTMSG_GAME, STR_MAP_UNAVAILABLE );
					}
					DrawText( localMapPid != 0 ? mapName : GetMsgStr( TEXTMSG_GAME, STR_MAP_WASTELAND ), __MouseX - ( localMapPid != 0 ? mapName.length() * 7 : 45 ), __MouseY + 20, 400, 20, isRed ? COLOR_RED : COLOR_LGREEN, FONT_BIG, 0 );
				}
			}
        }
        // binyan - Hex attack
        if( __IsHexAttack && GetCurrentCursor() == CURSOR_USE_WEAPON )
        {
			int tohit = to_hit_hex( __ctrlDown );
            if( tohit > 0 )
                DrawText( tohit + "%", __MouseX + 6, __MouseY + 6, ( ( tohit / 10 >= 1 ? 2 : 1 ) + 2 ) * 10, 10, COLOR_RED, FONT_FALLOUT, 0 );
			
			CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
			CritterCl@ chosen = GetChosen();
			if( valid( target ) && isGM( chosen ) )
			{
				string sub_info;
				sub_info = target.Stat[ ST_CURRENT_HP ] + " / " + target.Stat[ ST_MAX_LIFE ];
				DrawText( sub_info, __MouseX + 6, __MouseY - 18, sub_info.length() * 10, 10, COLOR_GREEN, FONT_FALLOUT, 0 );
				
				sub_info = target.Stat[ ST_CURRENT_AP ] + " / " + target.Stat[ ST_ACTION_POINTS ];
				DrawText( sub_info, __MouseX + 12, __MouseY - 6, sub_info.length() * 10, 10, COLOR_LBLUE, FONT_FALLOUT, 0 );
			}
        }
        if( __ShowTimeouts )
            show_timeouts();
    }
    else if( layer == 4 )
	{
	}
    else if( layer == 5 )
    {
        int active_screen = GUI_GetActiveScreen();
        bool show = !__IsTextInput && active_screen == CLIENT_MAIN_SCREEN_GAME; //&& !__ConsoleActive
        //send positions of players' sprites, send empty if gui is active
        overlay_loop(show);
    }
    else if( layer == 100 && __GmapActive )
    {
        render_global_map();
    }
}

void render_global_map()
{
    CritterCl@ ch = GetChosen();
    if(ch !is null)
    {
        // Here you can draw on global map

        // bool  __GmapActive - активна ли глобальная карта и все ли следующие нижеприведенные переменные корректны;
        // bool  __GmapWait   - включен режим ожидания ответа о подтверждении энкаунтера;
        // float __GmapZoom   - текущий масштаб, не забывайте учитывать его при рисовании на карте;
        // int   __GmapOffsetX/Y   - смещение карты от нулевой координаты (верхний-левый угол);
        // int   __GmapGroupCurX/Y - координаты группы игрока;
        // int   __GmapGroupToX/Y  - координаты точки назначения;
        // float __GmapGroupSpeed  - текущая скорость передвижения.
        // Для примера, расчет текущего пикселя группы:
        // x = __GmapGroupX / __GmapZoom + __GmapOffsetX, y = __GmapGroupY / __GmapZoom + __GmapOffsetY.

        int flags = ( FT_NOBREAK | FT_CENTERX | FT_CENTERY | FT_BORDERED ),
            font = FONT_FALLOUT;

        float  size = 10 / __GmapZoom;

        uint16 chx = __GmapGroupCurX / 10, chy = __GmapGroupCurY / 10;

        if( @data_color != null && __global & CONF_GLOB_WILD != 0 )
        {
            uint len = data_color.length();

            if( len > 0 && len % 2 == 0 )
            {
                int[] drawData( len / 2*18 );

                for( uint i = 0, j = 0; i < len / 2; j++ )
                {
                    float x = ( data_color[ j * 2 ] & 0xFFFF ),
						  y = ( ( data_color[ j * 2 ] >> 16 ) );

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;

                    int a = data_color[ j * 2 + 1 ];

                    uint k = i * 18;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y;
                    drawData[ k++ ] = a;
                    drawData[ k++ ] = x + size;
                    drawData[ k++ ] = y + size;
                    drawData[ k++ ] = a;

                    i++;
                }
                drawData.resize( len / 2 * 18 );
                DrawPrimitive( DRAW_PRIMITIVE_TRIANGLELIST, drawData );
            }
        }

        if( size > 10 && __global & CONF_GLOB_GRID != 0 )
        {
            uint8 alpha = CLAMP( ( size - 5 ) * 20, 0, 0xAA );
            int   r = 0x22, g = 0x22, b = 0x22;
            r = CLAMP( r, 0, 0xFF );
            g = CLAMP( g, 0, 0xFF );
            b = CLAMP( b, 0, 0xFF );
            int   color = ( ( alpha ) << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b );

            float x0 = __GmapOffsetX,
                  y0 = __GmapOffsetY,
                  x = ( ZONE_COUNT_X * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetX,
                  y = ( ZONE_COUNT_Y * ZONE_LENGTH ) / __GmapZoom + __GmapOffsetY;

            uint w = ZONE_COUNT_X * ZONE_LENGTH / 10,
                 h = ZONE_COUNT_Y * ZONE_LENGTH / 10;

            int[] drawData( ( w + h + 2 )*6 );

            for( uint i = 0; i <= h; i++ )
            {
                drawData[ i * 6 ] = x0;
                drawData[ i * 6 + 1 ] = y0 + size * i;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x;
                drawData[ i * 6 + 4 ] = y0 + size * i;
                drawData[ i * 6 + 5 ] = color;
            }
            for( uint j = 0; j <= w; j++ )
            {
                uint i = h + 1 + j;
                drawData[ i * 6 ] = x0 + size * j;
                drawData[ i * 6 + 1 ] = y0;
                drawData[ i * 6 + 2 ] = color;
                drawData[ i * 6 + 3 ] = x0 + size * j;
                drawData[ i * 6 + 4 ] = y;
                drawData[ i * 6 + 5 ] = color;
            }

            DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
        }

        if( size >= 5 )
        {
            float x = ( chx * 10 ) / __GmapZoom + __GmapOffsetX,
                  y = ( chy * 10 ) / __GmapZoom + __GmapOffsetY;

            {
                int color = int( 0xAA00FFFF );

                int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + size - 1, y + size - 1, color, x + 1, y + size - 1, color, x + 1, y + 1, color };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }
        }

        if( @data_number != null )
        {
            uint len = data_number.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0; i < len / 2; i++ )
                {
                    float x = ( data_number[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_number[ i * 2 ] >> 16 ) );

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    int a = data_number[ i * 2 + 1 ] & 0xFFFF,
                        b = data_number[ i * 2 + 1 ] >> 16;
                    ;
                    // if(x<0 || y<0 || x>)
                    string str = a;
                    if( b > 0 )
                        str += "+" + ( b - a );

                    {
                        uint8 alpha = MIN( ( 2000.0f / size ), 0x88 );
                        int   color = 0x00FFAA00 | ( ( alpha ) << 24 );

                        int[]  drawData = { x + 1, y + 1, color, x + size - 1, y + 1, color, x + 1, y + size - 1, color, x + size - 1, y + size - 1, color };
                        DrawPrimitive( DRAW_PRIMITIVE_TRIANGLESTRIP, drawData );
                    }
                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, 0xFF22AAFF, font, flags );
                }
            }
        }

        if( @data_char != null )
        {
            uint len = data_char.length();

            if( len > 0 && len % 2 != 1 )
            {
                for( uint i = 0; i < len / 2; i++ )
                {
                    float x = ( data_char[ i * 2 ] & 0xFFFF ),
                          y = ( ( data_char[ i * 2 ] >> 16 ) );

                    x = x * 10 / __GmapZoom + __GmapOffsetX;
                    y = y * 10 / __GmapZoom + __GmapOffsetY;
                    uint a = ( data_char[ i * 2 + 1 ] & 0x00FFFFFF ) | 0xFF000000,
                         b = data_char[ i * 2 + 1 ] >> 24;

                    string str = " ";
                    str[ 0 ] = b;

                    int tw = 0, th = 0, lines = 0;
                    GetTextInfo( str, 0, 0, font, flags, tw, th, lines );
                    DrawText( str, x - ( tw >> 1 ), y - ( tw >> 1 ), size + tw, size + tw, a, font, flags );
                }
            }
        }

        {
            float x = ( __MouseX - __GmapOffsetX ) * __GmapZoom,
                  y = ( __MouseY - __GmapOffsetY ) * __GmapZoom;

            x -= x % 10;
            y -= y % 10;

            string str = floor( x / 10 ) + " : " + floor( y / 10 );

            x = x / __GmapZoom + __GmapOffsetX;
            y = y / __GmapZoom + __GmapOffsetY;

            if( size >= 5 )
            {
                int[]  drawData = { x + 1, y + 1, int( COLOR_RED ), x + size - 1, y + 1, int( COLOR_RED ), x + size - 1, y + size - 1, int( COLOR_RED ), x + 1, y + size - 1, int( COLOR_RED ), x + 1, y + 1, int( COLOR_RED ) };
                DrawPrimitive( DRAW_PRIMITIVE_LINESTRIP, drawData );
            }

            int tw = 0, th = 0, lines = 0;

            GetTextInfo( str, 0, 0, font, FT_NOBREAK, tw, th, lines );
            DrawText( str, __MouseX + 30, __MouseY + 10, tw, th, COLOR_LGREEN, font, FT_NOBREAK );
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Render map function. You can use DrawMap* functions only there. This drawing before 1 iface layer.
void render_map()
{
    DrawMapTiles();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Mouse behaviours. Click states look in _client_defines.fos, Mouse click states.
// Return true to disable engine events.
bool mouse_down( int click )
{ 
	if (SGUI.HandleEvent(MouseDownUIEvent(click))) {
		return true;
	}

    return GUI_MouseDown( click, __MouseX, __MouseY );
}

bool mouse_up( int click )
{
	if (SGUI.HandleEvent(MouseUpUIEvent(click))) {
		return true;
	}

    return GUI_MouseUp( click, __MouseX, __MouseY );
}

void mouse_move( int x, int y )
{
	if (SGUI.HandleEvent(MouseMoveUIEvent(x, y))) {
		return;
	}

    GUI_MouseMove( x, y );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Keyboard behaviours. Key codes look in _client_defines.fos DirectInput keyboard scan codes.
// Return true to disable engine events.
bool AltDown = false;
bool key_down( uint8 key )
{
	if (SGUI.HandleEvent(KeyDownUIEvent(key))) {
		return true;
	}

    if (WASDInputKeyState(key, true)) {
        return true;
    }

    if(__ctrlDown && key == DIK_O) {
        //show or hide overlay
        overlay_visibility();
        return true;
    }
    if( __ConsoleActive )
	{
		CritterCl@ ch = GetChosen();
		if( valid(ch) )
		{
			if( key != DIK_RETURN )
			{
				if( ch.Param[CR_TYPING_TIME] < int( __FullSecond + __TypingDelay ) )
				{
					RunServerScriptUnsafe( "rp_chat@unsafe_ShowTyping", 0, 0, 0, null, null );
				}
			}
			else
			{
				if( ch.Param[CR_TYPING_TIME] > int( __FullSecond + __TypingDelay ) )
				{
					RunServerScriptUnsafe( "rp_chat@unsafe_stopTyping", 0, 0, 0, null, null );
				}
			}
		}
	} 

    if( __waiting )
    {
        CritterCl@ ch = GetChosen();
        if( @ch != null )
        {
            if(__ConsoleActive) 
			{
				bool key_disallowed = (key == DIK_ESCAPE);
                return key_disallowed;
            }
			else
			{
                if( key == DIK_RETURN )
				{
                    __ConsoleActive = true;
                    return true;
                }
            }

            if( key == DIK_ESCAPE || key == DIK_SPACE )
            {
                RunServerScriptUnsafe( "ltp@unsafe_StopProcess",  0, 0, 0, null, null );
            }
            return true;
        }
        else
		{
            __waiting = false;
		}
	}

    // Effect example, temporary
    if( key == DIK_LMENU || key == DIK_RMENU )
	{
        AltDown = true;
	}
	
    if( key == DIK_LCONTROL || key == DIK_RCONTROL )
	{
        __ctrlDown = true;
	}
	
    if( key == DIK_Z )
	{
        __MapZooming = true;
    }
	
	if( GUI_KeyDown( key ) ) {
		// Hotkey consumed
		return true;
	}
	else
	{
		// disable hardcoded date and time hotkey
		if( key == DIK_SLASH && _MainScreen==CLIENT_MAIN_SCREEN_GAME && !__ConsoleActive && !__IsTextInput && !__ctrlDown && !AltDown )
		{
			RunServerScriptUnsafe( "main@unsafe_getIngameTime", -1, 0, 0, null, null );
			return true;
		}
	}
    return false;
}

bool key_up( uint8 key )
{
	if (SGUI.HandleEvent(KeyUpUIEvent(key))) {
		return true;
	}

    if( WASDInputKeyState( key, false ) )
	{
        return true;
    }

    if( key == DIK_LMENU || key == DIK_RMENU )
	{
        AltDown = false;
    }
	
	if( key == DIK_LCONTROL || key == DIK_RCONTROL )
	{
        __ctrlDown = false;   
	}
	
    if( __waiting )
	{
        return !__ConsoleActive;
	}
	
    if( key == DIK_Z )
	{
        __MapZooming = false;
	}
    return GUI_KeyUp( key );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on mouse/keyboard input lost (alt-tab, minimize, lost focus).
void input_lost()
{
	if (SGUI.HandleEvent(InputLostUIEvent())) {
		return;
	}

    AltDown = false;
    __ctrlDown = false;
    __MapZooming = false;

    GUI_InputLost();
}


// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out game.
void critter_in( CritterCl& cr )
{
    CritterCl@ ch = GetChosen();
    if( !(ch is null) && ( ch.Id == cr.Id ) && ( prevId != cr.Id ) )
    {
        @data_number = null;
        @data_color = null;
        @data_char = null;
        LoadNames();
        prevId = cr.Id;
    }

    updateNick( cr );

    // Default colors
    cr.NameColor = COLOR_CRITTER_NAME;
    cr.ContourColor = ( cr.IsPlayer() ? COLOR_CONTOUR_YELLOW : COLOR_CONTOUR_RED );

    if( __fastPanel )
	{
        HidePanel( true );
    }
}

void critter_out( CritterCl& cr )
{
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something item in/changed/out map.
void item_map_in( ItemCl& item )
{
	#ifndef PHYSICAL_UI
        iList().add( item );
    #endif //PHYSICAL_UI
}

void item_map_changed( ItemCl& itemNow, ItemCl& itemBefore )
{
    #ifndef PHYSICAL_UI
	    iList().change( itemNow, itemBefore );
    #endif //PHYSICAL_UI
}

void item_map_out( ItemCl& item )
{
    #ifndef PHYSICAL_UI
	    iList().remove( item );
    #endif //PHYSICAL_UI
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on something critter in/out chosen inventory.
void item_inv_in( ItemCl& item )
{
	if( item.GetType() == ITEM_TYPE_CONTAINER )
	{
		RunServerScriptUnsafe( "main@unsafe_ItemsWeight", item.Id, 0, 0, null, null );
  	}
}

void item_inv_out( ItemCl& item )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on player drag&drop some item.
void item_drop( ItemCl& item )
{

}

string last_radio_message = "";
bool last_radio_message_recieved = true;
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message on map.
// By default delay == [TextDelay + message length * 100] ms
bool map_message( string& message, uint16& hexX, uint16& hexY, uint& color, uint& delay )
{
    if(message == "")
	{
		return false;
	}
	
    // Detect radio
    if( color == 0xFFFFFFFE )
	{
        MapMessage(message, hexX, hexY, color, delay);
        message = ".." + message + "..";
		
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			if( !last_radio_message_recieved )
			{
				Message( "|0xFFFFFF " + last_radio_message );
            }
			else
			{
				last_radio_message_recieved = false;
			}
			last_radio_message = message;
		}
	}
		
	if( color == COLOR_GRAY )
	{
        Message("|0x8F8F8F " + message );
	}
	
	if( color == COLOR_LGRAY )
	{
        Message("|0xD3D3D3 " + message );
	}
	
	if( color == COLOR_TEXT || color == COLOR_CHAT_SHOUT)
	{
        MapMessage(message, hexX, hexY, color, delay);
		Message( "???: " + message );
	}

    if (message == "")
	{
		return false;
	}
	
	return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on receive message.
// By default delay == [TextDelay + message length * 100] ms
bool in_message( string& message, int& sayType, uint& critterId, uint& delay )
{
    if(message == "")
	{
		return false;
	}
	
    if( sayType > SAY_RADIO )
	{
		return true;
	}

    if(!InMessage(message, sayType, critterId, delay))
	{
        return false;
    }

	CritterCl@ receiver = GetChosen();

    //send message to overlay, for logging and avatar position adjustment
    overlay_message(message, sayType, critterId, delay);
	
    if( sayType == SAY_RADIO )
	{
		if( last_radio_message.length() != message.length() && findFirst( last_radio_message, message ) == -1 )
		{
			last_radio_message = ".." + message + "..";
			//last_radio_message_recieved = false;
		}
		else
		{
			last_radio_message_recieved = true;
		}
		
        return true;                          // for work radio and service messages
	}

    if( ( __sinf & SINF_CRID_CHAT ) != 0 && critterId != 0 && sayType <= SAY_WHISP_ON_HEAD )
    {
        message = "[" + critterId + "] " + message;
    }
	
    if( ( __sinf & SINF_INSIGHT ) != 0 )
	{
        return true;
	}

	return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on send message.
bool out_message( string& message, int& sayType )
{
    if(message == "")
	{
		return false;
	}
	bool result = OutMessage(message, sayType);
    if(message == "")
	{
		return false;
    }
	return result;
}

bool out_command( string& message, int& sayType )
{
	
    if( __MessagePrefix != "" )
    {
        message = __MessagePrefix + " " + message;
        __MessagePrefix = "";
    }

    if( __IsHotkeysUse )
	{
        __IsTextInput = true;
	}
	
    if( findFirst( message, "~hotkeys" ) == 0 )
    {
        string@[] @ msg = split( message, " " );
        if( msg.length() == 1 )
		{
            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        }
		else
        {
            if( msg[ 1 ] == "on" )
			{
                SetHotkeysUse( true );
            }
			else if( msg[ 1 ] == "off" )
			{
                SetHotkeysUse( false );
			}
			
            if( __IsHotkeysUse )
			{
                __IsTextInput = true;
            }

            Message( "Hotkeys use is now " + ( __IsHotkeysUse ? "on" : "off" ) );
        }
        return false;
    }
    // /////////////////////////////////////////////


    if( message[ 0 ] == '%' ) // Command
	{
		string@[] @ valuesStr = splitEx( message, " " );
		int p0 = 0, p1 = 2, p2 = 6;
		if( valuesStr.length() == 2 ) 
		{
			if( !StrToInt( valuesStr[ 1 ], p0 ) )
			{
				string[] letters = { "S", "P", "E", "C", "I", "A", "L" };
				p0 = letters.find( valuesStr[ 1 ] ) + 1;
			}
		}
		
		if( valuesStr.length() == 3 ) 
		{
			StrToInt( valuesStr[ 1 ], p1 );
			StrToInt( valuesStr[ 2 ], p2 );
		}
		
		CritterCl@ chosen = GetChosen();
		CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
		if( isGM( chosen ) && valid( target ) )
		{
			int[] vals = { p0, p1, p2, target.Id };
			RunServerScriptUnsafe( "test@unsafe_rolling_GM", 0, 0, 0, null, vals );
			return false;
		}
		RunServerScriptUnsafe( "test@unsafe_rolling", p0, p1, p2, null, null );
		return false;
	}
	
	if( message[ 0 ] == '~' ) // Command
    {
		if( findFirst( message, "~ilex" ) != -1 )
		{
			CritterCl@ chosen = GetChosen();
			if( !chosen.IsLife() )
			{
				return false;
			}
			
			ItemCl@ hand = _CritGetItemHand( chosen );
			if( !valid( hand ) )
			{
				return false;
			}
			
			string current_lexem = hand.Lexems;
			if( current_lexem.length() >= 27 )
			{
				uint remaining = 127 - current_lexem.length();
				Message( "|0xFFFF00" + GetMsgStr( TEXTMSG_GAME, STR_ITM_LEX_WARN ) + remaining + GetMsgStr( TEXTMSG_GAME, STR_SYMBOLS ) );
			}
			
			string new_lexem = "";
			
			if( message.length() > 5 )
			{
				new_lexem = substring( message, 6, message.length() - 6 );
			}
			if( new_lexem.length() != 0 )
			{
				new_lexem = current_lexem + new_lexem;
			}
			RunServerScriptUnsafe( "test@unsafe_addLexem", 0, 0, 0, new_lexem, null );
			return false;
		}
		
		if( message == "~toglobal" ) //move to GM
		{
            RunServerScriptUnsafe( "test@unsafe_toglobal", 0, 0, 0, null, null );
            return false;
		} 
		
		if( message == "~suicide" )
        {
            RunServerScriptUnsafe( "suicide@unsafe_killself", 0, 0, 0, "", null );
            return false;
        }
		
		if( message == "~naked" )
		{
            RunServerScriptUnsafe( "general_unsafe@unsafe_getNaked", 0, 0, 0, "", null );
            return false;
		}

		string@[]@ parts = split( message, " " );

		if( parts[0] == "~desc" ) 
		{
			uint16 hexX = 0, hexY = 0;
			CritterCl @ choo = GetChosen();
			GetMonitorHex( __MouseX, __MouseY, hexX, hexY );

			string text = "";
			int l = parts[0].length();
			if( parts.length() > 1 && message.length() > 5 ) 
			{
				text = substring( message, 5, message.length() - 5 );
			}
			RunServerScriptUnsafe( "general_unsafe@unsafe_newPopup", hexX, hexY, 0, text, null ); 
			return false; 
		}
			
		if( parts[0] == "~lex" ) 
		{
			string text = "";
			if( parts.length() > 1 && message.length() > 5 )
			{
				text = substring( message, 5, message.length() - 5 );
			}
			RunServerScriptUnsafe( "general_unsafe@unsafe_selfLex", 0, 0, 0, text, null ); 
			return false; 
		}

		if( message == "~sf" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 1, 0, 0, "", null );
            return false;
        }

        if( message == "~sb" )
        {
            RunServerScriptUnsafe( "general_unsafe@unsafe_sleep", 0, 0, 0, "", null );
            return false;
        }

        if( message == "~mobhot" )
        {
            __usermobhotkeys = ( __usermobhotkeys ? false : true );
            Message( "mobhotkeys : " + ( __usermobhotkeys ? "On" : "Off" ) );
            return false;
        }
		
		if( message == "~faction")
		{
			ShowScreen( CLIENT_SCREEN_FACTION, 0, 0, 0 );
			Message("show faction");
			return false;
		}		
        return true;
    }

    if( message[ 0 ] == '#' || message[ 0 ] == '%' || message[ 0 ] == '$' ) // tnf commands
    {
		CritterCl @target = GetMonitorCritter( __MouseX, __MouseY );
		string targetInfo = valid( target ) ? "[" + target.Name + " #" + target.Id + "]" : "";
        RunServerScriptUnsafe("general_unsafe@unsafe_log", 0, 0, 0, GetChosen().Name + " #" + GetChosen().Id + " " + targetInfo + " - " + message, null);
        return gm_msg(message);
    }

    Message( "|0xFFFF00" + GetMsgStr( TEXTMSG_GAME, STR_COMMAND_NOT_FOUND ) );
    return false;
}

bool out_speak( string& message, int& sayType )
{
    CritterCl@ chosen = GetChosen();
	ItemCl@ gagItem = _CritGetItemHead( chosen );
	
    if( chosen !is null and sayType< SAY_NETMSG and chosen.IsDead() and chosen.Anim2Dead > ANIM2_DEAD_BACK )
    {
        Message( "|0xFFFF00" + GetMsgStr( TEXTMSG_GAME, STR_DEAD_CANT_TALK ) );
        return false;
    }

    //Проверка на то, что в сообщении есть что-либо кроме пробелов.
	bool result = false;
    for( uint i = 0, j = message.length(); i < j; i++ )
    {
        if( message[ i ] != ' ' )
        {
            result = true;
            break;
        }
    }
	if( result == false )
	{
		return false;
	}
	
  	//Шаманская прослушка-в-рацию.
    if( chosen !is null && (SAY_NORM == sayType || SAY_SHOUT == sayType || SAY_WHISP == sayType || SAY_RADIO == sayType ) )
	{
        RunServerScriptUnsafe( "radio@unsafe_OutMessage", sayType, 0, 0, message, null );
    }
	
	switch( sayType )
	{
		case( SAY_NORM ): 	
		case( SAY_EMOTE ): 	
		case( SAY_SOCIAL ):	//<- Этот тип речи используется для "разового" серого текста под курсор.
			//Просто "нормально" обрабатывает эти типы речи, ничего дополнительно с ними не делая.
			break;
		case( SAY_WHISP ):
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );
			break;
		case( SAY_SHOUT ):
			RunServerScriptUnsafe( "rp_chat@unsafe_shout_all", 0, 0, 0, message, null);
			break;
		case( SAY_RADIO ):
		{
			RunServerScriptUnsafe( "general_unsafe@unsafe_radioHead", 0, 0, 0, message, null );
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Radio", 0, 0, 0, message, null ); 
			RunServerScriptUnsafe( "rp_chat@unsafe_GM_Hear_Whisper", 0, 0, 0, message, null );//TODO: Дублируется-ли текст шёпота ГМам?
			break;
		}
		default: Message( "Unhandled sayType: " + sayType ); return false;
	}

	//Серый текст и возможность говорить за целевое существо:
	if( sayType != SAY_RADIO && ( chosen.StatBase[ ST_FOLLOW_CRIT ] != 0 || sayType == SAY_SOCIAL ) )
	{
		uint16 hexX = 0, hexY = 0;
		GetMonitorHex( __MouseX, __MouseY, hexX, hexY );
		RunServerScriptUnsafe( "rp_chat@unsafe_SayChatMessage", sayType, hexX, hexY, message, null );
		return false; //Не отсылает сообщение стандартными методами, скрипт перехватывает управление.
	}

	//На стороне сервера записывает данные в SayLog.txt
	RunServerScriptUnsafe( "rp_chat@unsafe_SayLog", sayType, 0, 0, message, null );

	if( chosen.IsKnockout() && sayType < SAY_SOCIAL ) 
	{
		RunServerScriptUnsafe( "general_unsafe@unsafe_KnockSay", sayType, 0, 0, message, null ); 
		return false; 
	}

	return true;
}

bool to_hit_hex_enable()
{
    CritterCl@ chosen = GetChosen();
    if( !chosen.IsLife() )
	{
        return false;
	}
	
    CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );
    if( valid( target ) && !target.IsDead() ) //Для этого есть другие обработчики.
	{
        return false;
	}
	
    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );
    if( tx == 0 && ty == 0 )
	{
        return false;
	}
	
	ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
	if( valid( item ) && ( item.HexX != tx && item.HexY != ty ) )
	{
		return false;
	}
	return true;
}

// binyan - Hex attack
int to_hit_hex( bool anyway )
{
	if( !anyway && !to_hit_hex_enable() )
	{
		return 0;
	}
	
	CritterCl@ chosen = GetChosen();

	CritterCl@ target = GetMonitorCritter( __MouseX, __MouseY );

    uint16 tx = 0, ty = 0;
    GetMonitorHex( __MouseX, __MouseY, tx, ty );

	ItemCl@ item = GetMonitorItem( __MouseX, __MouseY );
	
    ItemCl@ realWeapon = _CritGetItemHand( chosen );

    uint8      mode = 0;
    ProtoItem@ weapon = chosen.GetSlotProto( SLOT_HAND1, mode );
    if( !valid( weapon ) && valid( realWeapon ) )
	{
        @weapon = GetProtoItem( realWeapon.Proto.ProtoId );
	}
	
	if( weapon is null )
	{
		return 0;
	}
	
    uint    skillNum = _WeaponSkill( weapon, mode );
    int     dmgType = _WeaponDmgType( weapon, mode );

    bool    isFlareGun = valid( realWeapon ) && ( realWeapon.AmmoPid == PID_FLARE_GUN_AMMO ) && ( _WeaponModeUse( mode ) == 1 ); // pm added flare gun check
    bool    isRocket = valid( realWeapon ) && ( ( realWeapon.AmmoPid == PID_EXPLOSIVE_ROCKET ) || ( realWeapon.AmmoPid == PID_ROCKET_AP ) || ( realWeapon.AmmoPid == PID_ROBO_ROCKET_AMMO ) || ( realWeapon.AmmoPid == PID_GRENADELAUNCHER_AMMO ) );

    int    dist = GetDistantion( chosen.HexX, chosen.HexY, tx, ty );
	
    uint16 toHx = tx, toHy = ty;
    GetHexCoord( chosen.HexX,  chosen.HexY, toHx, toHy,  0.0f, dist );
    if( ( tx != toHx ) || ( ty != toHy ) )
	{
        return 0;
	}
	
    int wpnMaxDist = _WeaponMaxDist( weapon, mode );
    if( skillNum == SK_THROWING )
	{
        wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
	}
	
    if( dist > wpnMaxDist )
	{
        return 0;
	}
	
    int use = _WeaponModeUse( mode );

	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );

    int toHit = getFullSkill( chosen, null, skillNum, weaponSubtype ) - chosen.Param[ ST_PARALYSIS_LEVEL ] * 3 + 2 * _WeaponMaxDist( weapon, use ) - chosen.Param[ ST_DRUNK ];
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;


    int distmod1 = 2; // used for initial weapon bonus
    int distmod2 = 0; // minimal distance
    if( weaponPerk == WEAPON_PERK_LONG_RANGE )
	{
        distmod1 = 4;
    }
	else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = chosen.Stat[ ST_PERCEPTION ];
    int acc = dist;

    if( dist < distmod2 )
	{
        acc += distmod2;
    }
	else
    {
        if( chosen.IsPlayer() )
		{
            acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
        }
		else
		{
            acc -= perception * distmod1;
		}
	}

    if( -2 * perception > acc )
	{
        acc = -2 * perception;
	}
	
    if( acc >= 0 )
    {
        if( chosen.Damage[ DAMAGE_EYE ] != 0 )
		{
            acc *= -12;
        }
		else
		{
            acc *= -4;
		}
	}
    else
	{
        acc *= -4;
	}
	
    toHit += acc;
    blockers = GetCrittersPath( chosen.HexX, chosen.HexY, tx, ty, 0.0f, dist, FIND_LIFE, null ); // + map
    toHit -= 10 * blockers;

    if( chosen.Trait[ TRAIT_ONE_HANDER ] != 0 )
	{
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );
	}
	
    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;

    if( handlingStrength < reqStrength )
	{
        toHit -= ( reqStrength - handlingStrength ) * 20;
    }
	
	if( weaponPerk == WEAPON_PERK_ACCURATE )
	{
        toHit += 20;
	}
	
	int aim = _WeaponModeAim( mode );
	if( aim == HIT_LOCATION_NONE && _WeaponAim( weapon, mode & 0x0F ) )
	{
		aim = chosen.ParamBase[CR_AUTO_AIM];
	}
	
    uint16 ammoRound = _WeaponRound( weapon, use );
	bool isBurst = ammoRound > 1;
	if( isBurst )
	{
		aim = HIT_LOCATION_UNCALLED;
	}
	
    int hitMod = GetHitAim( aim );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
	{
        hitMod /= 2;
    }
	toHit -= hitMod;

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
	{
        toHit -= 25;
    }
	toHit = CLAMP( toHit, 5, 95 );

    return toHit;

}
// //////////////////////////////////////////////////////////////////////////////////////////////////

int getFullSkill( CritterCl& cr, CritterCl@ target, int skillNum, uint8 weaponSubtype )
{
    int   skillVal = cr.Skill[ skillNum ];

    if( cr.IsPlayer() )
    {
        if( weaponSubtype == WS_GUN )
        {
            if( skillNum == SK_SMALL_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
                }
            }

            if( skillNum == SK_BIG_GUNS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 3;
                skillVal += cr.Skill[ SK_ENERGY_WEAPONS ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP; 
                }
            }

            if( skillNum == SK_ENERGY_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_SMALL_GUNS ] / 2;
                skillVal += cr.Skill[ SK_BIG_GUNS ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
                {
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
                }
            }
        }
        else
        {
            if( skillNum == SK_UNARMED && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
				{
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
				}
			}

            if( skillNum == SK_MELEE_WEAPONS && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 2;
                skillVal += cr.Skill[ SK_THROWING ] / 3;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
				{
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
				}
			}

            if( skillNum == SK_THROWING && skillVal < SECONDARY_SKILLS_BONUS_CAP )
            {
                skillVal += cr.Skill[ SK_UNARMED ] / 3;
                skillVal += cr.Skill[ SK_MELEE_WEAPONS ] / 2;
                if( skillVal > SECONDARY_SKILLS_BONUS_CAP )
				{
                    skillVal = SECONDARY_SKILLS_BONUS_CAP;
				}
			}
        }
    }
	
    // Roleplay
	if( cr.IsPlayer() && valid( target ) && target.IsPlayer() )
	{
		/*
		Если [маньяк, обычный, мирный] хочешь БЕЗ ШТРАФА
		 атаковать:  маньяка, обычного, мирного
		1) маньяк:   всегда,   всегда, цель в бою
		2) обычный:  всегда,    в бою, цель в бою
		3) мирный:    в бою,    в бою, ты и цель в бою
		*/
		//Если вне боя, и ты мирный, и вы оба НЕ маньяки..
		if( cr.Timeout[ TO_BATTLE ] == 0 && ( cr.Trait[ TRAIT_GOOD_NATURED ] != 0 || ( cr.Trait[ TRAIT_BLOODY_MESS ] == 0  && target.Trait[ TRAIT_BLOODY_MESS ] == 0 ) ) )
		{
			skillVal -= 30; 
		}
	}
	return skillVal;
}
// To-hit chance.
int to_hit( CritterCl& chosen, CritterCl& target, ProtoItem& weapon, uint8 weaponMode )
{
    int hitLocation = _WeaponModeAim( weaponMode );
	if( hitLocation == HIT_LOCATION_NONE && _WeaponAim( weapon, weaponMode & 0x0F ) )
	{
		hitLocation = chosen.ParamBase[CR_AUTO_AIM];
	}
	
    int use = _WeaponModeUse( weaponMode );
    uint16 ammoRound = _WeaponRound( weapon, use );
	bool isBurst = ammoRound > 1;
	if( isBurst )
	{
		hitLocation = HIT_LOCATION_UNCALLED;
	}
    if( use > 2 )
	{
        return 0;
	}
	
    if( target.IsDead() )
	{
        return 0;
	}
	
    if( !chosen.IsLife() )
	{
        return 0;
	}
	
    ItemCl@ realWeapon = _CritGetItemHand( chosen );
    ProtoItem@ ammo = null;

    if( valid( realWeapon ) && _WeaponRound( weapon, use ) > 0 )
	{
        if( realWeapon.AmmoCount == 0 )
		{
            return 0;
        }
		@ammo = GetProtoItem( realWeapon.AmmoPid );
    }

    uint skillNum = _WeaponSkill( weapon, use );
	
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : ( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
    int  skillVal = getFullSkill( chosen, target, skillNum, weaponSubtype ) - chosen.Param[ ST_PARALYSIS_LEVEL ] * 3 + 2 * _WeaponMaxDist( weapon, use )-  chosen.Param[ ST_DRUNK ];
    int  wpnMaxDist = _WeaponMaxDist( weapon, use );

    // Roleplay
    int dist = GetCrittersDistantion( chosen, target );
    if( dist > wpnMaxDist )
	{
        return 0;
	}
	
    int toHit = skillVal;
    int weaponPerk = weapon.Weapon_Perk;
    int blockers = 0;

    if( skillNum != SK_UNARMED && skillNum != SK_MELEE_WEAPONS )
    {
        int distmod1 = 2;
        int distmod2 = 0;
        if( weaponPerk == WEAPON_PERK_LONG_RANGE )
		{
            distmod1 = 4;
        }
		else if( weaponPerk == WEAPON_PERK_SCOPE_RANGE )
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = chosen.Stat[ ST_PERCEPTION ];
        int acc = dist;

        if( dist < distmod2 )
		{
            acc += distmod2;
		}
		else
        {
            if( chosen.IsPlayer() )
			{
                acc -= ( perception - 2 ) * distmod1;            // we want to keep it, because fo2238 might use it to display NPCs chance (via possessing)
            }
			else
			{
                acc -= perception * distmod1;
			}
		}

        if( -2 * perception > acc )
		{
            acc = -2 * perception;
		}

        if( acc >= 0 )
        {
            if( chosen.Damage[ DAMAGE_EYE ] != 0 )
			{
                acc *= -12;
            }
			else
			{
                acc *= -4;
			}
		}
        else
		{
            acc *= -4;
		}
		
        toHit += acc;

        blockers = GetCrittersPath( chosen.HexX, chosen.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null );
        if( !target.IsKnockout() )
		{
            blockers--;
        }
		toHit -= 10 * blockers;
    }

    if( !( weapon.Weapon_IsUnarmed ) && chosen.Trait[ TRAIT_ONE_HANDER ] != 0 && valid( realWeapon ) )
	{
        toHit += ( FLAG( weapon.Flags, ITEM_TWO_HANDS ) ? -40 : 20 );
	}
	
    int handlingStrength = chosen.Stat[ ST_STRENGTH ];
    int reqStrength = weapon.Weapon_MinStrength;

    if( handlingStrength < reqStrength )
	{
        toHit -= ( reqStrength - handlingStrength ) * 20;
    }
	if( weaponPerk == WEAPON_PERK_ACCURATE )
	{
        toHit += 20;
	}
	
    int acmod = target.Stat[ ST_ARMOR_CLASS ];
    if( valid( ammo ) )
	{
        acmod += ammo.Ammo_AcMod;
    }
	
	if( acmod > 0 )
	{
        toHit -= acmod;
	}

    if( chosen.Damage[ DAMAGE_EYE ] != 0 )
	{
        toHit -= 25;
	}   
	
    if( target.IsKnockout() )
	{
        toHit += 40;
	}
	
    int hitMod = GetHitAim( hitLocation );
    if( skillNum == SK_MELEE_WEAPONS || skillNum == SK_UNARMED )
	{
        hitMod /= 2;
    }
	toHit -= hitMod;
	
	if( valid(target) && target.IsBusy() )
	{
		if( ( chosen.Dir ) % 6 != target.Dir )
		{
			toHit -= acmod / 2;
			if( hitLocation == HIT_LOCATION_HEAD )
				toHit -= acmod / 2;
		}
	}

	if( hitLocation == HIT_LOCATION_HEAD || hitLocation == HIT_LOCATION_EYES )
	{
		toHit *= 0.5;
	}
    toHit = CLAMP( toHit, 5, 95 );

    return toHit;
}

uint GetHitAim( int hitLocation )
{
    switch( hitLocation )
    {
		case HIT_LOCATION_NONE:
			break;
		case HIT_LOCATION_UNCALLED:
			break;
		case HIT_LOCATION_TORSO:
			return __HitAimTorso;
		case HIT_LOCATION_EYES:
			return __HitAimEyes;
		case HIT_LOCATION_HEAD:
			return __HitAimHead;
		case HIT_LOCATION_LEFT_ARM:
		case HIT_LOCATION_RIGHT_ARM:
			return __HitAimArms;
		case HIT_LOCATION_GROIN:
			return __HitAimGroin;
		case HIT_LOCATION_RIGHT_LEG:
		case HIT_LOCATION_LEFT_LEG:
			return __HitAimLegs;
		default:
			break;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Override aim location set by player through targetting screen or simple click on target.
void hit_aim( uint8& aim )
{
	
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Combat results.
void combat_result( uint[]& data )
{
    CritterCl@ chosen = GetChosen();

	testInfo( CR_TEST_MODE_COMBAT, "Data: " + enlistUINT(data) );

    uint datalen = data.length();
    if( datalen < 4 )
	{
        return;
	}
	
    if( data[ 0 ] != datalen )
	{
        return;
	}
    uint current = 1;

    while( current < datalen )
	{
        int damage = -1;
        uint effect = 0;
        uint loc = 0;
        int message = -1;

        uint mode = data[ current++ ];
        uint who = data[ current++ ];
        uint who2;
        CritterCl@ originalTarget;

        CritterCl@ cr = GetCritter( who );
		CritterCl@ trueTarget = null;

        bool self = ( who == GetChosen().Id );
		
		bool isDead = true;

        string name = "error0";
        if( valid( cr ) )
		{
			if( !self )
			{
				name = cr.Name;
			}
			else
			{
				name = GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 );
			}
			isDead = !cr.IsPlayer();
        }

        uint offset;
        if( self )
		{
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE ) {
                offset = 506;
			} else {
                offset = 556;
			}
		}
		else
		{
            if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
			{
                offset = 606;
			}
			else if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
			{
                offset = 656;
			}
			else
			{
				offset = 706;
			}
		}

        string result;

        // reading and preparing the data:
        switch( mode )
        {
			case( CMSG_CRIT_MISS ):
			{
				effect = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 8 );
				result = ReplaceText( result, "%s", name );
				break;
			}
			case( CMSG_CRIT_MISS_DAMAGE ):
			{
				effect = data[ current++ ];
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 28 : 27 ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 ) {
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_HIT ):
			case( CMSG_HIT_DEAD ):
			{
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 7 : ( damage != 0 ? 17 : 21 ) ) );
				
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_AIMED_HIT ):
			case( CMSG_AIMED_HIT_DEAD ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 6 : ( damage != 0 ? 16 : 20 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );

				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_HIT ):
			{
				damage = data[ current++ ];
				effect = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_AIMED_HIT ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				effect = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_HIT_DEAD ):
			{
				damage = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 14 : ( damage != 0 ? 18 : 22 ) ) );
				result = ReplaceText( result, "%s", name );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_CRIT_AIMED_HIT_DEAD ):
			{
				loc = data[ current++ ];
				damage = data[ current++ ];
				message = data[ current++ ];
				result = GetMsgStr( TEXTMSG_COMBAT, offset + ( damage > 1 ? 5 : ( damage != 0 ? 15 : 19 ) ) );
				result = ReplaceText( result, "%s", name );
				result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, 1000 + cr.CrTypeAlias * 10 + loc - 1 ) );
				if( damage > 1 )
				{
					result = ReplaceText( result, "%d", damage );
				}
				break;
			}
			case( CMSG_OOPS ):
			{
				who2 = data[ current++ ]; // who2 was hit instead of who
				@trueTarget = GetCritter( who2 );
				if( self )
				{
					// It was original target
					uint gender_info = CLAMP( cr.Stat[ ST_GENDER ], GENDER_MALE, GENDER_IT ) * 100;
					result = GetMsgStr( TEXTMSG_COMBAT, 608 + gender_info );
					string nameTrue = "error1";
					if( valid( trueTarget ) )
					{
						nameTrue = trueTarget.Name;
					}
					result = ReplaceText( result, "%s", nameTrue );
				}
				else
				{
					// It was not original target
					result = GetMsgStr( TEXTMSG_COMBAT, offset + 3 );
					if( who2 == GetChosen().Id )
					{
						result = ReplaceText( result, "%s", GetMsgStr( TEXTMSG_COMBAT, chosen.Stat[ ST_GENDER ] == GENDER_MALE ? 506 : 556 ) );
					}
					else
					{
						string nameTrue = "error1";
						if( valid( trueTarget ) )
						{
							nameTrue = trueTarget.Name;
						}
						result = ReplaceText( result, "%s", nameTrue );
					}
					result = ReplaceText( result, "%s", name );
				}
				break;
			}
			case( CMSG_MISS ):
			{			
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
				result = ReplaceText( result, "%s", name );
				break;
			}
			case( CMSG_HIT_RANDOMLY ):
			{
				result = GetMsgStr( TEXTMSG_COMBAT, offset + 9 );
				result = ReplaceText( result, "%s", name );
				result += GetMsgStr( TEXTMSG_COMBAT, 108 ) + GetMsgStr( TEXTMSG_COMBAT, offset - 306 + 20 );
			}
			default:
				break;
        }

        bool isVerbose = ( __CombatMessagesType == 0 );
        string@[] ext;
		uint[] exts;

        if( message != -1 && isVerbose )       // Must be critical hit
		{
            result += GetMsgStr( TEXTMSG_COMBAT, message );
        }
		else if( effect != 0 )
		{
            offset -= 306;
			uint[] flags = { HF_KNOCKOUT, HF_KNOCKDOWN, HF_CRIPPLED_LEFT_LEG, HF_CRIPPLED_RIGHT_LEG, HF_CRIPPLED_LEFT_ARM, HF_CRIPPLED_RIGHT_ARM, HF_BLINDED, 
								0, 0, 0, 0, HF_BYPASS_ARMOR, 0, 0, HF_DROPPED_WEAPON, HF_LOST_NEXT_TURN, 0, 0, 0, 0, 0, HF_RANDOM };
			uint len = flags.length();
            if( mode > CMSG_CRIT_MISS_DAMAGE )
			{         // Hit flags
            	for( uint x = 0; x < len; x++ )
				{
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
				}
			}
			else
			{
				for( uint x = 0; x < len; x++ )
				{
					if( flags[x] != 0 && FLAG( effect, flags[x] ) )
					{ 
						ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + x ) ); 
						exts.insertLast( offset + x ); 
					}
				}
				
                if( FLAG( effect, MF_WAS_KILLED ) )
				{
                    ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) ) );
					exts.insertLast( offset + ( isDead ? 7 : 0 ) );
				}
            }
            offset += 306;
        }

		if( 8 <= mode && mode <= 11 && ( !isVerbose || message == -1 ) )
		{
            ext.insertLast( @GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) );
			exts.insertLast( offset + ( isDead ? 7 : 0 ) - 306 );
		}

		uint n = ext.length();
		testInfo( CR_TEST_MODE_COMBAT, "Ext.length = " + n );

        for( uint m = 0; m < n; m++ )
		{
            if( m == n - 1 )
			{
                result += GetMsgStr( TEXTMSG_COMBAT, 108 );
            }
			else
			{
                result += ", ";
			}
			
            result += valid( ext[m] ) ? ext[m] : "[" + m + "#" + exts[m] + "]" ;
			
			testInfo( CR_TEST_MODE_COMBAT, "#" + m + ":" + exts[m] + ": " + checkNull(ext[m]) + ";" );
        }

        result += ".";

		bool MyHit = chosen.Id == data[++current]; current++;
        Message( ( MyHit ? "|0xF5D742 " : "" ) + result, FOMB_COMBAT_RESULT );

        if( 8 <= mode && mode <= 11 && isVerbose && message != -1 )
		{
            Message( name + " " + GetMsgStr( TEXTMSG_COMBAT, offset + ( isDead ? 7 : 0 ) - 306 ) + ".", FOMB_COMBAT_RESULT );
		}
        // On head indication
        if( __DamageHitDelay > 0 && damage > 0 )
		{
            MapMessage( "-" + damage, cr.HexX, cr.HexY, __DamageHitDelay, 0xFFC80000, true, Random( -5, 5 ), -20 );
		}
	}
}

string generic_description_slot( int slot )
{
	CritterCl@ chosen = GetChosen();
	string result = "|0x3CF800 -----------------------\n";
	
	ItemCl@ item = null; 
	if( slot == SLOT_HAND1 )
	{
		@item = _CritGetItemHand( chosen );
	}
	else
	{
		@item = _CritGetItemHandExt( chosen );
	}
	
	if( !valid( item ) )
	{
		uint8 mode = 0;
		int bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
		ProtoItem@ unarmed = chosen.GetSlotProto( slot, mode );
		result += GetMsgStr( TEXTMSG_GAME, STR_INV_NO_ITEM ) + "\n";
		result += GetMsgStr( TEXTMSG_GAME, STR_INV_UNARMED_DMG ) + "|0xFFFF00  ";
		result += ( _WeaponDmgMin( unarmed, _WeaponModeUse( mode ) ) + bonus ) + "|0x3CF800  - " + "|0xFFFF00 ";
		result += ( _WeaponDmgMax( unarmed, _WeaponModeUse( mode ) ) + bonus ) + "\n";
		result += "\n\n";
		
		return result;
	}
	
	int use = _WeaponModeUse( item.Mode );
	if( use > 2 )
	{
		use = 0;
	}
	
	result += getItemTextName( itemText( item ) ) + "\n";

	if( item.GetType() != ITEM_TYPE_WEAPON )
	{
		if( item.GetCount() > 1 )
		{
			result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE );
			result += "|0xFFFF00 " + item.GetCount();
		}
		
		return result + "\n\n\n";
	}

	bool isAmmoRegen = ( item.GetProtoId() == PID_SOLAR_SCORCHER ) || ( item.GetProtoId() == PID_SUN ) || ( item.GetProtoId() == PID_SUN2 ) || ( item.GetProtoId() == PID_SUN3 )
						|| ( item.GetProtoId() == PID_FIRE_GECKO_FLAME_WEAPON ) || ( item.GetProtoId() == PID_FIREBREATH );
	uint DmgMult = 1;
	uint DmgDiv = 1;
	uint16 AmmoProto = 0;
	uint16 ammoRound = _WeaponRound( item.Proto, use );
	bool isBurst = ammoRound > 1;
	uint16 AmmoPid;
	
	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		if( !isAmmoRegen )
		{
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( valid ( AmmoProto ) )
			{
				DmgMult = AmmoProto.Ammo_DmgMult;
				DmgDiv = AmmoProto.Ammo_DmgDiv;
			}
		}
	}
	
	int bonus = 0;
	uint skill = _WeaponSkill( item.Proto, use );
	
	if( skill == SK_UNARMED || skill == SK_MELEE_WEAPONS )
	{
		bonus = chosen.Stat[ ST_MELEE_DAMAGE ];
	}
	
	uint8 weapon_Subtype = item.Proto.Item_Subtype;
	if( skill == SK_THROWING && ( weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) )
	{
        bonus = chosen.Stat[ ST_MELEE_DAMAGE ] / 2;
	}
	
	result += GetMsgStr( TEXTMSG_GAME, STR_INV_DMG ) + " ";
	result += "|0xFFFF00 " + ( ( _WeaponDmgMin( item.Proto, use ) + bonus ) * DmgMult / DmgDiv );
	result += "|0x3CF800  - ";
	
	if( isBurst )
	{ 
        string column = "|0xFFFF00 " +  ( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * DmgMult / DmgDiv );
        while ( column.length() < 5 ) column += " ";
        result += column + "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BURST );
		result += "|0xFFFF00 " + ammoRound + "\n";
    }
	else
	{
        result += "|0xFFFF00 " + ( ( _WeaponDmgMax( item.Proto, use ) + bonus ) * DmgMult / DmgDiv ) + "\n";
    }
		
	if( _WeaponMaxDist( item.Proto, use ) > 1 )
	{
		result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_DIST ) + " ";
		
		int wpnMaxDist = _WeaponMaxDist( item.Proto, use );
		if( skill == SK_THROWING )
		{
			wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int(10), chosen.Stat[ ST_STRENGTH ] ) );
		}
		result += "|0xFFFF00 " + wpnMaxDist;
		
		if( skill == SK_THROWING && ( weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_PRIM || weapon_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) )
		{
			result += "\n";
		}
	}
	
	if( _GetWeaponBlastRadius( item.Proto ) > 0 )
	{
		result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS );
		result += "|0xFFFF00 " + item.Proto.Blast_Radius + "\n";
	}

	
	if( item.Proto.Weapon_MaxAmmoCount > 0 )
	{
		if( !isAmmoRegen )
		{
			ProtoItem@ AmmoProto = GetProtoItem( item.AmmoPid  );
			if( _GetAmmoBlastRadius( AmmoProto ) > 0 )
			{
				result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_BLAST_RADIUS );
				result += "|0xFFFF00 " + AmmoProto.Blast_Radius;
			}
		}
		
		result += "\n";
		result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO ) + " ";
		result += "|0xFFFF00 " + item.AmmoCount;
		result += "|0x3CF800 /"; 
		result += "|0xFFFF00 " + item.Proto.Weapon_MaxAmmoCount + " ";
		
		if( !isAmmoRegen )
		{
			AmmoPid = item.AmmoPid;
			result += "|0x3CF800 " + _GetAmmoShortDisc( AmmoPid );
		}
		else
		{
			result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_RECHARGABLE_AMMO );
		}
	}
	else if( item.GetCount() > 1 )
	{
		result += "|0x3CF800 " + GetMsgStr( TEXTMSG_GAME, STR_YOU_HAVE );
		result += "|0xFFFF00 " + item.GetCount();
	}
		
	result += "\n";
	
	return result;
}

#define DESCRIPTION_DEFAULT_DELAY	( 33 )
int[] description_tick_delays = { 0, 0, 0, 0 };
string[] generic_descriptions = { "DESC_INVENTORY_MAIN", "DESC_INVENTORY_SPECIAL", "DESC_INVENTORY_STATS", "DESC_INVENTORY_RESIST" };

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Generic description. Descriptions type look in _client_defines.fos, Generic descriptions types.
// int& offsX, int& offsY - offsets of text, by default is zero.
string generic_description( int descType, int& offsX, int& offsY )
{
	
    CritterCl@ chosen = GetChosen();
    if( not valid( chosen ) || descType < 0 || descType >= int(generic_descriptions.length()) )
        return "";

	//Message( "" + description_tick_delays[descType] );//DEBUG ONLY
	
	if( description_tick_delays[descType] <= 0 )
	{
		description_tick_delays[descType] = DESCRIPTION_DEFAULT_DELAY;
		generic_descriptions[descType] = update_generic_description( descType );
	}
	else
	{
		description_tick_delays[descType]--;
	}

	update_generic_description_offsets( descType, offsX, offsY );
	return generic_descriptions[descType];
}

void update_generic_description_offsets( int descType, int& offsX, int& offsY )
{
	switch( descType )
	{
		case( DESC_INVENTORY_MAIN ):
			offsY = -2;
			break;
		case( DESC_INVENTORY_SPECIAL ):
			offsX = 23;
			offsY = -12;
			break;
		case( DESC_INVENTORY_STATS ):
			offsX = -8;
			offsY = -12;
			break;
		case( DESC_INVENTORY_RESIST ):
			offsX = 35;
			offsY = 98;
			break;
	}
}

string update_generic_description( int descType )
{
	CritterCl@ chosen = GetChosen();
	
	string result;

    if( descType == DESC_INVENTORY_MAIN )
    {
        result += chosen.Name + "\n";
        //result += "|0x3CF800 -----------------------\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_STRENGTH ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_PERCEPTION ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_ENDURANCE ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_CHARISMA ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_INTELLECT ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_AGILITY ) ) + "\n";
        result += GetMsgStr( TEXTMSG_GAME, STR_INV_SHORT_SPECIAL( ST_LUCK ) ) + "\n";
		result += "\n\n\n\n\n\n\n"; // FoRP Inventory 2020 adjustment

		result += generic_description_slot( SLOT_HAND1 );
		result += generic_description_slot( SLOT_HAND2 );
	
		// Additional slots
        result += "\n\n"+ GetMsgStr( TEXTMSG_GAME, STR_INV_EXTRA_SLOTS ) + "\n";
		result += "|0x3CF800 -----------------------\n";
		
		ItemCl@ headwear = _CritGetItemHead(chosen);
		if( valid( headwear ) ) 
		{ 
			result += getItemTextName( itemText( headwear ) ) + "\n";
        } 
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_HEAD_EMPTY ) + "\n";
		}
		result += "\n\n|0x3CF800 -----------------------\n";
		
		ItemCl@ backpack = _CritGetItemBack(chosen);
		if( valid( backpack ) ) 
		{ 
			result += getItemTextName( itemText( backpack ) ) + "\n";
		} 
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_BACK_EMPTY ) + "\n";
		}
		result += "\n\n|0x3CF800 -----------------------\n";
		
		ItemCl@ misc = _CritGetItemMisc(chosen);
		if( valid( misc ) ) 
		{ 
			result += getItemTextName( itemText( misc ) ) + "\n";
        }
		else 
		{ 
			result += GetMsgStr( TEXTMSG_GAME, STR_INV_SLOT_MISC_EMPTY ) + "\n";
		}
    }
	
    if( descType == DESC_INVENTORY_SPECIAL )
    {
        result += "\n\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_STRENGTH ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_PERCEPTION ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_ENDURANCE ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_CHARISMA ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_INTELLECT ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_AGILITY ] + "\n";
        result += "|0xFFFF00 " + chosen.Stat[ ST_LUCK ];
    }
	
    if( descType == DESC_INVENTORY_STATS )
    {
        result += "\n\n";
		// Hit Points
        result += "               "  + GetMsgStr( TEXTMSG_GAME, STR_INV_HP ) + " ";
        result += "|0xFFFF00 " + chosen.Stat[ ST_CURRENT_HP ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_MAX_LIFE ] + "\n";
		// AP Regen
		string apregen = GetMsgStr( TEXTMSG_GAME, STR_INV_APREGEN );
		string thatap = "|0xFFFF00 " + floor(chosen.Stat[ ST_APREGEN ]/100.0f) + "." + (chosen.Stat[ ST_APREGEN ] % 100);
		
        float current_weight = cutLesserDigits( chosen.Param[ CR_ITEMS_WEIGHT ] / 1000.0 );
		float max_weight = cutLesserDigits( chosen.Stat[ ST_CARRY_WEIGHT ] / 1000.0 );
		string current_volume = chosen.ItemsVolume();
		// Armor Class
		string arclass = GetMsgStr( TEXTMSG_GAME, STR_INV_AC );
		string thatac = "|0xFFFF00 " + (chosen.Stat[ ST_ARMOR_CLASS ]);
		result += "|0x3CF800                " + ReplaceText(arclass, "VALUE", thatac)  + "\n";
		// String calls
		result += "|0x3CF800                " + ReplaceText(apregen, "VALUE", thatap)  + "\n"; // Action Points Renegeration
		result += "|0x3CF800                " + GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_WEIGHT ) + "|0xFFFF00 \n               " + current_weight + "|0x3CF800  / " + "|0xFFFF00 " + max_weight + "|0x3CF800  " + GetMsgStr( TEXTMSG_GAME, STR_INV_KG ) +"\n";
		result += "|0x3CF800                " + GetMsgStr( TEXTMSG_GAME, STR_INV_TOTAL_VOLUME ) + "|0xFFFF00 \n               " + current_volume + "|0x3CF800  / " + "|0xFFFF00 1000\n";
		// Resistance type names
		result += "|0x3CF800   -----------------------\n";
		
		ItemCl@ armor = _CritGetItemArmor(chosen);
		//if( valid( armor ) ) { result += "  " + getItemTextName( itemText( armor ) ) + ":\n";
       //} else { result += "|0x3CF800   Без брони: \n";
		//}
		result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_NORMAL )     + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_LASER )      + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_FIRE )       + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_PLASMA )     + "\n";
        result += "|0x3CF800 "   + GetMsgStr( TEXTMSG_GAME, STR_INV_EXPLODE )    + "\n";
		result += "|0x3CF800   " + GetMsgStr( TEXTMSG_GAME, STR_INV_ELECTRO );
    }
	
    if( descType == DESC_INVENTORY_RESIST )
    {
        result += "|0xFFFF00      " + chosen.Stat[ ST_NORMAL_ABSORB ]  + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_NORMAL_RESIST ]  + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_LASER_ABSORB ]   + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_LASER_RESIST ]   + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_FIRE_ABSORB ]    + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_FIRE_RESIST ]    + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_PLASMA_ABSORB ]  + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_PLASMA_RESIST ]  + "|0x3CF800  %\n";
        result += "|0xFFFF00      " + chosen.Stat[ ST_EXPLODE_ABSORB ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_EXPLODE_RESIST ] + "|0x3CF800  %\n";
		result += "|0xFFFF00      " + chosen.Stat[ ST_ELECTRO_ABSORB ] + "|0x3CF800  / " + "|0xFFFF00 " + chosen.Stat[ ST_ELECTRO_RESIST ] + "|0x3CF800  %";
    }

    return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Item description. Look types look in _client_defines.fos, Item look types.
string item_description( ItemCl& item, int lookType )
{
	RunServerScriptUnsafe( "general_unsafe@unsafe_mark_last_checked_item", item.Id, lookType, 0, null, null ); //Фича для GM-панели.

	if( FLAG( GetChosen().Param[MIO_FLAGS], MIO_FLAG_SHOW_HINTS ) )
	{
		if( item.Accessory == ACCESSORY_HEX && lookType == ITEM_LOOK_ONLY_NAME )
		{
			//__look_details = 0;
			return "";
		}
	}

	if( item.Info != 0 )
	{		
		if( item.Info == 11 )
		{
			//return "" + lookType;
			
			if( lookType == ITEM_LOOK_ONLY_NAME )
			{
				string text = GetMsgStr( TEXTMSG_GAME, 110000 + item.Val9 );
				text = ReplaceText( text, "STATE", GetMsgStr( TEXTMSG_GAME, 120000 + item.Val0 ) );
				text = ReplaceText( text, "NAME",  itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, item.Val1 * 100 ) + COLOR_NETMSG );
				text = ReplaceText( text, "VALUE", GetMsgStr( TEXTMSG_GAME, 130000 + item.Val3 ) );
				return text;
			}
			else
			{
				string text = GetMsgStr( TEXTMSG_GAME, 110000 + item.Val9 + 1 );
				text = ReplaceText( text, "DESC", GetMsgStr( TEXTMSG_GAME, 140000 + item.Val4 ) );
				return text;
			}
		}
	}

	CritterCl@ chosen = GetChosen();
    // Default error text
    if( not IsMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + ( lookType != ITEM_LOOK_ONLY_NAME ? 1 : 0 ) ) )
	{
        return GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK_NOTHING );
	}
    string result;

    // Car on world map
    if( lookType == ITEM_LOOK_WM_CAR )
    {
        string fuel = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_FUEL );
        fuel = ReplaceText( fuel, "VALUE",     item.Charge / 100 );
        fuel = ReplaceText( fuel, "MAX_VALUE", item.Proto.Car_TankVolume / 100 );
        string deterioration = GetMsgStr( TEXTMSG_GAME, STR_INV_CAR_DETERIORATION );
        deterioration = ReplaceText( deterioration, "VALUE", item.Deterioration * 100 / item.Proto.Car_MaxDeterioration );
        result = fuel + "\n" + deterioration;
    }
    // Short info
    else if( lookType == ITEM_LOOK_ONLY_NAME )
    {
        if(  item.Info != 0 && item.Val9 == PID_POPUP )
		{
            result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", itemColor( item ) + getItemTextName( item.Lexems ) + COLOR_NETMSG );
        }
        else
		{
            result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_LOOK ), "NAME", itemColor( item ) + GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + COLOR_NETMSG );
            if( item.Lexems != "" )
            {
                string lex = "" + item.Lexems;
                for( uint i = 0, len = lex.length(); i < len; i++ )
                {
                    uint8 chr = lex[ i ];
                    if( chr == 36 )
                    {
                        lex = "";
                        break;
                    }
                }
				
                if( lex != "" )
				{
                    result += " " + lex;
				}
			}
			
            if( ( ( __sinf & SINF_ITEMID ) != 0 ) && item.GetType() > 1 && item.GetType() < 13 )
            {
                result += " |0xffff0000 id: " + item.Id + " pid: " + item.GetProtoId();
            }
        }
    }
    // Full info
    else
    {
        
        if(  item.Info != 0 && item.Val9 == PID_POPUP )
		{
            string name = getItemTextName( item.Lexems );
            if ("" != name)
			{
                result += name;
            }

            string description = getItemTextDescription( item.Lexems );
            if ("" != description)
			{
                result += "\n-----------------------\n";
                result += description;
            }
        }
        else
		{
            if( lookType == ITEM_LOOK_INVENTORY )
			{
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) ) + "\n-----------------------\n";
			}
			
            if( item.GetProtoId() == PID_HOLODISK && item.HolodiskNumber != 0 )
			{
                result += GetMsgStr( TEXTMSG_HOLO, STR_HOLO_INFO_NAME( item.HolodiskNumber ) );
			}
			else
			{
                result += GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) + 1 );
			}
			
            if( item.Lexems != "" )
            {
                string lex = "" + item.Lexems;
                for( uint i = 0, len = lex.length(); i < len; i++ )
                {
                    uint8 chr = lex[ i ];
                    if( chr == 36 )
                    {
                        lex = "";
                        break;
                    }
                }
                if( lex != "" )
				{
                    result += " " + lex + "\n";
				}
			}
        }

        if( lookType != ITEM_LOOK_MAP )
		{
            uint16 pid = item.GetProtoId();
			if(item.GetType() == ITEM_TYPE_WEAPON)
			{
				// Strength Requirement
				if( item.GetType() == ITEM_TYPE_WEAPON )
				{
					result += "\n-----------------------\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_STR_REQ );
					str = ReplaceText( str, "VALUE", item.Proto.Weapon_MinStrength  );
					result += str;
				}
				//  Custom object speed
				if( FLAG( item.Flags, ITEM_CAN_USE ) || FLAG( item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON )
				{
					result += "\n";
					uint8 aim = ( item.Mode >> 4 ) & 0x0F;
					string str2;
					str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_WAIT_TIME );
					uint val = _GetProtoWindupTime( item.Proto );
					if( chosen.ParamBase[CR_AUTO_AIM] == HIT_LOCATION_NONE && ( _WeaponAim( item.Proto, item.Mode ) && ( aim == HIT_LOCATION_NONE ) ) ) {
						val = val / 2;
					}						
					str2 = ReplaceText( str2, "VALUE", val );
					result += str2;
				}
				//  Custom AP cost
				if( FLAG(item.Flags, ITEM_CAN_USE) || FLAG(item.Flags, ITEM_CAN_USE_ON_SMTH ) || item.GetType() == ITEM_TYPE_WEAPON && item.Mode != USE_RELOAD )
				{
					result += "\n";
					uint8 aim = ( item.Mode >> 4 ) & 0x0F;
					uint val =  GetUseApCost( chosen, item, item.Mode);
					if( chosen.ParamBase[CR_AUTO_AIM] != HIT_LOCATION_NONE && ( _WeaponAim( item.Proto, item.Mode ) && ( aim == HIT_LOCATION_NONE ) ) )
					{
						val += val * 20 / 100;
					}
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_AP_COST );					
					str = ReplaceText( str, "VALUE", val );
					result += str;
				}
				// Ammo & Reload info
				if( item.Proto.Weapon_MaxAmmoCount > 0 )
				{
					// Custom Reload AP cost
					result += "\n";
					string str;
					str = GetMsgStr( TEXTMSG_GAME, STR_INV_RELOAD_COST );
					str = ReplaceText( str, "VALUE", item.Proto.Weapon_ReloadAp );
					// Ammo load
					string str2;
					str2 = GetMsgStr( TEXTMSG_GAME, STR_INV_HAS_SHOTS );
					str2 = ReplaceText( str2, "VALUE",     item.AmmoCount );
					str2 = ReplaceText( str2, "MAX_VALUE", item.Proto.Weapon_MaxAmmoCount );
					// Caliber
					string str3;
					str3 = GetMsgStr (TEXTMSG_GAME, STR_INV_CALIBER_MSG);
					str3 = ReplaceText( str3, "AMMO", GetMsgStr( TEXTMSG_GAME, STR_CALIBER( item.Proto.Weapon_Caliber ) ) );
					result += str + "\n" + str2 + "\n" + str3;
				}
			}
			else if( item.GetType() == ITEM_TYPE_ARMOR )
			{
				result += "\n\n-----------------------";
			}
			// Armor Class Mod
			if( item.Proto.Armor_AC > 0 )
			{
				string str;
				str = GetMsgStr ( TEXTMSG_GAME, STR_INV_ARMOR_AC);
				str = ReplaceText (str, "VALUE", item.Proto.Armor_AC);
				result += str;
			}
		    
			else if(item.GetType() == ITEM_TYPE_AMMO)
			{
				// Ammo stats
				result += "\n-----------------------";
				string ammoACMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_POWER );
				ammoACMod = ReplaceText( ammoACMod, "ACMOD", item.Proto.Ammo_AcMod);
				string ammoMult  = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_MULT  );
				ammoMult  = ReplaceText( ammoMult,  "MULT",  item.Proto.Ammo_DmgMult );
				ammoMult  = ReplaceText( ammoMult,  "DIV",   item.Proto.Ammo_DmgDiv  );
				string ammoDRMod = GetMsgStr( TEXTMSG_GAME, STR_INV_AMMO_DRMOD );
				ammoDRMod = ReplaceText( ammoDRMod, "DRMOD", item.Proto.Ammo_DrMod);
				string ammoCal = GetMsgStr( TEXTMSG_GAME, STR_INV_CALIBER_MSG );
				ammoCal = ReplaceText( ammoCal, "AMMO", GetMsgStr(TEXTMSG_GAME, STR_CALIBER(item.Proto.Ammo_Caliber)));

				result += "\n" + ammoACMod + "\n" + ammoMult + "\n" + ammoDRMod + "\n" + ammoCal;
			}
            
            // Deterioration
            if( item.IsDeteriorable() )
            {
                uint8  brokenFlags    = item.BrokenFlags;
                uint8  brokenCount = item.BrokenCount;
                uint16 deterioration = item.Deterioration;

                // Broken level, procent
                result += "\n";
                if( FLAG( brokenFlags, BI_NOTRESC ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
				}
                else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_LOW );
                }
				else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_NORM );
                }
				else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
				{
                    result += GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_HIGH );
                }
				else
				{
                    result += ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_PROCENT ), "VALUE", deterioration * 100 / MAX_DETERIORATION );
				}
				
                // Service
                if( FLAG( brokenFlags, BI_SERVICE ) )
				{
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE );
				}

                // Service ext
                if( FLAG( brokenFlags, BI_SERVICE_EXT ) )
				{
                    result += "\n" + GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_SERVICE_EXT );
				}
				
                // Broken count
                CritterCl@ chosen = GetChosen();
				if( valid( chosen ) )
				{
                    result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_DETERIORATION_BROKEN_COUNT ), "VALUE", brokenCount );
				}
			}

            // Key id
            if( item.GetType() == ITEM_TYPE_KEY )
			{
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_KEY_NUMBER ), "KEY_ID", item.LockerId );
			}
			result += "\n-----------------------";
			
			// Partial_Item
			if( item.Proto.Partial_Item > 0 && item.Val0 > 0 )
			{ 
				string partial_info = GetMsgStr( TEXTMSG_GAME, STR_ITEM_USES_LEFT ) + "|0xE5C62B VALUE ";
				result += "\n" + ReplaceText( partial_info, "VALUE", item.Val0 );
			}

			// Weight
			uint containter = item.GetProtoId();
			uint8 itemType = item.GetType();

			if( containter == PID_POT_ALCO || Flasks.find( containter ) != -1 )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight + item.Val2 ); // Val2 отвечает за заполненность тары
			
			}
			else if( glass_bottles[2].find(  containter ) != -1 )
			{
                result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight - ( item.Proto.Partial_Item * 100 - item.Val2 ) ); // Val2 отвечает за заполненность тары, обратная логика для бутылок
			}
			else if( itemType == ITEM_TYPE_CONTAINER )
			{
				float weight;
				chosenContainerItems.get( ""+item.Id, weight );
				weight += item.Proto.Weight;
				float weightBonus = 1.0f;
				string bonus = "";
				if( item.CritSlot == SLOT_BACK || item.CritSlot == SLOT_MISC )
				{
					switch( item.GetProtoId() )
					{
						case( PID_BACKPACK ):
						case( PID_PORTABLE_REFRIGERATOR ):
						case( PID_STUFF_SUPPLIES):		
							weightBonus = 0.5f;
							bonus = " ( 50% )";
							break;
						case( PID_BROWN_BAG ):
						case( PID_TRAVEL_BAG ):
						case( PID_CHEMTEC_CASE ):
						case( PID_METAL_CASE ):
						case( PID_BLOODY_FIRST_AID_BAG ):
						case( PID_FIRST_AID_BAG ):
						case( PID_cashbag ):
						case( PID_DOCTORS_BAG ):
						case( PID_FIRST_AID_KIT ):		
						case( PID_FIELD_MEDIC_KIT ):		
						case( PID_PARAMEDICS_BAG ):		
						case( PID_MEDICAL_SUPPLIES ):		
						case( PID_BRIEFCASE ):		
							weightBonus = 0.8f;
							bonus = " ( 80% )";
							break;
						case( PID_PORTMONE ):
						case( PID_AMMO_BELT ):
							weightBonus = 0.1f;
							bonus = " ( 10% )";
							break;
						default:
							weightBonus = 1.0f;
							break;
					}
				}
				
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", weight * weightBonus );
				result += bonus;
			}
			else if( itemType == ITEM_TYPE_ARMOR && item.CritSlot == SLOT_ARMOR )
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight / 2 );
				result += " ( 50% )";
				
			}
			else
			{
				result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_ITEM_WEIGHT_GRAMM ), "VALUE", item.Proto.Weight * item.GetCount() );
			}
			
			// Volume
			result += "\n" + ReplaceText( GetMsgStr( TEXTMSG_GAME, STR_INV_VOLUME ), "VALUE", item.Proto.Volume * item.GetCount() );
			// Homebrew Taste
			uint[] taste_pids = { PID_HOMEBREW_PRT };
			int m = taste_pids.find( item.GetProtoId() );
			if( m != -1 )
			{
				result += "\n-----------------------";
				item.Val8 > 0 ? result += GetMsgStr( TEXTMSG_TEXT, STR_HOMEBREW_TASTE ) + ReplaceText( GetMsgStr( TEXTMSG_TEXT, STR_HOMEBREW_TASTE_BEGIN + item.Val8 ), ".", "" ) : result;
			}
			// Flask Taste
			int l = Flasks.find( item.GetProtoId() );
			if( l != -1 )
			{
				result += "\n-----------------------";
				item.Val1 > 0 ? result += GetMsgStr( TEXTMSG_TEXT, STR_SMELL_CANTEEN ) + ReplaceText( GetMsgStr( TEXTMSG_ITEM, item.Val1*100 ) , ".", "" ) : result;
			}
		}
    }

    // Format tags
    if( item.Lexems != "" )
	{
        return FormatTags( result, item.Lexems );
    }
	return result;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Critter description. Look types look in _client_defines.fos, Critter look types.
string critter_description( CritterCl& cr, int lookType )
{
    string result = critter_description_maker( cr, lookType ); //Базовое описание цели.

    //Подробное описание состояния и инвентаря цели.
	if( lookType == CRITTER_LOOK_FULL )
    {
        critter_description_full( cr, result );
	}

    if( lookType == CRITTER_LOOK_SHORT && ( __sinf & SINF_CRID ) != 0 )
    {
        result += " |0xffff0000 " + cr.Id;
    }

    // Format tags
    if( cr.Lexems != "" )
	{
        return FormatTags( result, cr.Lexems );
	}
	
    return result;

}

string critter_description_full( CritterCl& cr, string& result )
{
	result += "" + COLOR_NETMSG + critter_description_health( cr ) + critter_description_hand( cr ) + critter_description_slots( cr ) + critter_description_stats( cr );
			
	return result;
}

string critter_description_maker( CritterCl& target, int lookType )
{
	CritterCl@ chosen = GetChosen();
	
	return critter_description_maker( lookType, target.Id, target.Stat[ ST_AGE ], target.Stat[ ST_GENDER ], target.CrType, target.Stat[ ST_BODY_TYPE ], target.IsPlayer(), target.Name, target.Pid, target.IsLife(), target.IsKnockout(), target.IsDead() );
}

string critter_description_maker( int lookType, int target_id, int age, int gender, int crType, int bodyType, bool isPlayer, string name, uint16 npcPid, bool isLife, bool isKnockout, bool isDead )
{
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_NOTHING );
	
	CritterCl@ chosen = GetChosen();

	if( lookType == CRITTER_ONLY_NAME )
	{
		CritterCl@ cr = GetCritter( target_id );
		if( !valid( cr ) )
		{
			return "[null]";
		}
		
		if( cr.Param[ QST_MEDIUM ] != 0 )
		{
			if( cr.Param[ QST_MEDIUM ] == 2 )
			{
				name = "";
			}
			
			if( cr.Param[ QST_MEDIUM ] == 3 )
			{
				string@ s_temp = cr.Lexems;
				if( !(s_temp is null) )
				{
					name = s_temp;
				}
			}
			
			if( cr.Param[ QST_MEDIUM ] >= 4 )
			{
				string@ s_temp = GetName( cr.Param[ QST_MEDIUM ] );
				if( !(s_temp is null) )
				{
					cr.Name = s_temp;
				}
			}
		}
		else 
		{
			if( !isPlayer )
			{
				name = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
			}
		}
		result = name;
    }
	
	if( lookType == CRITTER_LOOK_SHORT )
	{
		if( name != "" || ( __sinf & SINF_LOGIN ) != 0 )
		{
			result = GetMsgStr( TEXTMSG_GAME, STR_YOU_SEE ) + COLOR_CRITTER + name + "|0x3CF800 .";
		}
		else
		{
			lookType = CRITTER_LOOK_FULL;
		}
	}
	
	if( lookType == CRITTER_LOOK_FULL )
	{
		string view_name = "technical_line";
		string view_age = "";
		
		bool hasAge = false;
		bool isMale = gender == GENDER_MALE;
		bool isFemale = gender == GENDER_FEMALE;
		
		switch( bodyType )
		{
			case( BT_MEN ): 
			case( BT_WOMEN ):
			{
				uint ageStr = GetMsgStrNumUpper( TEXTMSG_GAME, STR_CRIT_LOOK_AGE( CLAMP( gender, GENDER_MALE, GENDER_FEMALE ), CLAMP( age, 0, 90 ) ) );
				if( ageStr != 0 )
				{
					view_name = GetMsgStr( TEXTMSG_GAME, ageStr );
				}
				else if( name == "" )
				{
					view_name = "???";
				}
				else
				{
					view_name = name;
					view_name = ".";
				}
				break;
			}
		}
			
		string description = view_age + view_name;
		
		description = strupr( substring ( description, 0, 1 ) ) + substring( description, 1, description.length() - 1 );
		int line_type = isLife ? STR_CRIT_LOOK_LIFE : isKnockout ? STR_CRIT_LOOK_KO : isDead ? STR_CRIT_LOOK_DEAD : STR_CRIT_LOOK_NOTHING;
		if( line_type != STR_CRIT_LOOK_NOTHING )
		{
			if( !isPlayer )
			{
				description = GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_NAME( npcPid ) );
				description += "|0x3CF800 . " + GetMsgStr( TEXTMSG_DLG, STR_NPC_PROTO_DESC( npcPid ) );
			}
			result = ReplaceText( GetMsgStr( TEXTMSG_GAME, uint( line_type ) ), "NAME", COLOR_CRITTER + description );
		}
	}
	return result;
}

string critter_description_health( CritterCl& cr )
{
	int gender = cr.Stat[ ST_GENDER ];
	string result = GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_WHO( gender ) );
	
	int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
	if( cr.IsDead() )
	{
		if( cr.IsNpc () ) {
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( -1 ) ) + genderEnding( cr );	
		}
		else
		{
			result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 0 ) );
		}
	}
	else if( cr.Stat[ ST_CURRENT_HP ] < 0 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 1 ) ) + genderEnding( cr );
	else if( hp_proc <= 30 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 2 ) ) + genderEnding( cr );
	else if( hp_proc <= 50 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 3 ) ) + genderEnding( cr );
	else if( hp_proc <= 70 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 4 ) ) + genderEnding( cr );
	else if( hp_proc <= 90 )
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 5 ) ) + genderEnding( cr );
	else
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_STATE( 6 ) ) + genderEnding( cr );

	if( _CritIsInjured( cr ) )
	{
		bool needComa = false;

		int hp_proc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_LIMBS( gender, hp_proc >= 90 ) ) + ": ";
		
		uint lineNum = 0;
		switch( cr.Stat[ ST_BODY_TYPE ] ) //Take line from FOCOMBAT.MSG based on CritterType Allias from CritterTypes.cfg
		{
			case( BT_BRAHMIN ):
				lineNum = 1150;
				break;
			case( BT_DOG ):
				lineNum = 1160;
				break;
			case( BT_SUPER_MUTANT ):
				lineNum = 1180;
				break;			
			case( BT_RAT ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_RAT_MOLERAT ):
						lineNum = 1190;
						break;	
					case( CRTYPE_RAT_PIGRAT ):
						lineNum = 1550;
						break;		
					default:  // CRTYPE_RAT
						lineNum = 1240;
						break;	
				}
				break;
			}	
			case( BT_RADSCORPION ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_RADSCORPION ):
						lineNum = 1570;
						break;
					case( CRTYPE_RADSCORPION_SMALL ):
						lineNum = 1590;
						break;
					default: // CRTYPE_RADSCORPION_HUGE, CRTYPE_RADSCORPION_BLC_HUGE, CRTYPE_RADSCORPION_CAVE
						lineNum = 1220;
						break;
				}
			}
			case( BT_FLOATER ):
				lineNum = 1230;
				break;
			case( BT_CENTAUR ):
				lineNum = 1250;
				break;
			case( BT_ROBOT ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_ROBOEYE ):
						lineNum = 1540;
						break;
					case( CRTYPE_TURRET_PLASMA ): 
					case( CRTYPE_TURRET_MINIGUN ):
					case( CRTYPE_TURRET_LASER_TOWER ):
					case( CRTYPE_TURRET_LASER ):
						lineNum = 1900;
						break;
					case( CRTYPE_ROBOT ):
					case( CRTYPE_ROBOT_BLUE ): 
						lineNum = 1660;
						break;
					case( CRTYPE_ROBOT_HANDY ): 
						lineNum = 1170;
						break;
					default: // CRTYPE_ROBOBRAIN
						lineNum = 1530;
						break;
				}
				break;
			}
			case( BT_MANTI ):
				lineNum = 1520;
				break;
			case( BT_DEADCLAW ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_DEADCLAW_SMALL ):
						lineNum = 1600;
						break;
					case( CRTYPE_DEADCLAW_BEAST ):
						lineNum = 1310;
						break;
					default: // CRTYPE_DEADCLAW, CRTYPE_DEADCLAW_GREY
						lineNum = 1510;
						break;
				}
				break;
			}
			case( BT_PLANT ):
				lineNum = 1650;
				break;
			case( BT_GECKO ):
				lineNum = 1670;
				break;
			case( BT_ALIEN ):
			{
				switch( cr.CrType )
				{
					case( CRTYPE_ALIEN_EGG ):
						lineNum = 1580;
						break;
					default: // CRTYPE_ALIEN_REG, CRTYPE_ALIEN_QUEEN
						lineNum = 1800;
						break;
				}
				break;
			}
			case( BT_GIANT_ANT ):
				lineNum = 1970;
				break;
			case( BT_BIG_BAD_BOSS ):
				lineNum = 1850;
				break;
			case( BT_GIANT_BEETLE ):
				lineNum = 4030;
				break;
			case( BT_GIANT_WASP ):
				lineNum = 4150;
				break;
			case( BT_YAO ):
				lineNum = BT_YAO;
				break;
			case( BT_SWAMP_LURKER ):
				lineNum = 3470;
				break;
			case( BT_CROCS ):
				lineNum = 4160;
				break;
			default: // BT_MEN, BT_WOMEN, BT_CHILDREN, BT_GHOUL
				lineNum = 1110;
				break;
		}
		
		if( cr.ParamBase[ DAMAGE_EYE ] != 0 )
		{
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 6 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_ARM ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 2 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_ARM ] != 0 )
		{
			if( needComa )
			{				
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 1 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_RIGHT_LEG ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 4 );
			needComa = true;
		}
		if( cr.ParamBase[ DAMAGE_LEFT_LEG ] != 0 )
		{
			if( needComa )
			{
				result += "|0x3CF800 , ";
			}
			result += "|0xFFFF00 " + GetMsgStr( TEXTMSG_COMBAT, lineNum + 5 );
			needComa = true;
		}
	}
	return result + "|0x3CF800 ."; 
}

string critter_description_hand( CritterCl& cr )
{
	ItemCl@ item  = _CritGetItemHand(cr);
	if( !valid( item ) ) return "";

	int bodyType = cr.Stat[ ST_BODY_TYPE ];
	int crType = cr.CrType;

	bool twoHanded = valid( item ) ? FLAG( item.Flags, ITEM_TWO_HANDS ) : false;
	bool determined = true;
	
	string hands;
	switch( crType )
	{
		case( CRTYPE_TURRET_PLASMA ): 
		case( CRTYPE_TURRET_MINIGUN ):
		case( CRTYPE_TURRET_LASER_TOWER ):
		case( CRTYPE_TURRET_LASER ):
		case( CRTYPE_ROBOEYE ):
			hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMAMENT );
			break;
		default:
			determined = false;
			break;
	}
	
	if( !determined )
	{
		switch( bodyType )
		{
			case( BT_BRAHMIN ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_ARMAMENT );
				break;
			case( BT_RAT ):
			case( BT_DOG ):
			case( BT_PLANT ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CHAPS );
				break;
			case( BT_GIANT_ANT ):
			case( BT_GIANT_BEETLE ):
			case( BT_GIANT_WASP ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANDIBLES );
				break;
			case( BT_RADSCORPION ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_PINCERS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_PINCER );
				break;
			case( BT_FLOATER ):
			case( BT_ALIEN ):
			case( BT_CENTAUR ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_TENTACLES ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_TENTACLE );
				break;
			case( BT_ROBOT ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANIPULATORS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_MANIPULATOR );
				break;
			case( BT_GECKO ):
				hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CHAPS );
				break;
			case( BT_MANTI ):
			case( BT_YAO ):
			case( BT_DEADCLAW ):
				hands = twoHanded ? hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CLAWS ) : hands = GetMsgStr( TEXTMSG_GAME, STR_CRIT_HOLDS_IN_CLAW );
				break;
			default: //regular characters
				hands = twoHanded ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_HAND1_2H ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HAND1_1H );
				break;
		}
	}					
	return " " + hands + " " + getItemTextName( itemText( item ) ) + ".";
}

string critter_description_slots( CritterCl& cr )
{
	string result;
	
	ItemCl@ offhand = _CritGetItemHandExt( cr );
	if( valid( offhand ) )
	{
		result += " " + GetMsgStr( TEXTMSG_GAME, STR_CRIT_LOOK_MISC ) + ".";
		result = ReplaceText( result, "MISC", getItemTextName( itemText( offhand ) ) );
	}
	
	bool hasPrefix = false;
	bool female = cr.Stat[ ST_GENDER ] == GENDER_FEMALE;
	
	ItemCl@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		result += ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_FEMALE_ARMOR ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_MALE_ARMOR ) ) + getItemTextName( itemText( armor ) );
		hasPrefix = true;
	}

	ItemCl@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		result += ( hasPrefix ? ", " : ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_FEMALE_ARMOR ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_MALE_ARMOR ) ) ) + getItemTextName( itemText( head ) );
		hasPrefix = true;
	}

	ItemCl@ misc = _CritGetItemMisc( cr );
	if( valid( misc ) )
	{
		result += ( hasPrefix ? GetMsgStr( TEXTMSG_GAME, STR_AND ) : ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_SHE_HEAD ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_HE_HEAD ) ) ) + getItemTextName( itemText( misc ) );
		hasPrefix = true;
	}

	if( hasPrefix )
	{
		result += ".";
	}
	
	ItemCl@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		result += GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK ) + getItemTextName( itemText( back ) ) + ( female ? GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK_SHE_ENDLINE ) : GetMsgStr( TEXTMSG_GAME, STR_CRIT_BACKPACK_HE_ENDLINE ) );
	}
	
	return result;
}

//descriptions based on appearence and stats
string critter_description_stats( CritterCl& cr )
{
	if( cr.Stat[ ST_BODY_TYPE ] >= BT_BRAHMIN && cr.IsNpc() ) 
	{
		return "";
	}
	
	CritterCl@ chosen = GetChosen();

	ItemCl@ item2 = _CritGetItemHandExt( cr );
	ItemCl@ item3 = _CritGetItemArmor( cr );

	// Список брони для сокрытия внешности.
	uint16[][] OpenArmorList =
	{
		{   // Снимаемое. Капюшоны.
			PID_PURPLE_ROBE, PID_BLACK_ROBE, PID_SANDROBE, PID_BROWN_ROBE, PID_DARK_GREEN_ROBE, PID_RED_RITUAL_ROBE, PID_BLACK_RITUAL_ROBE, PID_DARK_BLACK_ROBE, 
			PID_DARK_RED_ROBE, PID_RED_ROBE, PID_DARK_BROWN_ROBE, PID_DARK_BLUE_ROBE, PID_ATOM_CHILD_ROBE

		},{ // Неснимаемое. Скрывает всё.
			 PID_EKZO, PID_OXIDENED_POWER_ARMOR, PID_aras2k1, PID_arekzo, PID_EKZO_2, PID_POWERED_ARMOR_NEVADA, PID_aras2k2, PID_arbattl1,
			 PID_ardfnder, PID_HYENA_PA, PID_HYENA_PA_MK2, PID_ADVANCED_POWER_ARMOR, PID_ADVANCED_POWER_ARMOR_MK2
		},{ // Снимаемый шлем.
			 PID_POWERED_ARMOR, PID_HARDENED_POWER_ARMOR
		}
	};

	uint8 OpenArmor = 0;
	if( valid( item3 ) )
	{
		uint16 PID = item3.GetProtoId();
		for( uint8 i = 0, l = OpenArmorList.length(); i < l; i++ )
		{
			for( uint8 ii = 0, ll = OpenArmorList[ i ].length(); ii < ll; ii++ )
			{
				if( PID == OpenArmorList[ i ][ ii ] ) 
				{ 
					OpenArmor = i+1;
					break;
				}
			}
		}
	}

	bool hidelex = false;
	bool showface = true;
	bool showbody = true;
	bool female = cr.Stat[ ST_GENDER ] == GENDER_FEMALE;
	bool male = cr.Stat[ ST_GENDER ] == GENDER_MALE;
	
	string usual = " " + ( female ? GetMsgStr( TEXTMSG_GAME, STR_DESC_F_USUAL ) : ( male ? GetMsgStr( TEXTMSG_GAME, STR_DESC_M_USUAL ) : GetMsgStr( TEXTMSG_GAME, STR_DESC_USUAL ) ) );
	string look = "";

	hidelex = ( OpenArmor == 1 && FLAG( cr.Param[ MIO_FLAGS ], ITEM_FLAT ) );
	bool hideopt = ( FLAG( cr.Param[ MIO_FLAGS ], ITEM_HIDDEN ) );

	if( OpenArmor == 1 && hideopt )
	{
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_HOOD );
		showface = false;
		usual = "";
	}
	else if( OpenArmor == 2 )
	{
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_ARMOR );
		showface = false;
		showbody = false;
		usual = "";
	}
	else if( OpenArmor == 3 )
	{
		if( hideopt )
		{
			look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_APP );
			showface = false;
		}
		else 
		{
			look += GetMsgStr( TEXTMSG_GAME, STR_DESC_HIDDEN_ARMOR );
		}
		showbody = false;
		usual = "";
	}
	else 
	{ 
		look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS );
	}

	if( showface && chosen.Id != cr.Id )
	{
		if( chosen.Trait[ TRAIT_BLOODY_MESS ] != 0 )
		{
			look += " ";
			switch( Random( 0, 9 ) )
			{
				case( 0 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS_ANGIRLY );
					break;
				case( 1 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_MUMBLES_NEG );
					break;
				case( 2 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS_HATRED );
					break;
				case( 3 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_MOCKS );
					break;
				case( 4 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS_CONTEM );
					break;
				case( 5 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS_UGLY );
					break;
				case( 6 ): 
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_SQUINTS );
					break;
				case( 7 ):
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_LOOKS_HOSTILE );
					break;
				case( 8 ):
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_GRINNING );
					break;
				case( 9 ):
					look += GetMsgStr( TEXTMSG_GAME, STR_DESC_WHISPERS_DIE );
					break;
			}
			showface = false;
			showbody = false;
			usual = "";
		}
	}

	string comma = " ";
	if( !showface || !showbody ) 
	{ 
		comma = ", ";
	}
	bool truecomma;
	if( showface )
	{
		truecomma = true;
		switch( cr.Stat[ ST_CHARISMA ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_IRRESISTIBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_IRRESISTIBLE );
				break;
			case( 9 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_MBEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_MBEAUTIFUL );
				break;
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_BEAUTIFUL ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_BEAUTIFUL );
				break;
			case( 7 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_ATTRACTIVE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_ATTRACTIVE );
				break;
			case( 3 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_UNPLEASANT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_UNPLEASANT );
				break;
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DISGUSTING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DISGUSTING );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SICKENING ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SICKENING );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = "";
		}
	}

	if( showbody )
	{
		truecomma = true;
		switch( cr.Stat[ ST_STRENGTH ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_VSTRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_VSTRONG );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_STRONG ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_STRONG );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WEAK );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_QWEAK ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_QWEAK );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = ""; 
		}

		truecomma = true;
		switch( cr.Stat[ ST_ENDURANCE ] )
		{
			case( 10 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_TOUGH ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_TOUGH );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_WBUILT ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_WBUILT );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_SLIM ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_SLIM );
				break;
			case( 1 ):
				look += female ? comma +  GetMsgStr( TEXTMSG_GAME, STR_DESC_F_DELICATE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_DELICATE );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", "; 
			usual = "";
		}

		truecomma = true;
		switch( cr.Stat[ ST_AGILITY ] )
		{
			case( 10 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_AGILE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_AGILE );
				break;
			case( 9 ):
			case( 8 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_NIMBLE ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_NIMBLE );
				break;
			case( 3 ):
			case( 2 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_GRACELESS ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_GRACELESS );
				break;
			case( 1 ):
				look += female ? comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_F_CLUMSY ) : comma + GetMsgStr( TEXTMSG_GAME, STR_DESC_M_CLUMSY );
				break;
			default:
				truecomma = false;
		}
		if( truecomma ) 
		{ 
			comma = ", ";
			usual = "";
		}
	}

	string result = ( look != "" ? ( " " + look + usual + "." ) : "" );

	ItemCl@ armor = cr.GetItem( 0, SLOT_ARMOR );
	bool ArmorLexem = ( valid(armor) && armor.Lexems != "" );
	
	if( valid(armor) && ( armor.Val9 == PID_POPUP || armor.GetProtoId() == PID_POPUP ) )
	{
		ArmorLexem = false;
	}
	
	if( ( cr.Lexems != "" || ArmorLexem ) && !hidelex && cr.Param[ QST_MEDIUM ] != 3 ) 
	{ 
		result += " ";
		if( ArmorLexem )
		{
			result += armor.Lexems;
		}
		else
		{			
			result += cr.Lexems;
		}		
		result += "."; 
	}
	return result;
}


// //////////////////////////////////////////////////////////////////////////////////////////////////
// Elevator generation.
// Data specification:
// 1
// 1 start level
// 1 levels count
// 1 main pic
// 2 main pic width, height
// 1 additional pic offset
// 2 additional pic point
// 1 indicator animation offset in INTRFACE.LST
// 2 indicator animation point
// 1 button down pic offset in INTRFACE.LST
// 1 buttons count
// 4 rect for every button
bool get_elevator( uint type, uint[]& data )
{
    const string iface = "art\\intrface\\";
    const        uint[][] elevators =
    {
        //	 Level current, start, count               Main picture size                          Additional picture size                            Indicator animation size                  Buttons count
        //	         Main picture                               Additional picture                       Indicator animation                                  Button down picture                 Button coordinates
        // 0) BOS 1234
        { 0, 1, 4,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 4, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211, 11, 222, 58, 271 },
        // 1) BOS G1
        { 0, 0, 2,  GetStrHash( iface + "EL_BOS.FRM" ),   230, 284, GetStrHash( iface + "EL_BOS2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 2) Master 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 3) Master 34
        { 0, 3, 2,  GetStrHash( iface + "EL_MAST1.FRM" ), 230, 284, GetStrHash( iface + "EL_MAST2.FRM" ), 0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 4) Military 123
        { 0, 1, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 5) Military 34
        { 0, 3, 4,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL2.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 2, 11, 42, 58, 91, 11, 102, 58, 151 },
        // 6) Military 346
        { 0, 3, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL3.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 7) Military 456
        { 0, 4, 3,  GetStrHash( iface + "EL_MIL1.FRM" ),  231, 285, GetStrHash( iface + "EL_MIL4.FRM" ),  0, 37,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
        // 8) Vault 123
        { 0, 1, 3,  GetStrHash( iface + "EL_VAULT.FRM" ), 230, 284, 0,                                0, 0,  GetStrHash( iface + "elevator_indicator.frm" ), 121, 41,  GetStrHash( iface + "EBUT_IN.FRM" ), 3, 11, 42, 58, 91, 11, 102, 58, 151, 11, 162, 58, 211 },
    };

    uint index = ( type & 0xFFFF );
    uint currentLevel = ( type >> 16 );

    if( index > 8 )
        return false;
    data.resize( elevators[ index ].length() );
    for( uint i = 0; i < data.length(); i++ )
        data[ i ] = elevators[ index ][ i ];
    data[ 0 ] = currentLevel;
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Music/Video, see media.fos

void _PlaySound( int pos, int repeat, int, string@ soundName, int[] @ )
{
    PlaySound( soundName );
}

void _PlayMusic( int pos, int repeat, int, string@ musicName, int[] @ )
{
    PlayMusic( musicName, uint( pos ), uint( repeat ) );
}

void _PlayVideo( int canStop, int, int, string@ videoName, int[] @ )
{
    PlayVideo( videoName, canStop != 0 );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Effects, see effects.fos
void _FlushScreen( int fromColor, int toColor, int timeMs, string@, int[] @ )
{
    FlushScreen( fromColor, toColor, timeMs );
}

void _QuakeScreen( int noise, int timeMs, int, string@, int[] @ )
{
    QuakeScreen( noise, timeMs );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( ItemCl& item, CritterCl& cr, CritterCl& npc, bool sell )
{
    uint8  itemType = item.GetType();
    uint16 pid = item.GetProtoId();
    float   cost = item.Proto.Cost;

    if( pid == PID_BOTTLE_CAPS || pid == PID_REAL_BOTTLE_CAPS )
        return 1;
		
	if( pid == PID_DOLLAR_100 )
		return 100;

	if( pid == PID_DOLLAR_20 )
		return 20;
		
	if( pid == PID_DOLLAR_5 )
		return 5;

    if( itemType == ITEM_TYPE_ARMOR || itemType == ITEM_TYPE_WEAPON )
    {
        uint8 brokenCount = item.BrokenCount;
        uint8 brokenFlags = item.BrokenFlags;

        if( FLAG( brokenFlags, BI_NOTRESC ) || FLAG( brokenFlags, BI_BROKEN ) )
            cost *= 0.01;
        else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
            cost /= 3;
        else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
            cost /= 2;
        else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
            cost /= 1.4;
        else if( brokenCount > 0 )
            cost *= brokenCount != 100 ? brokenCount * 0.01 : 0.01;

        if( itemType == ITEM_TYPE_WEAPON && !item.IsStackable() )
        {
            cost += GetProtoItem( item.AmmoPid ).Cost * item.AmmoCount;
        }
    }

	//if( itemType == ITEM_TYPE_PARTIAL ) //TODO: Переделать в новый "тип" предметов (прото) - PARTIAL.
	uint[] partial_pids = { PID_ITSOAP01_PRT, PID_FPSHL6_PRT, PID_CIGARETTES_PRT };
	if( partial_pids.find( pid ) != -1 )
	{
		cost = cost * item.Val0 / 10; //Прямая зависимость от количества оставшихся предметов в "пачке".
	}

	//Торговля мк3 - учитывает опыт НД и ТНФ. Сделал бы отделной ф-ей, да толку - от этой итак ничего не осталось уже.
	
	//Редактируемые "настройки" торговли:
		float skill_range = 150; //Градация разницы в скиллах между НПЦ и чаром. Чем она шире - тем медленней падение/рост цен за 1% разницы.
		
		float price_range = 0.25; //Диапазон разброса цен на покупку у НПЦ.
		//Т.е. это больше НЕ "максимальная допустимая уценка скупки и наценка продажи".

	//Промежуточные функции. Не трогать почём зря!
		//Высчитывает % отношения разницы к допустимому разбросу скиллов. Диапазон: [ -1, 1 ]
		float skill = CLAMP( cr.SkillBase[ SK_BARTER ] - npc.SkillBase[ SK_BARTER ], -skill_range, skill_range ) * ( 1.0 / skill_range ); 

	//Основная логика:
		if( sell ) //Для продажи неписю:
			cost = cost * 0.4; //40% от себеса
		else //Для покупки у НПЦ:
			cost = cost * ( 0.75 - 0.25 * skill ); //От 50 до 100% цены себестоимости товара.
		
	//Конец "торговли".
	
	return CLAMP( floor( cost ), 1, cost );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine perk aviability.
bool check_perk( CritterCl& cr, uint perk )
{
    return PerkCheck( cr, perk );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to calculate registration data.
// Input: 7 special, 3 tag skills, 2 traits, age, gender
void player_data_generate( int[]& data )
{
    CritterGenerate( data );

    #ifdef PLAYERS_3D
    Set3DRegistrationGender( data[ ST_GENDER ] );
    #endif
}

bool player_data_check( int[]& data )
{
    SetCrtype( data );
    #ifdef PLAYERS_3D
    Fill3DRegistrationParameters( data );
    #endif

    return CritterGenerateCheck( data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on some critter action.

void SoundDoor( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	CritterCl@ cr = GetCritter( param0 );
	ItemCl@ item = GetItem( param1 );

	uint8 sound = SOUND_DOOR_NOT_OPEN;
	if( !( cr.HexY == item.HexY && cr.HexX == item.HexX ) ) {
		if( item.LockerCondition == 0 )			
			{ sound = SOUND_DOOR_CLOSE; 
		} else if( item.LockerCondition == 1 ) { 
			sound = SOUND_DOOR_OPEN; 
		} else { 
			sound = SOUND_DOOR_LOCK; 
		}
	}
	PlaySound( SOUND_DOOR, sound, item.Proto.SoundId, item.Proto.SoundId );
}

void critter_action( bool localCall, CritterCl& cr, int action, int actionExt, ItemCl@ item )
{
	uint8 mode = 0;
    const ProtoItem@ proto = ( valid( item ) ? item.Proto : cr.GetSlotProto( SLOT_HAND1, mode ) );
    
	if( !localCall && null !is proto && item !is null && proto.SoundId > 0 ) {
        if( ITEM_TYPE_DOOR == proto.Type || ITEM_TYPE_CONTAINER == proto.Type ) {
            uint8 sound = SOUND_DOOR_NOT_OPEN;
            if (!(cr.HexY == item.HexY && cr.HexX == item.HexX)) {
                if (0 == item.LockerCondition) {
                    sound = SOUND_DOOR_CLOSE;
                } else if (1 == item.LockerCondition) {
                    sound = SOUND_DOOR_OPEN;
                } else {
                    sound = SOUND_DOOR_LOCK;
                }
            }
            PlaySound(SOUND_DOOR, sound, proto.SoundId, proto.SoundId);
        } 
    }


	if( cr.IsChosen() )
    {
		// Not process locally called actions
		if( !localCall )
		{
			switch( action )
			{
				case ACTION_MOVE_ITEM:
					break;
				case ACTION_MOVE_ITEM_SWAP:
					break;
				case ACTION_USE_ITEM:
				{
					uint16 protoPid = proto.ProtoId;
					uint8 item_Subtype = item.Proto.Item_Subtype;
					string soundName = "";
					uint8 itemType = item.GetType();
					uint8 material = proto.Material;
					
					if( actionExt == 0 ) { return; }				
					uint16[] drink_pids = { PID_ANTIDOTE, PID_JET_ANTIDOTE }; //Напитки же подходят лишь для употребления внутрь:
					uint16[] inhailer_pids = { PID_JET, PID_TREB, PID_VINT }; // ингаляторы
					uint16[] pills_pids = { PID_MENTATS, PID_BUFFOUT, PID_RAD_X, PID_RAD_XL, PID_PILLEN, PID_ASPIRIN, PID_MENTATS_FRUIT, PID_PAINKILLERS2, PID_DESINFHN0, PID_PILLS, PID_HEART_PILLS }; // таблетки
					uint16[] injector_pids = { PID_PSYCHO}; // иголки
					
					if( itemType == ITEM_TYPE_FOOD ) {
						soundName = "chewy.ogg";
					} else if( inhailer_pids.find( protoPid ) != -1 ) {
						soundName = "jet.ogg";
					} else if( injector_pids.find( protoPid ) != -1 ) {
						soundName = Random( 1, 2 ) == 1 ? "obj_braintank_steam_01.wav" : "obj_braintank_steam_02.wav";
					} else if( pills_pids.find( protoPid ) != -1 ) {
						soundName = "solopill.ogg";				
					} else if( drink_pids.find( protoPid ) != -1 || ( ( itemType == ITEM_TYPE_DRINK && find_opened_drinks( item ) == true && item.CritSlot == SLOT_HAND1 ) ) ) {
						cr.Stat[ ST_GENDER ] == GENDER_MALE ? soundName = "water.wav" : soundName = "fem_drinking.ogg";
					} else if( Flasks.find( protoPid ) != -1 && item.CritSlot == SLOT_HAND1 && item.Val0 > 0 ) {
						cr.Stat[ ST_GENDER ] == GENDER_MALE ? soundName = "water.wav" : soundName = "fem_drinking.ogg";
					} else if( itemType == ITEM_TYPE_KEY ) {
						soundName = "BLANK.ACM";
					} else if( itemType == ITEM_TYPE_ARMOR ) {
						switch( material )
						{
							case( MATERIAL_FABRIC ):
								soundName = "ROBE.ACM";
								break;
							case( MATERIAL_LEATHER ):
								soundName = "LTHARMOR.ACM";
								break;
							case( MATERIAL_ARMORED_LEATHER ):
								soundName = "LTHARMOR.ACM";
								break;
							case( MATERIAL_METAL ):
								soundName = "MTLARMOR.ACM";
								break;
							case( MATERIAL_POLYMER ):
								soundName = "CMBTFLX.ACM";
								break;
							case( MATERIAL_COMPOSITE ):
								soundName = "PWRARMOR.ACM";
								break;
							default:
								soundName = "ROBE.ACM";
								break;
						}
					} else {
						soundName = "ROBE.ACM";
					}
					PlaySound( soundName );
					break;
				}
				
				case ACTION_DROP_ITEM:
					break;
				case ACTION_USE_WEAPON:
					if( FLAG( ( (actionExt >> 12) & 0xF), ACTION_FLAG_CHOSEN_INCLUSIVE ) )
						break; // PROCESS IT !
				// case ACTION_RELOAD_WEAPON: binyan - правка для действий по хоткеям
				case ACTION_USE_SKILL:
				// case ACTION_PICK_ITEM:
				// case ACTION_PICK_CRITTER:
				case ACTION_OPERATE_CONTAINER:
					return;             // Skip processing
				case ACTION_WINDUP:
				{
					if( FLAG( ( (actionExt >> 12) & 0xF), ACTION_FLAG_CHOSEN_INCLUSIVE ) ) {
						break; // PROCESS IT !
					}
					return;
				}
				default:
					break;              // Processing
			}
		}
		else
		{
			switch(action)
			{
				case ACTION_USE_WEAPON:
				{
					if( GetProtoWindupTime( proto, actionExt, cr ) != 0 && cr.ParamBase[ CR_IS_WINDUPED ] != 1 ) {
						cr.Wait( GetProtoWindupTime( proto, actionExt, cr ) ); // wait here, on client, let server handle.
						return;
					}
					break;
				}	
			}
		}
	}

    switch( action )
    {
		case( ACTION_TEST ):
		{
			Message("TEST ACTION PERFORMED");
			break;
		}
		
		case( ACTION_MOVE ):
		{
			// Not implemented
			// cr.Wait(move time);
			break;
		}
		
		case( ACTION_RUN ):
		{
			// Not implemented
			// cr.Wait(run time);
			break;
		}
		
		case( ACTION_MOVE_ITEM ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_MOVE_ITEM, cr ) );
				
				uint8 fromSlot = actionExt;
				uint8 toSlot = item.CritSlot;
				string soundName = "";
				uint8 material = proto.Material;
		
				cr.ClearAnim();
				
				if( toSlot == SLOT_HAND1 && proto.Type == ITEM_TYPE_WEAPON ) {
					cr.Animate( 0, ANIM2_SHOW_WEAPON, item );
					break;
				} else if( fromSlot == SLOT_HAND1 && proto.Type == ITEM_TYPE_WEAPON ) {
					cr.Animate( 0, ANIM2_HIDE_WEAPON, item );
					break;
				} else if( ( toSlot == SLOT_ARMOR || fromSlot == SLOT_ARMOR ) && proto.Type == ITEM_TYPE_ARMOR ) { 
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.ACM";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.ACM";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.ACM";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.ACM";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.ACM";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.ACM";
							break;
						default:
							soundName = "ROBE.ACM";
							break;
					}
				} else {
					PlaySound( "ROBE.ACM" );
				}
				PlaySound( soundName );
				cr.Animate( 0, ANIM2_SWITCH_ITEMS );
			}
			break;
		}
		
		case( ACTION_MOVE_ITEM_SWAP ):
		{		
			cr.Wait( GetActionTime( ACTION_MOVE_ITEM_SWAP, cr ) );
			PlaySound( "LTHARMOR.ACM" );
			break;
		}
		
		case( ACTION_USE_ITEM ):
		{
			if( !cr.IsLife() || !valid( proto ) ) { return; }

			cr.ClearAnim();

			if( proto.Type == ITEM_TYPE_WEAPON ) { 
				if( FLAG( proto.Flags, ITEM_CAN_USE_ON_SMTH ) && cr.IsAnimAviable( proto.Weapon_Anim1, proto.Weapon_Anim2_0 ) ) {
					cr.Animate( proto.Weapon_Anim1, proto.Weapon_Anim2_0, item );
				}
			} else {
				cr.Animate( 0, ANIM2_USE, item );
			}
			
			if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 ) {
				cr.Wait( GetProtoTime( proto, USE_USE, cr ) );
			}
			
			break; 
		}
			
		case( ACTION_DROP_ITEM ):
		{
			if( cr.IsLife() )
			{
				cr.Wait( GetActionTime( ACTION_DROP_ITEM, cr ) );
				const uint8 item_Subtype = item.Proto.Item_Subtype;
				cr.ClearAnim();
				string soundName = "";
				uint8 material = proto.Material;
				
				if( item_Subtype == 55 || item_Subtype == 56  ) {
					soundName = "KNIFE.ACM"; 
				} else if( item_Subtype == 58 || item_Subtype == 60 ) {
					soundName = "SLEDGE.ACM";
				} else if( item_Subtype == 57 || item_Subtype == 61 ) {
					soundName = "SPEAR.ACM";
				} else if( item_Subtype == 1 || item_Subtype == 2 || item_Subtype == 15 || item_Subtype == 25 || item_Subtype == 35 || item_Subtype == 41 ) {
					soundName = "PISTOL.ACM";
				} else if( item_Subtype == 3 || item_Subtype == 17 || item_Subtype == 27 || item_Subtype == 37 ) {
					soundName = "UZI.ACM";
				} else if( item_Subtype >= 4 && item_Subtype <= 8 || item_Subtype == 16 || item_Subtype == 18 || item_Subtype == 19 
					|| item_Subtype == 26 || item_Subtype == 28 || item_Subtype == 29 || item_Subtype == 36 || item_Subtype == 38 || item_Subtype == 39 || item_Subtype == 42 ) {
					soundName = "RIFLE.ACM";
				} else if( item_Subtype == 10 || item_Subtype == 11 || item_Subtype == 12 || item_Subtype == 14 ) {
					soundName = "FLAMETHR.ACM";
				} else if( item_Subtype == 13 || item_Subtype == 20 || item_Subtype == 30 || item_Subtype == 40 ) {
					soundName = "MINIGUN.ACM";
				} else if( proto.Type == ITEM_TYPE_ARMOR ) {			
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.ACM";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.ACM";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.ACM";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.ACM";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.ACM";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.ACM";
							break;
						default:
							soundName = "ROBE.ACM";
							break;
					}	
				} else { 
					soundName = "IPUTDOWN.ACM";
				}
				
				PlaySound( soundName );
				cr.Animate( 0, ANIM2_PICKUP );
			}
			break;
		}

		case( ACTION_USE_WEAPON ):
		{
			if( localCall )
				return;
			if( cr.IsLife() && valid( proto ) )
			{
				int  use   = ( actionExt & 0xF );
				int  aim   = ( ( actionExt >> 4 ) & 0xF );
				bool fail = ( ( ( actionExt >> 8 ) & 1 ) != 0 );
				
				if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 ) {
					cr.Wait( GetProtoTime( proto, use, cr ) );
				}
				cr.ClearAnim();
				uint8 weaponSubtype = proto.Item_Subtype;
				uint8 n = 4;
				if( proto.Item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN || proto.Item_Subtype == ITEM_SUBTYPE_WEAPON_LASER_MINIGUN || proto.Item_Subtype == ITEM_SUBTYPE_WEAPON_PLASMA_MINIGUN || proto.Item_Subtype == ITEM_SUBTYPE_WEAPON_PULSE_MINIGUN ) {
					n = 5;
				}
				
				if( proto.Weapon_MaxAmmoCount > 0 ) {
					for( uint8 i = 0; i < _WeaponRound( proto, use ); i += n ) {
						cr.Animate( 0, _WeaponAnim2( proto, use ), item );
					}
				} else {
					cr.Animate( 0, _WeaponAnim2( proto, use ), item );
				}
				
				if( fail ) {
					cr.Animate( 0, ANIM2_DAMAGE_FRONT, item );
				} else {
					cr.Animate( 0, ANIM2_TURNOFF_WEAPON );
				}
			}
			break;
		}
		
		case( ACTION_RELOAD_WEAPON ):
		{
			if( cr.IsLife() && valid( proto ) ) {
				cr.ClearAnim();
				cr.Animate( item.Proto.Weapon_Anim1, ANIM2_RELOAD, item );
				int radius = 3;
				CritterCl@[] players;
				int hx = cr.HexX, hy = cr.HexY;
				GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
				int[] values = { item.Proto.ProtoId, 2, radius };
				for( uint i = 0; i < players.length(); i++ ) {
					CritterCl@ player = players[i];
					if( valid( player ) ) {
						__PlayWeaponSound( cr.Id, hx, hy, "LAUGHTE1.mp3", values );
					}
				}
			}
			break;
		}
		
		case( ACTION_WINDUP ):
		{
			if(cr.IsLife() && cr.ParamBase[ CR_IS_WINDUPED ] != 1 ) {
				cr.Wait( GetProtoWindupTime( proto, actionExt, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_PREPARE_WEAPON );
			}
			break;
		}
		
		case( ACTION_USE_SKILL ):
		{
			if( cr.IsLife() && actionExt != SK_SNEAK && actionExt != SK_STEAL )
			{
				cr.Wait( GetActionTime( ACTION_USE_SKILL, cr ) );
				cr.ClearAnim();
				PlaySound( "LTHARMOR.ACM" );
				cr.Animate( 0, ANIM2_USE );
			}
			break;
		}
		
		case( ACTION_PICK_ITEM ):
		{
			if( cr.IsLife() )
			{	
				cr.Wait( GetActionTime( ACTION_DROP_ITEM, cr ) );
				const uint8 item_Subtype = item.Proto.Item_Subtype;
				bool isGround = ( valid( proto ) ? proto.GroundLevel : true );
				if( actionExt != 0 ) { isGround = true; }
				string soundName = "";
				uint8 material = proto.Material;
				cr.ClearAnim();
				
				if( proto.Type == ITEM_TYPE_DOOR ) {
					PlaySound( "BLANK.ACM" );	
				} else if( proto.Type == ITEM_TYPE_CONTAINER ) {
					PlaySound( "BLANK.ACM" );
				} else if( item_Subtype == 55 || item_Subtype == 56  ) {
					soundName = "KNIFE.ACM"; 
				} else if( item_Subtype == 58 || item_Subtype == 60 ) {
					soundName = "SLEDGE.ACM";
				} else if( item_Subtype == 57 || item_Subtype == 61 ) {
					soundName = "SPEAR.ACM";
				} else if( item_Subtype == 1 || item_Subtype == 2 || item_Subtype == 15 || item_Subtype == 25 || item_Subtype == 35 || item_Subtype == 41 ) {
					soundName = "PISTOL.ACM";
				} else if( item_Subtype == 3 || item_Subtype == 17 || item_Subtype == 27 || item_Subtype == 37 ) {
					soundName = "UZI.ACM";
				} else if( item_Subtype >= 4 && item_Subtype <= 8 || item_Subtype == 16 || item_Subtype == 18 || item_Subtype == 19 
					|| item_Subtype == 26 || item_Subtype == 28 || item_Subtype == 29 || item_Subtype == 36 || item_Subtype == 38 || item_Subtype == 39 || item_Subtype == 42 ) {
					soundName = "RIFLE.ACM";
				} else if( item_Subtype == 10 || item_Subtype == 11 || item_Subtype == 12 || item_Subtype == 14 ) {
					soundName = "FLAMETHR.ACM";
				} else if( item_Subtype == 13 || item_Subtype == 20 || item_Subtype == 30 || item_Subtype == 40 ) {
					soundName = "MINIGUN.ACM";
				} else if( proto.Type == ITEM_TYPE_ARMOR) {
					switch( material )
					{
						case( MATERIAL_FABRIC ):
							soundName = "ROBE.ACM";
							break;
						case( MATERIAL_LEATHER ):
							soundName = "LTHARMOR.ACM";
							break;
						case( MATERIAL_ARMORED_LEATHER ):
							soundName = "LTHARMOR.ACM";
							break;
						case( MATERIAL_METAL ):
							soundName = "MTLARMOR.ACM";
							break;
						case( MATERIAL_POLYMER ):
							soundName = "CMBTFLX.ACM";
							break;
						case( MATERIAL_COMPOSITE ):
							soundName = "PWRARMOR.ACM";
							break;
						default:
							soundName = "ROBE.ACM";
							break;
					}
				} else { 
					soundName ="IPUTDOWN.ACM";
				}
				PlaySound( soundName );
				cr.Animate( 0, isGround ? ANIM2_PICKUP : ANIM2_USE );
			}
			break;
		}
		
		case( ACTION_PICK_CRITTER ):
		{
			if( cr.IsLife() )
			{
				cr.Wait(GetActionTime(ACTION_PICK_CRITTER, cr));
				cr.ClearAnim();

				switch( actionExt )           // 0 - loot, 1 - steal, 2 - push
				{
				case 0:
					PlaySound( "ROPE.ACM" );
					cr.Animate( 0, ANIM2_LOOT );
					break;
				// case 1: cr.Animate(0, ANIM2_STEAL); break;
				case 2:
					cr.Animate( 0, ANIM2_PUSH );
					break;
				case 3:
					PlaySound( "ROPE.ACM" );
					cr.Animate( 0, ANIM2_STEAL );
					break;
				default:
					break;
				}
			}
			break;
		}
		
		case( ACTION_OPERATE_CONTAINER ):
		{
			if( cr.IsLife() ) {
				cr.Wait(GetActionTime(ACTION_OPERATE_CONTAINER, cr));
				cr.ClearAnim();
				int transferType = actionExt / 10;
				int directionType = actionExt % 10;
				
				PlaySound( "ROPE.ACM" );
				if( transferType == TRANSFER_HEX_CONT_DOWN || transferType == TRANSFER_CRIT_LOOT ) {
					cr.Animate( 0, ANIM2_PICKUP );
				} else {	
					cr.Animate( 0, ANIM2_USE );
				}
			}
			break;
		}
		
		case( ACTION_DODGE ):
		{
			if( cr.IsLife() ) {
				cr.Wait( GetActionTime( ACTION_DODGE, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt == 0 ? ANIM2_DODGE_FRONT : ANIM2_DODGE_BACK );
			}
			break;
		}
		
		case( ACTION_DAMAGE ):
		{
			if( cr.IsLife() || cr.IsKnockout() ) {
				cr.Wait( GetActionTime( ACTION_DAMAGE, cr ) );
				DamageSound( cr, actionExt );
				uint8 dir = actionExt & 0x1;
				cr.ClearAnim();
				if( cr.IsLife() ) {
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				} else	{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
			}
			break;
		}
		case( ACTION_DAMAGE_FORCE ):
		{
			if( cr.IsLife() || cr.IsKnockout() ) {
				cr.Wait( GetActionTime( ACTION_DAMAGE_FORCE, cr ) );
				DamageSound( cr, actionExt );
				uint8 dir = actionExt & 0x1;
				cr.ClearAnim();
				if( cr.IsLife() ) {
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_FRONT : ANIM2_DAMAGE_BACK );
				} else	{
					cr.Animate( 0, dir == 0 ? ANIM2_DAMAGE_PRONE_FRONT : ANIM2_DAMAGE_PRONE_BACK );
				}
			}
			break;
		}
		
		case( ACTION_KNOCKOUT ):
		{
			if( !cr.IsKnockout() ) {
				cr.Wait( GetActionTime( ACTION_KNOCKOUT, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_STANDUP ):
		{
			if( cr.IsKnockout() ) {
				cr.Wait( GetActionTime( ACTION_STANDUP, cr ) );
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_FIDGET ):
		{
			if( cr.IsLife() )
			{
				//cr.Wait(GetActionTime(ACTION_FIDGET, cr));
				cr.ClearAnim();
				cr.Animate( 0, ANIM2_FIDGET );
			}
			break;
		}
		
		case( ACTION_DEAD ):
		{
			if( !cr.IsDead() ) {
				cr.ClearAnim();
				cr.Animate( 0, actionExt );
			}
			break;
		}
		
		case( ACTION_CONNECT ):
		{    
			// __tempFastText = "";
			break;
		}
		
		case( ACTION_DISCONNECT ): //TODO: checkout later!
		{    
			__tempFastText = "";
			__fastPanelShow = false;
			__fastPanel = false;
			break;
		}
		
		case( ACTION_RESPAWN ):
		{
			if(!cr.IsChosen())
			{
				cr.Wait(GetActionTime(ACTION_RESPAWN, cr));
				cr.ClearAnim();
				cr.Animate(0, ANIM2_STANDUP_FRONT);
			}
			break;
		}
		
		case( ACTION_REFRESH ):
		{
			if( __tempFastText != "" )
				LoadPanel( 2, 0, 0, "", null );
			break;
		}
		
		default:
		{
			break;
		}
	}
}

uint SoundIdCounter = 1;
void DamageSound( CritterCl& cr, int actionExt )
{
	ItemCl@ armor = _CritGetItemArmor( cr );
	uint8 armorSubType = valid(armor) ? armor.Proto.Item_Subtype : 0;
	uint16 weaponPid = ( actionExt >> 16 ) & 0xFFFF;
	ProtoItem@ weaponProto = GetProtoItem( weaponPid );
	uint8 weaponSubType = valid(weaponProto) ? weaponProto.Item_Subtype : 0;
	string soundName = "WHD1FXX1.mp3";
		
   if( armorSubType >= 70 && armorSubType <= 73 ) { 
		if( ( weaponSubType >= 1 && weaponSubType <= 11 ) || (weaponSubType >= 13 && weaponSubType <= 14 ) ) {           
			soundName = "WHD1FXX1.mp3";
		} else if( weaponSubType >= 15 && weaponSubType <= 24 ) {
			soundName = "laser_01.ogg"; 
		} else if( weaponSubType >= 25 && weaponSubType <= 34 ) {
			soundName = "WHS1FXX1.mp3";
		} else if( weaponSubType >= 35 && weaponSubType <= 40 ) {
			soundName = "WHZ1FXX1.mp3";
		}
	} else if( armorSubType >= 74 && armorSubType <= 75 ) { 
		if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) ) {
			soundName = "WHD1MXX1.mp3";
		} else if( weaponSubType >= 15 && weaponSubType <= 24 ) {
			soundName = "laser_02.ogg";
		} else if( weaponSubType >= 25 && weaponSubType <= 34 ) {
			soundName = "WHS1FXX2.mp3";
		} else if( weaponSubType >= 35 && weaponSubType <= 40 ) {
			soundName = "WHZ1FXX2.mp3";
		}
	} else if( armorSubType >= 76 && armorSubType <= 78 ) { 
		if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) ) {
			soundName = "WHH1SXX2.mp3";
		} else if( weaponSubType >= 15 && weaponSubType <= 24 ) {
			soundName = "laser_03.ogg";
		} else if( weaponSubType >= 25 && weaponSubType <= 34 ) {
			soundName = "WHS1SXX1.mp3";
		} else if( weaponSubType >= 35 && weaponSubType <= 40 ) {
			soundName = "WHZ1MXX1.mp3";
		}
	} else if( armorSubType >= 79 && armorSubType <= 80 ) { 
		if ( ( weaponSubType >= 1 && weaponSubType <= 11 ) || ( weaponSubType >= 13 && weaponSubType <= 14 ) ) {
			soundName = "WHJ1MXX1.mp3";
		} else if( weaponSubType >= 15 && weaponSubType <= 24 ) {
			soundName = "laser_04.ogg";
		} else if( weaponSubType >= 25 && weaponSubType <= 34 ) {
			soundName = "WHS1WXX1.mp3";
		} else if( weaponSubType >= 35 && weaponSubType <= 40 ) {
			soundName = "WHZ1MXX2.mp3";
		}
	}
	
	int radius = 20;
	CritterCl@[] players;
	int hx = cr.HexX, hy = cr.HexY;
	GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
	int[] values = { radius };
	for( uint i = 0; i < players.length(); i++ ) {
		CritterCl@ player = players[i];
		if( valid( player ) ) {
			__PlaySound( SoundIdCounter++, hx, hy, soundName, values );
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 2d animation playing.
void animation2d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
    if( !animateStay )
	{
        PlayAnimSound( cr.CrType, cr.Stat[ ST_GENDER ], anim1, anim2 );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call before 3d animation playing.
void animation3d_process( bool animateStay, CritterCl& cr, uint anim1, uint anim2, ItemCl@ item )
{
	//we dont need this
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on some items collection generating.
// To force function call use RefreshItemsCollection(int collection)
// Collection constants see in Items collections _client_defines.fos
// If you want disable showing than just null pointer in collection
void items_collection( int collection, ItemCl@[]& items )
{
    if( collection == ITEMS_INVENTORY )
    {
        for( uint i = 0, j = items.length(); i < j; i++ )
        {
            switch( __inventoryCollection )
            {
            case 0:
                break;
            case 1:
                if( items[ i ].GetType() != ITEM_TYPE_WEAPON )
                    @items[ i ] = null;
                break;
            case 2:
                if( items[ i ].GetType() != ITEM_TYPE_AMMO )
                    @items[ i ] = null;
                break;
            case 3:
                if( items[ i ].GetType() != ITEM_TYPE_ARMOR )
                    @items[ i ] = null;
                break;
            case 4:
                if( items[ i ].GetType() != ITEM_TYPE_DRUG )
                    @items[ i ] = null;
                break;
            case 5:
                if( items[ i ].GetType() != ITEM_TYPE_MISC )
                    @items[ i ] = null;
                break;
            case 6:
                if( items[ i ].GetType() != ITEM_TYPE_KEY )
                    @items[ i ] = null;
                break;
            default:
                break;
            }
            // if(!items[i].IsCanUseByIndefine(choo)) @items[i] = null;
        }
    }

    // ShowItemByIndefineValue(items);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on log file saving.
void filename_logfile( string& filename )
{
    filename = "messagebox\\" + filename;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called on screenshot saving.
void filename_screenshot( string& filename )
{
    filename = "screenshots\\" + filename;
}

void SetHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "w" ) >= 0 )
    {
		if( param0 == 0 ) f.writeString( param3 );
        f.close();
        return;
    }
}

void CheckHardBan( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    file f;
    if( f.open( "data\\art\\intrface\\secret.png", "r" ) >= 0 )
    {
        int number = 0;
        string line;
        f.setPos( 0 );
        while( !f.isEndOfFile() )
        {
            f.readLine( line );
            if( line.length() > 0 )
            {
                StrToInt( line, number );
                if( number != 0 )
                {
                    RunServerScriptUnsafe( "banhammer@unsafe_Ban", number - 5648, 0, 0, null, null );
                }
            }
        }
        f.close();
    }
}

void loger( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( param1 == 0 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\help.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\help.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 1 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\warn.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\warn.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 2 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\kill.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\kill.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 3 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\faction.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\faction.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 4 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\bans.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\bans.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
        return;
    }
    else if( param1 == 5 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adventurers\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 6 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
                return;
            }
            return;
        }
        else
        {
            if( f.open( "adv_approved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 7 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( param0 <= 32 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
            }
            return;
        }
        else if( ( param0 ) % 2 == 0 )
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    string nameIt = GetMsgStr( TEXTMSG_ITEM, number * 100 );
                    nameIt += "\n";
                    f.writeString( "  " + nameIt );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
        else
        {
            if( f.open( "adv_disapproved\\" + param2 + ".txt", "a" ) >= 0 )
            {
                int    number = 0;
                string line = param3;
                line.resize( line.length() - 1 );
                StrToInt( line, number );
                if( number != 0 )
                {
                    f.writeString( line );
                }
                else
                    f.writeString( param3 );
                f.close();
            }
            return;
        }
    }
    else if( param1 == 8 )
    {
        file f;
        if( param0 == 0 )
        {
            if( f.open( "logs\\crims.txt", "w" ) >= 0 )
            {
                f.writeString( param3 );
                f.close();
                return;
            }
        }
        else if( f.open( "logs\\crims.txt", "a" ) >= 0 )
        {
            f.writeString( param3 );
            f.close();
            return;
        }
    }
}

void _testmode( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __testmode = uint( param0 );
}

void _sinf( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __sinf = uint( param0 );

    updateAllNicks();
}

bool waiting = false;

void _waiting( int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    __waiting = ( ( param0 != 0 ) ? true : false );
    ChangeCursor( ( __waiting ) ? CURSOR_WAIT : CURSOR_DEFAULT );
}

#define EXPBAR_POS_X       ( expbarPosX )
#define EXPBAR_POS_Y       ( expbarPosY )
#define EXPBAR_LINE_END    ( expbarLineEnd )

Sprite expbar,
       expbar_;

uint16 expbarPosX = 0, expbarPosY = 0, expbarLineEnd = 0;

void ExpBarSetPos()
{
    GetIfaceIniPos( "ExpBar", expbarPosX, expbarPosY, expbarLineEnd );

    expbar.Load( "bar1.png", int(PT_ART_INTRFACE) );
    expbar_.Load( "bar1_e.png", int(PT_ART_INTRFACE) );
}

void DrawExpBar()
{
    int[] drawData;

    CritterCl @ choo = GetChosen();
    if( choo is null )
        return;

    uint8  level = choo.StatBase[ ST_LEVEL ];
    uint   levelExp = NUMERICAL_NUMBER( level - 1 ) * 1000;

    uint16 exp = choo.StatBase[ ST_EXPERIENCE ] - levelExp,
           toLevelExp = NUMERICAL_NUMBER( level ) * 1000 - levelExp;

    float  expMod = exp * 100 / ( toLevelExp > 100 ? toLevelExp : 100 );

    uint16 time = choo.StatBase[ ST_EXPERIENCE_MULTIPLIER_TIME ];
    uint8  allTime = ( time ) & 0xFF,
           elapsedTime = ( time >> 8 ) & 0xFF;

    float  timeMod = elapsedTime * 100 / ( allTime > 0 ? allTime : 1 );

    uint16 r0 = 0x15,
           g0 = 0x1F,
           b0 = 0x00,

           r1 = 0x67,
           g1 = 0x60,
           b1 = 0x00;

    uint16 tempY = ( ( EXPBAR_POS_Y - EXPBAR_LINE_END ) * ( allTime > 0 ? timeMod * 0.01 :  expMod * 0.01 ) );

    for( uint16 i = 0; i < tempY; ++i )
    {
        i += 3;

        drawData.insertLast( EXPBAR_POS_X );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 5 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r1, g1, b1 ) );

        drawData.insertLast( EXPBAR_POS_X + 8 );
        drawData.insertLast( EXPBAR_POS_Y - i );
        drawData.insertLast( COLOR_RGB( r0, g0, b0 ) );


    }

    DrawSprite( expbar.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawPrimitive( DRAW_PRIMITIVE_LINELIST, drawData );
    DrawSprite( expbar_.Id, -1, EXPBAR_POS_X - 42, EXPBAR_POS_Y - 210, 0 );
    DrawText( "0" + choo.StatBase[ ST_EXPERIENCE_MULTIPLIER ], EXPBAR_POS_X - 20, EXPBAR_POS_Y + 30, 70, 10, COLOR_RGB( r1, g1, b1 ), FONT_NUM, 0 );
}

void GetIfaceIniPos( string iniKey, uint16& posX, uint16& posY, uint16& lineEnd )
{
    string@ str = GetIfaceIniStr( iniKey );
    if( @str == null || str == "" )
        return;

    string@[] @ valuesStr = splitEx( str, " " );
    if( valuesStr.length() != 3 )
        return;

    int[] values( 3 );
    for( int i = 0; i < 3; i++ )
        if( not StrToInt( valuesStr[ i ], values[ i ] ) )
            return;

    posX = values[ 0 ];
    posY = values[ 1 ];
    lineEnd = values[ 2 ];
}

bool isDKPInit = false;
uint16[] dkp_array;

void DKPInit(){

	if(dkp_array.length() % 2 != 0) Log("dkp_array wring size.");
		else isDKPInit = true;
}

uint16 DKPCheckDrugKey(uint8 key){

	if(!isDKPInit) DKPInit();

	for(uint8 i = 0, j = dkp_array.length(); i < j; i++){
		if(dkp_array[i] == key && i % 2 == 0) return dkp_array[i+1];
	}

return uint16(-1);
}

void ShowPopup( int popup_id, int param1, int param2, string@ default_text, int[] @ param4 ) {
	CritterCl@ chosen = GetChosen();
	if(!valid(chosen)) return;
    ItemCl@ popup = GetItem(popup_id);
	if(!valid(popup)) Message( default_text );
	string lexems(popup.Lexems);
	if( isGM( chosen ) )
		RunServerScriptUnsafe( "main@unsafe_ShowFullPopupInfo", popup_id, 0, 0, lexems, null );
    else
		RunServerScriptUnsafe( "main@unsafe_ShowPopup", popup_id, 0, 0, lexems, null );
}

void __ReInit (int p0, int p1, int p2, string@ p3, int[]@ p4) {
	start ();
	screen_change( true, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0);
	screen_change( false, CLIENT_MAIN_SCREEN_LOGIN, 0, 0, 0);
	render_iface (2);
}

void __Talk(int param0, int param1, int param2, string@ param3, int[]@ param4)
{
	//Message("Sended:\n'" + param3 + "'" );
	
	if( !valid( param3 ) ) return;
	
	string@[]@ parts = split( param3, "::" );
	
	string result = "";
	
	if( !valid( parts ) || parts.length() == 0 )
		result = "Nothing.";
	else
	{
		uint len = parts.length();
		for( uint i = 0; i < len; i++ )
		{
			int PID = 0;
			if( !StrToInt( parts[i], PID ) || PID <= 0 )
				result += parts[i];
			else
				result += GetMsgStr( TEXTMSG_ITEM, PID );
		}
	}
	
	//Message("Processed:\n'" + result + "'" );

	if( param0 == SAY_NETMSG )
		Message( result );
	else
		RunServerScriptUnsafe( "test@unsafe_CritterSay", param0, 0, 0, result, null );

	//Message("Returned.");
}

bool isGM( CritterCl@ cr )
{
	return ( cr.Stat[ ST_ACCESS_LEVEL ] >= ACCESS_MODER && cr.Param[ QST_VISION ] > 0 );
}

void NamesUpdater( int param0, int param1, int param2, string@ param3, int[] @ param4 ) { RunServerScriptUnsafe( "gm@unsafe_sinf", 0, 0, 0, null, null ); }

void updateMapId( int mapID, int, int, string@, int[]@ )
{
	__mapID = mapID;
    #ifndef PHYSICAL_UI
	    iList().checkMap();
    #endif //PHYSICAL_UI
}

//TODO: Сделать нормальные группификаторы в item_groups.fos
uint[] invisible_pids = {
	PID_INVISIBLE_BLOCK, // невидимый блокиратор
	PID_DOOR_BLOCKER, // тех айтем блокиратора двери
	PID_POPUP, //Попапы
	PID_SHADOW, //Тень
	PID_WILDFIRE_1, PID_WILDFIRE_2, PID_WILDFIRE_3, PID_WILDFIRE_4, PID_WILDFIRE_5, //дикий огонь
	PID_SMOKE, PID_STEAM, PID_STILL_STEAM, PID_FURNACE_SMOKE, //дым, пар
	PID_ASHES_1, PID_ASHES_2, PID_ASHES_3, //Пепел
	PID_SHELL_CASING, // гильзы
	//ДЕРЕВЬЯ:
	PID_TREE_GXS1, PID_TREE_GXS2, PID_TREE_GXS3, PID_TREE_DS1, PID_TREE_DS2, PID_TREE_DS3, PID_TREE_DS4, PID_TREE_DS5, PID_TREE_DS6, PID_TREE_DS7, PID_TREE_DS8, PID_TREE_DS9, PID_TREE_DS10, 
	PID_TREE_DS11, PID_TREE_BS1, PID_TREE_BS2, PID_TREE_BS3, PID_TREE_GS1, PID_TREE_GS2, PID_TREE_GS3, PID_TREE_GS4, PID_TREE_GS5, PID_TREE_GS6, PID_TREE_GS7, PID_TREE_GS8, PID_TREE_GS9,
	PID_TREE_GS10, PID_TREE_GS11, PID_TREE_GS12, PID_TREE_GS13, PID_TREE_GS14, PID_TREE_GS15, PID_TREE_GS16, PID_TREE_GS17, PID_TREE_GS18, PID_TREE_GS19, PID_TREE_DM1, PID_TREE_DM2, PID_TREE_GM1,
	PID_TREE_GM2, PID_TREE_GM3, PID_TREE_GM4, PID_TREE_GM5, PID_TREE_GM6, PID_TREE_GM7, PID_TREE_GM8, PID_TREE_GM9, PID_TREE_GM10, PID_TREE_GM11, PID_TREE_GM12, PID_TREE_GM13, PID_TREE_GM14, 
	PID_TREE_GM15, PID_TREE_DL1, PID_TREE_DL2, PID_TREE_DL3, PID_TREE_DL4, PID_TREE_DL5, PID_TREE_DL6, PID_TREE_DL7, PID_TREE_DL8, PID_TREE_DL9, PID_TREE_BL1, PID_TREE_BL2, PID_TREE_GL1, 
	PID_TREE_GL2, PID_TREE_GL3, PID_TREE_GL4, PID_TREE_GL5, PID_TREE_GL6, PID_TREE_GL7, PID_TREE_GL8, PID_TREE_GXXL1, PID_TREE_GXXL2, PID_TREE_CS1, PID_TREE_CS2, PID_TREE_CS3, PID_TREE_CL1, 
	PID_TREE_CL2, PID_TREE_CL3, PID_TREE_CL4, PID_TREE_CL5, PID_TREE_GL2S,
	//КУСТЫ
	PID_BUSH_GREEN_01, PID_BUSH_GREEN_02, PID_BUSH_GREEN_03, PID_BUSH_01, PID_BUSH_02, PID_BUSH_03, PID_BUSH_04, PID_BUSH_05, PID_BUSH_06, PID_BUSH_07, PID_BUSH_08,
	//АКТИВИРОВАННЫЕ ЛОВУШКИ
	PID_ACTIVE_MINE, PID_IMPOVISED_TRAP_ACTIVE, PID_IMPOVISED_TRAP_PLASMA_ACTIVE, PID_IMPOVISED_TRAP_PULSE_ACTIVE, PID_ACTIVE_MINE_PLASMA, PID_ACTIVE_MINE_PULSE, PID_TRAP_ACTIVE,
	//МАСКИРОВКА ДЛЯ ЛОВУШЕК
	PID_CAMO_01, PID_CAMO_02, PID_CAMO_03, PID_CAMO_04, PID_CAMO_05,PID_CAMO_06, PID_CAMO_07, PID_CAMO_08, PID_CAMO_09, PID_CAMO_10, PID_CAMO_11, PID_CAMO_12, PID_CAMO_13, PID_CAMO_14, PID_CAMO_15, 
	PID_CAMO_16, PID_CAMO_17, PID_CAMO_18, PID_CAMO_19,
	//Прослушки (оба имени пида #57, просто как пример) и прочие нычки
	PID_MICROPHONE, PID_ELECTRONIC_BUG,
	//Мешки с песком
	PID_SINGLE_SANDBAG, PID_DOUBLE_SANDBAG, PID_TRIPLE_SANDBAG, PID_QUADRO_SANDBAG, PID_QUINTO_SANDBAG, PID_SANDBAG_EMPTY, // Пустой мешок с песком
	//Динамическое освещение
	PID_SWITCH1_DIR2, PID_SWITCH1_DIR3, PID_SWITCH2_DIR2, PID_SWITCH2_DIR3, PID_SWITCH3_DIR2, PID_SWITCH3_DIR3, PID_LIGHT_SOURCE,
	//Эффекты
	PID_TARGET_BLOOD, PID_TARGET_SPARKS_HEAD0, PID_TARGET_SPARKS_HEAD1, PID_TARGET_SPARKS_HEAD2, PID_TARGET_SPARKS_CENTER0, PID_TARGET_SPARKS_CENTER1, PID_TARGET_SPARKS_CENTER2, 
	PID_TARGET_SPARKS_CENTER3, PID_TARGET_SPARKS_CENTER4, PID_TARGET_SPARKS_CENTER5, PID_TARGET_SPARKS_LEFT0, PID_TARGET_SPARKS_LEFT1, PID_TARGET_SPARKS_LEFT2, PID_TARGET_SPARKS_LEFT3, 
	PID_TARGET_SPARKS_LEFT4, PID_TARGET_SPARKS_LEFT5, PID_TARGET_SPARKS_RIGHT0, PID_TARGET_SPARKS_RIGHT1, PID_TARGET_SPARKS_RIGHT2, PID_TARGET_SPARKS_RIGHT3, PID_TARGET_SPARKS_RIGHT4,
	PID_TARGET_SPARKS_RIGHT5, PID_TARGET_SPARKS_SHOULDERS0, PID_TARGET_SPARKS_SHOULDERS1, PID_TARGET_SPARKS_SHOULDERS2, PID_TARGET_SPARKS_SHOULDERS3, PID_TARGET_SPARKS_SHOULDERS4, 
	PID_TARGET_SPARKS_SHOULDERS5, PID_TARGET_BLOOD_DARK, PID_TARGET_BLOOD_NORM, PID_TARGET_BLOODSTREAM_NORM
};


#define SHOW_PLAYER_INFO_DELAY	400
int last_player_info_tick = 0;
uint[][] IDs;
void show_player_info()
{
    #ifndef PHYSICAL_UI
	    if( GetTick() - last_player_info_tick < SHOW_PLAYER_INFO_DELAY * 0.95 ) return;
	    int delta = GetTick() - last_player_info_tick;
	    last_player_info_tick = GetTick();
    #endif //!PHYSICAL_UI
    #ifdef PHYSICAL_UI
        if(!PhysicalUI_StartFrame()) return;
        physical_selected_type = 0;
        physical_selected_id = 0;
    #endif //PHYSICAL_UI
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) ) return;
	bool is_gm = isGM( cr );

    Color@ line_color = NewColor( 0xe3, 0xad, 0x4f );
    Color@ select_color = NewColor( 0xa3, 0xed, 0x4f );
	
	if( FLAG( cr.Param[MIO_FLAGS], MIO_FLAG_SHOW_ITEMS ) )
	{
        #ifndef PHYSICAL_UI
            if( iList().updated() )
                IDs = iList().getIDs();
            
            string text;
            ItemCl@ item, stack;
            for( uint i = 0, l = IDs.length(); i < l; i++ )
            {
                if( IDs[i].length() == 0 || IDs[i][0] == 0 )
                    continue;
                
                @item = GetItem( IDs[i][0] );
                if( !valid( item ) || GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 )
                    continue;//TODO: PERCEPTION CHECK
                
                text = "";
                for( uint j = 0, k = IDs[i].length(); j < k; j++ )
                {
                    if( IDs[i][j] == 0 ) continue;
                    @stack = GetItem( IDs[i][j] );
                    
                    if( !valid( stack ) || ( !is_gm && invisible_pids.find( stack.GetProtoId() ) != -1 ) )
                        continue;

                    text += GUI_itemInfo( stack );
                }
                
                if( text.length() > 0 )
                    MapMessage( text, item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
                    //DrawTextAboveHex( text, item.HexX, item.HexY, NewColor( 255, 255, 255 ), true );	
            }
        #endif //!PHYSICAL_UI
        #ifdef PHYSICAL_UI
            ItemCl@[] items;
            uint len = GetAllItems(@items);
            for( uint i = 0; i < len; i++ ) {
                ItemCl@ item = items[i];
                if( GetDistantion( cr.HexX, cr.HexY, item.HexX, item.HexY ) > 16 || ( !is_gm && invisible_pids.find( item.GetProtoId() ) != -1 ) ) {
                    continue;
                }
                string@ text = GUI_itemInfo( item );
                if( text.length() > 0 ) {
                    //MapMessage( text, item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
                    PhysicalDrawTextAboveHex( text, item.HexX, item.HexY, line_color, 1, item.Id, 0, is_gm, is_gm );
                }
            }
        #endif //PHYSICAL_UI
	}
	
	if( FLAG( cr.Param[MIO_FLAGS], MIO_FLAG_SHOW_HINTS ) )
	{
        ItemCl@ item = null;
        #ifdef PHYSICAL_UI
            @item = PhysicalSelectItem(1);
        #endif //PHYSICAL_UI

        if(item is null) {
		    @item = GetMonitorItem( __MouseX, __MouseY );
        }
		
		if( valid( item ) ) {
            #ifndef PHYSICAL_UI
		        MapMessage( GUI_itemHelp( item ), item.HexX, item.HexY, SHOW_PLAYER_INFO_DELAY, 0xFFFFFFFF, false, 0, 0 );
            #endif //!PHYSICAL_UI
            #ifdef PHYSICAL_UI
		        PhysicalDrawTextAboveHex( GUI_itemHelp( item ), item.HexX, item.HexY, select_color, 1, item.Id, 0, true, true );
            #endif //PHYSICAL_UI
        }
	}

    #ifdef PHYSICAL_UI
        PhysicalUI_EndFrame();
    #endif //PHYSICAL_UI
}

void showF1()
{
	if( __ShowF1Help && !__f4Pressed && GUI_GetActiveScreen() == CLIENT_MAIN_SCREEN_GAME )
	{
		TabPic.Draw( 320, 10 );
		DrawText( "Название: 100%", 320, 10, TabPic.Width, TabPic.Height, COLOR_RGB( 125, 125, 125 ), FONT_FALLOUT, FT_CENTERXY );
		F1_tabs.Draw( 300, 30  );

		F1_text.Draw( ( __ScreenWidth - F1_text.Width ) / 2, ( __ScreenHeight - F1_text.Height ) / 2 );

		F1_arrows.Draw( __ScreenWidth / 2 - 150, __ScreenHeight - 165 );
		
		//For debugging:
		//DrawText( "[" + __MouseX + ", " + __MouseY + " ]", __MouseX, __MouseY, 100, 100, COLOR_RGB( 255, 255, 255 ), FONT_FALLOUT, FT_CENTERXY );
	}
}

string GUI_itemHelp( ItemCl@ item )
{
	if( !valid( item ) ) return "[null]";
	
	string result = GUI_itemInfo( item );
	
	switch( item.GetProtoId() )
	{//TODO: Более удобное и полное отображение инфрмации + колорайзинг сущностей в тексте (подсветка разных типов данных).
		case(7900): result += "\n"
					"|0xffffff " + "Закиньте в бочку горючих материалов:" + "\n" +
					"|0x78E354 " + "Дрова, хворост, палки, доски." + "\n" +
					"|0xffffff " + "И подожгите кремнем или зажигалкой." + "\n" +
					"|0x4ce0d2 " + "[Осторожней с патронами и взрывчаткой!]" + "\n" +
					"";
	}
	
	return result;
}

string GUI_itemInfo( uint id ) { return( GUI_itemInfo( GetItem( id ) ) ); }
string GUI_itemInfo( ItemCl@ item )
{
	if( !valid( item ) ) 
	{
		return "[null]";
	}

	string@ info = itemText( item ); //GetMsgStr( TEXTMSG_ITEM, STR_ITEM_INFO( item ) );
	string text = ( valid( info ) ? "|0xe3ad4f " + info + "\n" : "" );
	
	//Пример обхода текста из Фообж
	/*switch( item.GetProtoId() ) 
	{
		case( 8735 ):
		case( 8736 ):
		case( 8737 ):
		case( 8738 ):
		case( 8739 ):
			text = "Пламя";
	}*/
		
	if( item.Val9 != PID_POPUP && item.GetProtoId() != PID_POPUP )
	{
		text += ( valid( item.Lexems ) && item.Lexems.length() > 1 ? "'" + item.Lexems + "'\n" : "" );
	}
	
	CritterCl@ cr = GetChosen();
	if( !valid( cr ) ) 
	{
		return "[!cr]";
	}
	
	if( isGM( cr ) )
	{
		text += ( "|0xffffff " + "#" + "|0x78E354 " + item.Id + "|0xffffff " + " PID: " + "|0x78E354 " + item.GetProtoId() + "|0xffffff " + "\n" ) +
		"";//Сюда можно построчно компоновать что вздумается. Позже сделаю класс или иной конструктор многострочных выражений.
	
		uint[] vals = { item.Val0, item.Val1, item.Val2, item.Val3, item.Val4, item.Val5, item.Val6, item.Val7, item.Val8, item.Val9 };
		
		for( uint i = 0, l = vals.length(); i < l; i++ )
		{
			text += ( vals[i] != 0 ? "|0xffffff " + "VAL#" + "|0x4ce0d2 " + i + "|0xffffff " + ": " + "|0x78E354 " + vals[i] + "\n" : "" );
		}
	}
	
	return text;
}

void SetItemWeight( int itemId, int weight, int param2, string@ param3, int[]@ param4 )
{
	chosenContainerItems.set( ""+itemId, weight );
}

void __HearWhisper( int x, int y, int, string@ text, int[] @ )
{
	string@[] @ valuesStr = splitEx( text, "@" );
    if( valuesStr.length() != 2 )
	{
		return;
	}
	
    MapMessage( ".." + valuesStr[1] + "..", x, y, __DamageHitDelay, 0x0000FFFF, true, 0, 0 );
    Message( valuesStr[0] + ": |0x0000FFFF .." + valuesStr[1] + ".." );
}

//script calls
void __message_result( int Pid, int amount, int param2, string@ param3, int[]@ param4 )
{
	string inform = GetMsgStr( TEXTMSG_TEXT, STR_YOU_GATHERED ) += "\n -" + "|0xFFFF00  ";
	inform += GetMsgStr( TEXTMSG_ITEM, Pid * 100 );
	inform += "|0x3CF800  - " + "|0xFFFF00 " + amount + GetMsgStr( TEXTMSG_TEXT, STR_UNITS );
	Message( inform );
}

void __message_scavenging_result( int param0, int param1, int param2, string@ param3, int[]@ loot )
{
	string inform = GetMsgStr( TEXTMSG_TEXT, STR_YOU_GATHERED ) += "\n";
	for( uint i = 0; i < loot.length(); i++ )
	{
		uint16 lootPid = loot[ i ];
		inform += "|0x3CF800  - " + "|0xFFFF00 " + GetMsgStr( TEXTMSG_ITEM, lootPid * 100 ) + "|0x3CF800  -" + "|0xFFFF00  1" + "|0xFFFF00 ;\n";
	}
	inform[ inform.length() - 2 ] = '.';
	inform[ inform.length() - 1 ] = ' ';
	Message( inform );
}

void __message_raise_skill( int amount, int skillNum, int param2, string@ param3, int[]@ param4 )
{
	string inform;
	if( amount > 0 )
	{
		inform = GetMsgStr( TEXTMSG_TEXT, STR_SKILL_RAISED ) + "|0xFFFF00 " + GetMsgStr( TEXTMSG_GAME, skillNum * 10 + 100001 ) + GetMsgStr( TEXTMSG_TEXT, STR_SKILL_RAISED_BY ) + "|0xFFFF00 " + amount + "|0x3CF800 .";
	}
	else
	{
		inform = GetMsgStr( TEXTMSG_TEXT, STR_FAILED_TO_RAISE_SKILL );
	}
	Message( inform );
}

string genderEnding( CritterMutual& cr )
{
	switch( cr.Stat[ ST_GENDER ] )
	{
		case( 0 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_MALE_ENDING );
		case( 1 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_FEMALE_ENDING );
		case( 2 ): 
			return GetMsgStr( TEXTMSG_GAME, STR_GENDER_IT_ENDING );
	}
	return "";
}