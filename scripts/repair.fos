#ifndef REPAIR
#define REPAIR

#include "_utils.fos"
#include "repair_h.fos"
#include "_ltp.fos"
#include "gathering_h.fos"
#include "critter_skills_h.fos"
#include "handcuffs_h.fos"
#include "explode_h.fos"
#include "craft_recipes.fosh"
#include "decraft.fosh"

dictionary RepairHardList;

void InitRepairList()
{
	ItemPartArray@ Repair;

	@Repair = ItemPartArray();	
	Repair.Add( PID_FLINT, 1 );
	RepairHardList.set( "" + PID_KNIFE, Repair );

	@Repair = ItemPartArray();
	Repair.Add( PID_JUNK, 1 );
	RepairHardList.set( "" + PID_BRASS_KNUCKLES, Repair );
}

ItemPartArray@ GetRepairParts(uint16 pid)
{
	ItemPartArray@ Repair;
	if( RepairHardList.get(""+pid, @Repair) )
	{
		return Repair;
	}

	ProtoItem@ ItemProto = GetProtoItem(pid);

	if(valid(ItemProto) && ( ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_KNIFE || 
							ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_LONG_KNIFE ||
							ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_SPEAR ||
							ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_GRENADE_KIFE ) )
	{
		if( RepairHardList.get(""+PID_KNIFE, @Repair) )
		{
			return Repair;
		}
	}
	
	if(valid(ItemProto) && ( ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_HAMMER || 
							ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_GLOVE ||
							ItemProto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_CLUB ) )
	{
		if( RepairHardList.get(""+PID_BRASS_KNUCKLES, @Repair) )
		{
			return Repair;
		}
	}
	
	
	return GetItemParts(pid);
}

void ShowRepairInfo( Critter& cr, Item& item )
{
	if( !valid( item ) || !valid (cr ) )
	{
		return;
	}

	ItemPartArray@ Repair = GetRepairParts( item.GetProtoId() );
	if( !valid( Repair ) )
	{
		return;
	}

	ShowRepairInfo( cr, Repair, item );
}

void ShowRepairInfo( Critter& cr, ItemPartArray@ Repair, Item& item )
{
	if(!valid(cr) || !valid(Repair)) return;

	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, ( FLAG(Repair.Tools, TOOL_MULTITOOL) ? STR_NEED_HOLD_TOOL_AND_MULTITOOL : STR_NEED_HOLD_TOOL ) );
	for( int i = 0; i < 32; i ++ )
	{
		if( i == 2 ) // TOOL_MULTITOOL
		{
			continue;
		}
		if( ISBIT( Repair.Tools, i ) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_HOLD_TOOL_PID, "$proto@msg item " + ( ProtoToolPids[i] * 100 ) + "@" );
		}
	}

	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_PARTS );
	for( uint i = 0, len = Repair.length(); i < len; i++ )
	{
		uint count = Repair[i].Count;
		if( !FLAG( item.BrokenFlags, BI_BROKEN ) )
			count = uint(Repair[i].Count / 100.0f * GetDeteriorationProcent( item ));
		count = MAX(count, 1);
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_PARTS_PID, "$proto@msg item " + ( Repair[i].Pid * 100 ) + "@$amount" + count );
	}
}

bool TryRepairItem( Critter& cr, Item& item )
{
    if( !item.IsDeteriorable() && item.Proto.Item_Subtype != ITEM_SUBTYPE_BONDAGE )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_ITEM_UNBREAKABLE );
        return true;
	}

    if( cr.Timeout[ TO_SK_REPAIR ] > 0 )
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
        return true;
    }

    if( FLAG( item.BrokenFlags, BI_ETERNAL ) || FLAG( item.BrokenFlags, BI_NOTRESC ) || GetDeteriorationProcent( item ) >= 100 )
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_NO_RESC );
        return true;
    }
	
	if( IsTired( cr ) )
	{
		return false;
	}
	
	if( cr.IsInjured() )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_TO_REPAIR );
		return false; 
	}
	
	if( HandsTied( cr ) )
	{
		return false;
	}
	
    // Repair
    int repair = cr.Skill[ SK_REPAIR ];
    uint8 mode = 0;

    // Parts for weapons and armour
    uint16 Pid = item.GetProtoId();
	int type = item.GetType();
	uint8 Item_Subtype = item.Proto.Item_Subtype;
	bool isNonReparable = item.BrokenCount > MAX_BROKENS;
	bool hasAmmo = ( item.Proto.Weapon_MaxAmmoCount != 0 );
	ItemPartArray@ RepairParts = GetRepairParts(Pid);

	if( !valid(RepairParts) || isNonReparable )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_ITEM_CANT_FIX );
		return true;
	}

	uint firstTool = FindFirstTool(RepairParts.Tools);
	bool isMultitool = FLAG(RepairParts.Tools, TOOL_MULTITOOL) ? HasTool(cr, 2) : true;
	bool isNeedRepair = GetDeteriorationProcent( item ) > 0;

	if ( !HasTool(cr, firstTool) || !isMultitool || !isNeedRepair )
	{
		ShowRepairInfo(cr, RepairParts, item);
		return true;
	}

	for( uint i = 0, len = RepairParts.length(); i < len; i++ )
	{
		ItemPart@ currPart = RepairParts[i];
		if(!valid(currPart)) continue;

		uint count = currPart.Count;
		if( !FLAG( item.BrokenFlags, BI_BROKEN ) )
			count = uint(currPart.Count / 100.0f * GetDeteriorationProcent( item ));
		count = MAX(count, 1);

		if( cr.CountItem( currPart.Pid ) < count )
		{
			ShowRepairInfo(cr, RepairParts, item);
			return true;
		}
	}

	start_repair( cr, item );

    return true;
}

bool ltp_repair_inited = false;
void ltp_repair_init()
{
	LTPREG( LTP_REPAIR, process_repair )
	ltp_repair_inited = true;
}

bool start_repair( Critter& cr, Item& item )
{
	if( !ltp_repair_inited )
	{
		ltp_repair_init();
	}
	
	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	int repair_rate = ( cr.Skill[ SK_REPAIR ] ) + ( cr.Stat[ST_AGILITY] * 10 ) + ( cr.Stat[ST_INTELLECT] * 10 ) + OBJECT_DPA_BASE; 
	cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ceil( float( ( item.Deterioration ) / ( CLAMP( repair_rate, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) ) );
	
	uint[] values = { cr.Id };
	CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_RepairSound", values, true);
	CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);
	
	_CritAnimateUse( cr );
	
	StartProcess( cr, LTP_REPAIR, 0, item.Id, 0, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
	return true;
}

uint process_repair( Critter@ cr, int& param0, int& param1, int& param2 )
{
	LTPROCESS( cr, param0, LTP_REPAIR )
  	
	Item@ item = GetItem( param1 );
	
	if( valid( item ) )
    {
		param0++;

		if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
		{
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_FINISH_REPAIR );
			RepairResult( cr, item );
			
			if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
			{
				uint ammoCount = item.AmmoCount;
				if( ammoCount > 0 )
				{
					int skillNum = SK_REPAIR;
					Accident( cr, skillNum ); 
				}
			}
			return 0;
		}
		
		uint[] values = { cr.Id };
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_RepairSound", values, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);
		
		_CritAnimateUse( cr );
		
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}
	return 0;
}

void HandcuffsRepairResult(Critter& cr, Item& item)
{
	item.BONDAGE_STATE = BONDAGE_STATE_OFF;
	uint16 pid = item.GetProtoId();
	switch( pid )
	{
		case( PID_HANDCUFFS ):
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_HANDCUFFS_REPAIRED );
			item.PicInv = GetStrHash( null );
			break;
		case( PID_SHACKLES ):
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SHACKLES_REPAIRED );
			item.PicInv = GetStrHash( null );
			break;
		default:
			break;
	}

	item.Update();
}

void BrokenRepairResult(Critter& cr, Item& item)
{
	if(!valid(cr) || !valid(item))
		return;

	uint16 Pid = item.GetProtoId();
	ItemPartArray@ RepairParts = GetRepairParts(Pid);

	if( !valid(RepairParts) )
		return;

	if( FLAG( item.BrokenFlags, BI_HIGHBROKEN ) )
	{
		
	}
	else if( FLAG( item.BrokenFlags, BI_NORMBROKEN ) )
	{
		
	}
	else if( FLAG( item.BrokenFlags, BI_LOWBROKEN ) )
	{
		
	}
	
	int maxSkill = RepairParts.Tier * RepairParts.Tier * REPAIR_SK_MUL + REPAIR_SK_MOD;    
	int successRoll = Random( 1, maxSkill );

	if(cr.Param[SK_REPAIR] < successRoll)
	{
		bool IsDeletedAnything = false;
		uint16 resPid = 0;
		uint resCount = 0;
		while(!IsDeletedAnything)
		{
			uint partIndex = Random(0, RepairParts.length());
			ItemPart@ PartToDelete = RepairParts[partIndex];
			if(!valid(PartToDelete) || cr.CountItem(PartToDelete.Pid) < PartToDelete.Count)
				continue;

			cr.DeleteItem(PartToDelete.Pid, PartToDelete.Count);
			resPid = PartToDelete.Pid;
			resCount = PartToDelete.Count;
			IsDeletedAnything = true;
		}
		
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_REPAIR_FAIL );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_LOST, "$proto@msg item " + ( resPid * 100 ) + "@" + "$count" + resCount);
	}
	else
	{
		item.Deterioration = 0;
		UNSETFLAG( item.BrokenFlags, BI_BROKEN );

		item.BrokenCount++;
		if( item.BrokenCount >= MAX_BROKENS )
			SETFLAG( item.BrokenFlags, BI_NOTRESC );

		for(uint i = 0, len = RepairParts.length(); i < len; i++)
		{
			ItemPart@ PartToDelete = RepairParts[i];
			if(!valid(PartToDelete) || cr.CountItem(PartToDelete.Pid) < PartToDelete.Count)
				continue;

			cr.DeleteItem(PartToDelete.Pid, PartToDelete.Count);
		}

		cr.StatBase[ ST_EXPERIENCE ] += 40;
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_REPAIR_SUCC );
	}

	item.Update();
}

void ServiceRepairResult(Critter& cr, Item& item)
{
	if(!valid(cr) || !valid(item))
		return;

	uint16 Pid = item.GetProtoId();
	ItemPartArray@ RepairParts = GetRepairParts(Pid);

	if( !valid(RepairParts) )
		return;

	if( FLAG( item.BrokenFlags, BI_SERVICE ) )
	{

	}
	
	int maxSkill = RepairParts.Tier * RepairParts.Tier * REPAIR_SK_MUL + REPAIR_SK_MOD;    
	int successRoll = Random( 1, maxSkill );

	if(cr.Param[SK_REPAIR] < successRoll)
	{
		bool IsDeletedAnything = false;
		uint16 resPid = 0;
		uint resCount = 0;
		while(!IsDeletedAnything)
		{
			uint partIndex = Random(0, RepairParts.length());
			ItemPart@ PartToDelete = RepairParts[partIndex];
			if(!valid(PartToDelete) || cr.CountItem(PartToDelete.Pid) < PartToDelete.Count)
				continue;

			cr.DeleteItem(PartToDelete.Pid, PartToDelete.Count);
			resPid = PartToDelete.Pid;
			resCount = PartToDelete.Count;
			IsDeletedAnything = true;
		}
		
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_REPAIR_FAIL );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_LOST, "$proto@msg item " + ( resPid * 100 ) + "@" + "$count" + resCount);
	}
	else
	{
		SETFLAG( item.BrokenFlags, BI_SERVICE );
		UNSETFLAG( item.BrokenFlags, BI_BROKEN );

		item.BrokenCount++;
		if( item.BrokenCount >= MAX_BROKENS )
			SETFLAG( item.BrokenFlags, BI_NOTRESC );

		for(uint i = 0, len = RepairParts.length(); i < len; i++)
		{
			ItemPart@ PartToDelete = RepairParts[i];
			if(!valid(PartToDelete) || cr.CountItem(PartToDelete.Pid) < PartToDelete.Count)
				continue;

			uint count = PartToDelete.Count / 100 * item.Deterioration;
			cr.DeleteItem(PartToDelete.Pid, count);
		}

		item.Deterioration = 0;
		cr.StatBase[ ST_EXPERIENCE ] += 20;
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_REPAIR_SUCC );
	}

	item.Update();
}

void RepairResult( Critter& cr, Item& item )
{
	if( item.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE && item.BONDAGE_STATE == BONDAGE_STATE_BROKEN )
	{
		HandcuffsRepairResult(cr, item);
		return;
	}
	else if( FLAG( item.BrokenFlags, BI_BROKEN ) )
	{
        BrokenRepairResult(cr, item);
		return;
    }
	else
	{
		ServiceRepairResult(cr, item);
		return;
    }
}

void SetMaxDeteriorPics( Item& item )
{
	for( uint w = 0, wLen = picWear.length(); w < wLen; w += 2 )
	{
		if( "" + item.Proto.ProtoId == picWear[w] )
		{
			string base = picWear[ w + 1 ];
							
			if( base.length() > 0 )
			{
				item.PicMap = GetStrHash( "art\\items\\broken_armor\\ground_"+base+"_broken.png" );
				item.PicInv = GetStrHash( "art\\inven\\broken_armor\\"+base+"_broken.png" );
			}

			break;
		}
	}
}

void DeteriorateItem( Critter& cr, Item& item, int deteriorationCount )
{
    if( deteriorationCount <= 0 || !item.IsDeteriorable() || FLAG( item.BrokenFlags, BI_ETERNAL ) || FLAG( item.BrokenFlags, BI_BROKEN ) )
	{
		return;
	}
	
	if( item.GetType() == ITEM_TYPE_ARMOR )
	{
		if( FLAG( item.Proto.Armor_Perk, ARMOR_PERK_FRAGILE ) )
		{
			deteriorationCount = int ( deteriorationCount * ARMOR_PERK_FRAGILE_MALUS / 100 );
		}
		
		if( FLAG( item.Proto.Armor_Perk, ARMOR_PERK_DURABLE ) )
		{
			if( deteriorationCount <= ARMOR_PERK_DURABLE_TRESHOLD )
			{
				deteriorationCount = 0;
			}
		}
	}

    item.Deterioration += deteriorationCount;

    if( item.Deterioration >= MAX_DETERIORATION )
	{
        item.Deterioration = MAX_DETERIORATION;
		SetMaxDeteriorPics( item );
		
		if( item.Proto.Type == ITEM_TYPE_WEAPON )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DETERIORATION_WEAPON_BROKEN );
		}
		else if( item.Proto.Type == ITEM_TYPE_ARMOR )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ARMOR_IS_BROKEN );
		}
	}
	
	item.Update();
}

void SetDeterioration( Item& item, int deteriorationProcent )
{
    if( !item.IsDeteriorable() ) 
	{
		return;
	}
	
    UNSETFLAG( item.BrokenFlags, BI_BROKEN );
    deteriorationProcent = CLAMP( deteriorationProcent, 0, 100 );
    item.Deterioration = MAX_DETERIORATION * deteriorationProcent / 100;
    
	if( deteriorationProcent == 100 )
	{
		SetMaxDeteriorPics( item );
        SETFLAG( item.BrokenFlags, BI_BROKEN );
	}
	
    item.Update();
}

int GetDeteriorationProcent( Item& item )
{
    if( !item.IsDeteriorable() )
	{
		return 0;
	}
	
    if( FLAG( item.BrokenFlags, BI_BROKEN ) )
	{
		return 100;
	}
	
    int value = item.Deterioration * 100 / MAX_DETERIORATION;
    return CLAMP( value, 0, 100 );
}


class MenuAskAction: CenteredMenuHandler
{
    uint item_id;
    uint map_id;
	
    MenuAskAction( Item& item, Map& map )
	{
        item_id = item.Id;
        map_id = map.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
        Item@ item = GetItem( item_id );
		int type = item.GetType();
		uint8 subtype = item.Proto.Item_Subtype;
		uint16 pid = item.GetProtoId();
		
        if( !valid( map ) || !valid( item ) )
		{
            return false;
        }
		
		if( subtype == ITEM_SUBTYPE_BONDAGE && item.BONDAGE_STATE == BONDAGE_STATE_BROKEN && menu.ButtonMsg( STR_REPAIR_MENU_REPAIR ) )
		{
			TryRepairItem( cr, item );
			return false;
		}
		else if( item.IsDeteriorable() && menu.ButtonMsg( STR_REPAIR_MENU_REPAIR ) )
		{
			TryRepairItem( cr, item );
			return false;
		}

		if( item.IsDeteriorable() && menu.ButtonMsg( STR_REPAIR_MENU_REPAIR_INFO ) )
		{
			ShowRepairInfo( cr, item );
			return false;
		}
		
		if( ( pid == PID_REMOTE_DETONATOR || pid == PID_GM_REMOTE_DETONATOR || pid == PID_TNT_PACK_ACTIVE || pid == PID_SLAVE_COLLAR_SWITCH || ( pid == PID_SLAVE_COLLAR && item.BONDAGE_STATE == BONDAGE_STATE_OFF ) ) && menu.ButtonMsg( STR_REPAIR_MENU_SET_FREQUENCY ) )
		{
			int[] data = {0};
			cr.RunClientScript( "client_screen_numberpad@ShowScreen", item.Id, 0, 0, "Input radio frequency", data );
			return false;
		}
		
		if( menu.ButtonMsg( STR_REPAIR_MENU_DISMANTLE ) )
		{
			if( pid == PID_ACTIVE_DYNAMITE || pid == PID_TNT_PACK_ACTIVE )
			{
				Explode( item );
				return false;
			}
			TryDisassembleItem( cr, item );
			return false;
		}

		if( menu.ButtonMsg( STR_REPAIR_MENU_DISMANTLE_INFO ) )
		{
			ShowDecraftInfo( cr, item );
			return false;
		}
			
		if(	type == ITEM_TYPE_ARMOR )
		{
			if( ( subtype >= ITEM_SUBTYPE_ARMOR_AC20 && subtype <= ITEM_SUBTYPE_ARMOR_AC50 ) && menu.ButtonMsg( STR_REPAIR_MENU_INSTALL_RADIO ) )
			{
				InstallRadio( cr, item );
				return false;
			}
			
			if( hasItem( cr, PID_COLORS ) )
			{
				if( menu.ButtonMsg( STR_REPAIR_MENU_PAINT_ARMOUR ) )
				{
					Item@ paint = getItem( cr, PID_COLORS );
					TryPaintArmor( cr, paint, item );
					return false;
				}
			}
		}
		
		Item@ belt = _CritGetItemMisc( cr );
		if( valid( belt ) && belt.GetProtoId() == PID_AMMO_BELT )
		{	
			if( type == ITEM_TYPE_WEAPON
			  && ( subtype == ITEM_SUBTYPE_WEAPON_MELEE_SPEAR )
			  || ( subtype >= ITEM_SUBTYPE_WEAPON_GRENADE_BEGIN && subtype <= ITEM_SUBTYPE_WEAPON_GRENADE_END )
			  && !item.IsStackable() && menu.ButtonMsg( STR_REPAIR_MENU_STOW_WEAPONS ) )
			{
				uint itemsVolume = 0;
				Item@[] stuff;
				belt.GetItems( 0, stuff );
				for( uint i = 0; i < stuff.length(); i ++ )
				{
					itemsVolume += stuff[i].Proto.Volume * stuff[i].GetCount();
				}
				
				uint freeVolume = belt.Proto.Container_Volume - itemsVolume;
				float count = freeVolume / item.Proto.Volume;
				
				Item@[] inventoryItms;
				cr.GetItems( SLOT_INV, inventoryItms );

				Item@[] thrown;
				for( uint i = 0; i < inventoryItms.length(); i ++ )
				{
					if( inventoryItms[i].GetProtoId() == pid )
					{
						thrown.insertLast( inventoryItms[i] );
					}
				}
				
				uint itemCount = thrown.length(); 
				Item@ moved = null;
				
				if( count <= 0 )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BELT_NOT_ENOUGH_SPACE );
				}
				else if( uint( count ) >= itemCount )
				{
					for( uint i = 0; i < itemCount; i ++ )
					{
						@ moved = thrown[i];
						if( valid( moved ) )
						{
							MoveItem( moved, 1, belt, 0 );
						}
					}
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BELT_STOWED_WEAPONS, "$count" + itemCount );
				}
				else
				{
					for( uint i = 0; i < uint( count ); i ++ )
					{
						@ moved = thrown[i];
						if( valid( moved ) )
						{
							MoveItem( moved, 1, belt, 0 );
						}
					}
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_BELT_STOWED_WEAPONS, "$count" + count );
				}
				return false;
			}
		}
		return true;
    }
		
	int getDescriptionFile()
    {
    	return TEXTMSG_TEXT;
    }

	int getDescriptionLine()
	{
		return STR_REPAIR_MENU_MAIN;
	}
	
	string@ Description( Critter& cr )
	{
		Item@ item = GetItem( item_id );
		
		uint broken = 0;
		uint deterioration = 0;
		uint serviceRepair = 0;
		uint serviceExtRepair = 0;
		string deteriorationRepair = "";
		if( item.IsDeteriorable() )
		{
			if( FLAG( item.BrokenFlags, BI_NOTRESC ) )
			{
				deterioration = STR_DETERIORATION_NO_RESC;				
			}
			else if( FLAG( item.BrokenFlags, BI_LOWBROKEN ) )
			{
				deterioration = STR_DETERIORATION_BROKEN_LOW ;				
			}
			else if( FLAG( item.BrokenFlags, BI_NORMBROKEN ) )
			{
				deterioration = STR_DETERIORATION_BROKEN_NORM;				
			}
			else if( FLAG( item.BrokenFlags, BI_HIGHBROKEN ) )
			{
				deterioration = STR_DETERIORATION_BROKEN_HIGH;			
			}
			else
			{
				deteriorationRepair = STR_INSERT_TEXT_LINE( STR_REPAIR_MENU_COMMON_DET ) 
									+ "$commonDeterioration" + (item.Deterioration * 100 / MAX_DETERIORATION) ;
			}
			
			if( FLAG( item.BrokenFlags, BI_SERVICE ) )
			{
				serviceRepair = STR_DETERIORATION_SERVICE;
			}

			if( FLAG( item.BrokenFlags, BI_SERVICE_EXT ) )
			{
				serviceExtRepair = STR_DETERIORATION_SERVICE_EXT;
			}

			broken = item.BrokenCount;
		}
		
		if( deterioration != 0 ) deteriorationRepair = STR_INSERT_GAME_LINE( deterioration );

		string service = "$service";
		if( serviceRepair != 0 )
			service += STR_INSERT_TEXT_LINE( STR_REPAIR_MENU_SERVICE_STATE )
					+  "$serviceState" + STR_INSERT_GAME_LINE( serviceRepair );
					
		string serviceExt = "$serviceExt";
		if( serviceRepair != 0 )
			serviceExt += STR_INSERT_TEXT_LINE( STR_REPAIR_MENU_SERVICE_STATE_EXT )
					   +  "$serviceExtState" + STR_INSERT_GAME_LINE( serviceExtRepair );

		string result = "$itemRepair" + STR_INSERT_ITEM_LINE( item.GetProtoId() * 100 )
		 	   + "$deteriorationRepair" + deteriorationRepair
			   + service
			   + serviceExt
			   + "$brokenRepair" + broken;

		return result;
    }
}

void StartMenuAskAction( Critter& cr, Item& item )
{
    Map@ map = cr.GetMap();
    if( !valid(map) )
	{
        return;
    }

    iMenuHandler@ handler = MenuAskAction( item, map );
    iDialogBox@ menu = OpenMenu( cr, "Action menu", handler );
}

//Armor radio installation	
bool InstallRadio( Critter& cr, Item& armor )
{
	if( FLAG( armor.Flags, ITEM_RADIO ) )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_ARMOUR_HAS_RADIO ); 
		return false;
	}
	
	if( IsTired( cr ) )
	{
		return false;
	}
	
	if( HandsTied( cr ) )
	{
		return false;
	}
	
	if( cr.IsInjured() )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_TO_INSTALL_RADIO );
		return false; 
	}
	
	if( !checkSkill( cr ) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FAILED_INSTALL_RADIO );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SKILLS_TO_INSTALL_RADIO );
		return false;
	}
	
	if( !checkTools( cr ) )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FAILED_INSTALL_RADIO );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_TOOLS_AND_HOLD_TOOL );
		for( uint i = 0; i < RadioInstallTools.length; i++ )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_HOLD_TOOL_PID, "$proto@msg item " + ( RadioInstallTools[i] * 100 ) + "@" );
		}	
		return false;
	}
	
	if( !checkComponents( cr ) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FAILED_INSTALL_RADIO );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_PARTS );
		for( uint i = 0; i < RadioInstallComponents.length; i++ )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_PARTS_PID, "$proto@msg item " + ( RadioInstallComponents[i] * 100 ) + "@$amount" + RIComponentsAmount[i] );
		}			
		return false;
	}
	
	start_install_radio( cr, armor );
	return true;
}

bool checkSkill( Critter& cr )
{
	if( cr.ParamBase[  SK_REPAIR ] < 200 || cr.ParamBase[ SK_SCIENCE ] < 150 )
	{
		return false; 
	}
	return true;
}

bool checkTools( Critter& cr )
{
	for( uint i = 0; i < RadioInstallTools.length; i++ )
	{
		Item@ tool = cr.GetItem( RadioInstallTools[i], -1 );
		if( !valid( tool ) )
		{
			return false;
		}
	}
	return true;
}

bool checkComponents( Critter& cr )
{
	for( uint i = 0; i < RadioInstallComponents.length; i++ )
	{
		Item@ component = cr.GetItem( RadioInstallComponents[i], -1 );
		uint required_amount = RIComponentsAmount[i];
		if( !valid( component ) || cr.CountItem( RadioInstallComponents[i] ) < required_amount )
		{
			return false;
		}
	}
	return true;
}

bool ltp_install_inited = false;
void ltp_install_init()
{
	LTPREG( LTP_INSTALL_RADIO, process_install_radio )
	ltp_install_inited = true;
}

bool start_install_radio( Critter& cr, Item& armor )
{
	if(!ltp_install_inited)
	{		
		ltp_install_init();
	}	
	uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ ST_AGILITY ] * ACTION_PAUSE_BONUS_RATE );
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	int install_rate = ( cr.Skill[SK_REPAIR] ) + ( cr.Stat[ST_AGILITY] * 10 ) + ( cr.Stat[ST_INTELLECT] * 10 ) + OBJECT_DPA_BASE; 
	cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ceil( float( ( OBJECT_HP_BASE * 10 ) / ( CLAMP( install_rate, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) ) );
	
	uint[] values = { cr.Id };
	
	CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_RepairSound", values, true);
	CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);	

	_CritAnimateUse( cr );
	
	StartProcess( cr, LTP_INSTALL_RADIO, 0, 0, armor.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
	return true;
}

uint process_install_radio( Critter@ cr, int& param0, int& param1, int& param2 )
{
	LTPROCESS( cr, param0, LTP_INSTALL_RADIO )

  	Item@ armor = GetItem( param2 );
	if( valid( armor ) )
    {
		param0++;
		
		if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
		{
			cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_FINISH_INSTALL_RADIO );
			InstallRadioResult( cr, armor );
			return 0;
		}
		
		uint[] values = { cr.Id };
		
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_RepairSound", values, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);

		_CritAnimateUse( cr );
		
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}
	return 0;
}

uint e_RepairSound( uint[]@ values )
{
	Critter@ cr = GetCritter(values[0]);
	Map@ map = cr.GetMap();
	map.PlaySound( RepairSounds[ Random( 0, RepairSounds.length() -1 ) ], cr.HexX, cr.HexY, 5 );
	return 0;
}

bool InstallRadioResult( Critter& cr, Item& armor )
{
	for( uint i = 0; i < RadioInstallComponents.length; i++ )
	{
		Item@ component = cr.GetItem( RadioInstallComponents[i], -1 );
		uint required_amount = RIComponentsAmount[i];
		if( !valid( component ) || cr.CountItem( RadioInstallComponents[i] ) < required_amount )
		{
			return false;
		}
		_SubItem( component, required_amount);
	}
	SETFLAG( armor.Flags, ITEM_RADIO );
	SETFLAG( armor.Flags, ITEM_CAN_USE );
	return true;
}

//Armor painting
bool TryPaintArmor( Critter& cr, Item& paint, Item& armor )
{
	uint8 PaintableArmorType = 0;
	uint16 armorPid = armor.GetProtoId();

	if( PaintableRobe.find( armorPid ) != -1 )
	{
		PaintableArmorType = 1;
	}
	else if( PaintableJumpsuit.find( armorPid ) != -1 )
	{
		PaintableArmorType = 2;	
	}
	else if( PaintableLeather.find( armorPid ) != -1 )
	{
		PaintableArmorType = 3;
	}
	else if( PaintableCA1.find( armorPid ) != -1 )
	{
		PaintableArmorType = 4;
	}
	else if( PaintableCA2.find( armorPid ) != -1 )
	{
		PaintableArmorType = 5;
	}
	else if( PaintableCA3.find( armorPid ) != -1 )
	{	
		PaintableArmorType = 6;
	}
	else
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_ARMOUR_CANT_REPAINT ); 
		return false;
	}
	
	if( IsTired( cr ) )
	{
		return false;
	}
	
	if( HandsTied( cr ) )
	{
		return false;
	}
	
	if( cr.IsInjured() )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_TO_REPAINT );
		return false; 
	}
	
	StartMenuPaintArmor( cr, armor, paint, PaintableArmorType );
	
	return true;
}

class MenuPaintArmor: CenteredMenuHandler
{
    uint armor_id;
	uint paint_id;
    uint map_id;
	uint8 armor_type;
	
    MenuPaintArmor( Item& armor, Item& paint, Map& map, uint8 PaintableArmorType )
	{
        armor_id = armor.Id;
		paint_id = paint.Id;
        map_id = map.Id;
		armor_type = PaintableArmorType;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
        Item@ armor = GetItem( armor_id );
		Item@ paint = GetItem( paint_id );
	
        if( !valid( map ) || !valid( armor ) || !valid( paint ) )
		{
            return false;
        }
		
		uint16[] armorType;
		switch( armor_type ) 
		{
			case( 1 ):
				armorType = PaintableRobe;
				break;
			case( 2 ):
				armorType = PaintableJumpsuit;
				break;
			case( 3 ):
				armorType = PaintableLeather;
				break;
			case( 4 ):
				armorType = PaintableCA1;
				break;
			case( 5 ):
				armorType = PaintableCA2;
				break;
			case( 6 ):
				armorType = PaintableCA3;
				break;
		}
		uint len = armorType.length();
		for( uint i = 0; i < len; i ++ )
		{
			ProtoItem@ armorBtn = GetProtoItem( armorType[i] );
			if( valid( armorBtn ) && menu.ButtonMsg( TEXTMSG_ITEM, armorBtn.ProtoId * 100 + 2 ) )
			{
				cr.StatBase[ ST_VAR7 ] = armorBtn.ProtoId;
				start_paint_armor( cr, armor, paint );
				return false;
			}
		}
		return true;
    }

	int getDescriptionFile()
    {
    	return TEXTMSG_TEXT;
    }

	int getDescriptionLine()
	{
		return STR_REPAIR_MENU_CHOOSE_COLOUR;
	}
	
    string@ Description( Critter& cr )
	{
		return null;
    }  
}

void StartMenuPaintArmor( Critter& cr, Item& armor, Item& paint, uint8 PaintableArmorType )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        return;
    }

    iMenuHandler@ handler = MenuPaintArmor( armor, paint, map, PaintableArmorType );
    iDialogBox@ menu = OpenMenu( cr, "Armour painting", handler );
}

bool ltp_paint_inited = false;
void ltp_paint_init()
{
	LTPREG( LTP_ARMOR_PAINT, process_paint_armor )
	ltp_paint_inited = true;
}

bool start_paint_armor( Critter& cr, Item& armor, Item& paint )
{
	if( !ltp_paint_inited )
	{
		ltp_paint_init();
	}
	
	uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
	cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
	uint install_rate = ( cr.Skill[ SK_REPAIR ] ) + ( cr.Stat[ ST_AGILITY ] * 10 ) + ( cr.Stat[ ST_INTELLECT ] * 10 ) + OBJECT_DPA_BASE; 
	cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ( OBJECT_HP_BASE * ( armor.Proto.Item_Subtype - 69 ) ) / ( CLAMP( install_rate, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) );
	
	uint[] values = { cr.Id };
	CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_RepairSound", values, true);
	CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);	

	cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
	
	StartProcess( cr, LTP_ARMOR_PAINT, 0, armor.Id, paint.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
	return true;
}

uint process_paint_armor( Critter@ cr, int& param0, int& param1, int& param2 )
{
	LTPROCESS( cr, param0, LTP_ARMOR_PAINT )
	
  	Item@ armor = GetItem( param1 );
	Item@ paint = GetItem( param2 );
	
	if( valid( armor ) && valid( paint ) )
    {
		param0++;
		
		if( param0 > cr.Param[ ST_LTP_SEQUENCE ] )
		{
			cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_FINISH_REPAINT );
			PaintArmor( cr, armor, paint );
			cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
			return 0;
		}
		
		uint[] values = { cr.Id };
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "e_RepairSound", values, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);

		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}
	return 0;
}

void PaintArmor( Critter& cr, Item& armor, Item& paint )
{
	if( !valid( armor ) || !valid( paint ) )
	{
		return;
	}
	
	if( cr.Stat[ ST_VAR7 ] == 0 )
	{
		return;
	}
	
	armor.ChangeProto( cr.StatBase[ ST_VAR7 ] );
	armor.Update();
	cr.StatBase[ ST_VAR7 ] = 0;
	_SubItem( paint, 1 );
}

#endif //REPAIR