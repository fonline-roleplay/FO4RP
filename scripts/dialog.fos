// Author: cvet, heX, Тринитротолуол, Tab10id
#include "_utils.fos"

#include "stdlib_h.fos"
#include "_npc_pids.fos"

#include "dialogs_dynamics.fos"

// Возвращает размер группы (живых ее участников)
// размер береться вне зависимости от того лидер это или просто партиец

import void FlushScreen( Critter& cr, bool fadeOut, uint timeMs ) from "effects";
import bool FactionInGame( Critter& player, Critter@ npc, int faction, int number ) from "factions";
import void PackageAlarm( Critter& player, int destination ) from "factions";
import void SecurityDoorOpenClose( Critter& player ) from "security_door";

import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, int attackerId ) from "combat"; // Export

bool d_CheckMonth( Critter& playe, Critter @npc, int monthFrom, int monthTo )
{
    return ( __Month <= monthTo && __Month >= monthFrom );
}

void r_setSkin( Critter& player, Critter@ npc, int skin )
{
	npc.StatBase[ ST_BODY_TYPE ] = skin;
	npc.ChangeCrType( skin );
}

bool d_isGM( Critter& player, Critter@ npc )
{
	return isGM( player );
}

bool d_isOwner( Critter& player, Critter@ npc )
{
    return uint( npc.Stat[ ST_FOLLOW_CRIT ] ) == player.Id;
}

bool d_isNotOwner( Critter& player, Critter@ npc )
{
    return !d_isOwner( player, npc );
}

void r_isOwner( Critter& player, Critter@ npc )
{
	ShowContainer( player, npc, TRANSFER_FAR_CRIT );
}

void r_setOwner( Critter& player, Critter@ npc )
{
    npc.StatBase[ ST_FOLLOW_CRIT ] = player.Id;
}

void r_clearOwner( Critter& player, Critter@ npc )
{
    npc.StatBase[ ST_FOLLOW_CRIT ] = 0;
}

void r_setOwner( Critter& player, Critter@ npc, int owner_id )
{
	if( !setOwner( player, npc, owner_id ) )
		player.Say( SAY_NETMSG, "Что-то пошло не так." );
}

bool setOwner( Critter& player, Critter@ npc, int owner_id )
{
    if( owner_id == 0 ) 
		return testInfo( player, "owner.ID == 0" );

	Critter@ owner = GetCritter( owner_id );
	if( !valid( owner ) )
		return testInfo( player, "!valid(owner)" );

	Map@ ownerMap = owner.GetMap();
	Map@ npcMap = npc.GetMap();
	if( !valid( ownerMap ) || !valid( npcMap ) || ownerMap.Id != npcMap.Id )
		return testInfo( player, "!valid(maps) or differend maps" );

	if( GetDistantion( owner.HexX, owner.HexY, npc.HexX, npc.HexY ) > 15 )
		return testInfo( player, "Too far away." );
		
	npc.StatBase[ ST_FOLLOW_CRIT ] = owner.Id;
	return true;
}

#define MAX_UINT	65535
bool d_hasItems( Critter& player, Critter@ npc, int pid, int amount )
{
    return player.Param[ QST_GAMEMODE ] == GAME_TEST || player.CountItem( pid ) >= uint( CLAMP( amount, 0, MAX_UINT ) );
}

void r_sellItems( Critter& player, Critter@ npc, int pid, int amount, int price, int experience )
{
	//Проверка на то, что у персонажа есть достаточно товара на продажу.
	if( player.CountItem( pid ) < uint( CLAMP( amount, 0, MAX_UINT ) ) )
	{
		if( player.Param[ QST_GAMEMODE ] == GAME_TEST )
			player.AddItem( pid, amount ); //Если он тестер - то просто выдаём ему необходимое количество товара.
		else
		{
			player.Say( SAY_NETMSG, "У вас недостаточно товара для сдачи." );
			return; //Иначе - отменяем обмен.
		}
	}		
	
	Item@ goods = player.GetItem( pid, -1 );
	if( !valid( goods ) ) 
	{
		player.Say( SAY_NETMSG, "У вас нет этого товара." );
		return;
	}
	
	//Мы буквально ПЕРЕДАЕМ указанное количество предметов от игрока неписю.
	if( goods.IsStackable() )
		MoveItem( goods, amount, npc );
	else 
	{ //Даже если объекты не стакаются, мы всё равно их корректно обрабатываем.
		for( int countdown = 0; countdown < amount; countdown++ )
		{
			@goods = player.GetItem( pid, -1 );
			if( !valid( goods ) )
			{
				player.Say( SAY_NETMSG, "Вы не смогли передать товар №" + countdown + "." );
				return;
			}
			
			MoveItem( goods, 1, npc );
		}
	}
	
	player.StatBase[ ST_EXPERIENCE ] += experience;
	
	//И затем так же буквально ПЕРЕДАЕМ указанное количество монет (награды) от игрока неписю. Если у того их не хватает - "довыдаём" сверх того.
	Item@ cash = npc.GetItem( PID_BOTTLE_CAPS, -1 );
	int available = 0;

	if( valid( cash ) )
	{
		available = cash.GetCount();
		
		if( available < price )
		{
			player.AddItem( PID_BOTTLE_CAPS, price - available );
			MoveItem( cash, available, player );
		}
		else
			MoveItem( cash, price, player );
	}
	else
		player.AddItem( PID_BOTTLE_CAPS, price );

	//Для отладки и тестов:
	if( player.Param[ QST_GAMEMODE ] == GAME_TEST )
		player.Say( SAY_NETMSG, "Sold #" + pid + " x" + amount + " for " + price + "$ & " + experience + ", available cash " + available + "$" );
}

//import bool d_freeRide( Critter& player, Critter@ npc ) from "dialog";
bool d_freeRide( Critter& player, Critter@ npc ) //exported
{
    return( player.KarmaBase[ KARMA_CHAMPION ] != 0 || player.KarmaBase[ KARMA_VC_GUARDSMAN ] != 0 );
}

void r_SwapCashOnly( Critter& player, Critter@ npc )
{
	npc.ModeBase[ MODE_BARTER_ONLY_CASH ] = ( npc.ModeBase[ MODE_BARTER_ONLY_CASH ] + 1 ) % 3;
	string text = "к сведению";
	switch( npc.ModeBase[ MODE_BARTER_ONLY_CASH ] )
	{
		case(0): text = "бартер"; break;
		case(1): text = "только золото и доллары"; break;
		case(2): text = "любую валюту"; break;
	}
	npc.Say( SAY_NORM, "О-кей, принимаю " + text + "." );
}

bool d_canBarter( Critter& player, Critter@ npc )
{
	return( npc.ModeBase[ MODE_NO_BARTER ] == 0 );
}

bool d_noBarter( Critter& player, Critter@ npc )
{
	return( npc.ModeBase[ MODE_NO_BARTER ] != 0 );
}

void r_SwapBarter( Critter& player, Critter@ npc )
{
	npc.ModeBase[ MODE_NO_BARTER ] = CLAMP( 1 - npc.ModeBase[ MODE_NO_BARTER ], 0, 1 );
	npc.Say( SAY_NORM, "О-кей, " + ( npc.ModeBase[ MODE_NO_BARTER ] != 0 ? "прекращаю" : "начинаю" ) + " торговлю." );
}

void r_SetNPCBarterSkill( Critter& player, Critter@ npc )
{
	player.ParamBase[ CR_VAL0 ] = npc.Id;
	player.ShowScreen( SCREEN_SAY, 0, "dialog@ask_SetNPCBarterSkill" );
	player.Say( SAY_SAY_TITLE, "Навык [0-300]:" );
}

bool d_isFollowing( Critter& player, Critter@ npc )
{
	return( npc.ModeBase[ MODE_NO_HOME ] != 0 );
}

bool d_isStanding( Critter& player, Critter@ npc )
{
	return( npc.ModeBase[ MODE_NO_HOME ] == 0 );
}

void r_DropMoving( Critter& player, Critter@ mob )
{
    mob.DropPlanes();
    mob.ClearEnemyStack();
	mob.ModeBase [MODE_NO_HOME] = 1;
	mob.SetHomePos( mob.HexX, mob.HexY, mob.Dir );
	mob.EraseTimeEvents( CTE_BRAHMIN_FOLLOW );
}

void r_SetFollow( Critter& player, Critter@ mob )
{
    mob.DropPlanes();
    mob.ClearEnemyStack();
	if( mob.ModeBase[MODE_NO_HOME] == 0 )
	{
		//mob.StatBase[ST_FOLLOW_CRIT] = playerId;
    	mob.ModeBase[MODE_NO_HOME] = 1;
    	mob.AddTimeEvent( "debug@cte_mob_follow", 0, CTE_BRAHMIN_FOLLOW, 0 );
    	mob.Say( SAY_EMOTE_ON_HEAD, "Следует" );
	} 
	else
	{
		//mob.StatBase[ST_FOLLOW_CRIT] = playerId;
		mob.ModeBase [MODE_NO_HOME] = 0;
		mob.SetHomePos( mob.HexX, mob.HexY, mob.Dir );
		mob.EraseTimeEvents( CTE_BRAHMIN_FOLLOW );
		mob.Say( SAY_EMOTE_ON_HEAD, "Останавливается" );
	}
}

void ask_SetNPCBarterSkill( Critter& player, uint answerI, string& answerS )
{
	Critter@ npc = GetCritter( player.ParamBase[ CR_VAL0 ] );
	
	int skill = 0;
	
	if( !StrToInt( answerS, skill ) || skill < 0 || skill > 300 )
	{
		player.Say( SAY_NETMSG, "Навык должен быть в диапазоне от 0 до 300." );
		r_SetNPCBarterSkill( player, npc );
		return;
	}
	if( skill > player.SkillBase[ SK_BARTER ] )
	{
		player.Say( SAY_NETMSG, "Вы не можете выставить навык выше своего. Ищите умелого торговца." );
		r_SetNPCBarterSkill( player, npc );
		return;
	}
	npc.SkillBase[ SK_BARTER ] = skill;
	npc.Say( SAY_NORM, "О-кей, я изменю расценки." );
	RunDialog( player, npc, true );
}

void r_CashBack( Critter& player, Critter@ npc )
{	
    Item@[] items;
	npc.GetItems( SLOT_INV, items );
	npc.GetItems( SLOT_HAND1, items );
	npc.GetItems( SLOT_HAND2, items );
	MoveItems( items, player );
	player.Say( SAY_EMOTE, "Забирает выручку" );
}

void r_ChangeBarter( Critter& player, Critter@ npc )
{	
	npc.ModeBase[ MODE_NO_BARTER ] = npc.ModeBase[ MODE_NO_BARTER ] == 0 ? 1 : 0;
	player.Say( SAY_NETMSG, "Меняла теперь " + ( npc.ModeBase[ MODE_NO_BARTER ] == 1 ? "не " : "") + "торгует. " );
}

int DFGroupCount( Critter& player, Critter@ npc )
{
    Critter @ leader;
    if( not valid( player.GetFollowLeader() ) ) // если у игрока нет лидера
        @leader = player;                       // тогда считаем что он и есть лидер
    else
        @leader = player.GetFollowLeader();     // иначе берем лидера

    Critter@[] groups;
    groups.insertLast( @leader );
    leader.GetFollowGroup( FIND_LIFE, groups );
    return groups.length();
}

// !/ Размер группы больше >=VAL
bool d_GroupCountMore( Critter& player, Critter@ npc, int val )
{
    return DFGroupCount( player, npc ) >= val;
}

bool d_GroupCountLess( Critter& player, Critter@ npc, int val )
{
    return DFGroupCount( player, npc ) < val;
}

// !/ У всех уровень больше >=VAL
// Проверка что все игроки в группе больше или равны указанному уровню.
bool d_GroupLevelMore( Critter& player, Critter@ npc, int val )
{
    Critter@[] groups;
    groups.insertLast( @player );
    player.GetFollowGroup( FIND_LIFE, groups );
    for( uint i = 0; i < groups.length(); i++ )
        if( groups[ i ].Stat[ ST_LEVEL ] < val ) // если хотябы один из них меньше требуемого уровня
            return false;
    return true;
}

bool d_GroupLevelLess( Critter& player, Critter@ npc, int val )
{
    Critter@[] groups;
    groups.insertLast( @player );
    player.GetFollowGroup( FIND_LIFE, groups );
    for( uint i = 0; i < groups.length(); i++ )
        if( groups[ i ].Stat[ ST_LEVEL ] > val ) // если хотябы один из них меньше требуемого уровня
            return false;
    return true;
}

// Игроку известна эта локация?
bool d_IsLocationVisible( Critter& player, Critter@ npc, int LocNum )
{
    return player.IsKnownLoc( false, uint16( LocNum ) );
}

// Игроку НЕ известна эта локация?
bool d_IsLocationNotVisible( Critter& player, Critter@ npc, int LocNum )
{
    return not player.IsKnownLoc( false, uint16( LocNum ) );
}

// Есть зависимости от наркотиков?
bool d_IsAddict( Critter& player, Critter@ npc )
{
    for( uint i = ADDICTION_BEGIN; i <= ADDICTION_END; i++ )
        if( player.Addiction[ i ] != 0 )
            return true;
    return false;
}

import void SetDrug( Critter& cr, uint16 drugPid ) from "drugs";

void r_ClearAddictions( Critter& player, Critter@ npc )
{
	SetDrug( player, PID_JET_ANTIDOTE );
}

// У игрока нет зависимостей от наркотиков?
bool d_IsNotAddict( Critter& player, Critter@ npc )
{
    return not d_IsAddict( player, npc );
}

// Игрок в группе? (лидер тоже считаеться)
bool d_GroupPresent( Critter& player, Critter@ npc )
{
    return DFGroupCount( player, npc ) > 1;
}

// Игрок НЕ в группе? (лидер тоже считаеться)
bool d_NotGroupPresent( Critter& player, Critter@ npc )
{
    return not d_GroupPresent( player, npc );
}

// Отложенная всплывающая строка над нпц
void r_SayMessageDelayed( Critter& player, Critter @ npc, int strNum, int delaySeconds, int sayType )
{
    if( !valid( npc ) )
        return;
    uint[] values = { npc.Id, uint( sayType ), uint( strNum ) };
    CreateTimeEvent( __FullSecond + delaySeconds, "e_SayMessage", values, true );
}

uint e_SayMessage( uint[] @ values )
{
    if( values.length() < 3 )
        return 0;
    Critter @ cr = GetCritter( values[ 0 ] );
    if( !valid( cr ) )
        return 0;
    int did = cr.Stat[ ST_DIALOG_ID ];
    if( did == 0 )
        return 0;
    cr.SayMsg( values[ 1 ], TEXTMSG_DLG, DLGSTR( did, values[ 2 ] ) );
    return 0;
}

// Шпионаж
void dlg_TrySpy( Critter& player, Critter@ banker, string@ playerName )
{
    if( !valid( banker ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;

    uint     BankerDialog = banker.Stat[ ST_DIALOG_ID ];
    uint     DlgStr = 100;
    string   lexems = "$Victim " + playerName;

    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }

    if( player.Id == cr.Id )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 9 ) );
        return;
    }

    // Пол.
    if( cr.Stat[ ST_GENDER ] == GENDER_MALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 11 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 12 ) + "@";
    }

    // Репликации.
    if( cr.Stat[ ST_REPLICATION_COUNT ] / cr.Stat[ ST_LEVEL ] <= 2 )
    {
        lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 13 ) + "@";
    }
    else if( cr.Stat[ ST_REPLICATION_COUNT ] / cr.Stat[ ST_LEVEL ] > 2 && cr.Stat[ ST_REPLICATION_COUNT ] / cr.Stat[ ST_LEVEL ] < 10 )
    {
        lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 14 ) + "@";
    }
    else
    {
        lexems += "$ReplCount @msg dlg " + DLGSTR( BankerDialog, DlgStr + 15 ) + "@";
    }

    // Год рождения.
    lexems += "$Born " + ( __Year - cr.Stat[ ST_AGE ] );

    if( player.Skill[ SK_SPEECH ] >= 40 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ), lexems );
    }

    // Уровень.
    if( player.Skill[ SK_SPEECH ] >= 50 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        lexems = "";
        lexems += "$Level " + cr.Stat[ ST_LEVEL ];
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
    }

    // Карма.
    if( player.Skill[ SK_SPEECH ] >= 60 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        int[] Values = { -2147483647, -1000, -750, -500, -250, 250,     500,    750,    1000 };
        int[] Descs =   { 6125,                         6122,   6119, 6116, 6113, 6110, 6107, 6104, 6101 };
        int CurKarma = 0;
        for( uint i = 0; i < Values.length(); i++ )
        {
            if( int(cr.Stat[ ST_KARMA ]) >= Values[ i ] )
            {
                CurKarma = Descs[ i ];
            }
            else
            {
                break;
            }
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_GAME, CurKarma );
    }

    // Статы.
    if( player.Skill[ SK_SPEECH ] >= 70 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        lexems = "";
        // Сила.
        if( cr.StatBase[ ST_STRENGTH ] < 4 )
        {
            lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 16 ) + "@";
        }
        else if( cr.StatBase[ ST_STRENGTH ] >= 4 && cr.StatBase[ ST_STRENGTH ] < 7 )
        {
            lexems += "$Strength" + "";
        }
        else if( cr.StatBase[ ST_STRENGTH ] >= 7 && cr.StatBase[ ST_STRENGTH ] <= 8 )
        {
            lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 17 ) + "@";
        }
        else
        {
            lexems += "$Strength @msg dlg " + DLGSTR( BankerDialog, DlgStr + 18 ) + "@";
        }
        // Восприятие.
        if( cr.StatBase[ ST_PERCEPTION ] < 4 )
        {
            lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 19 ) + "@";
        }
        else if( cr.StatBase[ ST_PERCEPTION ] >= 4 && cr.StatBase[ ST_PERCEPTION ] < 7 )
        {
            lexems += "$Perception" + "";
        }
        else if( cr.StatBase[ ST_PERCEPTION ] >= 7 && cr.StatBase[ ST_PERCEPTION ] <= 8 )
        {
            lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 20 ) + "@";
        }
        else
        {
            lexems += "$Perception @msg dlg " + DLGSTR( BankerDialog, DlgStr + 21 ) + "@";
        }
        // Выносливость.
        if( cr.StatBase[ ST_ENDURANCE ] < 4 )
        {
            lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 22 ) + "@";
        }
        else if( cr.StatBase[ ST_ENDURANCE ] >= 4 && cr.StatBase[ ST_ENDURANCE ] < 7 )
        {
            lexems += "$Endurance" + "";
        }
        else if( cr.StatBase[ ST_ENDURANCE ] >= 7 && cr.StatBase[ ST_ENDURANCE ] <= 8 )
        {
            lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 23 ) + "@";
        }
        else
        {
            lexems += "$Endurance @msg dlg " + DLGSTR( BankerDialog, DlgStr + 24 ) + "@";
        }
        // Обаяние.
        if( cr.StatBase[ ST_CHARISMA ] < 4 )
        {
            lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 25 ) + "@";
        }
        else if( cr.StatBase[ ST_CHARISMA ] >= 4 && cr.StatBase[ ST_CHARISMA ] < 7 )
        {
            lexems += "$Charisma" + "";
        }
        else if( cr.StatBase[ ST_CHARISMA ] >= 7 && cr.StatBase[ ST_CHARISMA ] <= 8 )
        {
            lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 26 ) + "@";
        }
        else
        {
            lexems += "$Charisma @msg dlg " + DLGSTR( BankerDialog, DlgStr + 27 ) + "@";
        }
        // Интеллект.
        if( cr.StatBase[ ST_INTELLECT ] < 4 )
        {
            lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 28 ) + "@";
        }
        else if( cr.StatBase[ ST_INTELLECT ] >= 4 && cr.StatBase[ ST_INTELLECT ] < 7 )
        {
            lexems += "$Intellect" + "";
        }
        else if( cr.StatBase[ ST_INTELLECT ] >= 7 && cr.StatBase[ ST_INTELLECT ] <= 8 )
        {
            lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 29 ) + "@";
        }
        else
        {
            lexems += "$Intellect @msg dlg " + DLGSTR( BankerDialog, DlgStr + 30 ) + "@";
        }
        // Ловкость.
        if( cr.StatBase[ ST_AGILITY ] < 4 )
        {
            lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 31 ) + "@";
        }
        else if( cr.StatBase[ ST_AGILITY ] >= 4 && cr.StatBase[ ST_AGILITY ] < 7 )
        {
            lexems += "$Agility" + "";
        }
        else if( cr.StatBase[ ST_AGILITY ] >= 7 && cr.StatBase[ ST_AGILITY ] <= 8 )
        {
            lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 32 ) + "@";
        }
        else
        {
            lexems += "$Agility @msg dlg " + DLGSTR( BankerDialog, DlgStr + 33 ) + "@";
        }
        // Удача.
        if( cr.StatBase[ ST_LUCK ] < 4 )
        {
            lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 34 ) + "@";
        }
        else if( cr.StatBase[ ST_LUCK ] >= 4 && cr.StatBase[ ST_LUCK ] < 7 )
        {
            lexems += "$Luck" + "";
        }
        else if( cr.StatBase[ ST_LUCK ] >= 7 && cr.StatBase[ ST_LUCK ] <= 8 )
        {
            lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 35 ) + "@";
        }
        else
        {
            lexems += "$Luck @msg dlg " + DLGSTR( BankerDialog, DlgStr + 36 ) + "@";
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
    }

    // Тагнутые боевые навыки.
    if( player.Skill[ SK_SPEECH ] >= 80 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {

        uint[] CombatSkills = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_MELEE_WEAPONS, SK_THROWING };
        uint[] TagSkills = { cr.TagSkill[ TAG_SKILL1 ], cr.TagSkill[ TAG_SKILL2 ], cr.TagSkill[ TAG_SKILL3 ], cr.TagSkill[ TAG_SKILL4 ] };

        for( uint i = 0; i < CombatSkills.length(); i++ )
        {
            for( uint t = 0; t < TagSkills.length(); t++ )
            {
                if( CombatSkills[ i ] == TagSkills[ t ] )
                {
                    if( cr.Skill[ TagSkills[ t ] ] < 100 )
                    {
                        lexems = "$CmbtSkillTag @msg dlg " + DLGSTR( BankerDialog, DlgStr + 60 + Random( 0, 1 ) ) + "@";
                        switch( TagSkills[ t ] )
                        {
                        case SK_SMALL_GUNS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 41 ) + "@";
                            break;
                        case SK_BIG_GUNS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 42 ) + "@";
                            break;
                        case SK_ENERGY_WEAPONS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 43 ) + "@";
                            break;
                        case SK_UNARMED:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 44 ) + "@";
                            break;
                        case SK_MELEE_WEAPONS:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 45 ) + "@";
                            break;
                        case SK_THROWING:
                            lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 46 ) + "@";
                            break;
                        default:
                            break;
                        }
                        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 6 ), lexems );
                    }
                }
            }
        }

    }

    // Тагнутые небоевые навыки.
    if( player.Skill[ SK_SPEECH ] >= 85 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        uint[] Skills = { SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN };
        uint[] TagSkills = { cr.TagSkill[ TAG_SKILL1 ], cr.TagSkill[ TAG_SKILL2 ], cr.TagSkill[ TAG_SKILL3 ], cr.TagSkill[ TAG_SKILL4 ] };
        for( uint i = 0; i < Skills.length(); i++ )
        {
            for( uint t = 0; t < TagSkills.length(); t++ )
            {
                if( Skills[ i ] == TagSkills[ t ] )
                {
                    if( cr.Skill[ TagSkills[ t ] ] < 100 )
                    {
                        lexems = "$SkillTag @msg dlg " + DLGSTR( BankerDialog, DlgStr + 62 + Random( 0, 2 ) ) + "@";
                        switch( TagSkills[ t ] )
                        {
                        case SK_FIRST_AID:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 65 ) + "@";
                            break;
                        case SK_DOCTOR:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 66 ) + "@";
                            break;
                        case SK_SNEAK:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 67 ) + "@";
                            break;
                        case SK_LOCKPICK:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 68 ) + "@";
                            break;
                        case SK_STEAL:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 69 ) + "@";
                            break;
                        case SK_TRAPS:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 70 ) + "@";
                            break;
                        case SK_SCIENCE:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 71 ) + "@";
                            break;
                        case SK_REPAIR:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 72 ) + "@";
                            break;
                        case SK_SPEECH:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 73 ) + "@";
                            break;
                        case SK_BARTER:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 74 ) + "@";
                            break;
                        case SK_GAMBLING:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 75 ) + "@";
                            break;
                        case SK_OUTDOORSMAN:
                            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 76 ) + "@";
                            break;
                        default:
                            break;
                        }
                        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 7 ), lexems );
                    }
                }
            }
        }

    }

    // Прокачаный боевой навык.
    if( player.Skill[ SK_SPEECH ] >= 90 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {

        lexems = "";
        int CurSkill = 0;
        int MaxSkill = 0;
        uint[] CombatSkills = { SK_SMALL_GUNS, SK_BIG_GUNS, SK_ENERGY_WEAPONS, SK_UNARMED, SK_MELEE_WEAPONS, SK_THROWING };

        for( uint i = 0; i < CombatSkills.length(); i++ )
        {
            if( CurSkill < cr.Skill[ CombatSkills[ i ] ] )
            {
                CurSkill = cr.Skill[ CombatSkills[ i ] ];
                MaxSkill = CombatSkills[ i ];
            }
        }
        if( CurSkill < 90 )
        {
            lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 37 ) + "@";
            lexems += "$CombatSkillMax";
        }
        else
        {
            if( CurSkill >= 90 && CurSkill < 150 )
                lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 38 ) + "@";
            if( CurSkill >= 150 && CurSkill < 200 )
                lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 39 ) + "@";
            if( CurSkill >= 200 )
                lexems += "$CombatSkillLvl @msg dlg " + DLGSTR( BankerDialog, DlgStr + 40 ) + "@";
            switch( MaxSkill )
            {
            case SK_SMALL_GUNS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 41 ) + "@";
                break;
            case SK_BIG_GUNS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 42 ) + "@";
                break;
            case SK_ENERGY_WEAPONS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 43 ) + "@";
                break;
            case SK_UNARMED:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 44 ) + "@";
                break;
            case SK_MELEE_WEAPONS:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 45 ) + "@";
                break;
            case SK_THROWING:
                lexems += "$CombatSkillMax @msg dlg " + DLGSTR( BankerDialog, DlgStr + 46 ) + "@";
                break;
            default:
                break;
            }
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 ), lexems );

    }

    // Прокачаный небоевой навык.
    if( player.Skill[ SK_SPEECH ] >= 100 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {

        lexems = "";
        int CurSkill = 0;
        int MaxSkill = 0;
        uint[] Skills = { SK_FIRST_AID, SK_DOCTOR, SK_SNEAK, SK_LOCKPICK, SK_STEAL, SK_TRAPS, SK_SCIENCE, SK_REPAIR, SK_SPEECH, SK_BARTER, SK_GAMBLING, SK_OUTDOORSMAN };

        for( uint i = 0; i < Skills.length(); i++ )
        {
            if( CurSkill < cr.Skill[ Skills[ i ] ] )
            {
                CurSkill = cr.Skill[ Skills[ i ] ];
                MaxSkill = Skills[ i ];
            }
        }
        if( CurSkill <= 90 )
        {
            lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 47 ) + "@";
        }
        else
        {
            switch( MaxSkill )
            {
            case SK_FIRST_AID:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 48 ) + "@";
                break;
            case SK_DOCTOR:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 49 ) + "@";
                break;
            case SK_SNEAK:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 50 ) + "@";
                break;
            case SK_LOCKPICK:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 51 ) + "@";
                break;
            case SK_STEAL:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 52 ) + "@";
                break;
            case SK_TRAPS:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 53 ) + "@";
                break;
            case SK_SCIENCE:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 54 ) + "@";
                break;
            case SK_REPAIR:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 55 ) + "@";
                break;
            case SK_SPEECH:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 56 ) + "@";
                break;
            case SK_BARTER:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 57 ) + "@";
                break;
            case SK_GAMBLING:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 58 ) + "@";
                break;
            case SK_OUTDOORSMAN:
                lexems += "$AnySkill @msg dlg " + DLGSTR( BankerDialog, DlgStr + 59 ) + "@";
                break;
            default:
                break;
            }
        }
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 5 ), lexems );

    }

    // Количество денег на счету.
    if( player.Skill[ SK_SPEECH ] >= 110 - ( player.Stat[ ST_CHARISMA ] + player.Stat[ ST_LUCK ] ) / 2 )
    {
        lexems = "";
        lexems += "$ReplMoney " + cr.Stat[ ST_REPLICATION_MONEY ] + "$ReplCount " + cr.Stat[ ST_REPLICATION_COUNT ];
        player.SayMsg( SAY_APPEND, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 8 ), lexems );
    }
}

void dlg_ForSearching( Critter& player, Critter@ barman, string@ playerName )
{
    if( !valid( barman ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;
    uint   BankerDialog = barman.Stat[ ST_DIALOG_ID ];
    uint   DlgStr = 200;
    // Имя запрашиваемого криттера и инициализация переменной с лексемами.
    string lexems = "$Victim " + playerName;
    // Пол бармена.
    if( barman.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
    }
    // Игрок не найден.
    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }
    // Пол запрашиваемого криттера.
    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
    }
    player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 11 ), lexems );
    return;
}

void dlg_TrySearching( Critter& player, Critter@ barman, string@ playerName )
{

    #define LOC_NAME    # (mapId)                       ( ( mapId + 100 ) * 1000 ) // поиск названия локации в файле FOGM.msg
    if( !valid( barman ) )
        return;
    if( !IS_DIALOG_SAY_MODE( playerName ) || IS_DIALOG_END( playerName ) )
        return;
    if( playerName.length() <= 1 )
        return;
    uint   BankerDialog = barman.Stat[ ST_DIALOG_ID ];
    uint   DlgStr = 200;
    // Имя запрашиваемого криттера и инициализация переменной с лексемами.
    string lexems = "$Victim " + playerName;
    // Пол бармена.
    if( barman.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 10 ) + "@";
    }
    else
    {
        lexems += "$BarmanGen @msg dlg " + DLGSTR( BankerDialog, DlgStr + 9 ) + "@";
    }
    // Игрок не найден.
    Critter@ cr = GetPlayer( playerName );
    if( !valid( cr ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 0 ), lexems );
        return;
    }
    // Пол запрашиваемого криттера.
    if( cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 8 ) + "@";
    }
    else
    {
        lexems += "$Gender @msg dlg " + DLGSTR( BankerDialog, DlgStr + 7 ) + "@";
    }
    // Игрок спрашивает о самом себе.
    if( player.Id == cr.Id )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 1 ) );
        return;
    }
    // Криттер на глобале.
    Map@ map = cr.GetMap();
    if( !valid( map ) )
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
        return;
    }
    // Локация, где находится криттер. Диапазоны PID: до 150 и 210-235. Города и репликации.
    if( cr.GetMap().GetLocation().GetProtoId() < 50 || cr.GetMap().GetLocation().GetProtoId() >= 200 )
    {
        lexems += "$Place @msg GM " + LOC_NAME( cr.GetMap().GetLocation().GetProtoId() ) + "@";
        // Криттер находится в той же локации, что и игрок.
        if( barman.GetMap().GetLocation().Id == cr.GetMap().GetLocation().Id )
        {
            player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 3 ), lexems );
            return;
        }
        // Криттер найден, лексемы сформированы - даем информацию.
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 4 + Random( 0, 2 ) ), lexems );
    }
    else
    {
        player.SayMsg( SAY_DIALOG, TEXTMSG_DLG, DLGSTR( BankerDialog, DlgStr + 2 ), lexems );
        return;
    }
}


import void ChangeStatus( Critter& cr, uint16 status, uint8 value, bool set ) from "critter_status";

bool d_ToHeal_Toxic( Critter& player, Critter@ npc )
{
	return player.StatBase[ ST_BLOOD_TOXIC ] > 0;
}

void r_ToHeal_Toxic( Critter& player, Critter@ npc )
{
	player.StatBase[ ST_BLOOD_TOXIC ] = 0;
	ChangeStatus( player, CR_STATUS_BLOOD_TOXIC, 0, false );
}

bool d_ToHeal_Bullet( Critter& player, Critter@ npc )
{
	return FLAG( player.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER );
}

void r_ToHeal_Bullet( Critter& player, Critter@ npc )
{
	ChangeStatus( player, CR_STATUS_BULLET_OVER, 0, false );
}

bool d_ToHeal_Bleed( Critter& player, Critter@ npc )
{
	return player.ParamBase[ BP_BLOOD_LOSS ] > 0 || player.StatBase[ ST_BLEED ] > 0;
}

void r_ToHeal_Bleed( Critter& player, Critter@ npc )
{
	player.ParamBase[ BP_BLOOD_LOSS ] = 0;	
	player.StatBase[ ST_BLEED ] = 0;
}

bool d_ToHeal_Heavy( Critter& player, Critter@ npc )
{
	return FLAG( player.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG );
}

void r_ToHeal_Heavy( Critter& player, Critter@ npc )
{
	ChangeStatus( player, CR_STATUS_HEAVY_DMG, 0, false );
}

bool d_IsToHeal( Critter& player, Critter@ npc )
{
    return player.Stat[ ST_CURRENT_HP ] < player.Stat[ ST_MAX_LIFE ];
}

void r_ToHeal_HP( Critter& player, Critter@ npc )
{
    player.StatBase[ ST_CURRENT_HP ] = player.Stat[ ST_MAX_LIFE ];
}

void r_ToHeal( Critter& player, Critter@ npc )
{
    player.StatBase[ ST_CURRENT_HP ] = player.Stat[ ST_MAX_LIFE ];
}

void r_ShowLocation( Critter& player, Critter@ npc, int locNum )
{
    player.SetKnownLoc( false, uint16( locNum ) );
}

void r_FadeOut( Critter& player, Critter@ npc, int time )
{
    if( time == 0 )
        time = 2000;
    FlushScreen( player, false, time );
}

void r_TransitToGlobal( Critter& player, Critter@ npc )
{
    player.TransitToGlobal( false );
}

void r_TransitToLocation( Critter& player, Critter@ npc, int locPid, int mapIndex )
{
    TransitToLoc( player, locPid, mapIndex, 0 );
}

void r_InfoMessage( Critter& player, Critter@ npc, int strNum )
{
    InfoMessage( player, npc, strNum );
}

void r_DoorOpen( Critter& player, Critter@ npc, int entireNum )
{
    DoorControl( player, entireNum, true );
}

void r_DoorClose( Critter& player, Critter@ npc, int entireNum )
{
    DoorControl( player, entireNum, false );
}

// Даем игроку голодиск
void r_GiveHolodisk( Critter& player, Critter@ npc, int holodiskNum )
{
    Item@ holo = player.AddItem( PID_HOLODISK, 1 );
    holo.HolodiskNumber = holodiskNum;
    holo.Update();
}

bool d_DuplKey( Critter& player, Critter@ npc )
{
    Item@ key = player.GetItem( 0, SLOT_HAND1 );
    if( !valid( key ) || key.GetType() != ITEM_TYPE_KEY )
        return false;
    return true;
}

import void KeyUseScreen( Critter& player, uint answerI, string& answerS ) from "item";

void r_DuplKey( Critter& player, Critter @ npc )
{
    Item @ key = player.GetItem( 0, SLOT_HAND1 );
    if( !valid( key ) || key.GetType() != ITEM_TYPE_KEY )
        return;
    Item @ newKey = player.AddItem( PID_BLANK_KEY, 1 );
    newKey.LockerId = key.LockerId;
    newKey.SetLexems( "$KeyLex" + "some key" );
    player.StatBase[ ST_VAR0 ] = newKey.Id;
    player.ShowScreen( SCREEN_SAY, 0, "item@KeyUseScreen" );
    newKey.Update();
}

void give_dosimetr( Critter& player, Critter @ npc )
{
    Item@ dosimetr = player.AddItem( PID_DOSIMETR, 1 );
    dosimetr.Val1 = Random( 20, 300 );
    dosimetr.Val2 = Random( 20, 550 );

    dosimetr.SetLexems( "указанны координаты " + dosimetr.Val1 / 10 + " и " + dosimetr.Val2 / 10 );
}

void get_cow( Critter& player, Critter @ npc )
{
    Critter@[] brahmins;
    Map @ map = player.GetMap();
    Item@ flute = player.GetItem( PID_FLUTE, 0 );
	uint count = map.GetCritters( NPC_PID_Brahmin, FIND_LIFE_AND_KO | FIND_ONLY_NPC, brahmins ); 
    if( count > 0 && int( map.Id ) == flute.Val1 )
    {
        for( uint i = 0; i < count; i++ )
        {
            uint   cuffs_state = brahmins[ i ].StatBase[ HANDCUFFS ];
            uint16 master = ( cuffs_state ) & 0xFFFF;
            if( player.Id == master )
            {
                if( brahmins[ i ].Stat[ ST_VAR5 ] >= 5 )
                {
                    player.AddItem( PID_BOTTLE_CAPS, 100 );
                    DeleteNpc( brahmins[ i ] );
                    // GetUnicumVar(UVAR_loyality, player.Id, npc.Id)+=1;  поправить увеличение лояльности
                }
                else
                    DeleteNpc( brahmins[ i ] );
            }
        }
    }
}

void give_Package( Critter& player, Critter @ npc, int destination )
{
    if( _CritCountItem( player, PID_PACKAGE ) != 0 )
    {
        npc.Say( SAY_NORM, "да ты уже с грузом" );
        return;
    }
    Item@  pack = player.AddItem( PID_PACKAGE, 1 );
    pack.Val1 = destination;
    string dest = "";
    switch( destination )
    {
    case 1:
        dest = "Отнести на склад Модока";
        npc.Say( SAY_NORM, "отнесите это Джо, его магазин недалеко от главных ворот" );
        break;
    case 2:
        dest = "Отнести на ферму";
        npc.Say( SAY_NORM, "отнесите это Филу, на ферму, сейчас он в отъезде, но может быть вы дождетесь его когда-нибудь" );
        break;
    case 3:
        dest = "Отнести мутанту на свалку";
        npc.Say( SAY_NORM, "отнесите это Туроку, это мутант на свалке, обычно в палатке сидит" );
        break;
    case 4:
        dest = "Отнести в Форт Саттер";
        npc.Say( SAY_NORM, "отнесите это Биллу, он в форте, обычно на нижинх этажах, скорее всего с генераторами возится" );
        break;
    }
    pack.SetLexems( "" + dest );
    if( FactionInGame( player, npc, 6, 2 ) )
        pack.Val2 = 1;
    pack.Val3 = player.Id;
    PackageAlarm( player, destination );
    player.ModeBase[ MODE_NO_WALK ] = 1;
    player.ModeBase[ MODE_NO_RUN ] = 1;
}

void give_Package_chek( Critter& player, Critter @ npc, int destination )
{
    Item@ pack = player.GetItem( PID_PACKAGE, 0 );
    if( pack.Val1 == destination )
    {
        Item@ chek = player.AddItem( PID_PACKAGE_CHEK, 1 );
        chek.Val1 = pack.Val1;
        chek.Val2 = pack.Val2;
        chek.Val3 = pack.Val3;
        DeleteItem( pack );
        npc.Say( SAY_NORM, "спасибо, держите расписку о получении" );
    }
    else
        npc.Say( SAY_NORM, "это не та посылка" );
}

void get_Package_chek( Critter& player, Critter @ npc, int late )
{
    Item@ chek = player.GetItem( PID_PACKAGE_CHEK, 0 );
    int   destination = chek.Val1;
    int   exp;
    int   payout;
    if( chek.Val3 != int( player.Id ) )
        late = 1;
    switch( destination )
    {
    case 1:
        exp = 20;
        payout = 20;
        if( chek.Val2 != 0 )
            break;
    case 2:
        exp = 50;
        payout = 50;
        break;
    case 3:
        exp = 80;
        payout = 80;
        break;
    case 4:
        exp = 150;
        payout = 100;
        break;
    }
    if( chek.Val2 != 0 && destination >= 3 && late == 0 )
    {
        exp *= 10;
        payout *= 10;
    }
    if( late != 0 )
    {
        npc.Say( SAY_NORM, "долго слишком, бери оплату" );
        exp /= 4;
        payout /= 4;
    }
    else
        npc.Say( SAY_NORM, "бери оплату" );
    if( chek.Val3 == int( player.Id ) )
        player.StatBase[ ST_EXPERIENCE ] += exp;
    player.AddItem( PID_BOTTLE_CAPS, payout );
    DeleteItem( chek );
}

void getCure( Critter& player, Critter @ npc )
{
    Item @ hypo = player.AddItem( PID_HYPO_BLOOD, 1 );
    GameVar@ strain = GetGlobalVar( GVAR_desease_strain );
    hypo.Val1 = 0;
    hypo.Val2 = 0;
    hypo.Val3 = strain.GetValue();
    hypo.SetLexems( "$HypoLex" + " вакцина номер " + hypo.Val3 );
    hypo.Update();
}

void giveCure( Critter& player, Critter @ npc )
{
    Item@    hypo = player.GetItem( PID_HYPO_BLOOD, 0 );
    GameVar@ strain = GetGlobalVar( GVAR_desease_strain );
    if( ( hypo.Val3 > strain.GetValue() ) && hypo.Val2 >= 50 )
        strain.opAddAssign( hypo.Val3 );
    npc.Say( SAY_NORM, "я должен сделать несколько тестов" );
    DeleteItem( hypo );
}

void MakeCure( Critter& doctor, Item@ hypo )
{
	if(!valid(hypo)) return;
    
	doctor.Say( SAY_NETMSG, "Вы проводите серию тестов." );
    
	GameVar@ strain = GetGlobalVar( GVAR_desease_strain );
    
	if( ( hypo.Val3 > strain.GetValue() ) && hypo.Val2 >= 50 )
        strain.opAddAssign( hypo.Val3 );
    
    hypo.Val1 = 0;
    hypo.Val2 = 0;
    hypo.Val3 = strain.GetValue();
    hypo.SetLexems( "$HypoLex" + " вакцина для штамма " + hypo.Val3 );
    hypo.Update();
}


//Диалоговые скрипты на сессию Ривердейла
//Условия для терминала с пропусками, для кассира и для роботов стражей

bool d_hasKey( Critter& player, Critter@ npc )
{	
    return player.CountItem( PID_BLUE_PASS_KEY ) > 0;
}

bool d_noKey( Critter& player, Critter@ npc )
{
    return player.CountItem( PID_BLUE_PASS_KEY ) == 0;	
}

bool d_chance( Critter& player, Critter@ npc, int val )
{
    return player.ParamBase[ CHANCE ] <= val;
}

void r_chance( Critter& player, Critter@ npc, int val )
{	
	player.ParamBase[ CHANCE ] = Random( 0, val );
}

void r_alarm( Critter& player, Critter@ npc )
{	
	if( npc.GetTimeEvents( CTE_WARNING, null, null, null ) == 0 )
	{
		npc.AddTimeEvent( "cte_forget", REAL_SECOND( 60 ), CTE_WARNING, 0 );
		RadioMessage( 0, "[Металлический голос]: Обнаружено неавторизованное лицо у входа в охраняемую область!" );
	}
}

uint cte_forget (Critter& cr, int identifier, uint& rate) {
	return 0;
}

bool d_has_100_NCR_Dollars( Critter& player, Critter@ npc ) 
{
	if( player.CountItem( PID_DOLLAR_100 ) > 0 ) 
	{
		return true;
	}
	
	return false;
}

bool d_has_NOT_100_NCR_Dollars( Critter& player, Critter@ npc ) 
{
	if( player.CountItem( PID_DOLLAR_100 ) == 0 ) 
	{
		return true;
	}
	
	return false;
}

bool d_has_Tickets_In_Cass( Critter& player, Critter@ npc ) 
{
	if( npc.CountItem( PID_KOKOWEEF_MINE_SCRIP ) > 0 ) 
	{
		return true;
	}
	
	return false;
}

bool d_has_NOT_Tickets_In_Cass( Critter& player, Critter@ npc ) 
{
	if( npc.CountItem( PID_KOKOWEEF_MINE_SCRIP ) == 0 ) 
	{
		return true;
	}
	
	return false;
}

bool d_p_has_Ticket( Critter& player, Critter@ npc ) 
{
	if( player.CountItem( PID_KOKOWEEF_MINE_SCRIP ) > 0 ) 
	{
		return true;
	}
	
	return false;
}

bool d_p_has_NOT_Ticket( Critter& player, Critter@ npc ) 
{
	if( player.CountItem( PID_KOKOWEEF_MINE_SCRIP ) == 0 ) 
	{
		return true;
	}
	
	return false;
}

void r_Get_Terminal_Num( Critter& player, Critter@ npc ) 			
{
	player.ParamBase[ ST_VAR7 ] = npc.Id;							
	player.ParamBase[ ST_VAR8 ] = 1;								
	
	//Log( "Айди аппарата"+player.ParamBase[ ST_VAR7 ] );				
}

void r_Clear_Terminal_Num( Critter& player, Critter@ npc ) 
{
	player.ParamBase[ ST_VAR7 ] = 0;							
	player.ParamBase[ ST_VAR8 ] = 0;								
	
	//Log( "Айди аппарата"+player.ParamBase[ ST_VAR7 ] );				
}

bool d_p_has_Ticket_Tape( Critter& player, Critter@ npc ) 
{
	if( player.CountItem( PID_CASH_TAPE ) >= 1 ) 
	{
		return true;
	}
	
	return false;
}

bool d_Get_Ticket_Tape( Critter& player, Critter@ npc ) 
{
	if( player.ParamBase[ ST_VAR7 ] != 0 && player.ParamBase[ ST_VAR8 ] == 1 ) 
	{
		return true;
	}
	
	return false;
}

//Условия для диалога "Дверь драг-пушера"
//-------------------------------------------------------------------------

//Проверка "свой-чужой"
bool d_Is_Trust_Level( Critter& player, Critter@ npc ) 
{
	if( player.ParamBase[CR_TRUST_LEVEL] != 1 ) 
	{
		return true;
	}
	
	return false;
}

//Логика двери
void r_Trust_Level_Is_Ok( Critter& player, Critter@ npc ) 
{	
	if( player.ParamBase[CR_TRUST_LEVEL] == 1 ) 
	{
		SecurityDoorOpenClose( player );
	}
}

//НПЦ проверяет похож ли собеседник на копа
bool d_is_Look_like_Cop( Critter& player, Critter@ npc ) 
{//Надо переделать по хорошему на проверку параметра "коп", который вешаается звездой шерифа
	if( player.CountItem( PID_GUARD_BADGE ) > 0 || player.CountItem( PID_SHER_BADGE ) > 0 || player.CountItem( PID_SHERIFF_BADGE ) > 0 || player.CountItem( PID_COMBAT_ARMOR ) > 0 || player.CountItem( PID_POLICE_ARMOR ) > 0 || player.CountItem( PID_RIOT_ARMOR ) > 0 || player.CountItem( PID_copinv1 ) > 0 ) 
	{
		return true;
	}
	
	return false;
}

//-------------------------------------------------------------------------

































