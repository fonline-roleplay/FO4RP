#ifndef GENERAL_UNSAFE
#define GENERAL_UNSAFE

#include "_utils.fos"
#include "wait_time_h.fos"
#include "npc_planes_h.fos"
#include "firestarter_h.fos"
#include "terminal_h.fos"
#include "vending_h.fos"
#include "fish_h.fos"
#include "combat_h.fos"
#include "repair_h.fos"
#include "gateway_h.fos"
#include "lockers_h.fos"
#include "furniture_h.fos"
#include "casino_h.fos"
#include "gm_h.fos"
#include "windup_h.fos"
#include "handcuffs_h.fos"
#include "plants_h.fos"
#include "gathering_h.fos"
#include "trap_h.fos"
#include "speed_h.fos"
#include "hitchance_h.fos"
#include "serializator.fos"
#include "waterworks_h.fos"
#include "stdlib_h.fos"
#include "module/utils/param_names.fos"

import void Actions( Critter& cr, uint8 actionType, uint16 pickType ) from "context_callback";
import bool critter_use_skill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen ) from "main";
import void critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo ) from "main";
import void LookDataRefresh( Critter& cr ) from "main";
import bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command ) from "main";

import uint8 checkWater( Map& map, uint16 tx, uint16 ty ) from "qmap_water";

bool Action( Critter& player, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	uint16 moverHexX = player.HexX, moverHexY = player.HexY, aimHexX = 0, aimHexY = 0;
	if( valid( targetCr ) )
	{ 
		aimHexX = targetCr.HexX;   
		aimHexY = targetCr.HexY;
	}
	else if( valid( targetItem ) )
	{ 
		aimHexX = targetItem.HexX; 
		aimHexY = targetItem.HexY; 
	}
	else if( valid( targetScen ) )
	{ 
		aimHexX = targetScen.HexX;
		aimHexY = targetScen.HexY; 
	}
	else
	{
		return false;
	}

	uint dist = GetDistantion( moverHexX, moverHexY, aimHexX, aimHexY );
	if( dist > 1 )
	{ 
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_FAR ); 
		return false; 
	}
	
	uint8 dir = GetDirection( moverHexX, moverHexY, aimHexX, aimHexY );
	player.SetDir( dir );
	player.Action( ACTION_PICK_CRITTER, 3, null );
	return true;
}

void unsafe_OpenDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
	if( player.IsDead() || player.IsKnockout() || player.IsBusy() || IsAnimal( player ) || IsInsect( player ) || player.Timeout[ TO_SK_STEAL ] > 0 )
	{
		return;
	}

	Map@ map = player.GetMap();
	uint16 hexX, hexY;
	uint8 dir;
	for( uint8 i = 0; i < 6; i++ )
	{
		hexX = player.HexX;
		hexY = player.HexY;
		dir = ( player.Dir + i ) % 6;
		map.MoveHexByDir( hexX, hexY, dir, 1 );
		Item@ item = map.GetDoor( hexX, hexY );
		if( !valid( item ) )
		{
			Item@[] items;
			uint count = map.GetItems( hexX, hexY, items );
			if( count > 0 )
			{
				@item = @items[ Random( 0, count - 1 ) ];
			}
		}
		
		if( !valid( item ) )
		{
			continue;
		}
		
		if( FLAG( item.Flags, ITEM_CAN_USE ) || FLAG( item.Flags, ITEM_CAN_PICKUP ) )
		{
			if( !Action( player, null, item, null ) )
			{
				continue;
			}
			
			if( !item.EventSkill( player, SKILL_PICK_ON_GROUND ) )
			{
				critter_use_skill( player, SKILL_PICK_ON_GROUND, null, item, null );
			}
			
			player.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 2 );
			player.StatBase[ ST_CURRENT_AP ] -= __RtApCostPickItem * 100;
			break;
		}
		// else
		// {
			// player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NO_HINGE );
			// break;
		// }
	}
}

void unsafe_MobGoHome( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ vals )
{
	if( !isGM( player ) )
	{
		return;
	}
	Critter@ target = GetCritter( param0 );
	if( valid(target) && !target.IsPlayer() )
	{
		if( target.ModeBase[ MODE_NO_HOME ] != 0 )
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SEND_CR_HOME, "$npc" + param0 );
		}
		else
		{	
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CR_IS_HOME, "$npc" + param0 );
		}
		target.ModeBase[ MODE_NO_HOME ] = 0;
	}
}

void unsafe_radioHead( Critter& cr, int, int, int, string@ message, int[]@ ) 
{
	if( cr.IsDead() )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_DEAD_CANT_TALK );
		return;
	}
	
	Item@[] items;
	Item@ radio = null;
	if( cr.GetItems( -1, items ) > 0 )
	{
		for( uint i = 0, l = items.length(); i < l; i++ )
		{
			@ radio = items[i];
			if( valid( radio ) )
			{
				if( FLAG( radio.Flags, ITEM_RADIO ) )
				{
					cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_USE_RADIO );
					break;
				}
			}
		}
	}		
}

void unsafe_contmenu_callback( Critter& player, int id, int screenId, int actionId, string@ command, int[] @ myArr )
{
    player.StatBase[ ST_LAST_CRIT_ID ] = myArr[ ARRAY_ID_INDEX ];
    player.StatBase[ ST_OBJECT_TYPE ] = myArr[ ARRAY_OBJ_INDEX ];
    player.StatBase[ ST_ITEM_HEXX ] = myArr[ ARRAY_ITEM_HEXX ];
    player.StatBase[ ST_ITEM_HEXY ] = myArr[ ARRAY_ITEM_HEXY ];
    player.StatBase[ ST_ITEM_PID ] = myArr[ ARRAY_ITEM_PID ];


    switch( myArr[ ARRAY_SCREEN_INDEX ] )
    {
		case SCREEN_BAG:
			player.ShowScreen( myArr[ ARRAY_SCREEN_INDEX ], id, "context_callback@ScreenBag" );
			break;
		case SCREEN_SKILLBOX:
			player.ShowScreen( myArr[ ARRAY_SCREEN_INDEX ], id, "context_callback@ScreenSkillbox" );
			break;
		case ACTION_PICK_ITEM:
			Actions( player, myArr[ ARRAY_SCREEN_INDEX ], 0 );
			break;
		case ACTION_PICK_CRITTER:
			Actions( player, myArr[ ARRAY_SCREEN_INDEX ], myArr[ ARRAY_PICK_TYPE ] );
			break;
		case ACTION_DIR:
			Actions( player, myArr[ ARRAY_SCREEN_INDEX ], 0 );
			break;
		case ACTION_TALK:
			Actions( player, myArr[ ARRAY_SCREEN_INDEX ], 0 );
			break;
		case ACTION_FAST:
			Actions( player, myArr[ ARRAY_SCREEN_INDEX ], myArr[ ARRAY_SKILL_INDEX ] );
			break;
		default:
			break;
    }

}

//Log commands # $ ~
void unsafe_log( Critter& cr, int locX, int locY, int type, string@ message, int[] @ p4 )
{
    file f;
    if( f.open( "logs\\commandslog.txt", "a" ) >= 0 )
    {
        f.writeString( __Day + "." + __Month + "." + __Year + " " + MakeTime( __FullSecond ) + message + "\n" );
        f.close();
    }
	
	DiscordSendMessage( "gm_commandslog", "```" + message + "```" );
}

//Log GM panel actions
void unsafe_log_2( Critter& cr, int locX, int locY, int type, string@ message, int[] @ p4 )
{
    file f;
    if( f.open( "logs\\gm_panel.txt", "a" ) >= 0 )
    {
        f.writeString( __Day + "." + __Month + "." + __Year + " " + MakeTime( __FullSecond ) + message + "\n" );
        f.close();
    }
	
	DiscordSendMessage( "gm_panel", "```" + message + "```" );
}

//Digits input for ingame items
void unsafe_inputDigits( Critter& player, int itemId, int digits, int type, string@ param3, int[] @ param4 )
{
    Item@ item = GetItem( itemId );
	if( !valid( item ) )
	{
		return;
	}

	player.RunClientScript( "client_screen_numberpad@HideScreen", 0, 0, 0, "", null );

	uint16 Pid = item.GetProtoId();
	if( vending_machines.find( Pid ) != -1 )
	{
		if( type == 0 )
		{
			item.SELLING_PRICE = digits;
		}
		else
		{
			item.BUYING_PRICE = digits;
		}
		
		StartMenuVendingMachine( player, item );
	}
	else if( Pid == PID_TERMINAL )
	{
		if( type == 0 )
		{
			if( item.PASSWORD == 0 )
			{
				item.PASSWORD = digits;
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEW_PASSWORD, "$digits" + digits );
				LogCrimeMovement( player, item, "sets new password" );//  [" + item.PASSWORD + "]" ); 
			}
			else if( item.PASSWORD == digits )
			{
				item.CONSOLE_PASSWORD = 0;
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CORRECT_PASSWORD );
				LogCrimeMovement( player, item, "inputs correct password" );// [" + item.PASSWORD + "]" ); 
			}
			else
			{
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_PASSWORD );
				LogCrimeMovement( player, item, "inputs wrong password" ); //[" + digits + "] instead of [" + item.PASSWORD + "]"
			}
		}
		
		RestoreMenu( player, item );
	}
	else if( Pid == PID_TNT_PACK_ACTIVE || Pid == PID_REMOTE_DETONATOR || Pid == PID_GM_REMOTE_DETONATOR )
	{
		item.Val4 = digits;
		item.Val2 = player.Id;
		item.Update();
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MSG_NEW_FREQUENCY, "$digits" + digits );
	}
	else if( Pid == PID_SLAVE_COLLAR || Pid == PID_SLAVE_COLLAR_SWITCH )
	{
		item.Val5 = digits;
		item.Update();
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MSG_NEW_FREQUENCY, "$digits" + digits );
	}
	else if( Pid == PID_JUKEBOX1 || Pid == PID_JUKEBOX2 || Pid == PID_JUKEBOX3 || Pid == PID_JUKEBOX4 )
	{
		item.Val6 = digits;
		StartMenuJukebox( player, item );
	}
	else if( item.GetType() == ITEM_TYPE_DOOR || ( item.GetType() == ITEM_TYPE_CONTAINER && item.Proto.Container_Changeble ) ) 
	{
		SETFLAG( item.LockerCondition, LOCKER_ELECTRO );
		
		string pass = digits;
		uint len = pass.length() - 1;
		if( len <= 0 )
		{
			len = 4;
			digits = 1111;
			pass = digits;
		}
		
		item.Val1 = len;
		item.Val4 = digits;
		item.LockerComplexity = player.Skill[ SK_SCIENCE ];
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEW_CODE, "$code" + digits );
		
		if( param4[0] > 0 )
		{
			Item@ codelock = GetItem( param4[0] );
			if( valid( codelock ) )
			{
				//Log( "An item #" + item.Id + " is locked on a code lock. Lock complexity is: " + item.LockerComplexity + "." );
				LogCrimeMovement( player, item, "is locked on a code lock. Lock complexity is: " + item.LockerComplexity + "." );
				_SubItem( codelock, 1 );
			}
		}
	}
}

void unsafe_openCodeDoor( Critter& player, int itemId, int code, int param2, string@ param3, int[] @ param4 )
{
    Item@ item = GetItem( itemId );
    if( !valid( item ) )
	{
		return;
	}
	
    if( ( player.HexX < item.HexX + 2 || player.HexX > item.HexX - 2 ) && ( player.HexY < item.HexY + 2 || player.HexY > item.HexY - 2 ) )
	{
		if( param2 != 0 )
		{
            if( code >= pow( 10, item.Val1 ) )
			{
                item.Val4 = code;
				player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEW_CODE, "$digits" + code );
                return;
            }
			else
			{
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_UNACCEPTABLE_CODE );
                return;
            }
		}
        
		if( item.Val4 == code )
		{
            if( _LockerIsClose( item ) )
			{
                item.LockerOpen();
                player.RunClientScript( "client_screen_codedoor@HideScreen", 0, 0, 0, "", null );
				Map@ map = player.GetMap();
				if( item.GetType() == ITEM_TYPE_DOOR )
				{
					PlayDoorSound( map, item.HexX, item.HexY, item.GetProtoId(), item.LockerCondition, 15 );
					ToggleDoorBlocker( map, item, false );
				}
				
				if( item.GetType() == ITEM_TYPE_CONTAINER )
				{
					if( item.Proto.Container_Changeble )
					{
						PlayDoorSound( map, item.HexX, item.HexY, item.GetProtoId(), item.LockerCondition, 15 );
					}
					
					ShowContainer( player, item, item.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
				}
				
				LogCrimeMovement( player, item, "Enters correct password" ); 		
            }
		}
		else
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_CODE );
			RestoreMenu( player, item );
			LogCrimeMovement( player, item, "Enters wrong password" ); 			
		}
    }
	else
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_FAR );
	}
}

void unsafe_hex_attack( Critter& attacker, int hexX, int hexY, int weaponProto, string@ param3, int[] @ param4 )
{
	if( !attacker.IsLife() )
	{
		return;
	}
	
	if( attacker.Param[CR_IS_SHOOTING] != 0 )
	{
		return;
	}

	Map@ map = attacker.GetMap();
	if( !valid( map ) )
	{
        return;
	}

	if( attacker.Param[ CR_IS_RELAXING ] != 5 )
	{
		attacker.ParamBase[ CR_IS_RELAXING ] = 0;
	}
	
	attacker.ParamBase[ CR_IS_RELOADING ] = 0;
	
	Item@ hand = _CritGetItemHand( attacker );
    
	ProtoItem@ weapon = GetProtoItem( weaponProto );
	uint8 mode = attacker.Stat[ ST_HANDS_ITEM_AND_MODE ];
	
	if( valid( hand ) )
	{
		mode = hand.Mode;
		@weapon = GetProtoItem( hand.GetProtoId() );
	}
	
	if( !valid( weapon ) )
	{
		attacker.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_FIGHT );
		return;
	}
	
	//Log( "attacker " + attacker.Id + " hexX " + hexX + " hexY " + hexY + " weaponProto " + weaponProto );
	
	int weaponPerk = weapon.Weapon_Perk;
	int sneak_timeout = SNEAK_TIMEOUT( attacker );
	if( FLAG( weaponPerk, WEAPON_PERK_SILENT ) )
	{
		sneak_timeout /= 2;
	}
	
	attacker.ParamBase[ CR_SNEAKING ] = 0;
	attacker.TimeoutBase[ TO_SNEAK ] = sneak_timeout;

	if( attacker.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0 )
	{
		attacker.EraseTimeEvents( CTE_SLOWRELOAD );
		hand.SetEvent( ITEM_EVENT_MOVE, null );
	}

    uint16 toHx = hexX, toHy = hexY;
    int dist = GetDistantion( attacker.HexX, attacker.HexY, hexX, hexY );
	RustyGetHexCoord( map, attacker.HexX, attacker.HexY, toHx, toHy, 0.0f, dist );
	if( hexX != int( toHx ) || hexY != int( toHy ) )
    {
        attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_AIM_BLOCKED );
        return;
    }
	
	if( valid( hand ) )
	{
		bool brokenArm = attacker.Damage[ DAMAGE_LEFT_ARM ] + attacker.Damage[ DAMAGE_RIGHT_ARM ] > 0;
		bool brokenTwoArms = attacker.Damage[ DAMAGE_LEFT_ARM ] * attacker.Damage[ DAMAGE_RIGHT_ARM ] > 0;
		
		if( brokenTwoArms )
		{
			attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_DMG_TWO_ARMS );
			return;
		}

		if( FLAG( hand.Flags, ITEM_TWO_HANDS ) && brokenArm )
		{
			attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_DMG_ARM );
			return;
		}
	}
	
	int needAp = attack_ap( attacker, weapon, mode );
	bool HasAllAP = attacker.Stat[ ST_ACTION_POINTS ] == attacker.Stat[ ST_CURRENT_AP ];

	if( ( !HasAllAP && attacker.Stat[ ST_ACTION_POINTS ] < needAp ) || 
		( attacker.Stat[ ST_ACTION_POINTS ] >= needAp && attacker.Stat[ ST_CURRENT_AP ] < needAp ) &&
		  attacker.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 )
	{
		return;
	}
	
	uint windupTime = GetProtoWindupTime( weapon, mode, attacker );
	if( attacker.Param[ CR_AUTO_AIM ] == HIT_LOCATION_NONE )
	{
		windupTime /= 2;
	}
	
	if( windupTime == 0 )
	{
		windupTime == 300;
	}
	
	int skillNum = ( valid( weapon ) ? _WeaponSkill( weapon, 0 ) : ( valid( hand ) ? SK_MELEE_WEAPONS : SK_UNARMED ) );
	uint8 weaponType = ( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS ) ? WS_GUN : 
					( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
	int wpnMaxDist = _WeaponMaxDist( weapon, mode );
	
	ProtoItem@ ammo = null;
	
	if( weapon.Weapon_MaxAmmoCount > 0 )
	{
		if( hand.AmmoCount == 0 || hand.Deterioration == 10000 )
		{
			uint8 dir = GetDirection( attacker.HexX, attacker.HexY, toHx, toHy );
			attacker.SetDir( dir );

			if( weaponType == WS_GUN )
			{
				attacker.Action( ACTION_WINDUP, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | mode, valid( hand ) ? hand : null );
				attacker.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
			}
			else
			{
				attacker.Action( ACTION_USE_WEAPON, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | mode, valid( hand ) ? hand : null );
			}

			uint[] values = { attacker.Id, weapon.ProtoId };
			CreateTimeEvent( AFTER( REAL_MS( windupTime ) ), "e_emptySFX", values, false );
			attacker.ParamBase[ CR_IS_WINDUPED ] = 1;
			if( attacker.GetTimeEvents( CTE_WINDUP, null, null, null ) == 0 )
			{
				attacker.AddTimeEvent( "windup@cte_windup", 0, CTE_WINDUP, 0 );
			}
			
			return;
		}
		else
		{
			@ammo = GetProtoItem( hand.AmmoPid );
		}
	}
	
	if( weaponType == WS_GUN )
	{
		if( weapon.Item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER )
		{
			if( dist > wpnMaxDist )
			{
				attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_OUT_OF_RANGE );
				return;
			}
		}
		else if( valid( ammo ) && FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT ) )
		{
			if( dist > wpnMaxDist * 2 )
			{
				attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_OUT_OF_RANGE );
				return;
			}
		}
	}	
	else if( weaponType == WS_THROWING )
	{
		wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int( 10 ), attacker.Stat[ ST_STRENGTH ] ) );
		if( dist > wpnMaxDist )
		{
			attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_THROW_TOO_FAR );
			return;
		}
	}
	
    Critter@ target = map.GetCritter( uint16( hexX ), uint16( hexY ) );
	bool validTarget = valid( target );
	if( validTarget && target.Id == attacker.Id )
	{
		validTarget = false;
	}
	
	uint targetId = validTarget ? target.Id : 0;
	uint ammoPID = valid( ammo ) ? ammo.ProtoId : 0;
	attacker.SetDir( GetDirection( attacker.HexX, attacker.HexY, hexX, hexY ) );
	if( targetId == 0 )
	{
		@target = null;
	}		
	
	if( ( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS ) && dist > wpnMaxDist )
	{
		attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_OUT_OF_RANGE );
		return;
	}

	uint waitTime = _GetProtoWaitTime( weapon, mode );
	
	if( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS )
	{
		attacker.Wait( waitTime );
	}
    else if( attacker.Param[ CR_IS_WINDUPED ] == 0 && _WeaponAnim2( weapon, mode ) != ANIM2_AUTO )
    {
        if( _WeaponAnim2( weapon, mode ) == ANIM2_BURST )
		{
			attacker.Wait( windupTime + waitTime );
		}
		else
		{
			attacker.Wait( windupTime );
		}
    }
	else if( _WeaponAnim2( weapon, mode ) == ANIM2_AUTO )
	{
		if( attacker.Param[ CR_AUTO_ROUNDS_FIRED ] > 0 )
		{
			attacker.Wait( _GetProtoWaitTime( weapon, mode ) );
		}
		else
		{
			attacker.Wait( windupTime );
		}
	}
    else
    {
        attacker.Wait( 10 );
        windupTime = 0;
    }

	if( attacker.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 || skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS )
	{
		attacker.StatBase[ ST_CURRENT_AP ] -= needAp * 100;
	}
	
	if( _WeaponAnim2( weapon, mode ) == ANIM2_AUTO )
	{
		attacker.ParamBase[ CR_AUTO_ROUNDS_FIRED ] ++;
	}
	
	if( weapon.Windup_Time != 0 && !_ItemIsBroken( hand ) && GetDeteriorationProcent( hand ) < 100 )
	{
		attacker.Action( ACTION_WINDUP, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | mode, hand );
		attacker.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
		uint[] values = { attacker.Id, targetId, weapon.ProtoId, mode, ammoPID, hexX, hexY, 1, 0 };
		CreateTimeEvent( AFTER( REAL_MS( windupTime ) ), "combat@e_DelayedAttack", values, false );
		attacker.ParamBase[CR_IS_SHOOTING] = 1;
	}
	else
	{
		attacker.ParamBase[CR_IS_SHOOTING] = 0;
		CombatAttack( attacker, target, weapon, mode, ammo, hexX, hexY, false, false );
	}
}

void unsafe_critter_attack( Critter& attacker, int target_Id, int param1, int weaponProto, string@ param3, int[] @ param4 )
{
	if( !attacker.IsLife() )
	{
		return;
	}

	Critter@ target = GetCritter( target_Id );
	if( !valid( target ) )
	{
		return;
	}
	
	if( target_Id == int( attacker.Id ) )
	{
		return;
	}
	
	Item@ hand = _CritGetItemHand( attacker );
    
	ProtoItem@ weapon = GetProtoItem( weaponProto );
	uint8 mode = attacker.Stat[ ST_HANDS_ITEM_AND_MODE ];
	
	if( valid( hand ) )
	{
		mode = hand.Mode;
		@weapon = GetProtoItem( hand.GetProtoId() );
	}
	
	if( !valid( weapon ) )
	{
		return;
	}
	
	int needAp = attack_ap( attacker, weapon, mode );
	bool HasAllAP = attacker.Stat[ ST_ACTION_POINTS ] == attacker.Stat[ ST_CURRENT_AP ];

	if( ( !HasAllAP && attacker.Stat[ ST_ACTION_POINTS ] < needAp ) || 
		( attacker.Stat[ ST_ACTION_POINTS ] >= needAp && attacker.Stat[ ST_CURRENT_AP ] < needAp ) &&
		  attacker.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 )
	{
		return;
	}
	
	int skillNum = ( valid( weapon ) ? _WeaponSkill( weapon, 0 ) : ( valid( hand ) ? SK_MELEE_WEAPONS : SK_UNARMED ) );
	uint8 weaponType = ( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS ) ? WS_GUN : 
					( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
	ProtoItem@ ammo;
	if( weapon.Weapon_MaxAmmoCount > 0 )
	{
		@ammo = GetProtoItem( hand.AmmoPid );
	}

    int dist = GetDistantion( attacker.HexX, attacker.HexY, target.HexX, target.HexY );
	int wpnMaxDist = _WeaponMaxDist( weapon, mode );
	
	if( weaponType == WS_THROWING )
	{
		wpnMaxDist = MIN( wpnMaxDist, 3 * MIN( int( 10 ), attacker.Stat[ ST_STRENGTH ] ) );
	}
	
	//Log( "dist " + dist + " wpnMaxDist " + wpnMaxDist );
	if( ( valid( ammo ) && FLAG( ammo.Ammo_Perk, AMMO_PERK_SPREADSHOT ) ) )
	{
		if( dist > wpnMaxDist * 2 )
		{			
			attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_OUT_OF_RANGE );
			return;
		}
	}

	if( ( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS || skillNum == SK_THROWING || weapon.Item_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_FLAMETHROWER ) && dist > wpnMaxDist )
	{
		int run = attacker.Mode[ MODE_NO_RUN ] > 0 ? 0 : 1;
		int attack_dist = wpnMaxDist >= 2 ? wpnMaxDist - 1 : wpnMaxDist;
		attacker.RunClientScript( "client_main@__ChosenMoveToCritAction", target_Id, run, attack_dist, null, null );
		return;
	}
	
	if( ( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS ) && dist > wpnMaxDist )
	{
		attacker.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_OUT_OF_RANGE );
		return;
	}
	
	critter_attack( attacker, target, weapon, mode, ammo );
}

uint e_emptySFX( uint[]@ values )
{
	Critter@ cr = GetCritter( values[0] );
	int radius = 5;
	Critter@[] players;
	int hx = cr.HexX, hy = cr.HexY;
	cr.GetMap().GetCrittersHex( hx, hy, radius, FIND_ALL | FIND_ONLY_PLAYERS, players );
	int[] vals = { values[1], 4, radius };
	for( uint i = 0, len = players.length(); i < len; i++ )
	{
		Critter@ player = players[i];
		if( valid( player ) )
		{
			player.RunClientScript( "fofmod@__PlayWeaponSound", cr.Id, hx, hy, "LAUGHTE1.mp3", vals );
		}
	}
	
	players.resize(0);
	return 0;
}

void unsafe_hex_useItem( Critter& cr, int hexX, int hexY, int itm_pid, string@ command, int[] @ param4 )
{
	if( !cr.IsLife() )
	{
		return;
	}

	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
	Item@ usedItem = _CritGetItemHand( cr );	
	if( valid( usedItem ) )
	{
		uint16 usedItemPid = usedItem.GetProtoId();
		uint8 dir = GetDirection( cr.HexX, cr.HexY, hexX, hexY );
		cr.SetDir( dir );
		
		if( usedItemPid == PID_ROD_STRING_HOOK )
		{
			PrepareFishing( cr, usedItem, hexX, hexY );
		}
		
		if( GetDistantion( cr.HexX, cr.HexY, hexX, hexY ) > 1 )
		{
			MoveToHex( cr, map, usedItem, hexX, hexY );
			return;
		}
		
		if( usedItemPid == PID_SHOVEL || usedItemPid == PID_SPADE )
		{
			TryGetSand( cr, usedItem, hexX, hexY );
		}
		
		if( usedItemPid != PID_ROD_STRING_HOOK && checkWater( map, H2T( hexX ), H2T( hexY ) ) > 0 )
		{
			start_gathering_water( cr, 23541 );
		}
		
		if( farm_seeds.find( usedItemPid ) != -1 )
		{
			TryPlantSeed( cr, usedItem, hexX, hexY, null );
		}
		
		if( usedItem.GetType() == ITEM_TYPE_TRAP && usedItem.Proto.Item_Subtype == ITEM_SUBTYPE_MINE )
		{
			TryPlantMine( cr, usedItem, hexX, hexY );
		}
	}
}

void MoveToHex( Critter& cr, Map& map, Item& usedItem, uint16 hexX, uint16 hexY )
{
	uint16 hx = hexX, hy = hexY;
	uint8 revDir = GetDirection( hx, hy, cr.HexX, cr.HexY );
	map.MoveHexByDir( hx, hy, revDir, 1 );
	cr.RunClientScript( "client_main@__ChosenMoveAction", hx, hy, 2, null, null );
	uint[] values = { cr.Id, usedItem.Id, hexX, hexY };
	CreateTimeEvent( AFTER( REAL_MS( 500 ) ), "general_unsafe@e_WaitForIt", values, true );
}

uint e_WaitForIt( uint[] @ values ) 
{
	Critter@ cr = GetCritter( values[0] );
	if( MovementState( cr ) > 0 )
	{
		return REAL_MS( 300 );
	}
	
	Item@ usedItem = GetItem( values[1] );
	if( !valid( usedItem ) )
	{
		return 0;
	}
	
	uint16 hexX = values[2];
	uint16 hexY = values[3];
	
	uint8 dir = GetDirection( cr.HexX, cr.HexY, hexX, hexY );
	cr.SetDir( dir );
	uint16 usedItemPid = usedItem.GetProtoId();
	if( usedItemPid == PID_SHOVEL || usedItemPid == PID_SPADE )
	{
		TryGetSand( cr, usedItem, hexX, hexY );
	}
	
	if( farm_seeds.find( usedItemPid ) != -1 )
	{
		TryPlantSeed( cr, usedItem, hexX, hexY, null );
	}
	
	if( usedItem.GetType() == ITEM_TYPE_TRAP && usedItem.Proto.Item_Subtype == ITEM_SUBTYPE_MINE )
	{
		TryPlantMine( cr, usedItem, hexX, hexY );
	}
	
    return 0;
}

void unsafe_say( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ controlled = GetCritter( param0 );
    if( param1 != 1 && param1 != 5 && controlled.IsPlayer() )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_GM_ACCESS );
        return;
    }
	
    if( valid( controlled ) && controlled.ParamBase[ MERC_MASTER_ID ] != int( player.Id ) )
    {
        player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NEED_GM_ACCESS );
        return;
    }
	
    Say( player, param0, param1, 0 );
}

void unsafe_sleep( Critter& player, int isBack, int isRemote, int param2, string@ param3, int[] @ param4 )
{
	if( player.IsDead() )
	{
		player.ParamBase[ CR_SLEEPING_STATE ] = 0;
	} 
	else if( player.IsKnockout() && player.Param[ CR_SLEEPING_STATE ] > 0 )
    {
		if( player.Param[ CR_SLEEPING_STATE ] == 3 && isRemote == 0 )
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CANT_GET_UP );
			return;
		}
		player.ParamBase[ CR_SLEEPING_STATE ] = 0;
		player.ParamBase[ ST_CURRENT_AP ] = 0;
        player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_GET_UP );
		SayLog( player, crInfo( player ) + " gets up." );
    }
	else if( !player.IsKnockout() )
    {
        KnockoutOnce( player, isBack == 0, player.Stat[ ST_CURRENT_AP ] + 100 ); 
        player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_LIE_DOWN );
		SayLog( player, crInfo( player ) + " lies down." );
		player.ParamBase[ CR_SLEEPING_STATE ] = 1 + isBack;
		if( isRemote == 1 )
		{
			player.ParamBase[ CR_SLEEPING_STATE ] = 3;
		}
		
		Map@ map = player.GetMap();
		Item@[] mines;
		map.GetItems( player.HexX, player.HexY, mines );
		Item@ mine = null;
		for( uint i = 0, len = mines.length(); i < len; i++ )
		{
			@mine = mines[i];
			if( valid( mine ) )
			{
				uint16 pid = mine.GetProtoId();
				if( mine.GetType() == ITEM_TYPE_TRAP && ( pid == PID_ACTIVE_MINE || pid == PID_ACTIVE_MINE_PLASMA || pid == PID_ACTIVE_MINE_PULSE ) )
				{
					DetonateTrap( mine );
					break;
				}
			}
		}
		
		mines.resize(0);
    }
}

void unsafe_relax( Critter& player, int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	if( !player.IsLife() )
	{
		return;
	}
	
	hotkey_critter_anim( player, param0 );
}

//import void hotkey_critter_anim( Critter& cr, int param0 ) from "general_unsafe";
void hotkey_critter_anim( Critter& cr, int param0 )
{
	Map@ map = cr.GetMap();
	uint[] index;

	string sound = "ROBE.mp3";
	uint time = 1000;
	if( param0 > 0 )
	{
		string action_info = "" + param0;
		cr.ParamBase[ CR_IS_RELAXING ] = param0;
		cr.ParamBase[ CR_IS_WINDUPED ] = 0;
		
		switch( param0 )
		{
			case( 1 ):
			case( 2 ):
				sound = cr.Stat[ ST_GENDER ] == GENDER_MALE ?  "GenericM_KnockFront.wav" : ( cr.Stat[ ST_GENDER ] == GENDER_FEMALE ? "GenericF_KnockBack.wav" : "ROBE.mp3" );
				cr.Animate( 0, ANIM2_LIE_DOWN, null, false, true );
				action_info = "lies down to relax";
				break;
			case( 3 ):
			case( 4 ):
				cr.Animate( 0, ANIM2_LEAN_BEGIN, null, false, true );
				action_info = "leans forward";
				time = 300;
				break;
			case( 5 ):
			{
				cr.StatBase[ ST_CURRENT_AP ] -= 2000;
				if( !CheckCover( cr ) )
				{
					cr.ParamBase[ CR_IS_RELAXING ] = 8;
					action_info = "sits down";
				}
				else
				{
					action_info = "ducks in cover";
				}
				break;
			}
			case( 6 ):
				action_info = "fiddles hand on ground";
				time = 250;
				break;
			case( 7 ):
				action_info = "kneels";
				time = 250;
				break;
			case( 10 ):
				action_info = "doing squats";
				time = 250;
				break;
			case( 11 ):
				action_info = "flexing";
				time = 250;
				break;
			case( 9 ):
				action_info = "doing pushups";
				cr.Animate( 0, ANIM2_KNOCK_BACK, null, false, true );
				time = 750;
				break;
			case( 12 ):
				action_info = "doing abs";
				cr.Animate( 0, ANIM2_KNOCK_FRONT, null, false, true );
				time = 750;
				break;
			default:
				break;
		}

		if( cr.GetTimeEvents( CTE_RELAX, index, null, null ) == 0 )
		{
			cr.AddTimeEvent( "cte_unsafe_relax", REAL_MS( time ), CTE_RELAX, param0 );
		}

		SayLog( cr, crInfo( cr ) + " " + action_info + "." );
		PlayGenericSound( map, cr.HexX, cr.HexY, sound, 6 );
	}
	else
	{
		SayLog( cr, crInfo( cr ) + " stands up straight." );
		switch( cr.Param[ CR_IS_RELAXING ] )
		{
			case( 1 ):
			case( 2 ):
				sound = cr.Stat[ ST_GENDER ] == GENDER_MALE ?  "GenericM_Standup.wav" : ( cr.Stat[ ST_GENDER ] == GENDER_FEMALE ? "GenericF_Standup.wav" : "ROBE.mp3" );
				cr.Animate( 0, ANIM2_LIE_UP, null, false, false );
				break;
			case( 3 ):
			case( 4 ):
				cr.Animate( 0, ANIM2_LEAN_END, null, false, true );
				break;
			case( 5 ):
			case( 6 ):
			case( 7 ):
			case( 8 ):
			case( 9 ):
			case( 10 ):
			case( 11 ):
			case( 12 ):
				cr.Animate( 0, ANIM2_KNEEL_END, null, false, true );
				break;							
			default:
				break;
		}
		
		if( cr.GetTimeEvents( CTE_RELAX, index, null, null ) > 0 )
		{
			cr.EraseTimeEvents( CTE_RELAX );
			cr.AddTimeEvent( "cte_unsafe_relax", REAL_MS( 1000 ), CTE_RELAX, 0 );
		}
		
		PlayGenericSound( map, cr.HexX, cr.HexY, sound, 6 );
	}
}

uint cte_unsafe_relax( Critter& player, int identifier, uint& rate )
{
	switch( player.Param[ CR_IS_RELAXING ] )
	{
		case( 1 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_LYING );
			break;
		case( 2 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_LYING1 );
			break;
		case( 3 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_LEANING );
			break;
		case( 4 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_LEANING1 );
			break;
		case( 5 ):
		case( 8 ):
		{
			if( player.Param[ ST_BODY_TYPE ] > BT_GHOUL )
			{
				player.SetAnims( COND_LIFE, 0, ANIM2_DUCK );
			}
			else
			{
				player.SetAnims( COND_LIFE, 0, ANIM2_KNEEL );
			}
			break;
		}
		case( 6 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_KNEEL1 );
			break;
		case( 7 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_KNEEL2 );
			break;
		case( 9 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_PRONE_SEX );
			break;
		case( 10 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_ORAL );
			break;
		case( 11 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_ORAL_RECIEVE );
			break;
		case( 12 ):
			player.SetAnims( COND_LIFE, 0, ANIM2_SEX_RECIEVE );
			break;
		default:
			break;
	}

	if( ( player.Param[ CR_IS_RELAXING ] == 5 && ( MovementState( player ) == MOVE_STATE_RUN || !CheckCover( player ) ) ) 
		|| ( player.Param[ CR_IS_RELAXING ] != 5 && MovementState( player ) > MOVE_STATE_STILL ) 
		|| rate == 0 
		|| player.Param[ CR_IS_WINDUPED ] != 0
	  )
	{
		player.ParamBase[ CR_IS_RELAXING ] = 0;
		player.ParamBase[ CR_IN_COVER ] = 0;
		if( player.Param[ CR_IS_WINDUPED ] == 0 )
		{
			player.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
		}
		return 0;
	}
	
	return REAL_MS( 500 );
}

bool CheckCover( Critter& player )
{
	Map@ map = player.GetMap();
	if( !valid( map ) )
	{
		return false;
	}
	
	uint count = 0;	
	for( uint16 i = 0; i < 6; i++ )
	{
		uint16 hx = player.HexX, hy = player.HexY;
		map.MoveHexByDir( hx, hy, i, 1 );
		uint coverType = 0;
		if( !map.IsHexPassed( hx, hy ) )
		{
			bool noCover = false;
			
			FindData@[] allData;
			GetHexProtos( map, hx, hy, allData );
			for( uint j = 0, len = allData.length(); j < len; j++ )
			{
				ProtoItem@ protoItem = allData[j].Proto;

				if( FLAG( protoItem.Flags, ITEM_NO_BLOCK ) )
				{
					continue;
				}
				
				switch( protoItem.Material )
				{
					case( MATERIAL_WOOD ):
					{
						if( coverType < 2 )
						{
							coverType = 2;
						}
						break;
					}
					case( MATERIAL_METAL ):
					{
						if( coverType < 3 )
						{
							coverType = 3;
						}
						break;
					}
					case( MATERIAL_STONE ):
					case( MATERIAL_CEMENT ):
					{
						if( coverType < 4 )
						{
							coverType = 4;
						}
						break;
					}
					case( MATERIAL_DIRT ):
					{
						break;
					}
					case( MATERIAL_VOID ):
					{
						noCover = true;
						coverType = 0;
						break;
					}
					default:
					{
						if( coverType < 1 )
						{
							coverType = 1;
						}
						break;
					}
						break;
				}
				
				if( noCover || coverType == 4 )
				{
					break;
				}
			}
			
			allData.resize(0);
		}
		player.ParamBase[ CR_IN_COVER ] = SET_COVER_TYPE( coverType, i, player.ParamBase[ CR_IN_COVER ] );
		if( coverType != 0 )
		{
			count++;
		}
	}
	
	if( count == 0 )
	{
		return false;
	}
	
	return true;
}

//Proto array collector
class FindData
{
	FindData( uint16 protoid )
	{
		@Proto = GetProtoItem( protoid );
	}

	ProtoItem@ Proto;
}

class FindDataSceneryClient : FindData
{
	FindDataSceneryClient( SceneryClient@ val )
	{
		super( val.ProtoId );
	}
}

class FindDataItem : FindData
{
	FindDataItem( Item@ val )
	{
		super( val.Proto.ProtoId );
	}
}

void GetHexProtos( Map@ map, uint16 hexX, uint16 hexY, FindData@[]& array )
{
	SceneryClient@[] sceneries;
	uint iend = map.GetWalls( hexX, hexY, sceneries );

	iend += map.GetSceneryClients( hexX, hexY, sceneries );

	for( uint i = 0; i < iend; i++ )
	{
		array.insertLast( FindDataSceneryClient( sceneries[i] ) );
	}
	
	Item@[] items;
	iend = map.GetItems( hexX, hexY, items );

	for( uint i = 0; i < iend; i++ )
	{
		array.insertLast( FindDataItem( items [i] ) );
	}

}

#define hex_width ( 16 )
#define hex_height ( 12 )
void offsetItem( Item& item, int[] data )
{
	float zoom = data[0] / 1000.0f;
	int dx = int( data[1] * zoom );
	int dy = int( data[2] * zoom );
	
	int hx = data[3];
	if( int( item.HexX ) != hx )
	{
		int dHx = item.HexX - hx;
		
		int sign = ( dHx > 0 ? +1 : -1 );
		int min = MIN( hx, int( item.HexX ) );
		int max = MAX( hx, int( item.HexX ) );
		
		int delta = ( max - min );
		int pairs = int( delta / 2 );
		dx += pairs * hex_width * 3 * sign;
		dy -= pairs * hex_height * sign;
		
		if( delta % 2 != 0 )
		{
			if( max % 2 == 0 )
			{
				dx += hex_width * sign;
				dy -= hex_height * sign;
			}
			else
			{
				dx += hex_width * 2 * sign;					
			}
		}
	}
		
	int hy = data[4];
	if( int( item.HexY ) != hy )
	{
		int dHy = item.HexY - hy;
		
		dx -= ( dHy * hex_width );
		dy -= ( dHy * hex_height );
	}

	offset( item, dx, dy );
}

void unsafe_itemthrow( Critter& player, int hx, int hy, int precision, string@ param3, int[]@ data ) 
{
	if( player.IsBusy() || (player.Stat[ ST_CURRENT_AP ] < 50 && player.Stat[ ST_ACTION_POINTS ] > 50 ) )
	{
		return;
	}
	
	bool offsetting = true;
	bool IsGM = isGM(player);
	bool precise_throw = ( precision != 0 ) || IsGM;
	
	uint16 tx = hx, ty = hy;
	uint distance = GetDistantion( player.HexX, player.HexY, hx, hy );
	if( distance > 10 && !IsGM )
	{
		precise_throw = false;
	}
	
	Map@ currentMap = player.GetMap();

	if( !valid( currentMap ) || player.IsDead() || player.IsKnockout() || ( !IsGM && distance > uint( player.Stat [ ST_STRENGTH ] * 2 ) ) )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_FAR_TO_THROW );
		return;
	}
	
	RustyGetHexCoord( currentMap, player.HexX,  player.HexY, tx, ty,  0.0f, distance );

	bool obstructed_path = ( ( int(tx) != hx ) || ( int(ty) != hy ) );
	if( obstructed_path && distance > 10 && !IsGM )
	{
		offsetting = false;
		precise_throw = false;
	}
	
	Critter@ target = currentMap.GetCritter( tx, ty );

	Item@[] items;
	Item@ container;
	uint count = currentMap.GetItems( tx, ty, items );
	for( uint i = 0; i < count; i++ )
	{
		if( items[i].GetType() == ITEM_TYPE_CONTAINER && ( !items[i].Proto.Container_Changeble || FLAG( items[i].LockerCondition, LOCKER_ISOPEN ) ) )
		{
			@container = @items[i];
			break;
		}
	}
	
	if( precise_throw || ( !currentMap.IsHexPassed( tx, ty ) && !valid(target) && !valid(container) ) )
	{
		RustyGetHexCoordWall( currentMap, player.HexX, player.HexY, tx, ty,  0.0f, distance );
				
		uint32 target_item_id = MAKELONG( data[5], data[6] );
		if( target_item_id != 0 )
		{
			Item@ target_item = GetItem( target_item_id );
			
			if( valid( target_item ) )
			{
				tx = target_item.HexX;
				ty = target_item.HexY;
				
				if( target_item.GetType() == ITEM_TYPE_CONTAINER && ( !target_item.Proto.Container_Changeble || FLAG( target_item.LockerCondition, LOCKER_ISOPEN ) ) )
				{
					@container = @target_item;
				}
			}

		}
	}
	
	Item@ itemInHand = _CritGetItemHand( player );
	if( !valid( itemInHand ) )
	{
		return;
	}
	
	uint pid = itemInHand.GetProtoId();
	uint[] impossibles = { PID_WORKBENCH_TOKEN, PID_FIREPLACE_TOKEN, PID_AMMOBENCH_TOKEN };
	if( impossibles.find( pid ) > -1 || ( itemInHand.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE && itemInHand.BONDAGE_STATE == BONDAGE_STATE_ON ) )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_THROW );
		return;
	}

	SayLog( player, crInfo( player ) + " throws " + itemName( pid ) + " to (" + tx + ":" + ty + ")." );
	
	player.MoveItem( itemInHand.Id, 1, SLOT_INV );
	if( itemInHand.IsStackable() )
	{
		player.MoveItem( itemInHand.Id, 1, SLOT_HAND1 );
	}
	
	player.SetDir( GetDirection( player.HexX, player.HexY, tx, ty ) );
	if( valid( target ) && !target.IsDead() && !target.IsKnockout() )
	{
		bool targetFreeHands = !valid(_CritGetItemHand ( target ));
		if( targetFreeHands && CanCatch( target, itemInHand ) && !( target is player ) && !target.IsNpc() )
		{
			MoveItem( itemInHand, 1, target );
			target.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_CATCHES );
		}
		else
		{
			throw_on_ground( player, itemInHand, currentMap, tx, ty, pid, offsetting, data );
			if( !( target is player ) ) 
			{ 
				target.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_CATCH_FAIL );
			}
		}
		ChangeCritterSpeed( target );
	}
	else
	{
		if( precise_throw )
		{ //New "Alt-J" throw - precise placement over any item/container, without breaking "thrown" item;
			throw_on_ground( player, itemInHand, currentMap, tx, ty, pid, offsetting, data );
		}
		else if( pid == PID_OIL_LAMP && itemInHand.Val0 != 0 )
		{ //Thrown lighted oil lamps - explodes;
			_SubItem( itemInHand, 1 );
			GenerateFire( currentMap, tx, ty, 1, 1, player.Id );
		}
		else if( find_any_glass( itemInHand ) != 0 || itemInHand.Proto.Material == MATERIAL_GLASS )
		{ //Thrown glass items - shatters them;
			uint break_chance = Random( 1, 100 );
			if ( break_chance >= 20 )
			{
				currentMap.PlaySound( glass_break_sounds[ Random( 0, glass_break_sounds.length() -1 ) ], tx, ty, 10 );
				uint total_break_chance = Random( 0, 2 );
				
				if( total_break_chance != 2 || itemInHand.Proto.Material == MATERIAL_GLASS )
				{
					currentMap.SetTextMsg( tx, ty, COLOR_LGRAY, TEXTMSG_TEXT, STR_MAPMSG_BREAKS );
				}
				else
				{
					Item@ item = currentMap.AddItem( tx, ty, PID_ROSETTE, 1 );
					if( offsetting ) offsetItem( item, data ); else offset( item, 0, 0 );				
				}
				_SubItem( itemInHand , 1 );
			}
			else
			{
				throw_on_ground( player, itemInHand, currentMap, tx, ty, pid, offsetting, data );
			}
		}
		else
		{ //Default "J"-throw - unprecise throw on the ground below cursor;
			throw_on_ground( player, itemInHand, currentMap, tx, ty, pid, offsetting, data );
		}
	}
	
	if( IsGM ) return;

	currentMap.RunFlyEffect( _WeaponEffect( GetProtoItem(PID_FRAG_GRENADE), _WeaponModeUse (0) ), player, target, player.HexX, player.HexY, tx, ty );
	_CritAnimateThrow( player );	
	player.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_THROW );
	player.Wait( 200 * 5 ); 
	player.ParamBase[ ST_CURRENT_AP ] -= 50 * 100;
	ChangeCritterSpeed( player );
}

void throw_on_ground( Critter& player, Item& itemInHand, Map& currentMap, uint16 tx, uint16 ty, uint pid, bool offsetting, int[]@ data )
{
	if( itemInHand.IsStackable() )
	{
		_SubItem( itemInHand, 1 );
		Item@ thrownItem = currentMap.AddItem( tx, ty, pid, 1 );
		if( offsetting ) offsetItem( thrownItem, data );				
		else
		{
			uint[] values = { thrownItem.Id };
			CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "critter_item_movement@e_stack_items", values, true );
		}
	}
	else
	{
		MoveItem( itemInHand, 1, currentMap, tx, ty );
		if( offsetting ) offsetItem( itemInHand, data ); else offset( itemInHand, 0, 0 );
	}	
}

void unsafe_setAFK( Critter& player, int param0, int param1, int param2, string@ text, int[]@ param4 )
{
    if( !valid(text) || text == "" )
	{
		player.SetLexems( null );
		
		player.ParamBase[ CR_AFK_MODE ] = 0;
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CHANGE_DISABLED_AFK );
		SayLog( player, crInfo( player ) + " disabled AFK" );
	}
	else
	{
		string@ lexem = player.GetLexems();
		uint index = findFirstOf( lexem, "_", 0 );
		string oldLex = substring( lexem, 0, index );
		player.SetLexems( lexem_length_check( oldLex + "_" + text ) );
		
		player.ParamBase[ CR_AFK_MODE ] = 1;
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CHANGE_LEX_AFK );
		SayLog( player, crInfo( player ) + " AFK: " + text );
	}
	
	player.AddTimeEvent( "player_menu@cte_AFK_mode", 0, CTE_AFK, 0 );
}

void unsafe_selfLex( Critter& player, int param0, int param1, int param2, string@ text, int[]@ param4 )
{
	player.ParamBase[ CR_AFK_MODE ] = 0;

    if( !valid(text) || text == "" )
	{
		player.SetLexems( null );
	}
	else
	{
		player.SetLexems( lexem_length_check(text) );
	}
	
	player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CHANGE_LEX_SELF );
}

void unsafe_pushing( Critter& player, int type, int param1, int param2, string@ param3, int[] @ param4 )
{
	if( player.IsBusy() || player.IsDead() || player.IsKnockout() || player.StatBase[ ST_CURRENT_AP ] < 0 || player.Mode[ MODE_NO_PVP ] != 0 )
	{
		return;
	}
	
	Map@ map = player.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
	uint16 x = player.HexX, y = player.HexY;
	map.MoveHexByDir( x, y, player.Dir, 1 );
	Critter@ target = map.GetCritter( x, y );
	
	if( valid( target ) && target.Mode[ MODE_NO_PVP ] == 0 )
	{
		player.Wait( 1000 );
		player.Action( ACTION_PICK_CRITTER, 2, null );
		player.ParamBase[ ST_CURRENT_AP ] -= 5000;
		
		if( ( target.IsPlayer() || ( target.IsNoPlanes() && target.GetTalkedPlayers( null ) == 0 ) ) && target.Mode[MODE_NO_PUSH] == 0 )
		{
			if( target.IsDead() || target.IsKnockout() )
			{
				map.MoveHexByDir( x, y, player.Dir, 1 );
				target.TransitToHex( x, y, player.Dir, 0 );
			}
			else
			{
				target.MoveToDir( player.Dir );
			}
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PUSH_TARGET );
			SayLog( player, crInfo( player ) + " pushes " + crInfo( target ) + "." );
		}
		else
		{
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TARGET_RESIST );
			SayLog( player, crInfo( player ) + " with no success tried to push: " + crInfo( target ) + "." );
		}
	}
}

void unsafe_getNaked( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	getNaked( player );
}

void getNaked( Critter& cr )
{
	if( cr.ParamBase[ ST_BODY_TYPE ] >= BT_SUPER_MUTANT ) //not man, woman, child
	{
		return;
	}
	bool isMale = ( cr.Stat[ ST_GENDER ] == GENDER_MALE );
	uint crType = cr.Stat[ ST_BASE_CRTYPE ];

	if( true )
	{
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_UNDRESS );
		cr.Animate( 0, ANIM2_USE, null, false, true );
		cr.Animate( 0, ANIM2_PICKUP, null, false, true );
		
		Item@ armor = cr.GetItem( 0, SLOT_ARMOR );
		
		if( valid( armor ) )
		{
			_CritMoveItem( cr, armor, SLOT_INV );
		}
		else
		{
			cr.ParamBase[ ST_BASE_CRTYPE ] = isMale ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F;
			cr.ChangeCrType( isMale ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
		}
	}
}

void unsafe_KnockSay( Critter& cr, int sayType, int param1, int param2, string@ message, int[]@ param4 ) 
{ 
	cr.Say( sayType, message );
}

void unsafe_PetCommand( Critter& cr, int num, int val, int to, string@ message, int[]@ param4 ) 
{
	cr.SendMessage( num, val, to );
}

void unsafe_animation( Critter& cr, int type, int val, int targetId, string@ param3, int[]@ param4 )
{
	Critter@ target = @cr;
	if( isGM( cr ) && targetId != 0 )
	{
		@target = GetCritter( targetId );
	}
	
	if( !valid( target ) || target.IsDead() || target.IsKnockout() )
	{
		return;
	}
	
	if( type == ACTION_WINDUP )
	{
		ChangeWindup( target, false );
	}
	else
	{
		if( isGM( cr ) )
		{
			target.Action( type, val == 0 ? Random( 0, 1 ) : val - 1, null );
		}
		else
		{
			if( target.Stat[ ST_CURRENT_AP ] >= 20 )
			{
				target.Action( type, val == 0 ? Random( 0, 1 ) : val - 1, null );
				target.ParamBase[ ST_CURRENT_AP ] -= 20 * 100;
				target.Wait( 200 );
			}
		}
	}
}

void unsafe_addLexem( Critter& player, int itemId, int param1, int param2, string@ text, int[]@ param4 )
{
	player.StatBase[ ST_LAST_DOOR_ID ] = 0;
	
	Item@ item;
	if( itemId != 0 )
	{
		@item = GetItem( itemId );
	}
	else
	{
		@item = _CritGetItemHand( player );
	}
	
    if( !valid( item ) )
	{
		return;
	}
	
	uint type = item.GetType();
	bool isFurniture = ( type == ITEM_TYPE_DOOR || type == ITEM_TYPE_CONTAINER );
	
	if( !valid( text ) || text.length() < 2 )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ILEX_CLEARED );
		setLexDesc( item, "" );
		
		if( isFurniture )
		{
			setOverridenDesc( item, false );
		}
	}
	else
	{
		string desc = getLexDescRaw( item );
		setLexDesc( item, desc + text );

		if( isFurniture )
		{
			setOverridenDesc( item, true );
		}
		
		text = checkNull( Item_GetLexems( item ), "" );
		int remaining = 126 - text.length();
		player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ILEX_EXPANDED, "$remaining" + remaining );
	}
}

void unsafe_toglobal( Critter& cr, int, int, int, string@, int[]@ )
{
	if( isGM( cr ) )
	{
		cr.TransitToGlobal(false);
	}
}

void unsafe_VoiceVolumeAdjust( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	if( player.Stat[ ST_SPEECH_VOLUME ] == 50 && param0 == 5 )
	{
		return;
	}
	
	if( player.Stat[ ST_SPEECH_VOLUME ] == 0 && param0 == -5 )
	{
		return;
	}
	
	int var = CLAMP( player.StatBase[ ST_SPEECH_VOLUME ] + param0, 0, 50 );
	player.StatBase[ ST_SPEECH_VOLUME ] = var;
	uint hexes = CLAMP( 50 - var, 1, 50 );
	player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_VOICE_VOLUME, "$hexes" + hexes );
}

void unsafe_store_last_checked_item( Critter& cr, int itemId, int type, int, string@, int[]@ )
{
    cr.ParamBase[ CR_TARGET_CONTAINER_ID ] = itemId;
}

void unsafe_rolling( Critter& player, int param0, int param1, int param2, string@ param3, int[]@ param4 )
{
	roll( player, param0, param1, param2 );
}

void unsafe_rolling_GM( Critter& gm, int param0, int param1, int param2, string@ param3, int[]@ vals )
{
	if( !valid(vals) || vals.length() != 4 )
	{
		return;
	}
	
	Critter@ cr = GetCritter( vals[3] );
	if( !valid( cr ) )
	{
		return;
	}
	
	roll( cr, vals[0], vals[1], vals[2], gm.Id );
}

void roll( Critter& cr, int stat, int n, int val, int roller_id = 0 )
{
	if( stat < 0 || stat > 7 || n < 0 || val < 0 )
	{
		return;
	}
	
	uint statMsg;
	string result;
	int summ = 0;
	if( stat > 0 && stat < 8)
	{
		statMsg = STR_STAT_ROLL( stat );
		summ += cr.Stat[stat - 1];
	}
	
	if( n != 0 && val != 0 )
	{
		result += stat != 0 ? " + " : "";
		result += n + "d" + val + " =";
		for( int i = 0; i < n; i++ )
		{
			summ += Random( 1, val );
		}
		result += " " + summ;
	}
	else
	{
		result += " " + summ;
	}
	
	string info = "";
	if( roller_id != 0 )
	{
		Critter@ gm = GetCritter( roller_id );
		if( valid( gm ) )
		{
			info += "{ " + crInfo( gm ) + " } " ;
		}
	}
	
	info += crInfo( cr ) + " rolls ";
	if( stat != 0 )
	{
		cr.SayMsg( SAY_NORM, TEXTMSG_TEXT, statMsg, "$result" + result );
		info += PARAM_NAME(stat-1);
	}
	else
	{
		cr.Say( SAY_NORM, "|0xA6EEF900 " + result );
	}
	info += result;
	SayLog( cr, info );
}

void unsafe_InitSexState( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ CR_INIT_SEX ] = 1;
}

void unsafe_InitDevourState( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ CR_INIT_DEVOUR ] = 1;
}

void unsafe_StopNamingState( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ CR_REMEMBERING_NAME ] = 0;
}

void unsafe_FullAutoStop( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ CR_AUTO_ROUNDS_FIRED ] = 0;
	player.Wait( 0 );
}

void unsafe_SelectPetTarget( Critter& player, int command, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ CR_SELECT_PET_TARGET ] = command;
}

void unsafe_StopSelectPetTarget( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	player.ParamBase[ CR_SELECT_PET_TARGET ] = 0;
}

void unsafe_ToggleVoiceRadius( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	FLAG( player.Param[ PLAYER_FLAGS ], PLAYER_FLAG_VOICE_R ) ? UNSETFLAG( player.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_VOICE_R ) : SETFLAG( player.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_VOICE_R );
}

void unsafe_ToggleWeaponRadius( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	FLAG( player.Param[ PLAYER_FLAGS ], PLAYER_FLAG_WEAPON_R ) ? UNSETFLAG( player.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_WEAPON_R ) : SETFLAG( player.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_WEAPON_R );
}

void unsafe_turn_critter( Critter& player, int hexX, int hexY, int param2, string@ param3, int[] @ param4 )
{
	if( player.IsLife() )
	{
		uint8 dir = GetDirection( player.HexX, player.HexY, hexX, hexY );
		player.SetDir( dir );
		player.Wait( 500 );
		LookDataRefresh( player );
	}
}

void unsafe_SendGuitTabs( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ fets )
{
	Critter@[] critters;
    int count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, 15, FIND_ALL | FIND_ONLY_PLAYERS, critters );
	
	for(int i = 0; i < count; i++)
	{
		if(player.Id == critters[i].Id) continue;
		critters[i].RunClientScript( "client_guitar@RecvGuitTabs", player.Id, param1, 0, null, fets );
	}
}

class CmdDef
{
	string Cmd;
	uint8 Id;

	CmdDef(string@ cmd, uint8 id)
	{
		this.Cmd = cmd;
		this.Id = id;
	}
}

class CmdDefArray
{
	CmdDef@[] array;
	uint len = 0;

	CmdDefArray@ AddEntry( CmdDef@ entry )
	{
		return this.AddEntry( entry.Cmd, entry.Id );
	}

	CmdDefArray@ AddEntry( string cmd, uint8 id )
	{
		array.insertLast( CmdDef( cmd, id ) );
		len++;
		return this;
	}

	int GetCommandType( string@ command )
	{
		int res = -1;
		int findres = -1;
		for( uint i = 0; i < len; i++ )
		{
			CmdDef@ currEntry = array[i];
			findres = findFirst( command, array[i].Cmd );
			if( findres != -1 )
			{
				res = currEntry.Id;
			}
		}
		
		return res;
	}
}

CmdDefArray cmdDef;
bool isCmdDefInited = false;

void InitCmdDef()
{
	cmdDef.AddEntry("exit", CMD_EXIT)
	.AddEntry("myinfo", CMD_MYINFO)
	.AddEntry("gameinfo", CMD_GAMEINFO)
	.AddEntry("id", CMD_GAMEINFO)
	.AddEntry("move", CMD_MOVECRIT)
	.AddEntry("kill", CMD_KILLCRIT)
	.AddEntry("disconnect", CMD_DISCONCRIT)
	.AddEntry("toglobal", CMD_TOGLOBAL)
	.AddEntry("respawn", CMD_RESPAWN)
	.AddEntry("param", CMD_PARAM)
	.AddEntry("getaccess", CMD_GETACCESS)
	.AddEntry("additem", CMD_ADDITEM)
	.AddEntry("additemself", CMD_ADDITEM_SELF)
	.AddEntry("ais", CMD_ADDITEM_SELF)
	.AddEntry("addnpc", CMD_ADDNPC)
	.AddEntry("addloc", CMD_ADDLOCATION)
	.AddEntry("reloadscripts", CMD_RELOADSCRIPTS)
	.AddEntry("loadscript", CMD_LOADSCRIPT)
	.AddEntry("load", CMD_LOADSCRIPT)
	.AddEntry("reloadclientscripts", CMD_RELOAD_CLIENT_SCRIPTS)
	.AddEntry("rcs", CMD_RELOAD_CLIENT_SCRIPTS)
	.AddEntry("runscript", CMD_RUNSCRIPT)
	.AddEntry("run", CMD_RUNSCRIPT)
	.AddEntry("reloadlocations", CMD_RELOADLOCATIONS)
	.AddEntry("loadlocation", CMD_LOADLOCATION)
	.AddEntry("reloadmaps", CMD_RELOADMAPS)
	.AddEntry("loadmap", CMD_LOADMAP)
	.AddEntry("regenmap", CMD_REGENMAP)
	.AddEntry("reloaddialogs", CMD_RELOADDIALOGS)
	.AddEntry("loaddialog", CMD_LOADDIALOG)
	.AddEntry("reloadtexts", CMD_RELOADTEXTS)
	.AddEntry("reloadai", CMD_RELOADAI)
	.AddEntry("checkvar", CMD_CHECKVAR)
	.AddEntry("cvar", CMD_CHECKVAR)
	.AddEntry("setvar", CMD_SETVAR)
	.AddEntry("svar", CMD_SETVAR)
	.AddEntry("settime", CMD_SETTIME)
	.AddEntry("ban", CMD_BAN)
	.AddEntry("deleteself", CMD_DELETE_ACCOUNT)
	.AddEntry("changepassword", CMD_CHANGE_PASSWORD)
	.AddEntry("changepass", CMD_CHANGE_PASSWORD)
	.AddEntry("dropuid", CMD_DROP_UID)
	.AddEntry("drop", CMD_DROP_UID)
	.AddEntry("log", CMD_LOG);

	isCmdDefInited = true;
}

void unsafe_TryLogCommand( Critter& player, int param0, int param1, int param2, string@ command, int[] @ param4 )
{
	if(!isCmdDefInited)
	{
		InitCmdDef();
	}

	int findRes = cmdDef.GetCommandType(command);
	if(findRes == -1)
	{
		return;
	}

	if(!isGM(player) || !player_allowcommand(player, null, findRes))
	{
		return;
	}

	SayLogGM(player, crInfo(player) + " Using command: '" + command + "'" );

}

#endif // GENERAL_UNSAFE