#ifndef ENERGY_H
#define ENERGY_H

	#define ITEM_CUR_CHARGE Val1
	
	// start energyCells data
	const uint[] energyCells 		= { PID_ATOMIC_CELL	, PID_MICRO_FUSION_CELL	, PID_SMALL_ENERGY_CELL	, PID_CUENCELL_LOW	};
	const int[] EnergyChargeByCell	= {		500			,			300			,			100			,		50			};
	
	int GetChargeByBatteryPid( uint16 batteryPid )
	{
		// Public entry point.
		// Returns the charge amount provided by a battery with the given PID.
		// Looks up PID in the supported battery table and returns the mapped charge
		const int idx = energyCells.find( batteryPid );
		return ( idx >= 0 ? EnergyChargeByCell[ idx ] : 0 );
	}
	// end energyCells data
	
	// start RechargeGroup data
	enum RechargeGroup
	{
		// Rechargeable item groups (logical categories). 
		// Rules are applied per group instead of per-item PID.	
		
		RG_None = 0,			// Not a supported group
		RG_FlashlightBuiltIn,	// Built-in flashlight (perk-based)
		RG_Geiger,				// Geiger counter
		RG_Sensor,				// Motion sensor (include active variant)
		RG_Defib				// Reanimation kit
	}

	const int[] MaxChargeByGroup =
	{
		// Charge_max per group, indexed by RechargeGroup.
		0,    // RG_None
		200,  // RG_FlashlightBuiltIn
		400,  // RG_Geiger
		400,  // RG_Sensor
		300   // RG_Defib
	};
	
	int GetMaxChargeForGroup( RechargeGroup group )
	{
		// Public entry point.
		// Returns the maximum allowed charge for the given rechargeable item group.
		// Uses the group value as an index into `MaxChargeByGroup`; returns 0 if the index is out of range.
		const uint idx = uint( group );
		return ( idx < MaxChargeByGroup.length() ? MaxChargeByGroup[ idx ] : 0 );
	}
	
	RechargeGroup GetRechargeGroup( Item& rechargeableItem )
	{
		// Public entry point.
		// Detects rechargeable group for an item (perk-based built-in flashlight first, then PID-based devices).
		
		if ( !valid( rechargeableItem ) )
		{
			return RG_None;
		}

		if ( FLAG( rechargeableItem.Proto.HeadItem_Perk, HEAD_PERK_FLASHLIGHT ) || FLAG( rechargeableItem.Proto.Weapon_Perk, WEAPON_PERK_FLASHLIGHT ) )
		{
			return RG_FlashlightBuiltIn;
		}

		uint16 pid = rechargeableItem.GetProtoId();
		if ( pid == PID_GEIGER_COUNTER ) 
		{
			return RG_Geiger;
		}
		
		if ( pid == PID_REANIMATION_KIT )
		{
			return RG_Defib;
		}
		
		if ( pid == PID_MOTION_SENSOR || pid == PID_ACTIVE_MOTION_SENSOR )
		{
			return RG_Sensor;
		}

		return RG_None;
	}
	// end RechargeGroup data

	#ifndef ENERGY
		#ifdef __SERVER
			import void InitBatteryRules() from "energy";
			import int GetEnergyChargeFromBattery( uint16 batteryPid, Item& rechargeableItem ) from "energy";
			import bool ChargeItem( Critter& cr, Item& batteryItem, Item& rechargeableItem ) from "energy";
		#endif // __SERVER
	#endif //ENERGY
#endif //ENERGY_H
