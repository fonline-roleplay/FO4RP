// Debug functions

#include "_macros.fos"
#include "_colors.fos"
import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void ApplyMutation( Critter& cr ) from "morphes";
import void _MobInit( Critter& npc, bool firstTime ) from "mob";
import void FlushScreen( Critter& cr, uint fromColor, uint toColor, uint timeMs ) from "effects";
import void GM_MobInit( Critter& npc ) from "mob";

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Trinitro
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define FIND_DIST    ( 16 )

//import void DebugLog( string text ) from "debug";
void DebugLog( string text ) //export
{
		GameVar@ isLogging = GetGlobalVar( GVAR_DebugInfo );
		if( valid( isLogging ) && isLogging.GetValue() == 1 )
			Log( text );
}


void Radiate( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = null;
    if( param0 == 0 )
        @target = player;
    else
        @target = GetCritter( param0 );
    AffectRadiation( target, param1 );
}

void Mutate( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = null;
    if( param0 == 0 )
        @target = player;
    else
        @target = GetCritter( param0 );
    ApplyMutation( target );
}

void ViewPlanes( Critter& player, int param0, int param1, int param2 )
{
    if( param0 == 0 )
        param0 = 20;

    Map@ map = player.GetMap();
    if( not valid( map ) )
        return;

    Critter@[] critters;
    uint count = 0;
    if( param1 == 0 )
        count = map.GetCrittersHex( player.HexX, player.HexY, param0, FIND_ALL | FIND_ONLY_NPC, critters );
    else
    {
        Critter@ cr = GetCritter( param1 );
        if( not valid( cr ) )
            return;
        critters.resize( 1 );
        @critters[ 0 ] = cr;
    }

    for( uint i = 0; i < count; i++ )
    {
        NpcPlane@[] p;
        uint pcount = critters[ i ].GetPlanes( p );
        for( uint j = 0; j < pcount; j++ )
        {
            uint[] param = { critters[ i ].Id, p[ j ].Type, p[ j ].Priority };
            switch( p[ j ].Type )
            {
            case AI_PLANE_MISC:
                param.resize( 5 );
                param[ 3 ] = p[ j ].Misc_WaitSecond;
                param[ 4 ] = p[ j ].Misc_ScriptId;
                break;
            case AI_PLANE_ATTACK:
                param.resize( 5 );
                param[ 3 ] = p[ j ].Attack_TargId;
                param[ 4 ] = p[ j ].Attack_MinHp;
                break;
            case AI_PLANE_WALK:
                param.resize( 8 );
                param[ 3 ] = p[ j ].Walk_HexX;
                param[ 4 ] = p[ j ].Walk_HexY;
                param[ 5 ] = p[ j ].Walk_Dir;
                if( p[ j ].Run )
                    param[ 6 ] = 1;
                else
                    param[ 6 ] = 0;
                param[ 7 ] = p[ j ].Walk_Cut;
                break;
            case AI_PLANE_PICK:
                param.resize( 6 );
                param[ 3 ] = p[ j ].Pick_HexX;
                param[ 4 ] = p[ j ].Pick_HexY;
                param[ 5 ] = p[ j ].Pick_Pid;
                break;
            }
            CreateTimeEvent( __FullSecond + 60 + j, "e_ViewPlanes", param, false );
        }
    }
}

uint e_ViewPlanes( uint[] @ values )
{
    Critter@ crit = GetCritter( values[ 0 ] );
    if( not valid( crit ) )
        return 0;

    string msg = "error";
    switch( values[ 1 ] )
    {
    case AI_PLANE_MISC:
        msg = "<<MISC>> Prior=" + values[ 2 ];
        msg += " WaitMinute=" + values[ 3 ] + " ScriptId=" + values[ 4 ];
        break;
    case AI_PLANE_ATTACK:
        msg = "<<ATTACK>> Prior=" + values[ 2 ];
        msg += " TargId=" + values[ 3 ] + " MinHp=" + values[ 4 ];
        break;
    case AI_PLANE_WALK:
        msg = "<<WALK>> Prior=" + values[ 2 ];
        msg += " HexX=" + values[ 3 ] + " HexY=" + values[ 4 ] + " Dir=" + values[ 5 ];
        msg += " Run=" + values[ 6 ] + " Cut=" + values[ 7 ];
        break;
    case AI_PLANE_PICK:
        msg = "<<PICK>> Prior=" + values[ 2 ];
        msg += " HexX=" + values[ 3 ] + " HexY=" + values[ 4 ] + " Pid=" + values[ 5 ];
        break;
    }

    crit.Say( SAY_NORM_ON_HEAD, msg );
    return 0;
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// heX
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import void InjureCritter( Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId ) from "combat";

#define def    # ( X, DEF )( X == 0 ? DEF : X )

void lvl( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_LEVEL ] ) );
}

void team( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_TEAM_ID ] ) );
}

void role( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_NPC_ROLE ] ) );
}

void info( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ param0 ] ) );
}

void hp( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Stat[ ST_CURRENT_HP ] ) + "/" + "" + ( critters[ i ].Stat[ ST_MAX_LIFE ] ) );
}

// plan count
void planc( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].GetPlanes( null ) ) );
}

// show plans list
void plans( Critter& player, int param0, int param1, int param2 )
{
    NpcPlane@[] planes;
    string str;
    Critter@[] critters;
    uint   count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
    {
        str = "";
        uint count = critters[ i ].GetPlanes( planes );
        for( uint j = 0; j < count; j++ )
        {
            switch( planes[ j ].Type )
            {
            case AI_PLANE_MISC:
                str = str + "M ";
                break;
            case AI_PLANE_ATTACK:
                str = str + "A ";
                break;
            case AI_PLANE_WALK:
                str = str + "W ";
                break;
            case AI_PLANE_PICK:
                str = str + "P ";
                break;
            case AI_PLANE_PATROL:
                str = str + "P ";
                break;
            case AI_PLANE_COURIER:
                str = str + "C ";
                break;
            }
        }
        critters[ i ].Say( SAY_NORM_ON_HEAD, str );
    }
}

// player level info
void lvli( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST * 2, FIND_LIFE | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0; i < count; i++ )
        player.Say( SAY_NETMSG, GetPlayerName( critters[ i ].Id ) + ": " + "" + ( critters[ i ].Stat[ ST_LEVEL ] ) );
}

void dmg( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;
    InjureCritter( target, param1, param2, 0, player.Id );
}

void kill( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;
    target.Say( SAY_NETMSG, "Кара небесная поразила вас!" );
    target.ToDead( def( param1, ANIM2_DEAD_PULSE_DUST ), player );
    // target.SetTimeout(TO_REPLICATION, 3);
}

void body( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.ChangeCrType( param1 );
}

void anim( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    target.Animate( param1, param2, null, true, true );
}

void testmap( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] groups;
    groups.insertLast( @player );
    uint      locid = CreateLocation(
        def( param1, 400 ), player.WorldX, player.WorldY, groups );
    Location@ loc = GetLocation( locid );
    // if(not valid(loc)) GetMapByPid(mapProtoId, skipCount);
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map@ map;
    if( param0 != 0 )
        @map = loc.GetMap( param0 );
    else
        @map = loc.GetMapByIndex( 0 );
    if( not valid( map ) )
        return;
    player.TransitToMap( map.Id, 0 );
}

// Come To Daddy gm
void _ctd( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    ctd( player, param0, param1, param2 );
}

// Come To Daddy
void ctd( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( param0 );
    if( not valid( target ) )
        return;

    Critter@ daddy = ( ( param2 != 0 ) ? target : player );
    Critter@ child = ( ( param2 == 0 ) ? target : player );


    Map@ map = daddy.GetMap();
    if( not valid( map ) )
        return;

	if( child.ParamBase[ QST_GAMEMODE ] == GAME_START && daddy.GetAccess() <= ACCESS_MODER )
	{
    child.Say( SAY_NETMSG, "Игрок в стартовом режиме, его нельзя телепортировать." );
    return;
	}
	
		
    uint8 temp_dir = Random( 0, 5 );
    for( uint i = 0; i < 6; i++ )
    {
        uint16 hexX = daddy.HexX, hexY = daddy.HexY;
        map.MoveHexByDir( hexX, hexY, ( temp_dir + i ) % 6, 1 + param1 );
        if( not map.IsHexPassed( hexX, hexY ) )
            continue;
        child.TransitToMap( map.Id, hexX, hexY, 0 );
        break;
    }

}

void CalmDown( Critter& player, int crId, int param1, int param2 )
{
    Critter@ cr = GetCritter( crId );
    if( !valid( cr ) || cr.IsPlayer() )
    {
        player.Say( SAY_NETMSG, "НПЦ не найдет" );
        return;
    }
    else
        cr.ClearEnemyStack();
}

void god( Critter& player, int, int, int )
{
    for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
        player.StatBase[ i ] = 10;
    for( uint i = ST_NORMAL_ABSORB; i <= ST_EXPLODE_ABSORB; i++ )
        player.StatBase[ i ] = 100;
    for( uint i = ST_NORMAL_RESIST; i <= ST_POISON_RESISTANCE; i++ )
        player.StatBase[ i ] = 100;
    for( uint i = SK_SMALL_GUNS; i <= SK_OUTDOORSMAN; i++ )
        player.SkillBase[ i ] = 300;
    player.StatBase[ ST_MELEE_DAMAGE ] = 999;
    player.StatBase[ ST_ARMOR_CLASS ] = 100;
    player.StatBase[ ST_CURRENT_HP ] = 9999;
    player.StatBase[ ST_MAX_LIFE ] = 9999;
}

void GM_god( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
        player.StatBase[ i ] = 10;
    for( uint i = SK_SMALL_GUNS; i <= SK_OUTDOORSMAN; i++ )
        player.SkillBase[ i ] = 300;
    player.PerkBase[ PE_SHARPSHOOTER ] = 100;
    player.PerkBase[ PE_STRONG_BACK ] = 10;
    player.PerkBase[ PE_SILENT_RUNNING ] = 1;
    player.PerkBase[ PE_AWARENESS ] = 2;
    player.PerkBase[ PE_PATHFINDER ] = 3;
    player.StatBase[ ST_MAX_LIFE ] = 120;
    player.StatBase[ ST_CURRENT_HP ] = 9999;
    player.ModeBase[ MODE_HIDE ] = 1;
    player.ModeBase[ MODE_NO_LOOSE_LIMBS ] = 1;
    player.ModeBase[ MODE_INVULNERABLE ] = 1;
    player.ModeBase[ MODE_NO_STEAL ] = 1;
}

void mapid( Critter& player, int, int, int )
{
    Map@ map = player.GetMap();
    player.Say( SAY_NETMSG, "" + ( map.GetProtoId() ) );
}

void unsafe_GM_tele( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	if( player.GetAccess() >= ACCESS_MODER )
		tele( player, param0, param1, param2 );
}

void GM_tele( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    tele( player, param0, param1, param2 );
}

void tele( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    Location @ loc = GetLocationByPid( def( param1, player.GetMap().Id ), 0 );
    if( not valid( loc ) )
    {
        player.Say( SAY_NETMSG, "Location not found" );
        return;
    }
    Map @ map = loc.GetMapByIndex( param2 );
    if( not valid( map ) )
    {
        player.Say( SAY_NETMSG, "Map index not found" );
        @map = loc.GetMapByIndex( 0 );
        if( not valid( map ) )
            return;
    }
    
    target.SetWorldPos(loc.WorldX, loc.WorldY);
    target.TransitToMap( map.Id, 0 );
}

void items( Critter& player, int param0, int param1, int param2 )
{
    Item@[] items;
    uint count = player.GetMap().GetItems( player.HexX, player.HexY, items );
    for( uint i = 0; i < count; i++ )
        player.Say( SAY_NETMSG, "" + items[ i ].GetProtoId() );
}

void id( Critter& player, int param0, int param1, int param2 )
{
    Critter@[] critters;
    uint count = player.GetMap().GetCrittersHex( player.HexX, player.HexY, FIND_DIST, FIND_LIFE | FIND_ALL, critters );
    for( uint i = 0; i < count; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "" + ( critters[ i ].Id ) );
}

// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ...
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// ~run debug ToMapEntire 42 0 0
void ToMapEntire( Critter& player, int mapPid, int entire, int skip )
{
    Map@ map = ::GetMapByPid( mapPid, skip );
    if( valid( map ) )
    {
        player.TransitToMap( map.Id, entire );
    }
    else
    {
        player.Say( SAY_NETMSG, "Карта с pid=" + mapPid + " не найдена" );
    }
}

void ToMap( Critter& player, int mapPid, int X, int Y )
{
    Map@ map = GetMapByPid( mapPid, 0 );
    if( valid( map ) )
    {
        player.TransitToMap( map.Id, X, Y, 0 );
    }
    else
    {
        player.Say( SAY_NETMSG, "Карта с pid=" + mapPid + " не найдена" );
    }
}

// ищет нпц по диалогу на карте указанного прототипа
void NpcByDialog( Critter& player, int mapPid, int dialog, int )
{
    Map@ map = ::GetMapByPid( mapPid, 0 );
    if( valid( map ) )
    {
        Critter @[] npc;

        if( map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, npc ) == 0 )
        {

            player.Say( SAY_NETMSG, "не найдено нпц с таким диалогом" );

        }
        else
        {
            uint idF = 0;
            uint l = 0;
            for( uint i = 0; i < npc.length(); i++ )
            {
                if( npc[ i ].Stat[ ST_DIALOG_ID ] == dialog )
                {
                    l++;
                    idF = ( idF == 0 ? npc[ i ].Id : idF );
                }
            }
            player.Say( SAY_NETMSG, "Найдено нпц, в штуках:" + l + " Id первого:" + idF );
        }
    }

}

void SetReputation( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.ReputationBase[ num ] = val;
}

void Siren( Critter& cr, int, int, int )
{
    Map @ map = cr.GetMap();
    if( !valid( map ) )
    {
        cr.Say( SAY_NETMSG, "Невозможно проиграть звук на глобальной карте" );
        return;
    }
    map.PlaySound( "AIRSIREN.OGG" );
}

void Mirelurk( Critter& cr, int, int, int )
{
    cr.GetMap().AddNpc( 487, cr.HexX - 3, cr.HexY - 3, 0, null, null, null );

}

/*
   ~run debug ToMapEntire 137 0 0
   ~run debug Siren 0 0 0
   ~run debug Mirelurk 0 0 0
   ~loadscript debug
   ~run debug SetMode 1 527 1
   ~run test SetStat

 */
void SetMode( Critter& cr, int id, int mode, int value )
{
    Critter @ crit = GetCritter( id );
    crit.ModeBase[ mode ] = value;
}

void RunMapLoop( Critter& player, int ms, int param1, int param2 )
{
    Map@ map = player.GetMap();
    map.SetLoopTime( 0, ms );
    map.SetLoopTime( 1, ms + 500 );
    map.SetEvent( MAP_EVENT_LOOP_0, "e_Map_Loop_0_Run" );
    map.SetEvent( MAP_EVENT_LOOP_1, "e_Map_Loop_1_Run" );


}

void e_Map_Loop_0_Run( Map& map )
{
    map.SetLoopTime( 0, 3000 );
    Display_Ms_Msg( map );
}

void e_Map_Loop_1_Run( Map& map )
{
    map.SetLoopTime( 1, 3000 );
    Display_Ms_Msg( map );
}

void Display_Ms_Msg( Map& map )
{
    uint16 year = 0, month = 0, week = 0, day = 0, hour = 0, minute = 0, sec = 0, ms = 0;
    Critter @[] critArr( 1 );
    map.GetCritters( 0, FIND_ALL, critArr );

    if( critArr.length() == 0 )
        Log( "Не найдено криттеров" );
    else
    {

        Critter @ crt = critArr[ critArr.length() - 1 ];
        GetTime( year, month, week, day, hour, minute, sec, ms );
        crt.Say( SAY_SHOUT, "Current local second " + sec + "," + ms ); // SAY_SHOUT
    }
}

void Check_Dict_Element( Critter& player, int, int, int )
{
    dictionary dict;
    dict.set( player.Id + "|" + 1, 1 );
    dict.set( player.Id + "|" + 2, 2 );
    dict.set( player.Id + "|" + 3, 3 );
    if( dict.exists( player.Id + "|*" ) )
        player.Say( SAY_NORM, "Словарь обрабатывает звездочку в ключе" );
    else
        player.Say( SAY_NORM, "Хуй вам, словарь не обрабатывает звездочку в ключе" );
}

void SetRain( Critter& player, int capacity, int param1, int param2 )
{
    Map@ map = player.GetMap();
    if( !valid( map ) )
        return;
    map.SetRain( capacity );
}

void GetRain( Critter& player, int param0, int param1, int param2 )
{
    Map@ map = player.GetMap();
    if( !valid( map ) )
        return;
    player.Say( SAY_NETMSG, "Rain power: " + map.GetRain() );
}

void GetParam( Critter& player, int crId, int num, int val )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        player.Say( SAY_NETMSG, " " + toCr.Param[ num ] );
}

void GetParamBase( Critter& player, int crId, int num, int val )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        player.Say( SAY_NETMSG, " " + toCr.ParamBase[ num ] );
}

void SetParam( Critter& player, int crId, int num, int val )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ParamBase[ num ] = val;
        player.Say( SAY_NETMSG, "Done." );
    }
}

void GetId( Critter& player, int playerId, int param1, int param2 )
{
    player.ShowScreen( SCREEN_CLOSE, 0, "" );
    player.ShowScreen( SCREEN_SAY, 0, "answer_GetId" );
    player.Say( SAY_SAY_TITLE, "Введите логин персонажа." );
}

void answer_GetId( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() < 3 )
        return;

    Critter@ cr = GetPlayer( answerS );

    if( !valid( cr ) )
    {
        player.Say( SAY_NETMSG, "Нет такого персонажа." );
        return;
    }

    player.Say( SAY_NETMSG, "Login: " + answerS + " Id: " + cr.Id );
}

/* new from SDK
   import void AddWave(int waveNum, int mapId, int type) from "mob_wave";
   import void AddSpawnStep(int waveNum, uint8 radius, uint timeNext, uint x, uint y) from "mob_wave";
   import void AddMob(int waveNum, int pid, int team) from "mob_wave";
   import void AddMoveStep(int waveNum, uint8 radius, uint timeNext, uint x, uint y) from "mob_wave";
   import void AddAttackStep(int waveNum, uint8 radius, uint timeNext, uint timeRepeat, uint x, uint y) from "mob_wave";
   import void AddDeleteStep(int waveNum, uint8 radius, uint timeNext) from "mob_wave";
   import void _StartWave(int waveNum) from "mob_wave";
   import void AddTransitStep(int waveNum, uint8 radius, uint timeNext, uint x, uint y, uint mapId) from "mob_wave";


   void NewWave(Critter& cr, int num, int type, int)
   {
        AddWave(num, cr.GetMap().Id, type);
   }

   void AddStepSpawn(Critter & cr, int num, int radius, int timeNext)
   {
        AddSpawnStep(num, radius, timeNext, cr.HexX, cr.HexY);
   }

   void AddStepMove(Critter & cr, int num, int radius, int timeNext)
   {
        AddMoveStep(num, radius, timeNext, cr.HexX, cr.HexY);
   }

   void AddStepAttack(Critter & cr, int num, int radius, int timeNext)
   {
        AddAttackStep(num, radius, timeNext, 10, cr.HexX, cr.HexY);
   }

   void AddStepDelete(Critter & cr, int num, int radius, int timeNext)
   {
        AddDeleteStep(num, radius, timeNext);
   }

   void AddMob(Critter& cr, int num, int pid, int team)
   {
        AddMob(num, pid, team);
   }

   void AddStepTransit(Critter& cr, int num, int radius, int timeNext)
   {
        AddTransitStep(num, radius, timeNext, cr.HexX, cr.HexY, cr.GetMap().Id);
   }

   void BeginWave(Critter& cr, int num, int,int)
   {
        _StartWave(num);
   }

 */
/*
   ~run debug NewWave 1 3 0
   ~run debug AddStepSpawn 1 10 10
   ~run debug AddStepMove 1 10 10
   ~run debug AddStepAttack 1 10 10

   ~run debug AddMob 1 111 27~run debug AddStepDelete 1 10 10
   ~run debug BeginWave 1
 */

void NetId( Critter& player, int searchRadius, int, int )
{
    Critter @[] crits;
    player.GetMap().GetCrittersHex( player.HexX, player.HexY, searchRadius, FIND_ALL, crits );
    player.Say( SAY_NETMSG, "my info: HexX=" + player.HexX + "; HexY=" + player.HexY + "; SearchRadius=" + searchRadius );
    for( uint i = 0; i < crits.length(); i++ )
    {
        player.Say( SAY_NETMSG, "Critter Pid:" + crits[ i ].GetProtoId() + "; Dialog:" + crits[ i ].Stat[ ST_DIALOG_ID ] + "; Id:" + crits[ i ].Id );
    }
    player.Say( SAY_NETMSG, "Total: " + crits.length() );
}

void SetCritParam( Critter& player, int id, int param, int value )
{
    Critter @ cr = GetCritter( id );
    if( valid( cr ) )
    {
        cr.ParamBase[ param ] = value;
    }
}

void GetCritParam( Critter& player, int id, int param, int value )
{
    Critter @ cr = GetCritter( id );
    if( valid( cr ) )
    {
        player.Say( SAY_NETMSG, "Param #" + param + " val= " + cr.Param[ param ] );
    }
}

void ShowLocation( Critter& player, int, int, int )
{
    Map @ map = player.GetMap();
    if( valid( map ) )
    {
        Location @ loc = map.GetLocation();
        if( valid( loc ) && !loc.Visible )
            loc.Visible = true;
    }
}

// end of new from SDK

void GetMap( Critter& player, int param0, int param1, int param2 )
{
    Map@   map = player.GetMap();
    string str = map.Id;
    player.Say( SAY_NETMSG, "КАРТА - " + str );
    str = player.HexX + " " + player.HexY;
    player.Say( SAY_NETMSG, "Координаты - " + str );
    str = player.Dir;
    player.Say( SAY_NETMSG, "Направление - " + str );
}

void GetEnemyStack( Critter& player, int crId, int param1, int param2 )
{
    uint[] enemyStack;
    uint     x = 0;
    string   str;
    Critter@ cr = GetCritter( crId );
    if( !valid( cr ) )
        player.Say( SAY_NETMSG, "Криттер не найдет" );
    else if( cr.IsPlayer() )
        player.Say( SAY_NETMSG, "Криттер не является НПЦ" );
    else
    {
        cr.GetEnemyStack( enemyStack );
        player.Say( SAY_NETMSG, "Список врагов:" );
        while( x < enemyStack.length() )
        {
            str = "";
            str += x;
            str += ": ";
            str += enemyStack[ x ];
            player.Say( SAY_NETMSG, str );
            x++;
        }
    }

}

/*
   #pragma bindfunc "bool Critter::toNpc() -> fonline_tla.dll Critter_toNpc"
   #pragma bindfunc "bool Critter::toPlayer() -> fonline_tla.dll Critter_toPlayer"

   void toNpc(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        cr.toNpc();
   }

   void toPlayer(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        cr.toPlayer();
   }

   void isNpc(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        player.GetMap().SetText (player.HexX, player.HexY, 0xFFFFFFFF, "Криттер "+cr.Id+(cr.IsNpc()?" нпс.":" игрок."));
   }

   #pragma bindfunc "string@ Critter::getName() -> fonline_tla.dll Critter_getName"


   void getName(Critter & player, int playerId, int, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        player.Say(SAY_NETMSG, "У #"+ cr.Id +" имя: "+cr.getName());
   }

   #pragma bindfunc "string@ Critter::setName(int num) -> fonline_tla.dll Critter_setName"

   void setName(Critter & player, int playerId, int num, int)
   {
        Critter@ cr = GetCritter((playerId==0)?player.Id:playerId);
        cr.setName(num);
   }
 */

void deleteCritter( Critter& player, int id, int param, int value )
{
    Critter@ cr = GetCritter( id );
    if( valid( cr ) )
        DeleteNpc( cr );
}

void rotateCritter( Critter& player, int id, int param, int value )
{
    Critter@ cr = GetCritter( id );
    if( valid( cr ) )
    {
        cr.SetHomePos( cr.HexX, cr.HexY, param );
        cr.SetDir( param );
    }
}

void changeHome( Critter& player, int id, int x, int y )
{
    Critter@ cr = GetCritter( id );
    cr.SetHomePos( x, y, 0 );
}

void unsafe_GM_tel( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	if( player.GetAccess() >= ACCESS_MODER )
		GM_tel( player, param0, param1, param2, param3, param4 );
}

void GM_tel( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( valid( cr ) )
        cr.TransitToHex( param1, param2, cr.Dir );
}

void teleportCritter( Critter& player, int id, int x, int y )
{
    Critter@ cr = GetCritter( id );
    if( valid( cr ) )
        cr.TransitToHex( x, y, 0 );
}

void getCoords( Critter& player, int id, int x, int y )
{
    Critter@ cr = GetCritter( id );
    player.Say( SAY_NETMSG, "X = " + cr.HexX + " Y = " + cr.HexY );
}

void GM_lock( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Map@  map = player.GetMap();
    Item@ item = map.GetItem( param0 );
    if( valid( item ) )
        lock( player, param0, param1, param2 );
}

void lock( Critter& player, int itemId, int complexity, int lockId )
{
    Map@  map = player.GetMap();
    Item@ item = map.GetItem( itemId );
    if( valid( item ) )
    {
        item.LockerCondition = LOCKER_LOCKED;
        item.LockerComplexity = complexity;
        item.LockerId = lockId;
        item.Update();
        Item@ key = player.AddItem( PID_KEY, 1 );
        if( valid( key ) )
            key.LockerId = lockId;
        key.Update();
    }
}

void unlock( Critter& player, int itemId, int param, int param2 )
{
    Map@  map = player.GetMap();
    Item@ item = map.GetItem( itemId );

    if( valid( item ) )
    {
        item.LockerCondition = LOCKER_ISOPEN;
        item.LockerComplexity = 0;
        item.LockerId = 0;
        item.Update();
    }
}

void cleanEnemyStacks( Critter& player, int, int, int )
{
    Map@ map = player.GetMap();
    Critter@[] crits;
    uint crCount = map.GetCritters( 0, FIND_LIFE, crits );
    for( uint i = 0; i < crCount; ++i )
    {
        if( crits[ i ].IsNpc() )
        {
            crits[ i ].ClearEnemyStack();
            crits[ i ].DropPlanes();
        }
    }
}


void SetSkin( Critter& player, int param0, int param1, int param2 )
{
    Critter@ target = GetCritter( def( param0, player.Id ) );
    if( not valid( target ) )
        return;
    if( target.ChangeCrType( param1 ) )
        target.StatBase[ ST_BASE_CRTYPE ] = param1;
}

void CreateLoc( Critter& player, int param0, int param1, int param2 )
{
    CreateLocation( param0, param1, param2, null );
}

void DeleteLoc( Critter& player, int param0, int param1, int param2 )
{
    Location@ loc = GetLocationByPid( param0, 0 );
    DeleteLocation( loc.Id );
}

void getMapId( Critter& cr, int param0, int param1, int param2 )
{
    Map @ map = cr.GetMap();
    if( !valid( map ) )
        return;
    string msg = map.Id;
//   cr.Say(SAY_NETMSG, msg);
    Location @ loc = map.GetLocation();
    if( !valid( loc ) )
    {
        msg += "loc err";
    }
    else
    {
        msg += " " + loc.Id;
    }
    cr.Say( SAY_NETMSG, msg );

}

void setcoolarmor( Critter& cr, int p0, int p1, int p2 )
{
    if( p1 == 0 )
    {
        cr.Say( SAY_NETMSG, "invalid armor pid (second parameter)" );
        return;
    }
    ;
    Critter @ target = GetCritter( def( p0, cr.Id ) );
    Item @ armor = target.GetItem( p1, SLOT_INV );
    if( !valid( armor ) )
    {
        cr.Say( SAY_NETMSG, "armor !valid" );
        return;
    }
    armor.Val1 = target.Id;
    armor.Val2 = target.StatBase[ ST_BASE_CRTYPE ];
    cr.Say( SAY_NETMSG, "BaseCrTypeTarget " + armor.Val2 );
    armor.SetScript( "debug@_CoolArmor" );
    armor.Update();
}


void _CoolArmor( Item& armor, bool firstTime )
{
    if( firstTime )
    {
        armor.SetEvent( ITEM_EVENT_MOVE, "e_ArmorMove" );
    }
}

void e_ArmorMove( Item& item, Critter& cr, uint8 fromSlot )
{
    string msg = fromSlot + " " + item.CritSlot;
    cr.Say( SAY_NETMSG, msg );
    if( item.Val1 != cr.Id )
        return;
    if( ( item.CritSlot == SLOT_HAND1 || item.CritSlot == SLOT_HAND1 ) && fromSlot == SLOT_INV )
    {
        cr.ChangeCrType( 3 );
        cr.MoveItem( item.Id, item.GetCount(), SLOT_ARMOR );
        cr.Action( ACTION_MOVE_ITEM, SLOT_ARMOR, item );
        cr.Action( ACTION_REFRESH, 0, null );
        item.Update();
    }
}

import uint GetAllPlayers( Critter@[]& crs ) from "manager";

void GetAllPl( Critter& cr, int p0, int p1, int p2 )
{
    Critter@[] crs;
    string msg;
    GetAllPlayers( crs );
    if( crs.length() > 0 )
    {
        msg = crs.length();
        cr.Say( SAY_NETMSG, msg );
    }
}

void delItem( Critter& cr, int p0, int p1, int p2 )
{
    if( p0 != 1 )
    {
        Item @ item = cr.GetMap().GetItem( p1 );
        if( !valid( item ) )
            return;
        DeleteItem( item );
    }
    else
    {
        Item @[] items;
        cr.GetMap().GetItems( p1, items );
        if( items.length() > 0 )
        {
            DeleteItems( items );
        }
    }
}

void setblankscript( Critter& cr, int p0, int p1, int p2 )
{
    Item @ item = GetItem( p0 );
    if( !valid( item ) )
        return;
    item.SetScript( "" );
}

void spawnmob( Critter& cr, int p0, int p1, int p2 )
{
    uint16   hexX = 0, hexY = 0;
    Critter@[] crs;
    Critter@ mob;
    Map @ map = cr.GetMap();
    map.GetEntireCoords( p2, 0, hexX, hexY );
    map.GetCritters( 0, FIND_LIFE, crs );
    for( uint8 i = 0; i < p1; i++ )
    {
        @mob = map.AddNpc( p0, hexX + Random( -5, 5 ), hexY + Random( -5, 5 ), Random( 0, 5 ), null, null, null );
        mob.AddEnemyInStack( cr.Id );
    }
}

void delmob( Critter& cr, int p0, int p1, int p2 )
{
    Critter@[] crs;
    Map @ map = cr.GetMap();
    p1 = ( p1 == 0 ? FIND_DEAD : FIND_ALL );
    map.GetCritters( p0, p1, crs );
    for( uint16 i = 0; i < crs.length(); i++ )
    {
        DeleteNpc( crs[ i ] );
    }
}

void getadmin( Critter& cr, int p0, int p1, int p2 )
{
    Critter @[] crs;
    string msg;
    GetAllPlayers( crs );
    for( uint8 i = 0; i < crs.length(); i++ )
    {
        if( crs[ i ].GetAccess() >= ACCESS_TESTER )
        {
            msg += "player " + GetPlayerName( crs[ i ].Id ) + " id " + crs[ i ].Id + " access " + crs[ i ].GetAccess() + "\n";
        }
    }
    cr.Say( SAY_NETMSG, msg );
}

void getAllPls( Critter& cr, int p1, int p2, int p3 )
{
    #ifdef ANYDATA_ONLINE
    if( IsAnyData( DATA_ALL_PLAYERS ) )
    {
        uint16[] ids;
        Critter @ cr1;
        GetAnyData( DATA_ALL_PLAYERS, ids );
        for( uint i = 0; i < ids.length(); i++ )
        {
            @cr1 = GetCritter( ids[ i ] );
            if( cr1 is null )
                continue;
            cr.Say( SAY_NETMSG, " i " + i + " id= " + ids[ i ] + " access " + cr1.GetAccess() );
        }
    }
    #endif
    #ifndef ANYDATA_ONLINE
    Critter@[] crs;
    GetAllPlayers( crs );
    for( uint i = 0; i < crs.length(); i++ )
    {
        if( crs[ i ] is null )
            continue;
        cr.Say( SAY_NETMSG, " i " + i + " id= " + crs[ i ].Id + " access " + crs[ i ].GetAccess() );
    }
    #endif
    /*
       string func = "general_unsafe@unsafe_show_flare";
       cr.RunClientScript("client_script@GetPlayersWorldRadius", cr.WorldX, cr.WorldY, 300, func, null);
     */
}


void openDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ item = GetItem( uint( p1 ) );
    if( item is null )
        return;

    item.LockerOpen();
}

void closeDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ item = GetItem( uint( p1 ) );
    if( item is null )
        return;

    item.LockerClose();
}

void BlockHex( Critter& cr, int p1, int p2, int p3 )
{
    Map@ map = cr.GetMap();
    if( map is null )
        return;
    map.BlockHex( cr.HexX + p1, cr.HexY + p2, p3 != 0 );
}

void UnblockHex( Critter& cr, int p1, int p2, int p3 )
{
    Map@ map = cr.GetMap();
    if( map is null )
        return;
    map.UnblockHex( cr.HexX + p1, cr.HexY + p2 );
}

void noopenDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ door = GetItem( uint( p1 ) );
    if( door is null )
        return;
    if( p2 == 0 )
        SETFLAG( door.LockerCondition, LOCKER_NOOPEN );
    else
        UNSETFLAG( door.LockerCondition, LOCKER_NOOPEN );
}

void clearDoor( Critter& cr, int p1, int p2, int p3 )
{
    Item@ door = GetItem( uint( p1 ) );
    if( door is null )
        return;

    door.LockerClose();

    door.LockerCondition = 0;
    door.LockerId = 0;
    door.LockerComplexity = 0;
    door.Val0 = 0;
    door.Val1 = 0;
}

void di( Critter& cr, int p1, int p2, int p3 )
{
    Item@ item = GetItem( uint( p1 ) );
    if( item is null )
        return;

    DeleteItem( item );
}

void setScale( Critter& cr, int p1, int p2, int p3 )
{
    cr.ParamBase[ ST_SCALE_FACTOR ] = p1;
}
// ID to knock by anubis
void knock( Critter& player, int id, int param1, int param2 )
{
    Critter@ cr = GetCritter( id );
    cr.Say( SAY_EMOTE_ON_HEAD, "теряет сознание" );
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 100, cr.HexX, cr.HexY );
}

import void ApplyGhoul( Critter& cr ) from "morphes";
// fast ghoulefication
void makeGhoul( Critter& cr, int p1, int p2, int p3 )
{
    Critter@ target = GetCritter( p1 != 0 ? p1 : cr.Id );
    if( @target == null )
    {
        cr.Say( SAY_NETMSG, "something wrong" );
        return;
    }
    ApplyGhoul( target );
}

void AddMine( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX + 1, cr.HexY + 1, PID_ACTIVE_MINE, 1 );
    item.SetScript( "_MineInit" );
}

void _MineInit( Item& item, bool firstTime )
{
    item.TrapValue = 150;
    SETFLAG( item.Flags, ITEM_TRAP );
    item.SetEvent( ITEM_EVENT_WALK, "explode@_MineWalk" );
    item.Update();
}
/*
   import void SkillUp(Critter& player, int skill) from "stdlib";

   void UpSkill(Critter& cr, int crId, int skill, int)
   {
        SkillUp(GetCritter(uint(crId)), skill);
   }*/

void liststats( Critter& cr, int p0, int p1, int )
{
    Critter @ target = GetCritter( def( p0, cr.Id ) );
    for( uint16 i = STAT_BEGIN; i < STAT_END; i++ )
    {
        cr.Say( SAY_NETMSG, "id " + target.Id + " stat " + i + " " + target.Stat[ i ] );
    }

    for( uint16 i = SKILL_BEGIN; i < SKILL_END; i++ )
    {
        cr.Say( SAY_NETMSG, "id " + target.Id + " skill " + i + " " + target.Skill[ i ] );
    }
}

void HideAllMaps( Critter& cr, int, int, int )
{
    Critter@[] crs;
    uint crLen = GetAllPlayers( crs );

    Location@[]  locations;
    uint len = GetAllLocations( 0, locations );

    for( uint i = 0; i < len; i++ )
    {
        Location@ loc = locations[ i ];
        if( loc is null )
            continue;

        if( loc.Visible )
        {
            loc.Visible = false;
            Log( "Скрыта локация " + loc.Id );
        }

        loc.GeckVisible = false;

        for( uint k = 0; k < crLen; k++ )
        {
            if( crs[ k ].UnsetKnownLoc( true, loc.Id ) )
                Log( "Стерта для " + crs[ k ].Id );
        }
    }
}

void GM_setcodedoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    setcodedoor( player, param0, param1, param2 );
}

void setcodedoor( Critter& cr, int p0, int p1, int p3 )
{
    Item @ item = GetItem( p0 );
    if( @item == null )
        return;
//	item.SetScript("item@_InitCodeDoor");
    item.Val0 = 4;
    item.Val1 = p1 + 1;
    item.Val4 = p3 != 0 ? p3 : Random( pow( 10, item.Val1 ), pow( 10, ( item.Val1 + 1 ) ) - 1 );
    cr.Say( SAY_NETMSG, "code " + item.Val4 );
    item.LockerComplexity = Random( 50, 200 );
    SETFLAG( item.LockerCondition, LOCKER_ELECTRO );
    item.Update();
}

void Flushblack( Critter& player, int p0, int p1, int p3, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( p0 );
    FlushScreen( cr, COLOR_BLACK, COLOR_BLACK, p1 );
}

void GiveItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    cr.AddItem( param1, 1 );
}

void GM_mobinit( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    cr.StatBase[ ST_TEAM_ID ] = 33;
    GM_MobInit( cr );
}

void GM_GetParam( Critter& player, int crId, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        player.Say( SAY_NETMSG, " " + toCr.Param[ param1 ] );
}

void GM_SetParam( Critter& player, int crId, int param1, int param2, string@ param3, int[] @ param4 )
{
    if( crId == 0 )
        crId = player.Id;
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ParamBase[ param1 ] = param2;
        player.Say( SAY_NETMSG, "Done." );
    }
}

void GM_liststats( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter @ target = GetCritter( param0 );
    for( uint16 i = STAT_BEGIN; i < STAT_END; i++ )
    {
        player.Say( SAY_NETMSG, "id " + target.Id + " stat " + i + " " + target.Stat[ i ] );
    }

    for( uint16 i = SKILL_BEGIN; i < SKILL_END; i++ )
    {
        player.Say( SAY_NETMSG, "id " + target.Id + " skill " + i + " " + target.Skill[ i ] );
    }
}

void GM_openDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ item = GetItem( uint( param0 ) );
    if( item is null )
        return;

    item.LockerOpen();
}

void GM_closeDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ item = GetItem( uint( param0 ) );
    if( item is null )
        return;

    item.LockerClose();
}

void GM_noopenDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ door = GetItem( uint( param0 ) );
    if( door is null )
        return;
    if( param1 == 0 )
        SETFLAG( door.LockerCondition, LOCKER_NOOPEN );
    else
        UNSETFLAG( door.LockerCondition, LOCKER_NOOPEN );
}

void GM_clearDoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ door = GetItem( uint( param0 ) );
    if( door is null )
        return;

    door.LockerClose();

    door.LockerCondition = 0;
    door.LockerId = 0;
    door.LockerComplexity = 0;
    door.Val0 = 0;
    door.Val1 = 0;
}

void GM_deleteCritter( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( valid( cr ) )
        DeleteNpc( cr );
}

void GM_delItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item @ item = player.GetMap().GetItem( param0 );
    if( !valid( item ) )
        return;
    DeleteItem( item );
}

void GM_brokeItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item @ item = GetItem( param0 );
    if( !valid( item ) )
        return;
    item.Deterioration = param1;
    player.Say( SAY_NETMSG, "предмет " + item.Id + " сломан на " + param1 );
	item.Update();
}

void viewarcadepop( Critter& cr, int clear, int, int )
{
    GameVar@ firegeckoNow = GetGlobalVar( GVAR_firegecko_now );
    GameVar@ alienNow = GetGlobalVar( GVAR_alien_now );
    GameVar@ deathclawNow = GetGlobalVar( GVAR_deathclaw_now );
    GameVar@ flocentNow = GetGlobalVar( GVAR_floaterandcentaur_now );
    GameVar@ clawNow = GetGlobalVar( GVAR_claw_now );
    GameVar@ clawKidNow = GetGlobalVar( GVAR_clawkid_now );

    GameVar@ firegecko = GetGlobalVar( GVAR_firegecko_population );
    GameVar@ alien = GetGlobalVar( GVAR_alien_population );
    GameVar@ deathclaw = GetGlobalVar( GVAR_deathclaw_population );
    GameVar@ flocent = GetGlobalVar( GVAR_floaterandcentaur_population );

    if( clear > 0 )
    {
        firegeckoNow.opAssign( 0 );
        alienNow.opAssign( 0 );
        deathclawNow.opAssign( 0 );
        clawNow.opAssign( 0 );
        clawKidNow.opAssign( 0 );
        flocentNow.opAssign( 0 );
    }

    cr.Say( SAY_NETMSG, "firegecko : " + firegeckoNow.GetValue() + "\nalien : " + alienNow.GetValue() + "\ndeathclaw : " + deathclawNow.GetValue() + "\nclaw : " + clawNow.GetValue() + "\nclawkid :" + clawKidNow.GetValue() + "\nflocent : " + flocentNow.GetValue() );
    cr.Say( SAY_NETMSG, "\neggs\nfiregecko : " + firegecko.GetValue() + "\nalien : " + alien.GetValue() + "\ndeathclaw : " + deathclaw.GetValue() + "\nflocent : " + flocent.GetValue() );
}

void testcte( Critter& cr, int p0, int p1, int )
{
    for( uint8 i = 0; i <= p1; i++ )
    {
        cr.AddTimeEvent( "cte_test", p0 + Random( p0, p0 * 3 ), CTE_TEST, i );
    }
}

uint cte_test( Critter& cr, int identifier, uint& rate )
{
    cr.Say( SAY_NETMSG, "test cte " + rate );
    return 0;
}

void itemsetval( Critter& cr, int p0, int p1, int p3 )
{
    Item @ item = GetItem( p0 );
    if( @item == null )
        return;
    switch( p1 )
    {
    case 0:
        item.Val0 = p3;
        break;
    case 1:
        item.Val1 = p3;
        break;
    case 3:
        item.Val2 = p3;
        break;
    case 4:
        item.Val4 = p3;
        break;
    case 5:
        item.Val5 = p3;
        break;
    case 6:
        item.Val6 = p3;
        break;
    case 7:
        item.Val7 = p3;
        break;
    // case 0 : item.Val8 = p3; break;
    default:
        break;
    }

}

void itemgetval( Critter& cr, int p0, int p1, int p3 )
{
    Item @ item = GetItem( p0 );
    if( @item == null )
        return;
    string msg = "" + item.Val0 + "\n" +
                 item.Val1 + "\n" +
                 item.Val2 + "\n" +
                 item.Val3 + "\n" +
                 item.Val4 + "\n" +
                 item.Val5 + "\n" +
                 item.Val6 + "\n" +
                 item.Val7 + "\n" +
                 item.Val8 + "\n" +
                 item.Val9;

    cr.Say( SAY_NETMSG, msg );

}
/*
   void testidi(Critter& cr, int p0, int p1, int p3)
   {
        Item @ item = GetItem(p0);
        if(@item == null) return;
        if(p3 > 0)
        {
                cr.RunClientScript("client_main@set_indicator", item.Indicator-Random(0,4), 0, 0, "", null);
                return;
        }
        if(p1 == 0) cr.Say(SAY_EMOTE_ON_HEAD, ""+item.Indicator);
        else item.Indicator = p1;
   }*/

void GM_GiveAll( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    Item@[] items;
    if( param1 == 0 )
    {
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
		cr.GetItems( SLOT_ARMOR, items );
        MoveItems( items, player );
        cr.Say( SAY_NETMSG, "Вещи переданы вам от криттера " + cr.Id );
    }
    else if( param1 == 1 )
    {
        player.GetItems( SLOT_INV, items );
        player.GetItems( SLOT_HAND1, items );
        player.GetItems( SLOT_HAND2, items );
		cr.GetItems( SLOT_ARMOR, items );
        MoveItems( items, cr );
        cr.Say( SAY_NETMSG, "Вещи переданы криттеру " + player.Id );
    }
    else if( param1 == 2 )
    {
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
		cr.GetItems( SLOT_ARMOR, items );
        DeleteItems( items );
        cr.Say( SAY_NETMSG, "Удалены вещи у криттера " + player.Id + "." );
    }
}

void Clone( Critter& player, int param0, int param1, int param2 )
{
    Critter@ cr = GetCritter( param0 );
    if( !valid( cr ) )
        return;
    if( param1 == 1 )
    {
        for( uint i = 0; i <= 565; i++ )
        {
            cr.ParamBase[ i ] = player.Param[ i ];
        }
        player.Say( SAY_NETMSG, "Вы присвоили свои параметры персонажу " + cr.Id + "." );
    }
    else if( param1 == 0 )
    {
        for( uint i = 0; i <= 565; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        player.Say( SAY_NETMSG, "Вам присвоенны параметры персонажа " + cr.Id );
    }
}

void GM_Clone( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( valid( cr ) )
    {
        for( uint i = 0; i <= 80; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        for( uint i = 200; i <= 207; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        for( uint i = 209; i <= 217; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }

        for( uint i = 260; i <= 278; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        for( uint i = 300; i <= 439; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        for( uint i = 470; i <= 476; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        for( uint i = 480; i <= 498; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        for( uint i = 550; i <= 565; i++ )
        {
            player.ParamBase[ i ] = cr.Param[ i ];
        }
        player.Say( SAY_NETMSG, "Вам присвоенны параметры персонажа " + cr.Id );
        player.Say( SAY_NETMSG, "Сник цели равен " + cr.Param[ 208 ] );
    }
}

import void _TraderInit( Critter& trader, bool firstTime ) from "trader";

void GM_TraderInit( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Critter@ cr = GetCritter( param0 );
    if( !valid( cr ) )
        return;
    _TraderInit( cr, true );
}

void setautodoor( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item@ door = GetItem( param0 );
    if( door is null )
        return;
    uint16 x = 0;
    uint16 y = 0;
    Map@   map = door.GetMapPosition( x, y );
    uint16 x0 = x;
    uint16 y0 = y;
    for( uint8 i = 0; i < 6; i++ )
    {
        map.MoveHexByDir( x, y, i, 1 );
        if( param1 != 2 )
        {
            Item@ pedal = map.AddItem( x, y, PID_AUTODOOR, 1 );
            pedal.Val1 = door.Id;
            pedal.Val2 = param1;
        }
        else
        {
            Item@ pedal = map.GetItem( x, y, PID_AUTODOOR );
            if( valid( pedal ) )
                DeleteItem( pedal );
        }
        x = x0;
        y = y0;
    }
}

void setjukebox( Critter& cr, int id, int, int )
{
    Item @ item = GetItem( id );
    if( @item == null || item.GetType() != ITEM_TYPE_CONTAINER )
        return;
    item.SetScript( "jukebox@_JukeboxInit" );
}

void GM_GetItem( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Item @ item = GetItem( param0 );
    if( !valid( item ) )
        return;
    MoveItem( item, 0, player );
}
/*	deprecated
   import void TransitCritterToCell(Critter& cr, uint16 itemId) from "globalmap_group";

   void transit(Critter& cr, int dir, int, int)
   {
        TransitCritterToCell(cr, dir);
   }
 */
void chagecell( Critter& cr, int x, int y, int )
{
    cr.StatBase[ ST_CELL_X ] = x;
    cr.StatBase[ ST_CELL_Y ] = y;
}

import void arcadehiveinsert( Critter& cr, uint16 x, uint16 y, uint8 type ) from "arcade_menu";
import void arcadehivelist( Critter& cr ) from "arcade_menu";
import void arcadehiveclear( Critter& cr ) from "arcade_menu";
import void arcadehivedelone( Critter& cr, uint8 index ) from "arcade_menu";

void arcadehiveadd( Critter& cr, int x, int y, int type )
{
    arcadehiveinsert( cr, x, y, type );
}

void arcadehivelist( Critter& cr, int, int, int )
{
    arcadehivelist( cr );
}

void arcadehiveclear( Critter& cr, int, int, int )
{
    arcadehiveclear( cr );
}

void arcadehivedel( Critter& cr, int index, int, int )
{
    arcadehivedelone( cr, index );
}

import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

void testbox( Critter& cr, int p0, int, int )
{
    uint8 flags = 0;
    SETFLAG( flags, INPUTBOX_CLOSE_ON_ENTER );   // close on enter
    ShowInputBoxScreen( cr, "debug@unsafe_test_inputbox#mywindow", p0, flags );
}

void unsafe_test_inputbox( Critter& cr, int skill, int p1, int p2, string@ message, int[] @ p4 )
{
    cr.Say( SAY_NORM, "message " + message );
}

import void DropWild() from "globalmap_group";

void dropwild( Critter& cr, int, int, int )
{
    DropWild();
}

void setworld( Critter& cr, int id, int x, int y )
{
    Critter @ target = GetCritter( id > 0 ? id : cr.Id );
    if( target is null )
        return;

    target.SetWorldPos( x, y );
}

void additemsrndpic( Critter& cr, int id, int x, int y )
{
    Map @ map = cr.GetMap();
    if( map is null )
    {
        cr.Say( SAY_NETMSG, "map" );
        return;
    }

    for( uint8 i = 0; i < x; ++i )
    {
        Item @ item = map.AddItem( cr.HexX + ( Random( -10, 10 ) ), cr.HexY + ( Random( -10, 10 ) ), 2004, 1 );
        if( item is null )
            continue;
        /*
           string = "";
           brl1000.frm
         * brl2000.frm
         * tirs002.frm
         * weed05.frm
         * weed08.frm
         * boxes1.frm
         * boxes2.frm
         * boxes3.frm
         * boxes4.frm
         * car2.frm
         * car4.frm
         * chair1.frm
         * chair3.frm
         * njunk5.frm
         * njunk6.frm
         * trash3.frm
         * t
         */

        uint hash = GetStrHash( "art\\scenery\\corpse1.png" );


        item.SetMapPic( hash );

        cr.Say( SAY_NETMSG, "add " + hash );
    }

}

void delsatmobs( Critter& cr, int id, int x, int y )
{
    for( uint8 i = id; i < x; ++i )
    {
        Location @ loc = GetLocationByPid( i, 0 );
        if( loc is null )
            continue;

        Map @ map = loc.GetMapByIndex( 0 );
        if( map is null )
            continue;

        Critter@[] crs;
        map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, crs );
        Log( "delete len " + crs.length() );
        for( uint16 ii = 0, jj = crs.length(); ii < jj; ++ii )
        {
            if( crs[ ii ] is null )
                continue;

            Log( "delete " + ii );
            DeleteNpc( crs[ ii ] );
        }
    }
}

void itemrndpic( Critter& cr, int id, int x, int y )
{
    Item @ item = GetItem( id );
    if( item is null )
        return;

    uint hash = GetStrHash( "art\\scenery\\corpse1.png" );
    item.SetMapPic( hash );
}

void addplant( Critter& cr, int id, int x, int y )
{
    Item @ item = cr.AddItem( id, 1 );
    if( item is null )
        return;

    item.Val3 = x;
    item.SetScript( "plant@_InitPlant" );

}

void evilplant( Critter& cr, int id, int, int )
{
    cr.GetMap().AddNpc( id, cr.HexX - 3, cr.HexY - 3, 0, null, null, "mob@_MobInit" );

}

void droptime( Critter& cr, int id, int, int )
{
    for( uint i = TIMEOUT_BEGIN; i < TIMEOUT_END; i++ )
    {
        cr.TimeoutBase[ i ] = 0;
    }
}

void addtime( Critter& cr, int id, int, int )
{
    uint time = cr.TimeoutBase[ TO_REPLICATION ];
    if( time > __FullSecond )
    {
        time += REAL_SECOND( 10 );
    }
    else
    {
        time = __FullSecond + REAL_MINUTE( 1 );
    }

    cr.TimeoutBase[ TO_REPLICATION ] =  time;
}
import uint GetTile( Map& map, uint16 hexX, uint16 hexY, uint8 layer ) from "qmap";
void        gettile( Critter& cr, int id, int, int )
{
    Map @ map = cr.GetMap();
    if( map is null )
        return;
    // for(uint8 i = 0; i < 5; ++i){
    uint hash = map.GetTile( THX( cr.HexX ), THX( cr.HexY ) ); // GetTile(map, THX(cr.HexX), THX(cr.HexY), i);
    cr.Say( SAY_NETMSG, "tile hash\n* " + hash );
    // }
}

void gettiles( Critter& cr, int id, int, int )
{
    uint hash0 = GetStrHash( "art/tiles/road02.frm" ),
         hash1 = GetStrHash( "road02.frm" );
    cr.Say( SAY_NETMSG, "tile hash\n* " + hash0 + "\ntile hash\n* " + hash1 );
}

void varset( Critter& cr, int id, int x, int )
{
    GameVar@ isStored = GetLocalVar( LIVAR_motel_isStored, id );

    int      val = isStored.GetValue();

    cr.Say( SAY_NETMSG, "" + val );

    if( x > 0 )
    {
        uint8 temp = Random( 1, 100 );

        isStored.opAssign( temp );
    }
} /*

     void testgetdur(Critter& cr, int id, int, int){
         Item @ item = GetItem(id);
         if(item is null) return;

         cr.Say(SAY_NETMSG, "dur "+item.GetDurability());
     }

     void testsetdur(Critter& cr, int id, int val, int){
         Item @ item = GetItem(id);
         if(item is null) return;

         item.SetDurability(val);
         cr.Say(SAY_NETMSG, "dur "+item.GetDurability());
     }*/

import void ActivateMobScript( Map& map ) from "mob"; // Export

void testmob( Critter& cr, int id, int val, int )
{
    ActivateMobScript( cr.GetMap() );
}

#define SAT_ENERGY_MAX    ( 28 )

void spawnsateng( Critter& cr, int id, int val, int )
{
    Location @ loc;
    Item @ item;
    for( uint8 i = 13; i < 25; ++i )
    {
        @loc = GetLocation( i );
        if( loc is null )
            continue;

        Map @ map = loc.GetMapByIndex( 0 );
        if( map is null )
            continue;

        Item@[] conts;
        map.GetItemsByType( ITEM_TYPE_CONTAINER, conts );
        // GetItemsByType (int type, Item@[]@+ items)
        uint16 len = conts.length();

        // uint8 count = 2
        for( uint16 ii = 0; ii < 2; ++ii )
        {

            @item = conts[ Random( 0, len - 1 ) ];

            if( !(item is null) )
            {
                item.AddItem( PID_MICRO_FUSION_CELL, Random( 1, 3 ), 0 );
                Log( "SPAWN " + item.HexX + ":" + item.HexY );
            }
        }
    }
}

void testscreen(Critter& cr, int, int, int){
	cr.ShowScreen( SCREEN_DIALOGBOX, 2, "answer_test" );
        cr.Say( SAY_DIALOGBOX_TEXT, "Вас устраивает ваша зарплата?" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Да" );
        cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Нет" );
}

void answer_test( Critter& cr, uint answerI, string& answerS )
{
	string msg = "";
	if(answerI > 0){
		msg = "Правда чтоли?";
	}else{
		msg = "ВРешь!";
	}
	
	cr.Say(SAY_NETMSG, msg);
}