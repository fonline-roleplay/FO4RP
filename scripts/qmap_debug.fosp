                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

import bool SetTile(Map&map,uint hash,uint16 hexX,uint16 hexY,uint8 layer)from"qmap";
import bool SetTile(Map&map,uint hash,uint hash2,uint16 hexX,uint16 hexY,uint8 layer)from"qmap";
import uint16 AddOneHash(Map&map,uint hash)from"qmap";
import bool SetTiles(Map&map,int[]&data)from"qmap";

import uint8 checkCoast(Map&map,uint16 tx,uint16 ty)from"qmap_coast";

import uint8 checkWater(Map&map,uint16 tx,uint16 ty)from"qmap_water";
import uint8 checkWaterAround(Map&map,uint16 tx,uint16 ty,uint8 coast_flags)from"qmap_water";

import uint8 checkSand(Map&map,uint16 tx,uint16 ty)from"qmap_sand";
import bool checkSand(Map&map,uint16 from_tx,uint16 from_ty,uint16 to_tx,uint16 to_ty)from"qmap_sand";

import uint GetTile(Map&map,uint16 hexX,uint16 hexY,uint8 layer)from"qmap";

int makeHex(uint16 hexX,uint16 hexY,uint8 layer)
{
	return(int(hexX)&0xFFF)|((int(hexY)&0xFFF)<<12)|((int(layer)&0xFF)<<24);
}

class TextMapTile
{
	uint Hash;
	uint16 HexX;
	uint16 HexY;
}

class TextMapWall
{
	uint8 Type;
	uint16 Pid;
	uint16 HexX;
	uint16 HexY;     
	
}

class TextMapItem
{
	uint16 Pid;
	uint16 HexX;
	uint16 HexY;
	uint16 Count;
}

class TextMap
{
	string parsedFileName;
	int[]data;
	TextMapItem[]items;
	
	TextMapTile[]tiles;
	TextMapTile[]roofs;
	TextMapWall[]walls;
	
	uint It;
	uint Ir;
	uint Iw;
	
	void ClearTempData()
	{
		tiles.resize(0);
		roofs.resize(0);
		walls.resize(0);
		
		It=0;
		Ir=0;
		Iw=0;
	}
	
	bool ParseTextMap(string fileName)
	{
		file f;
		
		ClearTempData();
		
		if(f.open(fileName,"r")<0)
		return false;
		
		string str;
		int p=0;
		uint8 nn="\n"[0],pp=" "[0];
		
		while(!f.isEndOfFile())
		{
			f.readLine(str);
			if(str.length()<1||str[0]!=91)
			continue;
			
			string str2;
			while(!f.isEndOfFile())
			{
				p=f.getPos();
				f.readLine(str2);
				
				uint str2len=str2.length();
				
				if(str2len<1)
				continue;
				
				if(str2[0]==91)
				{
					f.setPos(p);
					break;
				}
				
				if(str=="[Tiles]\n")
				{
					if(str2len<4)
					continue;
					
					if(str2[str2len-1]==nn)
					str2[str2len-1]=pp;
					
					string@[]@str2s=splitEx(str2," ");
					if(str2s.length()>3)
					{
						if(str2s[0]=="tile")
						{
							int hexX=0,hexY=0;
							
							if(StrToInt(str2s[1],hexX)&&StrToInt(str2s[2],hexY)&&hexX>=0&&hexY>=0)
							{
								uint len=tiles.length();
								if(It>=len)
								tiles.grow((len>>4)+1);    
								
								tiles[It].Hash=GetStrHash(str2s[3]);
								tiles[It].HexX=uint16(hexX);
								tiles[It++].HexY=uint16(hexY);
							}
						}
						else if(str2s[0]=="roof")
						{
							int hexX=0,hexY=0;
							
							if(StrToInt(str2s[1],hexX)&&StrToInt(str2s[2],hexY)&&hexX>=0&&hexY>=0)
							{
								uint len=roofs.length();
								if(Ir>=len)
								roofs.grow((len>>4)+1);  
								
								roofs[Ir].Hash=GetStrHash(str2s[3]);
								roofs[Ir].HexX=uint16(hexX);
								roofs[Ir++].HexY=uint16(hexY);
							}
						}
					}
				}
				else if(str=="[Objects]\n")
				{
					if(str2len>5&&str2[str2len-1]==nn)
					str2[str2len-1]=pp;
					
					string@[]@str2s0=splitEx(str2," ");
					
					uint len=walls.length();
					if(Iw>=len)
					walls.grow((len>>4)+1);
					
					if(str2s0.length()<2)
					{
						if(walls[Iw].Pid!=0&&walls[Iw].HexY!=0)
						Iw++;
					}
					else
					{
						int val=0;
						if(StrToInt(str2s0[1],val))
						{
							if(str2s0[0]=="MapObjType")
							walls[Iw].Type=uint8(val);
							else if(str2s0[0]=="ProtoId")
							walls[Iw].Pid=uint16(val);
							else if(str2s0[0]=="MapX")
							walls[Iw].HexX=uint16(val);
							else if(str2s0[0]=="MapY")
							walls[Iw].HexY=uint16(val);
						}
					}
				}
			}
			
		}
		
		f.close();
		
		tiles.resize(It);
		roofs.resize(Ir);
		walls.resize(Iw);
		
		return!((It<1)&&(Ir<1)&&(Iw<1));
	}
	
	bool GetMinHex(uint16&hexX,uint16&hexY)
	{
		uint16 hexX0=0xFFFF,hexY0=0xFFFF;
		
		for(uint i=0,len=tiles.length();i<len;i++)
		{
			if(tiles[i].HexX>0&&tiles[i].HexX<hexX0)
			hexX0=tiles[i].HexX;
			if(tiles[i].HexY>0&&tiles[i].HexY<hexY0)
			hexY0=tiles[i].HexY;
		}
		for(uint i=0,len=roofs.length();i<len;i++)
		{
			if(roofs[i].HexX>0&&roofs[i].HexX<hexX0)
			hexX0=roofs[i].HexX;
			if(roofs[i].HexY>0&&roofs[i].HexY<hexY0)
			hexY0=roofs[i].HexY;
		}
		for(uint i=0,len=walls.length();i<len;i++)
		{
			if(walls[i].HexX>0&&walls[i].HexX<hexX0)
			hexX0=walls[i].HexX;
			if(walls[i].HexY>0&&walls[i].HexY<hexY0)
			hexY0=walls[i].HexY;
		}
		
		if(hexX0<0xFFFF&&hexY0<0xFFFF)
		{
			hexX=hexX0;
			hexY=hexY0;
			return true;
		}
		
		return false;
	}
	
	bool ApplyOffset(uint16 offX,uint16 offY)
	{
		uint16 hexX=0,hexY=0;
		if(!GetMinHex(hexX,hexY))
		return false;
		
		hexX-=hexX%2;
		hexY-=hexY%2; 
		
		for(uint i=0,len=tiles.length();i<len;i++)
		{
			tiles[i].HexX=(tiles[i].HexX-hexX)+offX;
			tiles[i].HexY=(tiles[i].HexY-hexY)+offY;
		}
		for(uint i=0,len=roofs.length();i<len;i++)
		{
			roofs[i].HexX=(roofs[i].HexX-hexX)+offX;
			roofs[i].HexY=(roofs[i].HexY-hexY)+offY;
		}
		for(uint i=0,len=walls.length();i<len;i++)
		{
			walls[i].HexX=(walls[i].HexX-hexX)+offX;
			walls[i].HexY=(walls[i].HexY-hexY)+offY;
		}
		
		return true;
	}
	
	uint GenerateData(Map&map)
	{
		if((tiles.length()<1)&&(roofs.length()<1)&&(walls.length()<1))
		return 0;
		
		data.resize(0);
		uint j=0;
		
		items.resize(0);
		uint Ii=0;
		
		data.resize((tiles.length()+roofs.length()+walls.length())*2);
		
		for(uint i=0,len=tiles.length();i<len;i++)
		{
			if(tiles[i].HexX>=0xFFF||tiles[i].HexY>=0xFFF)
			continue;
			data[j++]=int(AddOneHash(map,tiles[i].Hash));
			data[j++]=makeHex(tiles[i].HexX>>1,tiles[i].HexY>>1,0);
		}
		for(uint i=0,len=roofs.length();i<len;i++)
		{
			if(roofs[i].HexX>=0xFFF||roofs[i].HexY>=0xFFF)
			continue;
			data[j++]=int(AddOneHash(map,roofs[i].Hash));
			data[j++]=makeHex(roofs[i].HexX>>1,roofs[i].HexY>>1,1);
		}
		
		uint8 lvl=0;
		
		for(uint i=0,len=walls.length();i<len;i++)
		{
			if(walls[i].HexX>=0xFFF||walls[i].HexY>=0xFFF)
			continue;
			
			ProtoItem@proto=GetProtoItem(walls[i].Pid);
			if(proto is null)
			{
				Log("Некорректный pid: "+walls[i].Pid);
				continue;
			}
			
			if(proto.Type>(0)&&proto.Type<=(9))
			{
				if(items.length()<=Ii)
				items.resize(Ii+10);
				items[Ii].Pid=walls[i].Pid;
				items[Ii].HexX=walls[i].HexX;
				items[Ii].HexY=walls[i].HexY;
				items[Ii++].Count=1;
				continue;
			}
			
			lvl=2;
			if((proto.Flags&(0x00000008))!=0)
			{
				if((proto.Flags&(0x00000004))!=0)
				lvl=4;
				else
				lvl=3;
			}
			
			data[j++]=(((proto.Flags&(0x00000001))==0)?int(AddOneHash(map,proto.PicMap)):0xFFFF);
			data[j++]=makeHex(walls[i].HexX,walls[i].HexY,lvl);
		}
		
		data.resize(j);
		items.resize(Ii);
		
		return data.length()>>1;
	}
	
} 

void _client_build(Critter&player,int param0,int param1,int param2,string@param3,int[]@param4)
{
	uint hash=0;
	if(!(param3 is null))
	hash=GetStrHash(param3);
	build(player,param0,param1,((hash==0)?param2:int(hash)));
}

TextMap@Map2;

void build(Critter&player,int var,int param1,int param2)
{
	Map@map=player.GetMap();
	if(map is null)
	return;   
	
	uint16 hexX=player.HexX,
	hexY=player.HexY;
	
	uint16 tX=((player.HexX)>>1),
	tY=((player.HexY)>>1); 
	
	if(var==0)
	{
		uint8 l=uint8(param2);
		for(int i=-param1;i<=param1;i++)
		{
			for(int k=-param1;k<=param1;k++)
			{
				if(l<2)
				SetTile(map,0,uint16(tX+k),uint16(tY+i),l);
				else
				SetTile(map,0,uint16(hexX+k),uint16(hexY+i),l);
			}
		}
	}
	else if(var==1)
	{
		for(uint i=0;i<5;i++)
		{
			string text="art/tiles/gar200"+i+".frm";
			uint hash=GetStrHash(text);
			SetTile(map,hash,tX+1,tY+i-2,0);
		}
		if(param1!=0)
		{
			for(uint i=0;i<8;i++)
			{
				string text="art/scenery/corn"+Random(1,9)+".frm";
				uint hash=GetStrHash(text);
				SetTile(map,0,hash,hexX+1,hexY+i-4,0);
			}
		}
	}
	else if(var==2)
	{
		string[]nums={"00","01","03","08","06","07","12","14","15"};
		for(uint i=0;i<9;i++)
		{
			int x=(1-(i%3));
			int y=(i/3-1);
			string text="art/tiles/slime"+nums[i]+".frm";
			uint hash=GetStrHash(text);
			
			SetTile(map,hash,tX+x,tY+y,0);
		}
		
	}
	else if(var==3)
	{
		SetTile(map,uint(param2),tX,tY,0);
		player.Say((11),"Строю тайл "+param2+" на "+tX+" "+tY);
		
	}
	else if(var==4)
	{
		SetTile(map,uint(param2),tX,tY,1);
		player.Say((11),"Строю крышу "+param2+" на "+tX+" "+tY);
	}
	else if(var==5)
	{
		SetTile(map,uint(param2),hexX,hexY,2);
		player.Say((11),"Строю стену "+param2+" на "+hexX+" "+hexY);
	}
	else if(var==6)
	{
		TextMap myMap;
		string fileName="maps/";
		
		if(param1<0)
		{
			player.Say((11),"Неверный номер карты.");
			return;
		}
		
		if(param1<100)
		{
			fileName+="pattern_"+param1+".fomap";
		}
		else
		{
			switch(param1)
			{
				case 100:
				fileName+="anuri_testbunker.fomap";
				break;
				case 101:
				fileName+="anuri_testbunker_door.fomap";
				break;
				case 110:
				fileName+="SlaversCave.fomap";
				break;
				case 111:
				fileName+="phoenix0.fomap";
				break;
				case 112:
				fileName+="modoc.fomap";
				break;
				default:
				player.Say((11),"Неверный номер карты.");
				return;
			}
		}
		
		player.Say((11),"Открываем и парсим карту... ");
		
		if(myMap.ParseTextMap(fileName))
		player.Say((11),"Ок.");
		else
		{
			player.Say((11),"Fail.");
			return;
		}
		
		player.Say((11),"Тайлы: "+myMap.tiles.length());
		player.Say((11),"Крыши: "+myMap.roofs.length());
		player.Say((11),"Стены: "+myMap.walls.length());              
		
		@Map2=myMap;
	}
	else if(var==7)
	{
		if(Map2 is null)
		player.Say((11),"Нет спарсенной карты.");
		
		player.Say((11),"Применяем смещение... ");
		if(Map2.ApplyOffset(tX*2+param1*2,tY*2+param2*2))
		player.Say((11),"Ок.");
		else
		{
			player.Say((11),"Fail.");
			return;
		}
		
		player.Say((11),"Генерируем данные... ");
		uint len=Map2.GenerateData(map);
		if(len>0||Map2.items.length()>0)
		player.Say((11),"Получено "+len+" динамических объекта(ов) и "+Map2.items.length()+" итемов.");
		else
		{
			player.Say((11),"Fail.");
			return;
		}
	}
	else if(var==8)
	{
		if(Map2 is null)
		player.Say((11),"Нет спарсенной карты.");
		
		if(Map2.data.length()<2)
		player.Say((11),"Данные не сгенерированы.");
		
		player.Say((11),"Отсылаем в QMAP... ");
		
		if(SetTiles(map,Map2.data))
		player.Say((11),"Готово.");
		else
		{
			player.Say((11),"Fail.");
			return;
		}
		
		player.Say((11),"Спавним итемы...");
		
		uint count=0,len=Map2.items.length();
		for(uint i=0;i<len;i++)
		{
			Item@item=map.AddItem(Map2.items[i].HexX,Map2.items[i].HexY,Map2.items[i].Pid,Map2.items[i].Count);
			if(item!is null)
			{
				count++;
				if(item.GetType()==(9)||item.GetType()==(8))
				{
					item.LockerOpen();
					item.LockerClose();
				}
			}
		}
		player.Say((11),"Добалены "+count+" из "+len+" итемов.");
	}
}

void getTile(Critter&player,int var,int con,int param2)
{
	Map@map=player.GetMap();
	if(map is null)
	return;
	
	uint16 tx=((player.HexX)>>1);
	uint16 ty=((player.HexY)>>1);
	
	uint tick=GetTick();
	
	if(var==0)
	{
		uint hash=map.GetTile(tx,ty);
		
		player.Say((11),"Tile tx "+tx+" ty "+ty+" hash "+((con!=0)?int(hash):hash));
	}
	else if(var==1)
	{
		player.Say((11),"Этот тайл - "+((checkCoast(map,tx,ty)==0)?"не ":"")+"берег");
		player.Say((11),"Этот тайл - "+((checkWater(map,tx,ty)==0)?"не ":"")+"вода");
		player.Say((11),"Этот тайл - "+((checkSand(map,tx,ty)==0)?"не ":"")+"песок");
	}
	else if(var==2)
	{
		if(checkWaterAround(map,tx,ty,0xF)!=0)
		player.Say((11),"Рядом есть вода.");
		else
		player.Say((11),"Рядом нет вода.");
	}
	else if(var>=3)
	{
		if(var==3)
		{
			if(checkSand(map,tx-param2,ty+1,tx+param2,ty+1+param2*2))
			player.Say((11),"К югу пустая песчаная площадка "+(param2*2+1)+"x"+(param2*2+1));
		}
		if(var==4)
		{
			if(checkSand(map,tx+1,ty-param2,tx+1+param2*2,ty+param2))
			player.Say((11),"К западу пустая песчаная площадка "+(param2*2+1)+"x"+(param2*2+1));
		}
		if(var==5)
		{
			if(checkSand(map,tx-param2,ty-1,tx+param2,ty-1-param2*2))
			player.Say((11),"К северу пустая песчаная площадка "+(param2*2+1)+"x"+(param2*2+1));
		}
		if(var==6)
		{
			if(checkSand(map,tx-1,ty-param2,tx-1-param2*2,ty+param2))
			player.Say((11),"К востоку пустая песчаная площадка "+(param2*2+1)+"x"+(param2*2+1));
		}
		if(var==7)
		{
			if(checkSand(map,tx-param2,ty-param2,tx+param2,ty+param2))
			player.Say((11),"Вокруг пустая печаная площадка "+(param2*2+1)+"x"+(param2*2+1));
		}
	}
	
	player.Say((11),"На все рассчеты ушло: "+(GetTick()-tick));
}         

uint[]trd(101);
void testRandom(Critter&player,int var,int con,int param2)
{
	for(uint i=0;i<=100;i++)
	trd[i]=0;
	
	for(uint i=0;i<1000000;i++)
	{
		trd[Random(0,100)]+=1;
	}
	
	uint b=0;
	
	for(uint i=0;i<=100;i++)
	{
		if(trd[i]>b)
		b=trd[i];
	}
	
	uint[]scores;
	
	for(uint i=b;i>0&&scores.length()<10;i--)
	{
		for(uint k=0;k<=100;k++)
		{
			if(trd[k]>=i)
			{
				bool ck=true;
				for(uint t=0,len=scores.length();t<len;t++)
				{
					if(scores[t]!=k)
					continue;
					ck=false;
					break;
				}
				if(ck)
				scores.insertLast(k);
			}
		}
	}
	
	for(uint i=0,len=scores.length();i<len;i++)
	player.Say((11),"Место #"+i+" занимает "+scores[i]+" с "+trd[scores[i]]+" очками!");
}                            

void testField(Critter&cr,int p1,int p2,int param2)
{
	uint16 x=cr.HexX+p1,
	y=cr.HexY+p2;
	cr.RunClientScript("client_qfield@_TestField",int(x),int(y),0,null,null);
}

void setHexFlags(Critter&cr,int p1,int p2,int param2)
{
	uint16 x=cr.HexX+p1,
	y=cr.HexY+p2;
	cr.RunClientScript("client_qfield@_FieldChangeFlags",int(x),int(y),param2,null,null);
}         

void bh(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	uint16 x=cr.HexX+p1,
	y=cr.HexY+p2;
	
	map.BlockHex(x,y,p3!=0);
	cr.RunClientScript("client_qfield@_FieldSetFlags",int(x),int(y),(0x40)|(p3!=0?(0x80):0),null,null);
	SetTile(map,1544010718,x,y,0);
}

void ubh(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	uint16 x=cr.HexX+p1,
	y=cr.HexY+p2;
	
	map.UnblockHex(x,y);
	cr.RunClientScript("client_qfield@_FieldUnSetFlags",int(x),int(y),(0x40)|(0x80),null,null);
	SetTile(map,0,x,y,0);
}  

void tGetTiles(Critter&cr,int p1,int p2,int p3)
{
	Map@map=cr.GetMap();
	if(map is null)
	return;
	
	uint[]arr={1,2,3,4};
	uint num=map.GetTiles(cr.HexX,cr.HexY,p1!=0,arr);
	
	Log("Тайлов на "+cr.HexX+" "+cr.HexY+" гексе: "+num);
	for(uint i=0;i<arr.length();i++)
	{
		Log(i+") "+arr[i]);
	}
}                                               

void SetUVAR(Critter&player,int p0,int p1,int p2)
{
	GameVar@gvar=GetUnicumVar((2010),p0,p1);
	if(gvar is null)
	{
		player.Say((11),"fail");
		return;
	}
	gvar=p2;
}

void GetUVAR(Critter&player,int p0,int p1,int p2)
{
	GameVar@gvar=GetUnicumVar((2010),p0,p1);
	if(gvar is null)
	{
		player.Say((11),"fail");
		return;
	}
	player.Say((11),"val: "+gvar.GetValue());
}
