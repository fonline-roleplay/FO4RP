// Initil Author: rifleman17
#include "_utils.fos"
#include "_npc_pids.fos"

import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

import void AffectPoison( Critter& cr, int value ) from "poison";
import void AffectRadiation( Critter& cr, int value ) from "radiation";

// Дверь, которая зпкроется через 2 игровые минуты илии через некоторое число реальных секунд , указанное в val3

bool ScriptDoor( Item& door ) { return door.SetScript( "_DoorAutoCloseInit" ); }

void _DoorAutoCloseInit( Item& door, bool firstTime ) { door.SetEvent( ITEM_EVENT_SKILL, "e_UseAutoCloseDoor" ); }

bool e_UseAutoCloseDoor( Item& door, Critter& cr, int skill )
{
	CreateTimeEvent( __FullSecond + REAL_SECOND( door.Val3 == 0 ? 10 : door.Val3 ), "e_AutoCloseDoor", door.Id, true );
	return false;
}

uint e_AutoCloseDoor( uint[] @ val )
{
	Item@ door = GetItem( val[ 0 ] );
	if( not valid( door ) ) { return 0; }
	if( !FLAG( door.LockerCondition, LOCKER_ISOPEN ) ) { return 0; }

	uint16 x = 0;
	uint16 y = 0;
	Map@ map = door.GetMapPosition( x, y );
	if( not valid( map ) ) { return 0; }

	Critter@ cr = map.GetCritter( x, y );
	if( valid( cr ) )
	{
		if( cr.IsLife() ) { return REAL_SECOND( 10 ); } else { cr.TransitToMap( map.Id, x - 1, y, cr.Dir ); }
	}

	if( door.LockerClose() ) { return 0; }

	return REAL_MINUTE( 3 );
}

// Дверь, которая не открывается стандартными способами
void _ClosedDoorInit( Item& door, bool firstTime )
{
    door.SetEvent( ITEM_EVENT_SKILL, "_UseDoor" );
}

bool _UseDoor( Item& door, Critter& cr, int skill )
{
    return true;
}

// Дверь, при использовании которой открывается диалог
void _DialogDoorInit( Item& door, bool firstTime )
{
    door.SetEvent( ITEM_EVENT_SKILL, "_UseDialogDoor" );
}

bool _UseDialogDoor( Item& door, Critter& cr, int skill )
{
	cr.ParamBase[ ST_LAST_DOOR_ID ] = door.Id;
    RunDialog( cr, door.Val3, door.HexX, door.HexY, false );
    return true;
}

// Голодиск с номером, присвоенном в Val0
void _HoloInit( Item& item, bool firstTime )
{
    if( item.GetProtoId() != PID_HOLODISK )
        return;
    item.HolodiskNumber = item.Val0;
    item.SetScript( "" );
    item.Update();

}

// from old lite

// powermagic - ????????? ????? ??? ????????
void _RndAnim( Item& item, bool firstTime ) // Sprite& sprite) // ItemCl& itemCl
{
    int rndFrm = Random( 0, item.Val1 );    // itemCl.GetSpriteCount(item.GetProtoId())); // + 1
    // item.Animate(rndFrm, rndFrm);
    item.AnimStayBegin      = rndFrm;
    item.AnimStayEnd        = rndFrm;
    item.AnimShowBegin      = rndFrm;
    item.AnimShowEnd        = rndFrm;
    item.AnimHideBegin      = rndFrm;
    item.AnimHideEnd        = rndFrm;
//	for (int i = 0; i > Sprite.FrmCount; i++)
    return;
}

void _ItemBagInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ItemBagPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_ItemBagUseItem" );
// item.SetEvent(ITEM_EVENT_USE_ITEM, "e_ItemBagOpen");
}

bool e_ItemBagPick( Item& item, Critter& crit, int skill ) //what is it? deprecated!
{
	if( skill == SKILL_PICK_ON_GROUND && item.Accessory == ACCESSORY_HEX )
    {
        MoveItem( item, item.GetCount(), crit );
        crit.Say( SAY_NETMSG, "pick grnd" );
    }
    return true;
}

import void SwitchState( Item& locker ) from "lockers";

bool e_ItemBagUseItem( Item& item, Critter& crit, Item@ usedItem )
{
    if( valid( usedItem ) && usedItem.GetProtoId() == PID_SHOVEL )
    {
        Map @ map = crit.GetMap();
        if( map.IsHexPassed( item.HexX + 2, item.HexY + 2 ) )
        {
            string logMsg;
            Item @ hole = map.AddItem( item.HexX + 2, item.HexY + 2, ITEM_TREASURE_HOLE, 1 );
            SETFLAG( hole.LockerCondition, LOCKER_ISOPEN );
            logMsg = "Init = " + SETFLAG( hole.LockerCondition, LOCKER_ISOPEN );
            crit.Say( SAY_NETMSG, logMsg );
//       if(FLAG(hole.LockerCondition,LOCKER_ISOPEN)) {SwitchState(hole);}
            hole.Val4 = hole.HexX;
            hole.Val5 = hole.HexY;
            hole.Val7 = crit.WorldX;
            hole.Val8 = crit.WorldY;
            Item @ treasureMap = crit.AddItem( ITEM_TREASURE_MAP, 1 );
            treasureMap.Val7 = crit.WorldX;
            treasureMap.Val8 = crit.WorldY;
            treasureMap.SetLexems( "$hexX" + treasureMap.Val7 + "$hexY" + treasureMap.Val8 );
//       treasureMap.SetLexems("$hexY"+treasureMap.Val8);
            return true;
        }
    }
    else if( item.Accessory == ACCESSORY_HEX )
    {
//     MoveItem(usedItem, usedItem.GetCount(), item, 0);
        crit.ShowScreen( SCREEN_CLOSE, 0, "" );
        ShowContainer( crit, item, item.Proto.GroundLevel ? TRANSFER_HEX_CONT_DOWN : TRANSFER_HEX_CONT_UP );
        return true;
    }
    return false;
}

void _ShovelInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ShovelUse" );
}

bool e_ShovelUse( Item& item, Critter& cr, int skill )
{
    if( skill == SK_TRAPS  && item.Accessory == ACCESSORY_CRITTER ) // && item.GetProtoId() == PID_SHOVEL
    {
        Map @ map = cr.GetMap();
        if( map.IsHexPassed( cr.HexX + 2, cr.HexY + 2 ) )
        {
            string logMsg;
            Item @ hole = map.AddItem( cr.HexX + 2, cr.HexY + 2, ITEM_TREASURE_HOLE, 1 );
            SETFLAG( hole.LockerCondition, LOCKER_ISOPEN );
            hole.Val4 = hole.HexX;
            hole.Val5 = hole.HexY;
            hole.Val7 = cr.WorldX;
            hole.Val8 = cr.WorldY;
            Item @ treasureMap = cr.AddItem( ITEM_TREASURE_MAP, 1 );
            treasureMap.SetLexems( "$hexX" + treasureMap.Val7 + "$hexY" + treasureMap.Val8 );
            return true;
        }
    }
    return false;
}



// powermagic
// key && key brunch script

void _KeyBunchInit( Item& item, bool firstTime )
{
    //item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_KeyBunchAdd" );
    //item.SetEvent( ITEM_EVENT_USE, "e_KeyBunchUse" );
	//item.SetEvent( ITEM_EVENT_SKILL, "e_KeyBunchSkill" );
}

bool e_KeyBunchTest( Item& item, Critter& cr, int skill )
{
    if( skill == SKILL_PUT_CONT )
    {
        cr.Say( SAY_NETMSG, "dude great!" );
        return true;
    }
    return false;
}

bool e_KeyBunchSkill( Item& item, Critter& cr, int skill ) // 143
{
    string msg;
    switch( skill )
    {
		case SK_REPAIR:
		{
			Item@ temp = cr.AddItem( 82, 1 );
			msg = Random( 0, 51 );
			temp.SetLexems( "$KeyLex" + Random( 0, 51 ) );
		}
		case SKILL_PICK_ON_GROUND:
			if( item.Accessory == ACCESSORY_HEX )
			{
				MoveItem( item, item.GetCount(), cr );
				return true;
			}
			if( item.ContainerId == cr.Id )
			{
				cr.Say( SAY_NETMSG, "that's work" );
				key = item.Id;
				cr.ShowScreen( SCREEN_CLOSE, 0, "@"    ); return true;
			}
		case SK_TRAPS:
		{
			Item@[] keys;
			item.GetItems( 0, keys );
			if( keys.length() > 0 )
			{
				cr.Action( ACTION_PICK_CRITTER, 0, null );
				for( uint8 i = 0; i < keys.length(); i++ )
				{
					MoveItem( keys[ i ], keys[ i ].GetCount(), cr );
				}
				cr.Say( SAY_NETMSG, "SUCK MY BALLS BITCH!!! " + item.Accessory );
				return true;
			}
		}
		case SK_SCIENCE:
		{
			Item@[] keys;
			item.GetItems( 0, keys );
			int[] keysId;
			if( keys.length() > 0 )
			{
				for( uint8 i = 0; i < keys.length(); i++ )
				{
					keysId[ i ] = keys[ i ].Id;
				}
				cr.RunClientScript( "_ItemLexRtn", 0, 0, 0, null, keysId );
			}
			return true;
		}
	}
    return false;
}

bool e_KeyBunchAdd( Item& item, Critter& cr, Item@ usedItem )
{
    if( usedItem.GetType() == ITEM_TYPE_KEY )
    {
        MoveItem( usedItem, usedItem.GetCount(), item, 0 );
        cr.Say( SAY_NETMSG, "You're added some key to brunch" );
        return true;
    }
    return false;
}

uint key;

bool e_KeyBunchUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( valid( onItem ) && onItem.GetType() == ITEM_TYPE_DOOR )
    {
        Item@[] keys;
        item.GetItems( 0, keys );
        if( onItem.LockerCondition == LOCKER_LOCKED )
        {
            for( uint8 i = 0; i < keys.length(); i++ )
            {
                if( keys[ i ].LockerId == onItem.LockerId )
                {
                    onItem.LockerId = 0;
                    onItem.LockerComplexity = 0;
                    cr.Say( SAY_NETMSG, "You're ulock the door" );
                }
            }
        }
    }
    return false;
}



void KeyUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ key = GetItem( player.StatBase[ ST_VAR0 ] );
        key.SetLexems( "$KeyLex" + answerS );
        key.Update();
    }
}

void _LockerInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_LockerKeyUse" );
}

bool ItemLockedCont( Item& item )
{
    if( item.GetType() == ITEM_TYPE_CONTAINER )
    {
        uint16 proto = item.GetProtoId();
        if( 41 < proto && proto < 46 )
        {
            return true;
        }
        if( 127 < proto && proto < 140 )
        {
            return true;
        }
        if( 180 < proto && proto < 190 )
        {
            return true;
        }
        if( 366 < proto && proto < 371 )
        {
            return true;
        }
        switch( proto )
        {
        case 245:
            return true;
        case 501:
            return true;
        case 502:
            return true;
        case 521:
            return true;
        }
    }
    return false;
}

bool e_LockerKeyUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( valid( onItem ) )
    {
        if( ( onItem.GetType() == ITEM_TYPE_DOOR || onItem.Proto.Container_Changeble || onItem.GetProtoId() == PID_SLOT_MACHINE || onItem.GetProtoId() == PID_SLOT_MACHINE2 
		|| onItem.GetProtoId() == PID_VENDING_CIGS ) && onItem.Val1 == 0 && onItem.Val0 == 0 )
        {
            if( _LockerIsClose( onItem ) ) /*onItem.LockerCondition == LOCKER_ISOPEN*/
            {
				if( cr.CountItem( PID_CRAFT_M_BARS ) < 1 )
				{
					cr.Say( SAY_NETMSG, "Вам нужна хотя бы одна железяка для заготовки ключа под устанавливаемый замок." );
					return true;
				}
				
                if( onItem.LockerCondition != LOCKER_LOCKED && onItem.LockerComplexity == 0 )
                {
                    uint key_pid = PID_BLANK_KEY;
					switch( item.GetProtoId() )
                    {
                    case PID_LOCKER_LOW:
                        onItem.Val0 = 1;
						key_pid = PID_TEMPLE_KEY;
                        break;
                    case PID_LOCKER_MED:
                        onItem.Val0 = 2;
						key_pid = PID_JAIL_KEY;
                        break;
                    case PID_LOCKER_HARD:
                        onItem.Val0 = 3;
						key_pid = PID_VAULT_13_SHACK_KEY;
                        break;
                    }

					cr.DeleteItem( PID_CRAFT_M_BARS, 1 );
					
                    Item @ key = cr.AddItem( key_pid, 1 );
                    uint keyNumber = Random( 0, 65534 );
                    key.LockerId = keyNumber;

                    onItem.LockerId = keyNumber;
                    onItem.LockerCondition = LOCKER_LOCKED;
                    onItem.LockerComplexity = cr.Skill[SK_LOCKPICK];

                    Log( "Заперт объект №" + onItem.Id + " на замок сложности " + onItem.LockerComplexity + "." );
                    DeleteItem( item );

                    key.SetLexems( null );
                    key.Update();

					cr.StatBase[ ST_LAST_DOOR_ID ] = key.Id;
					cr.StatBase[ ST_LAST_CONT_ID ] = key.Accessory;
					ShowInputBoxScreen( cr, "main@unsafe_MakeDescLex#Описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
                    return true;
                }
                else
                {
                    cr.Say( SAY_NETMSG, "Дверь уже заперта, сначала взломайте замок." );
                    return true;
                }
            }
            else
            {
                cr.Say( SAY_NETMSG, "Сначала закройте объект." );
                return true;
            }
        }
        else
        {
            cr.Say( SAY_NETMSG, "Этот объект нельзя запереть." );
            return true;
        }
    }
    return false;
}

void _LightEnvInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_LightEnvSkill" );
}

bool e_LightEnvSkill( Item& item, Critter& cr, int skill )
{
    cr.Say( SAY_NETMSG, "Don't steal the light!" );
    return true;
}

// Sargonius
// Очистка голодиска
// А ещё вверху кто-то запорол кодировку русских комментов, беда.
void _EmptyDisk( Item& item, bool firstTime )
{
    if( firstTime )
        item.HolodiskNumber = 0;         // Обнуляем номер голодиска
}

bool e_FillRegistrationDocs( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.Val1 == 0 )
    {
        cr.Say( SAY_NETMSG, "Вы вписали своё имя в документ, теперь он действительный" );
        string@ name = GetPlayerName( cr.Id );
        item.SetLexems( "$ModocRegistrationName" + name );
        item.Val1 = cr.Id;
        return true;
    }
    else
    {
        string@ name = GetPlayerName( item.Val1 );
        cr.Say( SAY_NETMSG, "Документ заполнен на имя: " + name );
        return true;
    }
}

// flare

#include "_colors.fos"

#define FLARE_BURN_TIME    ( 1000 )

// import bool GetPlayerRadius(Critter@ player, Critter@[]@ crs, uint16 radius) from "main";
import uint GetPlayers( Critter& cr, uint16 radius, bool square, Critter@[]& crs ) from "manager";

string dataName;                 // for anyData;
// uint16 flareLocId = 0;

bool ShowFlare( Critter@[] crs ) // crs[length-1] - critter who run function
{
    uint8 length = crs.length();
    Map @ map = crs[ length - 1 ].GetMap();
    if( !valid( map ) )
        return false;
    Location @ loc = map.GetLocation();
    if( !valid( loc ) || loc.AutoGarbage == false )
    {
        crs[ crs.length() - 1 ].Say( SAY_NETMSG, "Запускать ракету здесь - бессмыслеца. Найдите более подходящее место." );
        return false;
    }
    /*dataName = "flare_"+loc.Id;
       uint16[] playersId;
       if(IsAnyData(dataName)) GetAnyData(dataName, playersId);
       for(uint16 i = 0; i < length; i++)
       {
       //push_back(playersId, crs[i].Id);
       playersId.insertLast(crs[i].Id);
       if(!crs[i].IsKnownLoc(true, loc.Id)) crs[i].SetKnownLoc(true, loc.Id);
       }
       SetAnyData(dataName, playersId);
       MakeLocVisible(loc, true);
       loc.Color != COLOR_RED?loc.Color = COLOR_RED:0;*/
    uint flareLocId = loc.Id;
    CreateTimeEvent( __FullSecond + FLARE_BURN_TIME, "e_ShowFlare", flareLocId, false );
    return true;
}

uint e_ShowFlare( uint[] @ values )
{
    Location @ loc = GetLocation( values[ 0 ] );
    if( !valid( loc ) )
        return 0;
    /*uint16[] playersId;
       MakeLocVisible(loc, false);
       dataName = "flare_"+loc.Id;
       if(IsAnyData(dataName)) GetAnyData(dataName, playersId);
       uint8 length = playersId.length();
       if(length <= 0) return 0;
       Critter @ cr;
       for(uint8 i = 0; i < length; i++)
       {
       @cr = GetCritter(playersId[i]);
       if(cr.IsKnownLoc(true, loc.Id))
       cr.UnsetKnownLoc(true, loc.Id);
       }
       EraseAnyData(dataName);*/
    return 0;
}

/*void MakeLocVisible(Location& loc, bool visible)
   {
   visible?loc.GeckVisible=true:loc.GeckVisible=false;
   visible?loc.GeckCount=1:loc.GeckCount=0;
   visible?loc.AutoGarbage=false:loc.AutoGarbage=true;
   //return false; //fail
   }*/

void _FlareGun( Item& item, bool firstTime )
{
    // if(firstTime)
    // {
    //item.SetEvent( ITEM_EVENT_SKILL, "e_FlareGunSkill" );
    // }
}

bool e_FlareGunSkill( Item& item, Critter& cr, int skill ) // 143
{
    if( skill != SK_TRAPS )
        return false;
    return FlareGunUse( cr, item );
}

bool FlareGunUse( Critter& cr, Item& item ) // export
{
    if( item.AmmoCount > 0 )
    {
        Critter@[] crs;
        GetGlobalMapCritters( cr.WorldX, cr.WorldY, 200, FIND_LIFE | FIND_ONLY_PLAYERS, crs );
        crs.insertLast( cr );
        if( !ShowFlare( crs ) )
            return false;
        item.AmmoCount -= 1;
        item.Update();
        cr.Say( SAY_NETMSG, "Вы запустили сигнальную ракету." );
    }
    return true;
}
/* //старая функция?? ShowFlare(crs) не будет работать с найденным.
   void testflare(Critter& cr, int p0, int p1, int p2)
   {
   Critter@[] crs;
   uint len = GetPlayers(cr, uint16(p0), p1!=0, crs);
   cr.Say(SAY_NETMSG, "вспышку увидят "+len);
   ShowFlare(crs);
   }*/
// end of flare

// gm item / quest reward

uint expBook;

void _ExpBookInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ExpBookSkill" );
    if( firstTime )
    {

        item.SetEvent( ITEM_EVENT_USE, "e_ExpBookUse" );
    }
}

bool e_ExpBookSkill( Item& item, Critter& cr, int skill )
{
    switch( skill )
    {
    case  SK_TRAPS:
        expBook = item.Id;
        cr.ShowScreen( SCREEN_SAY, 1, "ExpBookScreen" );
        break;
    case SK_REPAIR:
        item.Val1 = ( item.Val1 == 0 ? 1 : 0 );
        break;
    case SK_SCIENCE:
        cr.Say( SAY_NETMSG, "item state = " + item.Val1 );
        break;
    }
    return true;
}

void ExpBookScreen( Critter& cr, uint answerI, string& answerS )
{
    Item@ expBook0 = GetItem( expBook );
    expBook0.SetEvent( ITEM_EVENT_SKILL, "" );
    if( answerS.length() > 0 )
        StrToInt( answerS, expBook0.Val0 );
    cr.Say( SAY_NETMSG, "" + expBook0.Val0 + " " + answerI + " " + answerS );
}

bool e_ExpBookUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_NETMSG, "" + item.Val0 );
    if( item.Val0 != 0 )
    {
        if( item.Val1 == 0 )
        {
            cr.StatBase[ ST_EXPERIENCE ] += item.Val0;
        }
        else
        {
            cr.StatBase[ ST_UNSPENT_SKILL_POINTS ] += item.Val0;
            cr.Say( SAY_NETMSG, "U recive " + item.Val0 + " skill points" );
        }
        DeleteItem( item );
        return true;
    }
    return false;
}

// master key. unlock and open door
void _InitMasterKey( Item& key, bool firstTime )
{
	// Log( "Инициализируем ключ PID " + key.GetProtoId() + " # " + key.Id + "." );
    // key.SetEvent( ITEM_EVENT_USE, "e_MasterKeyUse" );
}

bool e_MasterKeyUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    // if( valid( onItem ) && ( onItem.GetType() == ITEM_TYPE_DOOR || onItem.GetType() == ITEM_TYPE_CONTAINER ) )
    // {
        // SwitchState( item );
        // item.Update();
    // }
    return true;
}

void _InitPoliceStuff( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_PoliceStuffUse" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_PoliceStuffPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_PoliceStuffHammer" );
}

import bool LocIsModoc( uint locPid ) from "globalmap_group";

bool e_PoliceStuffPick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        Map @ map = cr.GetMap();
        Location @ loc = map.GetLocation();
        if( LocIsModoc(loc.GetProtoId()) )
        {
            if( cr.CountItem( PID_GUARD_BADGE ) >= 1 || item.Val0 == 0 )
            {
                return false;
            }
            cr.Say( SAY_NETMSG, "Вы не уполномочены перенести табличку" );
            return true;
        }
        else if( item.Val1 == 0 )
        {
            return false;
        }
        cr.Say( SAY_NETMSG, "Вы не можете перенести табличку" );
        return true;
    }
    return true;
}

bool e_PoliceStuffHammer( Item& item, Critter& cr, Item@ usedItem )
{
    int HammerTime = ( 11 - cr.Stat[ ST_STRENGTH ] ) * 60 * 10;
    if( item.GetProtoId() == PID_SIGN )
    {
        if( ( cr.Timeout[ TO_SK_REPAIR ] == 0 ) && ( cr.StatBase[ ST_LEVEL ] >= 3 ) )
        {
            if( valid( usedItem ) && ( usedItem.GetProtoId() == PID_SLEDGEHAMMER ) )
            {
                if( cr.CountItem( PID_IRON_PROD ) >= 1 )
                {
                    item.Val1 += 1;
                    cr.DeleteItem( PID_IRON_PROD, 1 );
                    cr.Say( SAY_NETMSG, "Вы забиваете кувалдой крепежные штыри." );
                    cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + HammerTime;
                }
                else
                    cr.Say( SAY_NETMSG, "Нет крепежных штырей (арматур)." );
                return true;
            }
            if( valid( usedItem ) && ( usedItem.GetProtoId() == PID_CROWBAR ) && ( cr.ParamBase[ SK_REPAIR ] >= 100 ) )
            {
                if( item.Val1 >= 1 )
                {
                    item.Val1 -= 1;
                    cr.Say( SAY_NETMSG, "Вы выдергиваете ломиком крепежные штыри." );
                    cr.TimeoutBase[ TO_SK_REPAIR ] = __FullSecond + HammerTime;
                }
                else
                    cr.Say( SAY_NETMSG, "Табличка не закреплена." );
                return true;
            }
        }
        cr.Say( SAY_NETMSG, "У вас недостаточно сил." );
    }
    return false;
}

bool e_PoliceStuffUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_SIGN )
    {
        if( item.Val0 == 0 )
        {
            cr.ShowScreen( SCREEN_SAY, 0, "item@SignUseScreen" );
            cr.StatBase[ ST_VAR0 ] = item.Id;
        }
        else
            cr.Say( SAY_NETMSG, "табличка уже заполненна" );
    }
    return true;
}

void SignUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ item = GetItem( player.StatBase[ ST_VAR0 ] );
        item.SetLexems( "" + answerS );
        item.Val0 = 1;
        item.Update();
    }
}


import bool SetTrapOnItem( Critter& cr, Item& trap, Item& onItem ) from "trap"; // Export
import bool UseSkillOnTrappedItem(Item& trappedItem, Critter& cr,  int skill) from "trap"; // Export

void _TestTrapInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_TestTrapUse" );
}

bool e_TestTrapUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
//	return false;

    if( @cr == null || @item == null || @onItem == null )
        return false;
    // if(onItem.LockerCondition == LOCKER_ELECTRO) return false;
    if( SetTrapOnItem( cr, item, onItem ) )
    {
        onItem.SetEvent( ITEM_EVENT_SKILL, "trap@UseSkillOnTrappedItem" );
        return true;
    }
    return false;
}

void _WhistInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_WhistUse" );
}

bool e_WhistUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    map.PlaySound( "whist.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    cr.Say( SAY_EMOTE_ON_HEAD, "Свестит в свисток." );
    return true;
}

void _InitRpNamer( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_RpNamerUse" );
}

bool e_RpNamerUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_INFOPAD )
    {
        cr.ShowScreen( SCREEN_SAY, 0, "item@RpNamerUseScreen" );
        cr.StatBase[ ST_VAR0 ] = item.Id;
    }
    return true;
}

void RpNamerUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ item = GetItem( player.StatBase[ ST_VAR0 ] );
        player.SetLexems( answerS );
        DeleteItem( item );
    }
}

void _music_fleita( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_fleitaUse" );
}

bool e_fleitaUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    if( Random( 1, 5 ) > 4 )
        map.PlaySound( "flute.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 3 )
        map.PlaySound( "flute2.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 2 )
        map.PlaySound( "flute3.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 1 )
        map.PlaySound( "flute4.wav", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    else if( Random( 1, 5 ) > 0 )
        map.PlaySound( "flute5.ogg", cr.HexX, cr.HexY, cr.Stat[ ST_ENDURANCE ] * 5 );
    cr.Say( SAY_EMOTE_ON_HEAD, "Играет на флейте." );
    Location @ loc = map.GetLocation();
    if( ( loc.WorldX <= 50 ) || ( loc.WorldX >= 150 ) || ( loc.WorldY <= 50 ) || ( loc.WorldY >= 150 ) )
    {
        cr.Say( SAY_NETMSG, "Вы слишком далеко от фермы." );
        return true;
    }
    if( ( loc.WorldX >= item.Val2 - 20 ) && ( loc.WorldX <= item.Val2 + 20 ) && ( loc.WorldY >= item.Val3 - 20 ) && ( loc.WorldY <= item.Val3 + 20 ) )
    {
        cr.Say( SAY_NETMSG, "Тут брамины уже паслись." );
        return true;
    }
    if( loc.Id >= 100 && loc.Id <= 139 )
    {
        cr.Say( SAY_NETMSG, "Начинаете пасти стадо." );
        item.Val1 = map.Id;
        item.Val2 = loc.WorldX;
        item.Val3 = loc.WorldY;
        cr.AddTimeEvent( "cte_BrahminEat", ( 60 * 3 ) * __TimeMultiplier, CTE_WORK, 0 );
    }
    return true;
}

uint cte_BrahminEat( Critter& cr, int identifier, uint& rate )
{
    Critter@[] brahmins;
    Item@ flute = cr.GetItem( PID_FLUTE, SLOT_HAND1 );
    Map @ map = cr.GetMap();
    if( !valid( flute ) || !valid( map ) )
        return 0;
    if( ( map.GetCritters( NPC_PID_Brahmin, FIND_LIFE_AND_KO | FIND_ONLY_NPC, brahmins ) > 0 ) && int( map.Id ) == flute.Val1 )
    {
        for( uint i = 0, ii = brahmins.length(); i < ii; i++ )
            brahmins[ i ].StatBase[ ST_VAR5 ] += 1;

        cr.Say( SAY_NETMSG, "Брамины кажется насытились тут" );
    }
    return 0;
}

void _dosimetr( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_dosimetrUse" );
}

bool e_dosimetrUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    Map @ map = cr.GetMap();
    cr.Say( SAY_EMOTE_ON_HEAD, "Производит замер." );
    Location @ loc = map.GetLocation();
    if( ( loc.WorldX >= item.Val1 - 20 ) && ( loc.WorldX <= item.Val1 + 20 ) && ( loc.WorldY >= item.Val2 - 20 ) && ( loc.WorldY <= item.Val2 + 20 ) )
    {
        cr.Say( SAY_NETMSG, "Кажется место правильное, остается только подождать несколько минут." );
        item.Val3 = map.Id;
        cr.AddTimeEvent( "cte_dosimetrUse", 60 * 3, CTE_WORK, 0 );
    }
    return true;
}

uint cte_dosimetrUse( Critter& cr, int identifier, uint& rate )
{
    Item@ dosimetr = cr.GetItem( PID_DOSIMETR, SLOT_HAND1 );
    Map @ map = cr.GetMap();
    if( !valid( dosimetr ) || !valid( map ) )
        return 0;
    if( int( map.Id ) == dosimetr.Val3 )
    {
        cr.Say( SAY_NETMSG, "Индикатор изменил цвет на желтый, можно возвращаться." );
        DeleteItem( dosimetr );
        cr.AddItem( PID_DOSIMETR_USED, 1 );
    }
    else
        cr.Say( SAY_NETMSG, "Время прошло, но индикатор не сменил цвет, кажется мы сделали что-то неправильно." );
    return 0;
}

void _TraderBadge( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_traderbadgeUse" );
}

bool e_traderbadgeUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "Показывает значек торговца" );
    return true;
}

void _PochtaBadge( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_PochtaBadgeUse" );
}

bool e_PochtaBadgeUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "Показывает значек оружейника" );
    return true;
}

void _kosakInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_kosakUse" );
}

bool e_kosakUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	Item @ respirator = _CritGetItemHandExt( cr );
	if( !(respirator is null) && respirator.GetProtoId() == PID_RESPIRATOR )
	{
		cr.Say( SAY_NETMSG, "Вы не можете курить через респиратор." );
		return true;
	}

	if( ( _CritCountItem( cr, PID_LIGHTER ) < 1 && _CritCountItem( cr, PID_FIREPLACE_TOKEN ) < 1 ) )
	{
		cr.Say( SAY_NETMSG, "Вам нужен источник огня, что бы прикурить." );
		return true;
	}
	
    
    Map @ map = cr.GetMap();
	if( Random( 0, 1 ) > 0 )
        map.PlaySound( "smoking.ogg", cr.HexX, cr.HexY, 1 );
    else
        map.PlaySound( "drugs2.wav", cr.HexX, cr.HexY,  1 );

	if( valid( onCritter ) && onCritter.IsPlayer() )
	{
		SayLog( cr, crInfo( cr ) + " предлагает " + crInfo( onCritter ) + " дунуть косяк." );
		onCritter.ParamBase[ CR_VAL0 ] = item.Id;
		
		onCritter.ShowScreen( SCREEN_DIALOGBOX, 1, "answer_SmokingWeed" );
		onCritter.Say( SAY_DIALOGBOX_TEXT, "Вам предлагают дунуть косяк, согласитесь?");
		onCritter.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Да" );
		onCritter.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Нет" );
		
		cr.Say( SAY_NETMSG, "Вы предложили дунуть." );		
		return true;
	}
	
	SmokingWeed( cr, item );
    return true;
}

void SmokingWeed( Critter& cr, Item& item )
{
    SayLog( cr, crInfo( cr ) + " раскуривает косяк." );
	cr.Say( SAY_EMOTE_ON_HEAD, "Раскуривает косяк" );
    cr.StatBase[ ST_EXPERIENCE ] += 10 * Random( 1, 5 );
	//cr.StatBase[ ST_RADIATION_LEVEL ] += Random( 0, 2 );
	AffectPoison( cr, Random( 1, 5 ) );
	cr.StatBase[ ST_HUNGER ] -= Random( 2, 4 );
	cr.StatBase[ ST_THIRST ] -= Random( 2, 4 );
    cr.StatBase[ ST_DYSPNEA ] -= Random( 0, 10 );

	int time = cr.Timeout[ TO_TIREDNESS ];
	if( time > 0 )
	{
		//time = CLAMP( time - __FullSecond, 0, time );
		time = CLAMP( time - REAL_SECOND( Random( 60, 120 ) ), 0, time );
		cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + time;
	}
	
	if( Random( 0, 2 ) == 0 )
		_SubItem( item, 1 );
}

void answer_SmokingWeed( Critter& targetCr, uint answerI, string& answerS)
{
	Item@ weed = GetItem( targetCr.ParamBase[ CR_VAL0 ] );
	if( valid( weed ) )
		SmokingWeed( targetCr, weed );
}


import void Warn( Critter& admin, int param0, int param1, int param2 )  from "warning"; // ErlKing
import void say( Critter& player, int param0, int param1, int param2 )  from "gm";      // ErlKing

void _InitGmPistol( Item& item, bool firstTime )
{
	//TrackItemState( item );
	
	item.SetEvent( ITEM_EVENT_USE, null );
	item.SetEvent( ITEM_EVENT_SKILL, null );
	item.SetEvent( ITEM_EVENT_ATTACK, null );
}

string[] GMPISTOL_ACTIONS = { "скачать help", "скачать warn", "очистить help", "очистить warn" };

bool e_GmPistolUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_GM_PISTOL && isGM( cr ) )
    {
		string[] data = { "answer_GmPistol_GM_menu", "Что желаешь хозяин?" };
		for( uint i = 0, l = GMPISTOL_ACTIONS.length(); i < l; i++ )
			data.insertLast( GMPISTOL_ACTIONS[i] );
		DIALOG_MENU( cr, data );
		cr.StatBase[ ST_VAR1 ] = item.Id;
    }
    return true;
}

void clearGmPistol( Item& item )
{
	item.Val0 = 1;
	item.SetEvent( ITEM_EVENT_USE, null );
    item.SetEvent( ITEM_EVENT_SKILL, null );
    item.SetEvent( ITEM_EVENT_ATTACK, null );
}

void answer_GmPistol_GM_menu( Critter& cr, uint answerI, string& answerS )
{
	Item@ item = GetItem( cr.StatBase[ ST_VAR1 ] );
	if( !valid( item ) ) return;
	
	LogInfoTime( "logs\\containers.txt", crInfo( cr ) + " тщетно пытается " + GMPISTOL_ACTIONS[answerI] + ". Фотик обнулён - функционал сброшен." );
	clearGmPistol( item );
}

bool e_GmPistolPick( Item& item, Critter& cr, int skill )
{
	LogInfoTime( "logs\\containers.txt", crInfo( cr ) + " тщетно пытается поднять ГМ-фотик. Функционал сброшен, теперь это просто фотик." );
	clearGmPistol( item );
    return false;
}

string[] GMPISTOL_ACTIONS_DEFAULT = { "предупреждение", "дать опыт", "дать скиллов", "дать деньги", "кнокнуть" };
string[] GMPISTOL_ACTIONS_USER = { "сленг", "повергейминг", "выход из роли", "мародерство", "клептомания", "метагейм", "мультоводство" };
bool e_GmPistolAttack( Item& item, Critter& cr, Critter& target )
{
	LogInfoTime( "logs\\containers.txt", crInfo( cr ) + " тщетно пытается абузить ГМ-фотик. Посмотрим, что он выберет.." );
	
    if( cr.IsPlayer() )
    {
		cr.StatBase[ ST_VAR0 ] = target.Id;
		cr.StatBase[ ST_VAR1 ] = item.Id;
        if( isGM( cr ) )
        {
			string[] data = { "answer_GmPistolAttack_GM", "Че те надо, карман?" };
			for( uint i = 0, l = GMPISTOL_ACTIONS_DEFAULT.length(); i < l; i++ )
				data.insertLast( GMPISTOL_ACTIONS_DEFAULT[i] );
			DIALOG_MENU( cr, data );
        }
        else
        {
			string[] data = { "answer_GmPistolAttack_player", "Че те надо, карман?" };
			for( uint i = 0, l = GMPISTOL_ACTIONS_USER.length(); i < l; i++ )
				data.insertLast( GMPISTOL_ACTIONS_USER[i] );
			DIALOG_MENU( cr, data );
        }
    }
    return true;
}

void answer_GmPistolAttack_player( Critter& cr, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( cr.Stat[ ST_VAR0 ] );
    if( !valid( target ) ) return;

	Item@ item = GetItem( cr.StatBase[ ST_VAR1 ] );
	if( !valid( item ) ) return;

	LogInfoTime( "logs\\containers.txt", crInfo( cr ) + " тщетно пытается выдать предупреждение " + crInfo( target ) + " за '" + GMPISTOL_ACTIONS_USER[answerI] + "'. Фотик обнулён - функционал сброшен." );
	clearGmPistol( item );
}

void answer_GmPistolAttack_GM( Critter& cr, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( cr.Stat[ ST_VAR0 ] );
    if( !valid( target ) ) return;

	Item@ item = GetItem( cr.StatBase[ ST_VAR1 ] );
	if( !valid( item ) ) return;

	LogInfoTime( "logs\\containers.txt", crInfo( cr ) + " тщетно пытается " + GMPISTOL_ACTIONS_DEFAULT[answerI] + " для " + crInfo( target, true ) +". Фотик обнулён - функционал сброшен." );
	clearGmPistol( item );
}

void GmPistol_exp( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.StatBase[ ST_EXPERIENCE ] += number;
        player.Say( SAY_NETMSG, "вы выдали " + number + " опыта игроку " + target.Id );
    }
}

void GmPistol_skill( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.StatBase[ ST_UNSPENT_SKILL_POINTS ] += number;
        player.Say( SAY_NETMSG, "вы выдали " + number + " скиллпоинтов игроку " + target.Id );
    }
}

void GmPistol_money( Critter& player, uint answerI, string& answerS )
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.AddItem( PID_BOTTLE_CAPS, number );
        player.Say( SAY_NETMSG, "вы выдали " + number + " монет, персонажу " + target.Id );
    }
}

//import void GmPistol_knockdown( Critter& player, uint answerI, string& answerS ) from "item";
void GmPistol_knockdown( Critter& player, uint answerI, string& answerS ) //exported
{
    Critter@ target = GetCritter( player.Stat[ ST_VAR0 ] );
    if( !valid( target ) )
        return;
    if( answerS.length() > 0 )
    {
        int number = 0;
        StrToInt( answerS, number );
        target.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( Random( 0, 1 ) == 0 ? true : false ), number, target.HexX, target.HexY );
        player.Say( SAY_NETMSG, "Вы уронили " + target.Id + " на " + number + " ОД." );
    }
}

void _InitRPStuff( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_RPStuffUse" );
}

bool e_RPStuffUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.Val0 == 0 )
    {
        cr.ShowScreen( SCREEN_SAY, 0, "item@RPStuffUseScreen" );
        cr.StatBase[ ST_VAR0 ] = item.Id;
    }
    else
        cr.Say( SAY_NETMSG, "уже заполненно" );
    return true;
}

void RPStuffUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ item = GetItem( player.StatBase[ ST_VAR0 ] );
        uint16 itemPid = item.GetProtoId();

        switch( itemPid )
        {
        case PID_RPSTUFF1:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPSTUFF2:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPSTUFF3:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPSTUFF4:
            item.SetLexems( "" + answerS );
            break;
		case PID_PICTURE:
            item.SetLexems( "" + answerS );
            break;	
        case PID_RPGUN1:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPGUN2:
            item.SetLexems( "" + answerS );
            break;
        case PID_RPGUN3:
            item.SetLexems( "" + answerS );
            break;
        }

        item.Val0 = 1;
        item.Update();
    }
}

void _InitPuti( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_DROP, "e_PutiDrop" );
}

void e_PutiDrop( Item& item, Critter& cr )
{
    if( cr.CountItem( PID_ROPE_USED ) != 0 || cr.CountItem( PID_HANDCUFFS_USED ) != 0 )
    {
        cr.AddItem( PID_PUTI, 1 );
        cr.Say( SAY_NETMSG, "Вы не можете снять путы" );
    }
    DeleteItem( item );
}

// depracated
void _InitCodeDoor( Item& item, bool firstTime )
{
    Log( "Depracated function item@_InitCodeDoor at item.Id " + item.Id );
    // item.SetEvent(ITEM_EVENT_SKILL, "e_CodeDoorSkill");
    // item.LockerCondition = LOCKER_ELECTRO;
}
/*
   bool e_CodeDoorSkill(Item& item, Critter& cr, int skill)
   {
        if(skill == SKILL_PICK_ON_GROUND)
        {
                if(_LockerIsClose(item))
                {

                        cr.RunClientScript("client_screen_codedoor@ShowScreen", item.Id, item.Val1, 0, "Введите код", null);
                        return true;
                }
        }
   return false;
   }*/

void _InitAidKit( Item& item, bool firstTime )
{
    item.SetLexems( "Медикаментов там " + SetupAidLeX( item.Indicator ) + "." );
}

string SetupAidLeX( uint8 aidValue )
{
    string resultTemp = "";

    if( aidValue == 100 )
        resultTemp = "полная сумка";
    else if( aidValue > 80 )
        resultTemp = "достаточно";
    else if( aidValue > 60 )
        resultTemp = "чуть больше половины";
    else if( aidValue > 40 )
        resultTemp = "немного меньше половины";
    else if( aidValue > 20 )
        resultTemp = "совсем не много";
    else if( aidValue > 10 )
        resultTemp = "на дне";
    else if( aidValue > 0 )
        resultTemp = "практически нет";
    else if( aidValue == 0 )
        resultTemp = "нет";

    return resultTemp;
}

void _AutoDoorInit( Item& item, bool firstTime )
{
    if( item.GetProtoId() == PID_AUTODOOR )
        item.SetEvent( ITEM_EVENT_WALK, "e_AutoDoorWalk" );
}

void e_AutoDoorWalk( Item& item, Critter& cr, bool entered, uint8 dir )
{
    Item@ door = GetItem( item.Val1 );
    if( !valid( door ) )
    {
        DeleteItem( item );
        return;
    }
	
	Map @ map = cr.GetMap();
	if( entered )
    {
        if( valid( cr ) && cr.IsPlayer() && cr.StatBase[ ST_BODY_TYPE ] < BT_BRAHMIN && !FLAG( door.LockerCondition, LOCKER_ISOPEN ) && !FLAG( door.LockerCondition, LOCKER_LOCKED ) && !(door.LockerCondition == LOCKER_ELECTRO) && map.GetData(24)>0 )
        {
            door.LockerOpen();
        }
    }
    else
    {
        if( valid( cr ) && cr.IsPlayer() && cr.StatBase[ ST_BODY_TYPE ] < BT_BRAHMIN && map.GetData(24)>0 )
        {
            uint16 x = 0;
            uint16 y = 0;
            @ map = door.GetMapPosition( x, y );
            if( map.GetCrittersHex( x, y, 1, FIND_LIFE, null ) == 0 ) door.LockerClose();
        }
    }
}

void _PillsInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_PillsUse" );
}

bool e_PillsUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    if( item.GetProtoId() == PID_HEART_PILLS )
    {
		cr.Say( SAY_EMOTE_ON_HEAD, "принимает таблетки" );
        cr.StatBase[ ST_POISONING_LEVEL ] += 1;
        return true;
    }
    else if( item.GetProtoId() == PID_PILLS )
    {
        //cr.StatBase[ ST_POISONING_LEVEL ] += 1;
		string info = "";
		if( cr.StatBase[ST_BLOOD_TOXIC] > 0 )
			info += "Есть признаки начала заражения крови. Проведите медобследование у доктора.";
		if( cr.StatBase[ST_BLOOD_TOXIC] > cr.Stat[ ST_ENDURANCE ] * 10 )
			info += " Обнаружены симптомы прогрессирования заражения крови, необходимо принять лекарства!";
		if( info.length() > 0 )
			cr.Say( SAY_NETMSG, info );
		else
			cr.Say( SAY_NETMSG, "Вам кажется, что нет смысла перестраховываться глотая эту гадость - вы не чувствуете симптомов заражения крови." );
        return true;
    }
    return true;
}

void _MercsSignInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_MercsSign" );
}

bool e_MercsSign( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "показывает плакат с нарисованным копотом" );
    return true;
}

void _MercsSign2Init( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_MercsSign2" );
}

bool e_MercsSign2( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    cr.Say( SAY_EMOTE_ON_HEAD, "показывает нашивку с нарисованным копотом" );
    return true;
}

void _InitEmptyHypo( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_EmptyHypoUse" );
}

bool e_EmptyHypoUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    bool onSelf = ( !valid( onCritter ) && !valid( onItem ) && !valid( onScenery ) );
    if( onSelf )
    {
        Item @ hypo = cr.AddItem( PID_HYPO_BLOOD, 1 );
        hypo.Val1 = cr.Id;
        hypo.Val2 = cr.Stat[ ST_TOXIC ];
        hypo.Val3 = cr.StatBase[ ST_DESEASE ];
        hypo.Val4 = cr.Param[ ST_BODY_TYPE ];
        hypo.Val5 = cr.Stat[ ST_POISONING_LEVEL ];
        hypo.Val6 = cr.Stat[ ST_RADIATION_LEVEL ];
        cr.StatBase[ ST_VAR0 ] = hypo.Id;
        cr.ShowScreen( SCREEN_SAY, 0, "item@HypoUseScreen" );
        hypo.Update();
        cr.DeleteItem( PID_HYPODERMIC_NEEDLE, 1 );
        cr.Say( SAY_NETMSG, "Вы взяли у себя образец крови." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Берет образец крови" );
        return true;
    }
    else if( cr.IsPlayer() && valid( cr ) && valid( onCritter ) )
    {
        if( cr.Timeout[ TO_BATTLE ] > 0 || onCritter.Timeout[ TO_BATTLE ] > 0 )
        {
            cr.Say( SAY_NETMSG, "Это неуместно" );
            return true;
        }
        Item @ hypo = cr.AddItem( PID_HYPO_BLOOD, 1 );
        hypo.Val1 = onCritter.Id;
        hypo.Val2 = onCritter.Stat[ ST_TOXIC ];
        hypo.Val3 = onCritter.StatBase[ ST_DESEASE ];
        hypo.Val4 = onCritter.Param[ ST_BODY_TYPE ];
        hypo.Val5 = onCritter.Stat[ ST_POISONING_LEVEL ];
        hypo.Val6 = onCritter.Stat[ ST_RADIATION_LEVEL ];
        cr.StatBase[ ST_VAR0 ] = hypo.Id;
        cr.ShowScreen( SCREEN_SAY, 0, "item@HypoUseScreen" );
        hypo.Update();
        cr.DeleteItem( PID_HYPODERMIC_NEEDLE, 1 );
        cr.Say( SAY_NETMSG, "Вы взяли образец крови." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Берет образец крови" );
        return true;
    }
    else
        cr.Say( SAY_NETMSG, "Это неуместно" );
    return true;
}

void HypoUseScreen( Critter& player, uint answerI, string& answerS )
{
    if( answerS.length() != 0 )
    {
        Item @ Hypo = GetItem( player.StatBase[ ST_VAR0 ] );
        Hypo.SetLexems( "$HypoLex" + answerS );
        Hypo.Update();
    }
}

void _InitBloodHypo( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_BloodHypoUse" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_BloodHypoSkill" );
}

import void ApplyDesease( Critter& player, int param0, int param1 ) from "morphes";

bool e_BloodHypoUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    bool onSelf = ( !valid( onCritter ) && !valid( onItem ) && !valid( onScenery ) );
    if( onSelf )
    {
        if( item.Val3 != 0 )
        {
            if( item.Val1 == 0 && cr.StatBase[ ST_DESEASE ] <= item.Val3 )
            {
                if( cr.GetTimeEvents( 7, null, null, null ) > 0 && cr.Stat[ ST_TOXIC ] > 0 )
                {
                    cr.EraseTimeEvents( 7 );
                    cr.StatBase[ ST_TOXIC ] = 0;
                }
                cr.StatBase[ ST_DESEASE ] = item.Val3;
            }
            else if( item.Val2 != 0 || Random( 0, 1 ) > 0 )
                ApplyDesease( cr, cr.Id, item.Val3 );
            else if( cr.StatBase[ ST_DESEASE ] < item.Val3 )
                cr.StatBase[ ST_DESEASE ] = item.Val3;
        }
        cr.Say( SAY_NETMSG, "Вы вкололи шприц себе." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Вкалывает шприц" );
        DeleteItem( item );
        return true;
    }
    else if( cr.IsPlayer() && valid( cr ) && valid( onCritter ) )
    {
        if( cr.Timeout[ TO_BATTLE ] > 0 || onCritter.Timeout[ TO_BATTLE ] > 0 )
        {
            cr.Say( SAY_NETMSG, "Это неуместно" );
            return true;
        }
        if( item.Val3 != 0 && onCritter.IsPlayer() )
        {
            if( item.Val1 == 0 && onCritter.StatBase[ ST_DESEASE ] <= item.Val3 )
            {
                if( onCritter.GetTimeEvents( 7, null, null, null ) > 0 && onCritter.Stat[ ST_TOXIC ] > 0 )
                {
                    onCritter.EraseTimeEvents( 7 );
                    onCritter.StatBase[ ST_TOXIC ] = 0;
                }
                onCritter.StatBase[ ST_DESEASE ] = item.Val3;
            }
            else if( item.Val2 != 0 || Random( 0, 1 ) > 0 )
                ApplyDesease( cr, onCritter.Id, item.Val3 );
            else if( onCritter.StatBase[ ST_DESEASE ] < item.Val3 )
                onCritter.StatBase[ ST_DESEASE ] = item.Val3;
        }
        cr.Say( SAY_NETMSG, "Вы вкололи шприц." );
        cr.Say( SAY_EMOTE_ON_HEAD, "Вкалывает шприц" );
        DeleteItem( item );
        return true;
    }
    else
        cr.Say( SAY_NETMSG, "Это неуместно" );
    return true;
}

import void MakeCure( Critter& doctor, Item@ hypo ) from "dialog";

bool e_BloodHypoSkill( Item& item, Critter& cr, int skill )
{
	if( skill != SK_DOCTOR && skill != SK_SCIENCE )
		return false;

	if( _CritCountItem( cr, PID_DOCTORS_BAG ) == 0 )
	{
		cr.Say( SAY_NETMSG, "Вам нужны соответствующие инструменты для анализа крови." );
		return true;
	}

	if( skill == SK_DOCTOR && cr.Skill[ SK_SCIENCE ] > 150 && cr.Skill[ SK_DOCTOR ] > 150 )
	{
		MakeCure( cr, item );
		return true;
	}
	
    if( skill == SK_SCIENCE )
    {
        int body = item.Val4;
        if( cr.Skill[ SK_SCIENCE ] > 50 || cr.Skill[ SK_SCIENCE ] > 50 )
        {
            switch( body )
            {
            case 0:
                cr.Say( SAY_NETMSG, "Это кровь человека." );
                break;
            case 1:
                cr.Say( SAY_NETMSG, "Это кровь человека." );
                break;
            case 2:
                cr.Say( SAY_NETMSG, "Это кровь человека." );
                break;
            case 3:
                cr.Say( SAY_NETMSG, "Это кровь супермутанта." );
                break;
            case 4:
                cr.Say( SAY_NETMSG, "Это кровь гуля." );
                break;
            case 5:
                cr.Say( SAY_NETMSG, "Это кровь брамина." );
                break;
            case 6:
                cr.Say( SAY_NETMSG, "Это кровь скорпиона" );
                break;
            case 7:
                cr.Say( SAY_NETMSG, "Это кровь крысы" );
                break;
            case 8:
                cr.Say( SAY_NETMSG, "Это кровь летуна" );
                break;
            case 9:
                cr.Say( SAY_NETMSG, "Это кровь кентавра" );
                break;
            case 10:
                cr.Say( SAY_NETMSG, "Это гидравлическая жидкость, непонятно как она попала в шприц." );
                break;
            case 11:
                cr.Say( SAY_NETMSG, "Это кровь собаки" );
                break;
            case 12:
                cr.Say( SAY_NETMSG, "Это жидкость мантиса" );
                break;
            case 13:
                cr.Say( SAY_NETMSG, "Это кровь смертокогтя" );
                break;
            case 14:
                cr.Say( SAY_NETMSG, "Это жидкость из растения" );
                break;
            case 15:
                cr.Say( SAY_NETMSG, "Это кровь гекко" );
                break;
            case 16:
                cr.Say( SAY_NETMSG, "Это кровь чужого" );
                break;
            }
            if( cr.Skill[ SK_SCIENCE ] > 100 && body <= 4 )
            {
                if( item.Val2 == 0 )
                    cr.Say( SAY_NETMSG, "Уровень лейкоцитов в норме." );
                else if( item.Val2 <= 50 )
                    cr.Say( SAY_NETMSG, "В крови присутствуют следы воздействия какого-то вируса." );
                else
                    cr.Say( SAY_NETMSG, "Заметны образования в крови, видимо воздействие вируса было довольно продолжительным." );
            }
        }
        return true;
    }
    return false;
}

void _InitPackage( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_DROP, "e_PackageDrop" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_PackageMove" );
    item.SetEvent( ITEM_EVENT_SKILL, "e_PackagePick" );
}

void e_PackageDrop( Item& item, Critter& cr )
{
    cr.ModeBase[ MODE_NO_WALK ] = 0;
    cr.ModeBase[ MODE_NO_RUN ] = 0;
}

void e_PackageMove( Item& item, Critter& crit, uint8 fromSlot )
{
    if( item.CritSlot == SLOT_HAND1 )
    {
        crit.ModeBase[ MODE_NO_WALK ] = 0;
        crit.ModeBase[ MODE_NO_RUN ] = 1;
    }
    if( fromSlot == SLOT_HAND1 )
    {
        crit.ModeBase[ MODE_NO_WALK ] = 1;
        crit.ModeBase[ MODE_NO_RUN ] = 1;
        crit.Say( SAY_NETMSG, "Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести." );
    }
}

bool e_PackagePick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        if( _CritCountItem( cr, PID_PACKAGE ) == 0 )
        {
            cr.ModeBase[ MODE_NO_WALK ] = 1;
            cr.ModeBase[ MODE_NO_RUN ] = 1;
            cr.Say( SAY_NETMSG, "Мешок слишком громоздок для рюкзака, нужно взять в руки, чтобы нести." );
            return false;
        }
        return true;
    }
    return true;
}

void _InitCompas( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_CompasUse" );
}

bool e_CompasUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
    string output = "";

    Location @ loc = GetLocation( 5 );
    if( loc !is null )
    {
        int x = cr.WorldX * 0.1 - loc.WorldX * 0.1, y = cr.WorldY * 0.1 - loc.WorldY * 0.1;
        if( cr.Skill[ SK_OUTDOORSMAN ] < 100 )
        {
            output += "Модок находиться : ";

            if( y > 0 )
                output += "Северо-";
            else if( y < 0 )
                output += "Юго-";
            if( x > 0 )
                output += "Западней";
            else if( x < 0 )
                output += "Восточней";
            else if( y > 0 )
                output = "Модок находиться : Севернее";
            else if( y < 0 )
                output = "Модок находиться : Южнее";
            else
                output = "Стрелка постоянно крутится";
        }
        if( cr.Skill[ SK_OUTDOORSMAN ] >= 100 )
        {
            output = "Координаты : x=" + x + ", y=" + y;
        }
    }
    else
        output = "Компас заклинило.";

    cr.Say( SAY_NETMSG, output );

    return false;
}

void Item_SetFrame( Item& item, uint8 frame ) // Sprite& sprite) // ItemCl& itemCl
{
    item.AnimStayBegin      = frame;
    item.AnimStayEnd        = frame;
    item.AnimShowBegin      = frame;
    item.AnimShowEnd        = frame;
    item.AnimHideBegin      = frame;
    item.AnimHideEnd        = frame;

    return;
}

void _GasMask( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE, "e_GasMaskUse" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_GasMaskMove" );
}

void e_GasMaskMove( Item& item, Critter& crit, uint8 fromSlot )
{
    if(item.CritSlot == SLOT_HAND2 )
    {
	crit.Say( SAY_NETMSG, "Вы одели респиратор." );
    }
    if(fromSlot == SLOT_HAND2 )
    {
	crit.Say( SAY_NETMSG, "Вы сняли респиратор." );
    }
}

bool e_GasMaskUse( Item& item, Critter& cr, Critter@ onCritter, Item@ onItem, Scenery@ onScenery )
{
	if (cr.GetItems( SLOT_HAND2, null)!=0)
		{
		cr.Say( SAY_NETMSG, "Уберите из рук все лишнее, чтобы нормально одеть респиратор." );
		}
	else
		{
	        cr.MoveItem(item.Id, 1, SLOT_HAND2);
		}
    return true;
}

void _BonesInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_BonesUseItem" );
}

bool e_BonesUseItem( Item& item, Critter& crit, Item@ usedItem )
{
    if( valid( usedItem ) && usedItem.GetProtoId() == PID_SHOVEL )
    {
		DeleteItem( item );
		crit.Say( SAY_NETMSG, "Вы закопали тело." );
        return true;
    }
    return false;
}

void _InitToken( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_TokenPick" );
	item.SetEvent( ITEM_EVENT_DROP, "e_TokenDrop" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_TokenMove" );
	item.SetEvent( ITEM_EVENT_WALK, "e_WorkplaceWalk" );
}

bool e_TokenPick( Item& item, Critter& cr, int skill )
{
    DeleteItem( item );
	return false;
}

void e_TokenDrop( Item& item, Critter& crit )
{
    DeleteItem( item );
}

void e_TokenMove( Item& item, Critter& crit, uint8 fromSlot )
{
    DeleteItem( item );
}

//Сделать дверь с окошком (делаю по аналогии с кодом Эрла) Указать номер диалога в val3 двери
void SetSecurityDoor( Critter& cr, int p0, int p1, int p2 ) 
{
	Item@ item = GetItem( p0 );
	
	if( !valid( item )) 
	{
		return;
	}
	
	item.Val3 = 5174; //сделать в ГМ-ке возможность задать это значение при навешивании скрипта
	
	item.SetScript( "_DialogDoorInit" );
    item.Update();
	
	
}

void SetWorkbench( Critter& cr, int p0, int p1, int p2 )
{
	Item@ item = GetItem(p0);
	if( !valid( item ) ) return;
    item.SetScript( "_InitWorkBench" );
    item.Update();
}

void _InitWorkBench( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_WorkBenchPick" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_WorkBenchCloneKey" );	
}

bool e_WorkBenchCloneKey( Item& item, Critter& cr, Item@ usedItem )
{
    if( !valid( usedItem ) )
		return false;
	
	if( usedItem.GetProtoId() == PID_HANDCUFFS )
	{
		if( _CritCountItem( cr, PID_CRAFT_M_BARS ) <= 0 )
		{
			cr.Say( SAY_NETMSG, "Вам нужна железная болванка для заготовки ключа от наручников." );
			return true;
		}
		cr.DeleteItem( PID_CRAFT_M_BARS, 1 );

		usedItem.Val2 = 0;
		cr.Say( SAY_NETMSG, "Вы восстановили утерянный ключ для этой пары наручников. При следующем надевании, он появится в инвентаре одевающего." );
		return true;
	}
	
	if( usedItem.GetType() == ITEM_TYPE_KEY )
    {
		if( _CritCountItem( cr, PID_CRAFT_M_BARS ) <= 0 )
		{
			cr.Say( SAY_NETMSG, "Вам нужна железная болванка." );
			return true;
		}
		cr.DeleteItem( PID_CRAFT_M_BARS, 1 );

		uint pid = usedItem.GetProtoId();
		if( pid == PID_BLANK_KEY )
			pid = PID_KEY; //Костыль "перехода" ключей от старого формата (@keylex@) к новому (чистая лексема).
		Item @ newKey = cr.AddItem( pid, 1 );

		newKey.LockerId = usedItem.LockerId;
		newKey.SetLexems( null );
		newKey.Update();

		cr.StatBase[ ST_LAST_DOOR_ID ] = newKey.Id;
		cr.StatBase[ ST_LAST_CONT_ID ] = newKey.Accessory;
		ShowInputBoxScreen( cr, "main@unsafe_MakeDescLex#Описание:", 0, INPUTBOX_CLOSE_ON_ENTER );
		return true;	
	}
    return false;	
}

bool e_WorkBenchPick( Item& item, Critter& cr, int skill )
{
    if( ( skill == SKILL_PICK_ON_GROUND ) && ( item.Accessory == ACCESSORY_HEX ) )
    {
        Item@ Workplace;
        @Workplace = cr.GetMap().GetItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK );
        if( !valid( Workplace ) )
		{
			@Workplace = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_GRAPPLE_HOOK, 1 );
		}
		Workplace.SetScript( "_WorkplaceInit" );
		if( cr.CountItem( PID_WORKBENCH_TOKEN ) == 0 ) cr.AddItem( PID_WORKBENCH_TOKEN, 1 );
		cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
    }
    return true;
}

void _WorkplaceInit( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_TokenPick" );
	item.SetEvent( ITEM_EVENT_DROP, "e_TokenDrop" );
    item.SetEvent( ITEM_EVENT_MOVE, "e_TokenMove" );
    item.SetEvent( ITEM_EVENT_WALK, "e_WorkplaceWalk" );
}

void e_WorkplaceWalk( Item& item, Critter& cr, bool entered, uint8 dir )
{
	if( !entered )
    {
	    Item@Token = cr.GetItem( PID_WORKBENCH_TOKEN, -1 );
        if( valid( Token )) DeleteItem( Token );
	    Item@Token2 = cr.GetItem( PID_FIREPLACE_TOKEN, -1 );
        if( valid( Token2 )) DeleteItem( Token2 ); 
    }
}

//====================================MIO_POLL_BOX=========================//

void _Poll( Item& item, bool firstTime )
{
	item.SetEvent( ITEM_EVENT_SKILL, "e_PollInit" );
}
bool e_PollInit( Item& item, Critter& cr, int skill )
{
	cr.ParamBase[ ST_VAR2 ] = item.Id;
	string[] List = { "1", "2", "3", "4", "5", "6" };
	string[] List2 = { "Кол-во пунктов", "Подсчитать", "Очистить урну" };

	if( skill == SK_SCIENCE )
	{
		if( cr.Id == uint ( item.Val0 ) )
		{
			cr.ShowScreen( SCREEN_DIALOGBOX, List2.length(), "Poll" );
			cr.Say( SAY_DIALOGBOX_TEXT, "Опции:" );
			for( uint i = 0, l = List2.length(); i < l; i++ ) { cr.Say( SAY_DIALOGBOX_BUTTON( i ), List2[ i ] ); }
		}
		else { cr.Say( SAY_EMOTE_ON_HEAD, "Пытается перенастроить механизм" ); }
		return true;
	}
	if( skill == SK_REPAIR )
	{
		if( item.Val0 == 0 ) { item.Val0 = cr.Id; cr.Say( SAY_NETMSG, "Урна ваша." ); }
		else if( uint ( item.Val0 ) == cr.Id ) { item.Val0 = 0; cr.Say( SAY_NETMSG, "Урна ничья." ); }
		else { cr.Say( SAY_EMOTE_ON_HEAD, "Пытается взломать механизм" ); }
		return true;
	}
	if( skill == -1 && cr.Id != uint ( item.Val0 ) )
	{
		cr.ShowScreen( SCREEN_DIALOGBOX, item.Val2, "Poll" );
		cr.Say( SAY_DIALOGBOX_TEXT, "Голосовать за номер:" );
		for( uint i = 0, l = item.Val2; i < l; i++ ) { cr.Say( SAY_DIALOGBOX_BUTTON( i ), "Номер "+List[ i ] ); }
		return true;
	}

	return false;
}
void Poll( Critter& player, uint answerI, string& answerS )
{
	Item@ Item0 = GetItem( player.Param[ ST_VAR2 ] );
	if( @ Item0 is null ) { return; }

	if( player.Id != uint ( Item0.Val0 ) )
	{
		if( uint ( Item0.Val1 ) != player.Id )
		{
			if( answerI == 0 ) { Item0.Val3 ++; }
			if( answerI == 1 ) { Item0.Val4 ++; }
			if( answerI == 2 ) { Item0.Val5 ++; }
			if( answerI == 3 ) { Item0.Val6 ++; }
			if( answerI == 4 ) { Item0.Val7 ++; }
			if( answerI == 5 ) { Item0.Val8 ++; }
			Item0.Val1 = player.Id;
			player.Say( SAY_EMOTE_ON_HEAD, "Голосует" );
		} else { player.Say( SAY_EMOTE_ON_HEAD, "Пытается сделать вброс" ); }
	}
	else
	{
		if( answerI == 0 )
		{
			string[] List = { "Один", "Два", "Три", "Четыре", "Пять", "Шесть" };
			player.ShowScreen( SCREEN_DIALOGBOX, List.length(), "Poll_x" );
			player.Say( SAY_DIALOGBOX_TEXT, "Число пунктов:" );
			for( uint i = 0, l = List.length(); i < l; i++ ) { player.Say( SAY_DIALOGBOX_BUTTON( i ), List[ i ] ); }
		}
		if( answerI == 1 )
		{
			string Str;
			for( uint i = 0, l = Item0.Val2; i < l; i++ )
			{
				switch( i )
				{
					case 0: Str +=  "1."+Item0.Val3; break;
					case 1: Str += " 2."+Item0.Val4; break;
					case 2: Str += " 3."+Item0.Val5; break;
					case 3: Str += " 4."+Item0.Val6; break;
					case 4: Str += " 5."+Item0.Val7; break;
					case 5: Str += " 6."+Item0.Val8; break;
				}
			}
			player.Say( SAY_EMOTE, "Считает голоса" );
			player.Say( SAY_NORM, Str );
		}
		if( answerI == 2 ) { Item0.Val1=0; Item0.Val3=0; Item0.Val4=0; Item0.Val5=0; Item0.Val6=0; Item0.Val7=0; Item0.Val8=0; }
	}
}
void Poll_x( Critter& player, uint answerI, string& answerS )
{
	Item@ Item0 = GetItem( player.Param[ ST_VAR2 ] );
	if( @ Item0 is null ) { return; }
	Item0.Val2 = answerI+1;
	player.Say( SAY_NETMSG, "Выбрано число пунктов: "+Item0.Val2 );
}



//==============MIO_RECORDER_WIP=============================//

import void RecorderAdjustment( Critter& cr, Item& targetItem ) from "mio_social";
import void RecorderUse( Critter& cr, Item& item ) from "mio_social";

void _Recorder( Item& item, bool firstTime )
{
	item.SetEvent( ITEM_EVENT_SKILL, "e_RecorderInit" );
}
bool e_RecorderInit( Item& item, Critter& cr, int skill )
{
	if( skill == 213 ) { RecorderAdjustment( cr, item ); return true; }
	else if( skill == -1 )
	{
		if( FLAG( item.Flags, ITEM_CAN_PICKUP ) ) { return false; }
		RecorderUse( cr, item );
		return true;
	}
	return false;
}

//===========MIO_DICE_AND_CARDS======================//

import void DiceAdjustment( Critter& cr, Item& targetItem ) from "mio_social";
import void DiceUse( Critter& cr, Item& item ) from "mio_social";

void _Dice( Item& item, bool firstTime )
{
	item.SetEvent( ITEM_EVENT_SKILL, "e_DiceInit" );
}
bool e_DiceInit( Item& item, Critter& cr, int skill )
{
	if( skill == 213 ) { DiceAdjustment( cr, item ); return true; }
	else if( skill == -1 )
	{
		if( FLAG( item.Flags, ITEM_CAN_PICKUP ) ) { return false; }
		DiceUse( cr, item );
		return true;
	}
	return false;
}

import void CardsAdjustment( Critter& cr, Item& targetItem ) from "mio_social";
import void CardsUse( Critter& cr, Item& item ) from "mio_social";

void _Cards( Item& item, bool firstTime )
{
	item.SetEvent( ITEM_EVENT_SKILL, "e_CardsInit" );
}
bool e_CardsInit( Item& item, Critter& cr, int skill )
{
	if( skill == 213 ) { CardsAdjustment( cr, item ); return true; }
	else if( skill == -1 )
	{
		if( FLAG( item.Flags, ITEM_CAN_PICKUP ) ) { return false; }
		CardsUse( cr, item );
		return true;
	}
	return false;
}