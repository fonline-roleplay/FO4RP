#ifndef CHOPPING
#define CHOPPING

#include "_utils.fos"
#include "_ltp.fos"
#include "chopping_h.fos"
#include "gathering_h.fos"
#include "critter_skills_h.fos"
#include "combat_h.fos"
#include "repair_h.fos"
#include "firestarter_h.fos"
#include "speed_h.fos"

bool ltp_chopping_inited = false;
void ltp_chopping_init()
{
	LTPREG( LTP_CHOPPING, process_chopping )
	ltp_chopping_inited = true;
}

bool PrepareChopping( Critter& cr, Item@ tool, Item@ tree ) 
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
    	return false;
    }
	
	if( !valid( tool ) || !valid( tree ) )
	{
		return false;
	}
	
   	uint toolPid = tool.GetProtoId();
	if( ChoppingTools.find( toolPid ) == -1 )
	{
		return false;
	}
	
	if( tool.CritSlot != SLOT_HAND1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_EQUIP_TOOL );
		return false;
	}
	
	if( tree.Proto.Item_Subtype != ITEM_SUBTYPE_TREE && tree.Proto.Item_Subtype != ITEM_SUBTYPE_TREE_SLUMP )
	{
		return false;
	}
	
	bool isSlump = tree.Proto.Item_Subtype == ITEM_SUBTYPE_TREE_SLUMP;
	bool isSlumpTool = toolPid == PID_SHOVEL || toolPid == PID_SPADE;
	if( isSlump != isSlumpTool )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, isSlump ? STR_USE_SHOWEL : STR_WRONG_INSTRUMENT );
		return true;
	}
	
	if( _ItemIsBroken( tool ) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOOL_BROKEN );
		return true;
	}
	
	if( IsTired( cr ) )
	{
		return true;
	}
	
	if( cr.IsDmgTwoArm() || cr.IsDmgTwoLeg() )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_CANT_WORK );
		return false; 
	}
	
	if( tool.IsDeteriorable() )
	{
		uint det = GetDeteriorationProcent( tool );
		SetDeterioration( tool, det + 1 );
	}
	
	if( tool.Deterioration >= MAX_DETERIORATION )
	{
		BreakTool( cr, tool );
		return false;
	}
	
	start_chopping( cr, tool, tree );
	return true;
}

bool start_chopping( Critter& cr, Item& tool, Item& tree )
{
	if(!ltp_chopping_inited)
	{
		ltp_chopping_init();
	}
	
	if( valid( tool ) && valid( tree ) )
	{	
		uint hit_pause = ACTION_PAUSE_BASE - (cr.Stat[ST_AGILITY] * ACTION_PAUSE_BONUS_RATE );
		cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		uint object_dpa = ( cr.Skill[SK_CHOPPING] ) + ( cr.Stat[ST_STRENGTH] * 10 ) + OBJECT_DPA_BASE; 
		cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ceil( float( OBJECT_HP_BASE / ( CLAMP( object_dpa, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) ) );
		StartProcess( cr, LTP_CHOPPING, 0, tool.Id, tree.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "chopping@e_ChoppingSound", cr.Id, false);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", cr.Id, true);
		return true;
	}
	return false;
}

uint process_chopping( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_CHOPPING )

    Item@ tool = GetItem( param1 );
  	Item@ tree = GetItem( param2 );
  	if( valid( tool ) && valid( tree ) )
    {
      	param0++;
		if( param0 > cr.Param[ ST_LTP_SEQUENCE ] )
		{
			if( tree.Proto.Item_Subtype == ITEM_SUBTYPE_TREE )
			{
				if( tree.RESOURCE_CAPACITY <= OBJECT_HP_BASE )
				{	
					SayLog( cr, crInfo( cr ) + " has chopped a tree!" );
					CutTree( cr, tree );
				}
				else
				{
					if( tree.RESOURCE_CAPACITY > ( OBJECT_HP_BASE * 2 ) )
					{
						ChangeFrame( tree, 1 );
					}
					
					if( tree.RESOURCE_CAPACITY <= ( OBJECT_HP_BASE * 2 ) )
					{
						ChangeFrame( tree, 2 );
					}
					
					SayLog( cr, crInfo( cr ) + " has cut a tree!" );
					
				}
			}
			else if( tree.Proto.Item_Subtype == ITEM_SUBTYPE_TREE_SLUMP )
			{
				if( tool.GetProtoId() != PID_SHOVEL && tool.GetProtoId() != PID_SPADE )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_USE_SHOWEL );
					return 0;
				}
				
				if( tree.RESOURCE_CAPACITY == 0 )
				{
					EraseTimeEvent( tree.EVENT );
					tree.EVENT = 0;
					DeleteItem( tree );
					SayLog( cr, crInfo( cr ) + " has uprooted a tree!" );
				}
			}
			else
			{
				return 0;
			}
			
			Profit( cr, tool, tree );
			int skillNum = SK_CHOPPING;
			Accident( cr, skillNum );
        }
		else
		{
			_CritAnimateSwing( cr );

			CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "chopping@e_ChoppingSound", cr.Id, false );
			CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", cr.Id, true );
			
			if( cr.IsInjured() )
			{
				uint damage = INJURED_HP_DAMAGE - cr.Stat[ ST_ENDURANCE ];
				hurt( cr, damage );
			}
			return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
		}
    }
	return 0;
}
//Action sound delay time event
uint e_ChoppingSound(uint[]@ values)
{
	Critter@cr = GetCritter(values[0]); 
	Map@ map = cr.GetMap();
	if( valid( map ) )
	{
		PlayGenericSound( map, cr.HexX, cr.HexY, _GetOneRandom( ChoppingSounds ), 30 );
	}
	
	return 0;
}

//Cut tree pid change, condition to regrow
uint CutTree( Critter& cr, Item@ tree )
{
	tree.ORIGINAL_TREE_PID = tree.GetProtoId();
	uint[] values = { tree.Id };
	tree.TREE_REGROW_TIME = 30 * 4; //time mul
	ChangeFrame( tree, 0 );
	switch( tree.RESOURCE_DNA )
	{
		case( 1 ):
			tree.ChangeProto( PID_TREE_CS1 );
			break;
		case( 2 ):
			tree.ChangeProto( PID_TREE_CS2 );
			break;
		case( 3 ):
			tree.ChangeProto( PID_TREE_CS3 );
			break;
		case( 4 ):
			tree.ChangeProto( PID_TREE_CL1 );	
			break;
		case( 5 ):
			tree.ChangeProto( PID_TREE_CL2 );	
			break;
		case( 6 ):
			tree.ChangeProto( PID_TREE_CL3 );	
			break;
		case( 7 ):
			tree.ChangeProto( PID_TREE_CL4 );	
			break;
		case( 8 ):
			tree.ChangeProto( PID_TREE_CL5 );	
			break;
		case( 9 ):
			tree.ChangeProto( PID_TREE_GL2S );	
			break;
	}
	return 0;
}

//~run chopping _ForceTreeRegrow 0 0 0
void _ForceTreeRegrow( Critter& player, int param0, int param1, int param2 )
{
	Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{
		Map@ map = maps[i];
		Item@[] chopped;
		
		map.GetItemsByType( ITEM_TYPE_PLANT, chopped );
		
		Item@ tree = null;
		for( uint j = 0, len = chopped.length(); j < len; j++ )
		{
			@ tree = chopped[j];
			if( valid( tree ) )
			{
				if( tree.Proto.Item_Subtype == ITEM_SUBTYPE_TREE_SLUMP )
				{
					tree.TREE_REGROW_TIME = 0;
					
					if( tree.ORIGINAL_TREE_PID <= 1 ) //error fixing
					{
						tree.ORIGINAL_TREE_PID = PID_TREE_BS1;
					}					
					
					uint[] values = { tree.Id };
					tree.EVENT = CreateTimeEvent( AFTER( REAL_SECOND( 1 ) ), "e_TreeRegrow", values, true );
				}
			}
		}
		
		chopped.resize(0);
	}
	
	maps.resize(0);
}

// Regrowth time event
uint e_TreeRegrow( uint[]@ values )
{
	Item@ cutTree = GetItem( values[0] );
	if( valid( cutTree ) )    
	{
		ProtoItem@ treeProto = GetProtoItem( cutTree.ORIGINAL_TREE_PID );
		if( valid( treeProto ) && cutTree.ORIGINAL_TREE_PID != 0 )
		{
			uint16 cutTreePid = cutTree.GetProtoId();
			cutTree.ChangeProto( cutTree.ORIGINAL_TREE_PID );
			cutTree.RESOURCE_CAPACITY = cutTree.Proto.StartValue_1;
			ChangeFrame( cutTree, 0 );
			EraseTimeEvent( cutTree.EVENT );
			cutTree.EVENT = 0;
		}
	}
	return 0;
}

//Loot
bool Profit( Critter& cr, Item& tool, Item@ tree )
{
	if( !valid( tool ) )
	{
		return false;
	}
	
	int amount = 0;
	uint toolMod = tool.GetProtoId();
	switch( toolMod )
	{	
		case( PID_REVKNIFE2 ):
		case( PID_MACHETE ):
			amount--;
			break;
		case( PID_AXE2 ):
			amount++;
			break;
	}
	
	uint lootRoll = ( Random( 0, 2 ) + ( cr.ParamBase[ SK_CHOPPING ] / 50 ) );
	amount+= lootRoll;
	if( amount < 1 )
	{
		 cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NOTHING_USEFULL );
	}
	else
	{
		raiseSkill( cr, SK_CHOPPING );
		
		taking_sweat(cr);
		SpawnBeneath( cr, PID_LOGS, amount );
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_GATHERED, "$proto@msg item " + ( PID_LOGS * 100 ) + "@$amount" + amount );
		cr.StatBase[ ST_EXPERIENCE ] += 25;
		
		if( valid( tree ) )
		{
			tree.RESOURCE_CAPACITY = tree.RESOURCE_CAPACITY - OBJECT_HP_BASE;
		}
		ChangeCritterSpeed( cr );
	}
	
	return true;
}

void CutTreeManager()
{    
    Map@[] maps;
    for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++)
	{   
		CheckCutTrees( maps[i] );
	}
}

void CheckCutTrees( Map& map )
{
	if( valid( map ) )
	{
		Item@[] mapPlants;
		Item@[] cutTrees;
		
		map.GetItemsByType( ITEM_TYPE_PLANT, mapPlants );
		
		for( uint i = 0; i < mapPlants.length(); i++ )
		{
			Item@ mapPlant = mapPlants[i];
			if( valid( mapPlant ) )
			{
				if( mapPlant.Proto.Item_Subtype == ITEM_SUBTYPE_TREE_SLUMP )
				{
					cutTrees.insertLast( mapPlant );
				}
			}
		}
		
		if( cutTrees.length() > 0 )
		{
			Item@ tree = null;
			for( uint j = 0; j < cutTrees.length(); j++ )
			{
				@tree = cutTrees[j];
				
				if( !valid( tree ) )
				{
					continue;
				}
				
				if( tree.ORIGINAL_TREE_PID == 0 )
				{
					continue;
				}
				
				if( tree.TREE_REGROW_TIME > 0 )
				{
					tree.TREE_REGROW_TIME --;
				}
				else
				{
					uint[] values = { tree.Id };
					uint period = Random( 1, 12 );
					tree.EVENT = CreateTimeEvent( AFTER( REAL_HOUR( period ) ), "e_TreeRegrow", values, true );
				}
			}
		}
	}
}

bool TryChopItem( Critter& cr, Item@ tool, Item@ target )
{
	Map@ map = cr.GetMap();
    if( !valid( map ) ) 
    {
    	return false;
    }
	
	if( !valid( tool ) || !valid( target ) )
	{
		return false;
	}
	
	if( target.Proto.Item_Subtype == ITEM_SUBTYPE_TREE || target.Proto.Item_Subtype == ITEM_SUBTYPE_TREE_SLUMP )
	{
		return false;
	}

   	uint toolPid = tool.GetProtoId();
	if( ChoppingTools.find( toolPid ) == -1 )
	{
		return false;
	}
		
	if( tool.CritSlot != SLOT_HAND1 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_EQUIP_TOOL );
		return false;
	}
	
	if( ( target.Proto.Type == ITEM_TYPE_CONTAINER || target.Proto.Type == ITEM_TYPE_DOOR ) && target.Proto.Item_Subtype != ITEM_SUBTYPE_FURNITURE )
	{
		return false;
	}
	
	if( target.Proto.Item_Subtype == ITEM_SUBTYPE_FIREWOOD || ( target.Proto.Material == MATERIAL_WOOD && ( target.Proto.Item_Subtype == ITEM_SUBTYPE_FURNITURE || ( target.Proto.Type == ITEM_TYPE_WEAPON && target.Proto.Item_Subtype == ITEM_SUBTYPE_WEAPON_MELEE_CLUB ) ) ) )
	{
		start_chop_item( cr, tool, target );
		return true;
	}

	return false;
}

//LTP_CHOP_ITEM
bool ltp_chop_item_inited = false;
void ltp_chop_item_init()
{
	LTPREG( LTP_CHOP_ITEM, process_chop_item )
	ltp_chop_item_inited = true;
}

bool start_chop_item( Critter& cr, Item& tool, Item& target )
{
	if( !ltp_chop_item_inited )
	{
		ltp_chop_item_init();
	}
	
	if( valid( tool ) && valid( target ) )
	{	
		uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ ST_STRENGTH ] * ACTION_PAUSE_BONUS_RATE );
		cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		uint chopping_rate = ( cr.Stat[ ST_STRENGTH ] * ACTION_PAUSE_BONUS_RATE ) + OBJECT_DPA_BASE; 
		cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ceil( float( 3000.0f / ( CLAMP( chopping_rate, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) ) );
		
		uint[] values = { cr.Id };
		
		_CritAnimateSwing( cr );
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "chopping@e_ChoppingSound", values, false);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", cr.Id, true);	

		StartProcess( cr, LTP_CHOP_ITEM, 0, target.Id, 0, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
		return true;
	}
	return false;
}

uint process_chop_item( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_CHOP_ITEM )

    Item@ target = GetItem( param1 );
  	if( valid( target ) )
    {
		param0++;
		
		if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
		{
			ChopItem( target );
			return 0;
		}
		
		uint[] values = { cr.Id };
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "chopping@e_ChoppingSound", values, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);

		_CritAnimateSwing( cr );
		
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}
	return 0;
}

void ChopItem( Item& target )
{
	if( valid( target ) )
	{
		Map@ map = GetMap( target.MapId );
		if( target.Proto.Type == ITEM_TYPE_CONTAINER )
		{
			DropContainerItems( map, target );
		}
		
		map.AddItem( target.HexX, target.HexY, PID_CHOPPED_FIREWOOD, 1 );
		_SubItem( target, 1 );
	}
}

// Sawhorse
class MenuSawhorse: CenteredMenuHandler
{
    uint sawhorse_id;
    uint map_id;
	
    MenuSawhorse( Item& sawhorse, Map& map )
	{
        sawhorse_id = sawhorse.Id;
        map_id = map.Id;
    }

    bool MenuUpdate( Critter& cr, iDialogBox& menu )
	{
        Map@ map = GetMap( map_id );
        if( !valid( map ) )
		{
            return false;
        }
		
        Item@ sawhorse = GetItem( sawhorse_id );
        if( !valid( sawhorse ) )
		{
            return false;
        }
		
		if( locked_in_place( sawhorse ) )
		{
			if( hasItems( cr, SawTools, SLOT_HAND1 ) && menu.ButtonMsg( STR_SAWHORSE_MENU_SAW ) )
			{
				Item@ tool = _CritGetItemHand( cr );
				PrepareSawing( cr, tool, sawhorse );
				return false;
			}

			if( menu.ButtonMsg( STR_FURNITURE_MENU_EXAMINE ) )
			{
				ShowContainer( cr, sawhorse, TRANSFER_HEX_CONT_UP );
				return false;
			}
			
			if( menu.ButtonMsg( STR_FURNITURE_MENU_DETACH ) )
			{
				LockInPlace( cr, sawhorse );
				return true;
			}
		}
		else
		{
			if( menu.ButtonMsg( STR_FURNITURE_MENU_ANCHOR ) )
			{
				LockInPlace( cr, sawhorse );
				return true;
			}

			if( menu.ButtonMsg( STR_FURNITURE_MENU_PICKUP ) )
			{
				PickItem( cr, sawhorse );
				ChangeCritterSpeed( cr );
				return false;
			}			
		}
		return true;
    }
	
	int getDescriptionFile()
    {
    	return TEXTMSG_TEXT;
    }

	int getDescriptionLine()
	{
		return STR_FURNITURE_SAWHORSE_INTERFACE;
	}
	
    string@ Description( Critter& cr )
	{
	
		string info;
		Item@ sawhorse = GetItem( sawhorse_id );
		
		Item@[] MaterialsCheck;
		uint count = sawhorse.GetItems( uint( -1 ), MaterialsCheck );
		Item@ material = null;
		info += "$contains";
		uint16 materialPid = 0;
		if( count == 0 )
		{ 
			info += STR_INSERT_TEXT_LINE( STR_EMPTY );
		}
		else
		{
			for( uint i = 0; i < MaterialsCheck.length(); i ++ )
			{
				materialPid = MaterialsCheck[i].GetProtoId();
				if( SawMaterialList.find( materialPid ) != -1 )
				{
					@material = MaterialsCheck[i];
					break;
				}
			}
			
			if( !valid( material ) )
			{
				info += STR_INSERT_TEXT_LINE( STR_SAWHORSE_MENU_NO_WOOD );
			}
			else
			{
				info += STR_INSERT_TEXT_LINE( STR_SAWHORSE_MENU_CONTAINS )
					 + "$item" + STR_INSERT_ITEM_LINE( materialPid * 100 )
					 + "$amount" + material.GetCount();
			}
		}		

		return info;
    }
}

void StartMenuSawhorse( Critter& cr, Item@ sawhorse )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        return;
    }

    iMenuHandler@ handler = MenuSawhorse( sawhorse, map );
    iDialogBox@ menu = OpenMenu( cr, "sawhorse", handler );
}

bool ltp_sawing_inited = false;
void ltp_sawing_init()
{
	LTPREG( LTP_SAWING, process_Sawing )
	ltp_sawing_inited = true;
}

bool PrepareSawing( Critter& cr, Item@ tool, Item@ sawhorse ) 
{
	Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
		return false;
	}
	
	if( !valid( tool ) )
	{
		return false;
	}
	
	if( !valid( sawhorse ) )
	{
		return false;
	}	
	
	if( sawhorse.GetProtoId() != PID_SAWHORSE )
	{
		return false;
	}
	
	if( !hasItems( cr, SawTools, SLOT_HAND1 ) )
	{
		return false;
	}

	if( IsTired( cr ) )
	{
		return false;
	}
	
	if( cr.IsDmgTwoArm() || cr.IsDmgTwoLeg() )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_INJURED_CANT_WORK );
		return false; 
	}
	
	Item@[] MaterialsCheck;
	sawhorse.GetItems( uint( -1 ), MaterialsCheck );
	Item@ material = null;
	uint16 materialPid;
	if( MaterialsCheck.length() == 0 )
	{ 
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SAWHORSE_EMPTY ); 
		return false; 
	}
	else
	{
		for( uint i = 0; i < MaterialsCheck.length(); i ++ )
		{
			materialPid = MaterialsCheck[i].GetProtoId();
			if( SawMaterialList.find( materialPid ) != -1 )
			{
				@material = MaterialsCheck[i];
				break;
			}
		}
		
		if( !valid( material ) )
		{ 
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_SAWHORSE_NO_WOOD ); 
			return false; 
		}
	}
	
	start_sawing( cr, tool, sawhorse, material );
	return true;
}

bool start_sawing( Critter& cr, Item& tool, Item& sawhorse, Item@ material )
{
	if(!ltp_sawing_inited)
	{
		ltp_sawing_init();
	}
	
	if( valid( tool ) && valid( sawhorse ) )
	{	
		uint hit_pause = ACTION_PAUSE_BASE - ( cr.Stat[ ST_STRENGTH ] * ACTION_PAUSE_BONUS_RATE );
		cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CLAMP( hit_pause, ACTION_PAUSE_MIN, ACTION_PAUSE_MAX );
		uint sawing_rate = ( cr.Stat[ ST_STRENGTH ] * ACTION_PAUSE_BONUS_RATE ) + OBJECT_DPA_BASE; 
		cr.ParamBase[ ST_LTP_SEQUENCE ] = int( ceil( float( 3000 / ( CLAMP( sawing_rate, OBJECT_DPA_MIN, OBJECT_DPA_MAX ) ) ) ) );
		
		uint[] values = { cr.Id };
		
		_CritAnimateSwing( cr );
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "chopping@e_SawingSound", values, false);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", cr.Id, true);	

		StartProcess( cr, LTP_SAWING, 0, sawhorse.Id, material.Id, cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] );
		return true;
	}
	return false;
}

uint process_Sawing( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESS( cr, param0, LTP_SAWING )
	
    Item@ sawhorse = GetItem( param1 );
  	Item@ material = GetItem( param2 );
  	if( valid( sawhorse ) && valid( material ) )
    {
		param0++;
		
		if( param0 > cr.ParamBase[ ST_LTP_SEQUENCE ] )
		{
			cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_FINISH_SAWING );
			Result( cr, sawhorse, material );
			int skillNum = SK_REPAIR;
			Accident( cr, skillNum );
			
			return 0;
		}
		
		uint[] values = { cr.Id };
		CreateTimeEvent( AFTER( REAL_MS( 700 ) ), "chopping@e_SawingSound", values, true);
		CreateTimeEvent( AFTER( REAL_MS( 1000 ) ), "gathering@e_TiredenessTimeout", values, true);

		_CritAnimateSwing( cr );
		
		if( cr.IsInjured() )
		{
			uint damage = INJURED_HP_DAMAGE - cr.Stat[ ST_ENDURANCE ];
			hurt( cr, damage );
		}
		
		return cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ];
	}
	return 0;
}

uint e_SawingSound( uint[]@ values )
{
	Critter@ cr = GetCritter(values[0]);
	Map@ map = cr.GetMap();
	PlayGenericSound( map, cr.HexX, cr.HexY, _GetOneRandom( ChoppingSounds ), 10 );
	return 0;
}

void Result( Critter& cr, Item& sawhorse, Item& material )
{
	if( !valid( sawhorse) && !valid( material ) )
	{
		return;
	}
	
	uint16 materialPid = material.GetProtoId();
	uint8 index = SawMaterialList.find( materialPid );
	uint16 resultPid = SawResultList[ index ];
	uint8 amount = SawAmount[index];
	cr.AddItem( resultPid, amount );
	_SubItem( material, 1 );
	
	uint[] values = { sawhorse.Id };
	CreateTimeEvent( AFTER( REAL_MS( 10 ) ), "chopping@e_SawUpdate", values, false );

	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED_PID, "$proto@msg item " +  ( resultPid * 100 ) + "@$amount" + amount + "\n" );

	cr.StatBase[ ST_EXPERIENCE ] += 25;
}

uint e_SawUpdate( uint[]@ values )
{
	Item@ sawhorse = GetItem( values[0]);
	Item@[] contItems;
	uint stuff = sawhorse.GetItems( uint( -1 ), contItems);

	if( stuff == 0 )
	{
		ChangeFrame( sawhorse, 0 );
		sawhorse.Update();
	}
	
	return 0;
}


/*
//ONE-TIME LIVE SERVER TREE UPGRADE
void _TreeUpgrade( Critter& player, int param0, int param1, int param2 )
{
	for( int ii = 0, jj = TreeList[1].length() ; ii < jj; ii++)
	{
		array<Item@> worldTrees = array<Item@>();
		int count = GetAllItems( TreeList[1][ii], @worldTrees );
		for( int treeIndex = 0; treeIndex < count; treeIndex++ )
		{
			Item@ tree = worldTrees[treeIndex];
			EraseTimeEvent( tree.EVENT );
			tree.EVENT = 0;
			tree.TREE_REGROW_TIME = Random( 4, 24 );
		}
	}
	worldTrees.resize(0);
}*/

#endif //CHOPPING