#ifndef __MAIN_MODULE__
#define __MAIN_MODULE__

#include "_utils.fos"
#include "_global_events.fos"
#include "_ltp.fos"

#include "autodoc_h.fos"
#include "bootlegging_h.fos"
#include "casino_h.fos"
#include "combat_h.fos"
#include "cooking_h.fos"
#include "critter_item_movement_h.fos"
#include "drugs_h.fos"
#include "effects_h.fos"
#include "explode_h.fos"
#include "firestarter_h.fos"
#include "fish_h.fos"
#include "flask_h.fos"
#include "food_h.fos"
#include "furnace_h.fos"
#include "furniture_h.fos"
#include "gateway_h.fos"
#include "gathering_h.fos"
#include "geiger_h.fos"
#include "globalmap_group_h.fos"
#include "handcuffs_h.fos"
#include "heal_h.fos"
#include "homebrew_h.fos"
#include "item_h.fos"
#include "lockers_h.fos"
#include "map_lights_h.fos"
#include "npc_names_holder_h.fos"
#include "npc_planes_h.fos"
#include "paralysis_h.fos"
#include "parameters_h.fos"
#include "perks_h.fos"
#include "plants_h.fos"
#include "poison_h.fos"
#include "radiation_h.fos"
#include "recorder_h.fos"
#include "reload_h.fos"
#include "repair_h.fos"
#include "robot_repair_h.fos"
#include "sandbag_h.fos"
#include "scenery_h.fos"
#include "sex_h.fos"
#include "smithing_h.fos"
#include "smoking_h.fos"
#include "speed_h.fos"
#include "teams_table.fos"
#include "terminal_h.fos"
#include "time_h.fos"
#include "vending_h.fos"
#include "waterworks_h.fos"
#include "wait_time_h.fos"
#include "wildplant_h.fos"

// Imports
import void InitializeGame() from "config";

import void WorldmapInit() from "worldmap";

import void EditRadioSettings( Critter& player, Item& radio ) from "radio";

import void skin( Critter& cr, int crType ) from "skins";

import void kind_tele2( Critter& master, Critter@ slave, int val ) from "map_start";

import void qmap_critter_in( uint mapId, Critter& cr ) from "qmap";
import void qmap_critter_out( uint mapId, Critter& cr ) from "qmap";
import void qmap_save_all() from "qmap";
import void qmap_load_all() from "qmap";

import bool UseShovel( Critter& cr, Item& item ) from "qmap_farm";

import void registerTraps() from "traps";

import void registerMines() from "traps_mines";

import NpcNamesHolder@ getNpcNamesHolder() from "npc_names_holder";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitializeGame();
}

uint16 GetVersionWorldSave( ::string@ time )
{
    ::array< uint > data;
    if( IsAnyData( "VersionWorldSave" ) && ::GetAnyData( "VersionWorldSave", data ) )
    {
        if( valid( time ) )
            time = "" + data[ 1 ] + "_" + data[ 2 ] + "_" + data[ 3 ] + "_" + data[ 4 ] + "_" + data[ 5 ];
        return data[ 0 ] % 9999;
    }
    return 0;
}

bool SaveWorldNextVersion()
{
    uint16 Year = 0, Month = 0, Day = 0, Hour = 0, Minute = 0, var = 0;
    GetTime( Year, Month, Day, var, Hour, Minute, var, var );
    ::array< uint > data = { GetVersionWorldSave( null ) + 1, Year, Month, Day, var, Hour, Minute };
	file version;
	if( version.open( "WorldVersion","w") != -1 )
	{	
		version.writeString( "" + data[0] );
		version.close();
	}
    return ::SetAnyData( "VersionWorldSave", data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Send info about others critters
    // Remember:
    // - all this info can be hacked in client;
    // - more parameters - more traffic.
    SetSendParameter( ST_GENDER, true );
    SetSendParameter( ST_AGE, true );
    SetSendParameter( ST_FOLLOW_CRIT, true );
    //SetSendParameter( ST_PLAYER_KARMA, true );
    // Armor class, uses Agility
    SetSendParameter( ST_ARMOR_CLASS, true );
    //SetSendParameter( ST_TURN_BASED_AC, true );
    // Agility
    SetSendParameter( ST_AGILITY, true );
    // Hit points, uses Strenght and Endurance
    SetSendParameter( ST_MAX_LIFE, true );
    SetSendParameter( ST_CURRENT_HP, true );
    // Strenght, uses battle timeout
    SetSendParameter( ST_STRENGTH, true );
    // Battle timeout
    //SetSendParameter( TO_BATTLE, true );
    // Endurance
    SetSendParameter( ST_ENDURANCE, true );
    // Charisma
    SetSendParameter( ST_CHARISMA, true );
	SetSendParameter( ST_CHARISMA_EXT, true );
    // Player Flags
    SetSendParameter( PLAYER_FLAGS, true );
    // Injures
    SetSendParameter( DAMAGE_EYE, true );
    SetSendParameter( DAMAGE_RIGHT_ARM, true );
    SetSendParameter( DAMAGE_LEFT_ARM, true );
    SetSendParameter( DAMAGE_RIGHT_LEG, true );
    SetSendParameter( DAMAGE_LEFT_LEG, true );
    // Item slots, passed with -
    SetSendParameter( -SLOT_HAND1, true );
	SetSendParameter( -SLOT_HAND2, true );
    SetSendParameter( -SLOT_ARMOR, true );
	SetSendParameter( -SLOT_MISC, true );
	SetSendParameter( -SLOT_HEAD, true );
	SetSendParameter( -SLOT_BACK, true );
    // Some flags for correct client working
    SetSendParameter( MODE_NO_BARTER, true );
    SetSendParameter( MODE_NO_STEAL, true );
    SetSendParameter( MODE_NO_LOOT, true );
    SetSendParameter( MODE_NO_FLATTEN, true );
    SetSendParameter( MODE_NO_TALK, true );
	// Cover state
	SetSendParameter( CR_IS_RELAXING, true );
	SetSendParameter( CR_IN_COVER, true );
    // 3d animation layers
// #ifdef PLAYERS_3D
    // Enable sending 3d layers, from Skin to Backpack
    uint fromLayer = ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN;
    uint toLayer = ST_ANIM3D_LAYERS + ANIM3D_LAYER_BACKPACK;
    for( uint i = fromLayer; i <= toLayer; i++ )
        SetSendParameter( i, true );
// #endif
    // Npc talk distance
    SetSendParameter( ST_TALK_DISTANCE, true );
    // Dialog id
    SetSendParameter( ST_DIALOG_ID, true );
    // To see pid of unarmed attack
    SetSendParameter( ST_HANDS_ITEM_AND_MODE, true );
    // Scale factor
    SetSendParameter( ST_SCALE_FACTOR, true );
    // Walk / Run speed
    SetSendParameter( ST_WALK_TIME, true );
    SetSendParameter( ST_RUN_TIME, true );

    SetSendParameter( SK_BARTER, true );
    // Game Modes
    SetSendParameter( QST_GAMEMODE, true );
    // Language barrier - binyan
    SetSendParameter( ST_BODY_TYPE, true );
	
    SetSendParameter( QST_MEDIUM, true );
	
	SetSendParameter( CR_IS_AGGRESSIVE, true );
	SetSendParameter( TRAIT_GOOD_NATURED, true );
	SetSendParameter( TRAIT_BLOODY_MESS, true );

	SetSendParameter( CR_DIRTINESS, true );
	SetSendParameter( CR_TYPING_TIME, true );
	SetSendParameter( CR_AFK_MODE, true );

    // charsheet&visibility
	SetSendParameter( QST_CHAR_VER, true );
    SetSendParameter( QST_CHAR_SECRET, true );
	SetSendParameter( QST_INVIS, true );

    // Send item data masks
    // Look fields in fonline.h 'struct Item::ItemData'
    //               SortValue  Info Indicator    PicMapHash       PicInvHash   AnimWaitBase AStay[2] AShow[2] AHide[2]      Flags      Rate LightDist Inten Flags  LightColor    ScriptId TrapValue       Count             Cost                ScriptValues[10]                                                                                                   Other 36 bytes
    // ITEM_DATA_MASK_CHOSEN                                                                                           ITEM_DATA_MASK_CHOSEN                                                                                                ITEM_DATA_MASK_CHOSEN
    int8[] mask0 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CRITTER                                                                                          ITEM_DATA_MASK_CRITTER                                                                                               ITEM_DATA_MASK_CRITTER
    int8[] mask1 = {   0,  0,     -1,    0,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0 };
    // ITEM_DATA_MASK_CRITTER_EXT                                                                                      ITEM_DATA_MASK_CRITTER_EXT                                                                                           ITEM_DATA_MASK_CRITTER_EXT
    int8[] mask2 = {   0,  0,     -1,   -1,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CONTAINER                                                                                        ITEM_DATA_MASK_CONTAINER                                                                                             ITEM_DATA_MASK_CONTAINER
    int8[] mask3 = {  -1, -1,     -1,   -1,      0,  0,  0,  0,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_MAP                                                                                              ITEM_DATA_MASK_MAP                                                                                                   ITEM_DATA_MASK_MAP
    int8[] mask4 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,   0,  0,  0,  0,   -1, -1,  -1, -1,  -1, -1,  -1, -1,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    SetItemDataMask( ITEM_DATA_MASK_CHOSEN, mask0 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER, mask1 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER_EXT, mask2 );
    SetItemDataMask( ITEM_DATA_MASK_CONTAINER, mask3 );
    SetItemDataMask( ITEM_DATA_MASK_MAP, mask4 );

    // call all functions added by _starter/START/AddStartCallback
    CallStartCallbacks();

    // old stuff
    qmap_load_all();
    WorldmapInit();
	
	// Inits

	SetGvar(GVAR_is_first_time, 0);

	GetVersionWorldSave( null );
	
	
    // Global Event Manager
    if( !manager_start() )
	{
        return false;
	}
	registerScriptingItems();
	getNpcNamesHolder().loadNpcNames();		
	
    return true;
}

void registerScriptingItems()
{
	registerTraps();
	registerMines();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59

void get_start_time( uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute )
{
    multiplier = 4;
    year = 2248;
    month = 5;
    day = 14;
    hour = 1;
    minute = 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
/*
uint loop() // moved to loop.fos
{
    return manager_loop();
}
*/
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo )
{
	if( cr.IsBusy() )
	{
		return;
	}
	cr.ParamBase[ CR_IS_RELAXING ] = 0;
	uint8 mode = weaponMode;
	
	if( _WeaponModeAim( mode ) == HIT_LOCATION_NONE && _WeaponAim( weapon, mode & 0x0F ) )
	{
		mode = ( weaponMode & 0x0F ) + ( cr.ParamBase[CR_AUTO_AIM] << 4 );
		if( cr.ParamBase[CR_AUTO_AIM] != HIT_LOCATION_NONE )
		{
			int delta = int( _WeaponApCost( weapon, weaponMode ) ) * 20;
			cr.StatBase[ ST_CURRENT_AP ] -= delta;
		}
	}

	uint windupTime = GetProtoWindupTime(weapon, mode, cr);

	uint[] vals = { cr.Id, target.Id, weapon.ProtoId, mode, 0, 0, 0 };
	if( valid( ammo ) )
	{
		vals[4] = ammo.ProtoId;
	}
	
	cr.SetDir( GetDirection( cr.HexX, cr.HexY, target.HexX, target.HexY ) );
	Item@ realWeapon = _CritGetItemHand( cr );
	uint8 weapon_Subtype = valid( realWeapon ) ? realWeapon.Proto.Item_Subtype : 0;
	
	if( cr.ParamBase[ CR_IS_WINDUPED ] == 0 )
	{
		if( cr.IsPlayer() && weapon_Subtype == ITEM_SUBTYPE_WEAPON_NORMAL_MINIGUN )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_COMBAT_SPIN_BARRELS );
			return;
		}
		cr.Wait( windupTime );
	}
	else
	{
		cr.Wait( 10 );
		windupTime = 5;
	}
	
	int skillNum = ( valid( weapon ) ? _WeaponSkill( weapon, 0 ) : ( valid( realWeapon ) ? SK_MELEE_WEAPONS : SK_UNARMED ) );
	uint8 weaponSubtype = ( skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS ) ? WS_GUN : 
					( ( skillNum == SK_THROWING ) ? WS_THROWING : ( skillNum == SK_MELEE_WEAPONS ) ? WS_MELEE : WS_UNARMED );
	
	if( weaponSubtype == WS_GUN )
	{
		cr.Action( ACTION_WINDUP, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | mode, valid( realWeapon ) ? realWeapon : null );
		cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
		if( cr.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0 )
		{
			cr.EraseTimeEvents( CTE_SLOWRELOAD );
			realWeapon.SetEvent( ITEM_EVENT_MOVE, null );
		}
	}
	else
	{
		CombatAttack( cr, target, weapon, mode, ammo, 0, 0 );
		cr.Wait( GetProtoTime( weapon, mode, cr ) );
		return;
	}
	
	CreateTimeEvent( AFTER( REAL_MS( windupTime ) ), "combat@e_DelayedAttack", vals, false );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked( Critter& cr, Critter& attacker )
{
    DEBUG_SAY( cr, "Main: " + crInfo( attacker ) + " attacks " + crInfo( cr ) );//DEBUG ONLY
	
	attacker.ParamBase[ LAST_ATTACKED ] = cr.Id;
	
	if( manager_critter_attacked( cr, attacker ) )
	{
		DEBUG_SAY( cr, "MANAGER FAILED" );//DEBUG ONLY
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count )
{
	/* Battle & death check */
    if( cr.IsDead() )
    {
        thief.StatBase[ST_LAST_STEAL_CR_ID] = 0;
        thief.StatBase[ST_STEAL_COUNT] = 0;
        return false;
    }
	else if( cr.StatBase[ST_FOLLOW_CRIT] == int( thief.Id ) )
	{
		return true;
	}
    else if( cr.Mode[ MODE_NO_PVP ] != 0 || thief.Mode[ MODE_NO_PVP ] != 0 )
    {
        thief.Say( SAY_NETMSG, "No PvP." );
        return false;
    }
	else if( !cr.IsLife() )
	{
		return true;
	}
		
    thief.TimeoutBase[ TO_AGGRESSOR ] = __FullSecond + REAL_MINUTE( 1 );

	/* Target perception & steal skill modifiers */
    int targetPeModifier = cr.Stat[ ST_PERCEPTION ];
    int targetStealModifier = cr.Skill[ SK_STEAL ];

    if( targetPeModifier <= 0 )
    {
        targetPeModifier = 1;
    }

    if( targetStealModifier <= 0 )
    {
        targetStealModifier = 1;
    }

    int basePeModifier = thief.Stat[ ST_PERCEPTION ];
    int baseAgModifier = thief.Stat[ ST_AGILITY ];
    int baseLkModifier = thief.Stat[ ST_LUCK ];
    int baseStealmodifier = thief.Skill[ SK_STEAL ];

    if( basePeModifier <= 0 )
    {
        basePeModifier = 1;
    }

    if( baseAgModifier <= 0 )
    {
        baseAgModifier = 1;
    }

    if( baseLkModifier <= 0 )
    {
        baseLkModifier = 1;
    }

    if( baseStealmodifier <= 0 )
    {
        baseStealmodifier = 1;
    }

    /* Look modifier */
    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX( dir1, dir2 ) - MIN( dir1, dir2 );
    if( kDir > 3 )
	{
        kDir = 6 - kDir;
	}
	
     /* Steal skill of thief */
    int steal = thief.Skill[ SK_STEAL ];
    if( steal <= 0 )
	{
        steal = 1;
    }
	
    /* Volume of an item */
	int volume = item.Proto.Volume;
    int volumeModifier = 0;
    if( volume <= 0 )
	{
        volume = 1;
        volumeModifier = 10;
	}
    else if(volume <= 20 && volume > 0 )
    {
        volumeModifier = 10;
    }

    /* Weight of an item */
    int weight = item.Proto.Weight;
    int weightModifier = 0;
    if ( weight <= 0 )
    {
        weight = 1;
        weightModifier = 10;
    }
    else if( weight <= 500 && weight > 0 )
    {
        weightModifier = 10;
    }
	
    /* Count modifier */
    int kCount = count / steal;
    if( kCount <= 0 )
	{
        kCount = 1;
	}

    /* Steal timer */
    uint lastStealCrId = thief.Stat[ ST_LAST_STEAL_CR_ID ];
    uint stealCount = thief.Stat[ ST_STEAL_COUNT ];
    if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
	{
        steal -= steal * stealCount * 9 / 100;
	}

    /* Final steal chance calculation 
       
       It's a sum of Steal % / 6 + PE + AG + LK 
       lowered by target's PE and Steal % / 6.
       If item that's being stolen has volume lower 
       than 20 then chance's being raised by 10%.
       Same if weight's lower than 500g then 
       additional 10% is being summed up. 
       
       Can't steal items bigger than 100 volume or 
       heavier than 2500g                           */

		int StealCalculation = CLAMP( ( ( steal - kDir * 10 ) + basePeModifier + baseAgModifier + baseLkModifier + volumeModifier + weightModifier - targetPeModifier - targetStealModifier ) / kCount, 5, 95 );
		int chance = Random( 1, 100 );
		bool success = ( chance < StealCalculation );

	/* Failed steal attempt because the item's too heavy */
    if( volume > 100 || weight > 2500 )
    {
		thief.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_VOLUME );
        string action_text = item.CritId == thief.Id ? "insert" : "steal";		
        CrimeLog( thief, crInfo( thief ) + " failed to " + action_text + " " + itemDesc( item ) + " ,victim: " + crInfo( cr ) );
		
		thief.Action( ACTION_PICK_CRITTER, 3, null );
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.Stat[ ST_CURRENT_HP ];
			AddAttackPlane( cr, 0, thief, thiefHp < 10 || Random( 1, 10 ) > cr.Stat[ ST_LUCK ] + 4 || cr.Stat[ ST_CHARISMA ] < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
		return false;
    }
	/* Succesful steal attempt */
	else if( success )
    {
        thief.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_SUCCESS );
		if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
        {
            stealCount++;
            if( stealCount > 11 )
			{
                stealCount = 11;
            }
			thief.StatBase[ ST_STEAL_COUNT ] = stealCount;
        }
        else
        {
            thief.StatBase[ ST_LAST_STEAL_CR_ID ] = cr.Id;
            thief.StatBase[ ST_STEAL_COUNT ] = 0;
        }
		thief.TimeoutBase[ TO_STEALING ] = STEAL_TIMEOUT( thief );
		thief.Action( ACTION_PICK_CRITTER, 1, null );
		return true;
    }
	/* Failed steal attempt */
    else
    {
		thief.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_FAIL );
		string action_text = item.CritId == thief.Id ? "insert" : "steal";		
        CrimeLog( thief, crInfo( thief ) + " failed to " + action_text + " " + itemDesc( item ) + " ,victim: " + crInfo( cr ) );
		
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.Stat[ ST_CURRENT_HP ];
			AddAttackPlane( cr, 0, thief, thiefHp < 10 || Random( 1, 10 ) > cr.Stat[ ST_LUCK ] + 4 || cr.Stat[ ST_CHARISMA ] < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
		return false;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param )
{
	bool isDog = ( cr.Stat[ ST_BODY_TYPE ] == BT_DOG );
	if( isDog && item.GetType() != ITEM_TYPE_FOOD && item.GetType() != ITEM_TYPE_DRINK && item.GetType() != ITEM_TYPE_FLASK && item.GetType() != ITEM_TYPE_DRUG )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
		return false;
	}
	
	string exception_catcher = cr.Id + "# in " + (valid(cr.GetMap())?"@"+cr.GetMap().Id:"global") + " used "
		+ (valid(item)?item.Id:0) + ":" + (valid(item)?item.GetProtoId():0) + " on [" 
		+ (valid(targetCr)?targetCr.Id:0) + ", " 
		+ (valid(targetItem)?targetItem.Id:0) + ":" + (valid(targetItem)?targetItem.GetProtoId():0) + ", " 
		+ (valid(targetScen)?targetScen.ProtoId:0) + "] with param " + param + ".";
	DebugLog( exception_catcher, 2 );
	
	_testInfo( cr, CR_TEST_MODE_USED, SAY_NETMSG, exception_catcher );

    uint16 pid = item.GetProtoId();
    bool useOnSelf = ( not valid( targetCr ) && not valid( targetItem ) && not valid( targetScen ) );
	
	cr.Wait(GetProtoTime(item.Proto, 0, cr));
	Map@ map = cr.GetMap();
	
	string action_info = crInfo( cr ) + " uses " + itemDesc( item ) + " on ";
	if( useOnSelf )
	{
		action_info += "self";
	}
	else
	{
		if( valid( targetCr ) )
		{
			action_info += crInfo( targetCr );
		}
		
		if( valid( targetItem ) )
		{
			action_info += itemDesc( targetItem );
		}		
		
		if( valid( targetScen ) )
		{
			action_info += "scenery #" + targetScen.ProtoId;
		}
	}
	SayLog( cr, action_info + "." );
	
	if( !valid( targetScen ) )
	{
		//Planting hydroponics
		if( hydro_seeds.find( pid ) != -1 )
		{
			if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_HYDRO_NS_EMPTY || targetItem.GetProtoId() == PID_HYDRO_EW_EMPTY ) )
			{
				TryPlantSeed( cr, item, 0, 0, targetItem );
				return true;
			}
		}
		//Planting mushrooms
		if( mushbed_seeds.find( pid ) != -1 )
		{
			if( valid( targetItem ) && targetItem.GetProtoId() == PID_MUSHBED_EMPTY )
			{
				TryPlantSeed( cr, item, 0, 0, targetItem );
				return true;
			}
		}
		// Plant Furtelizing
		if( valid( targetItem ) && furtilizers.find( pid ) != -1 )
		{
			if( growing_plants.find( targetItem.GetProtoId() ) != -1 || empty_beds.find( targetItem.GetProtoId() ) != -1 || farm_seeds.find( targetItem.GetProtoId() ) != -1 )
			{
				FurtilezePlant( cr, item, targetItem );
				return true;
			}
		}
		//Scavenging
		if( PrepareScavenging( cr, item, targetItem ) )
		{
			return true;
		}
		//Mining
		if( PrepareMining( cr, item, targetItem ) )
		{
			return true;
		}
		//Chopping
		if( PrepareChopping( cr, item, targetItem ) )
		{
			return true;
		}
		//Make firewood
		if( TryChopItem( cr, item, targetItem ) )
		{
			return true;
		}
		//Smithing
		if( PrepareSmithing( cr, item, targetItem ) )
		{
			return true;
		}
		//Flasks and other containers for liquids
		if( FlaskCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Slot machine
		if( SlotMachineCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Firesource check
		if( FireCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Sandbag placing check
		if( SandbagCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Container placing check
		if( ContainerCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Still check
		if( UseItemOnStill( cr, item, targetItem ) )
		{
			return true;
		}
		//Autodoc biogel charging
		if( ChargeAutodoc( cr, item, targetItem ) )
		{
			return true;
		}
		// Armor painting
		if( valid( item ) && valid( targetItem ) && pid == PID_COLORS && targetItem.GetType() == ITEM_TYPE_ARMOR )
		{
			TryPaintArmor( cr, item, targetItem ); 
			return true; 
		}
		//Shiv lex writing
		if( valid( item ) && valid( targetItem ) && pid == PID_SHIV )
		{
			ShivUse( cr, item, targetItem );
			return true;
		}
		//Cards deck
		if( valid( item ) && pid == PID_CARDS_DECK && !valid( targetScen ) )
		{
			if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CONTAINER )
			{
				CardsUse( cr, item, targetItem );
				return true;
			}
			
			if( valid( targetCr ) && targetCr.IsPlayer() && !useOnSelf )
			{
				CardsUse( cr, item, targetCr );
				return true;
			}
		}
		//Cards hand
		if( valid( item ) && pid == PID_CARDS_HAND && !valid( targetScen ) && valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CONTAINER )
		{
			ShowCardSHand( cr, item, targetItem );
			return true;
		}
	}
	//Interactions with scenery
	if( valid( targetScen ) )
	{	//Toilets
		if( scenToiletList.find( targetScen.ProtoId ) > -1 )
		{
			FlushToilet( cr, item );
			return true;
		}
	}
	//Various Items
	switch( pid )
	{
		case( PID_DICE ):
		case( PID_LOADED_DICE ):
			DiceUse( cr, item );
			return true;
		case( PID_BOTTLE_CAPS ):
			CoinUse( cr, item );
			return true;
		case( PID_TAPE_RECORDER ):
			StartMenuRecorder( cr, item );
			return true;
		case( PID_PHOTO ):
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_MAKES_PICTURE );
			cr.Action( ACTION_PICK_CRITTER, 3, null );
			return true;
		case( PID_FLUTE ):
			FluteUse( cr );
			return true;
		case( PID_MAGIC_8_BALL ):
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, Random( 1, 2 ) == 1 ? STR_MAGIC_BALL_YES : STR_MAGIC_BALL_NO );
			return true;
		case( PID_SHOVEL ): 
		case( PID_SPADE ):
			CheckRemainsRemoval( cr, targetItem );
			return true;
		case( PID_SLAVE_COLLAR_SWITCH ):
			StartMenuSCollar( cr, item );
			return true;
	}
	//Show single Card
	if( Cards.find( pid ) != -1 )
	{
		ShowCard( cr, item );
		return true;
	}
	//Fishing
	if( ( pid == PID_STRING || pid == PID_HOOK || Bait.find( pid ) != -1 ) && ( hasItem( cr, PID_ROD_STRING_HOOK, SLOT_HAND1 ) || hasItem( cr, PID_ROD_STRING, SLOT_HAND1 ) || hasItem( cr, PID_ROD, SLOT_HAND1 ) ) ) 
	{
		PrepareFishingRod( cr, item );
		return true;		
	}
	//Soap
	if( SoapItems.find( pid ) != -1 )
	{
		Critter@ target = useOnSelf ? @cr : @targetCr;
		if( valid( target ) )
		{
			Cleaning( cr, target, pid, 0 );
			return true;
		}
	}
	// Knife use
	if( CutCheck( cr, item, useOnSelf ? @cr : @targetCr ) )
	{ 
		return true;
	}
	//Blood wrapping
	if( pid == PID_CRAFT_L_RAGS && valid( targetItem ) && targetItem.GetProtoId() >= PID_BLOOD_SMALL_1 && targetItem.GetProtoId() <= PID_BLOOD_BIG_3 )
	{
		cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_WIPE_BLOOD );
		cr.Animate( 0, ANIM2_PICKUP, null, false, true );
		targetItem.Val0 -= Random( 1, 3 );
		
		if( targetItem.Val0 < 1 )
		{
			DeleteItem( targetItem );
		}
		return true;
	}
	//Doors
	if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_DOOR )
	{
        cr.StatBase[ ST_LAST_DOOR_ID ] = targetItem.Id;
    }
	//Bandage
	if( bandage_items.find( pid ) != -1 )
	{
		if( cr.IsPlayer() && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
			return true;
		}
		
		cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );
		
		if( useOnSelf )
		{
			UseBandageItem( cr, cr, item );
		}
		else if( valid( targetCr ) )
		{
			if( targetCr.IsLife() )
			{
				AskHealingItem( cr, targetCr, item, false );
			}
			else
			{
				UseBandageItem( cr, targetCr, item );
			}
		}
        return true;
    }
	//Skinning
	if( valid( targetCr ) )
	{
		if( SkinningTools.find( pid ) != -1 )
		{
			PrepareSkinning( cr, item, targetCr );
			return true;
		}
	}
    //Containers
	if( cr.IsPlayer() && useOnSelf && item.GetType() == ITEM_TYPE_CONTAINER )
	{
        ShowContainer( cr, item, TRANSFER_SELF_CONT );
        return true;
    }
	//Keybunch
    if( pid == PID_KEY_BUNCH && !( targetItem is null ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) )
	{
		KeyBunchUse( cr, item, targetItem );
		return true;
    }
    //Hypo Poison
    if( useOnSelf && pid == PID_HYPO_POISON && cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT )
	{
		if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NEUROTOX_SELF );
			AffectParalysis( cr, 50 );
			cr.DeleteItem( PID_HYPO_POISON, 1 );
		}
        return true;
    }
	
    if( valid( targetCr ) && pid == PID_HYPO_POISON && targetCr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT )
	{
        targetCr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NEUROTOX_YOU );
        AffectParalysis( targetCr, 50 );
        cr.DeleteItem( PID_HYPO_POISON, 1 );
        return true;
    }
    //Antidote
    if( useOnSelf && pid == PID_ANTIDOTE_2 )
	{
        if( cr.Param[ ST_PARALYSIS_LEVEL ] != 0 || cr.Param[ ST_POISONING_LEVEL ] != 0 ) {
            DropPoison( cr );
            DropParalysis( cr, 50 );
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return true;
        }
		else 
		{
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return false;
        }
    }
	
    if( valid( targetCr ) && pid == PID_ANTIDOTE_2 )
	{
        if( targetCr.Param[ ST_PARALYSIS_LEVEL ] != 0 || targetCr.Param[ ST_POISONING_LEVEL ] != 0 )
		{
			DropPoison( targetCr );
            DropParalysis( targetCr, 50 );
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return true;
        }
		else
		{
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return false;
        }
    }
	//Flasks
	if( item.GetType() == ITEM_TYPE_FLASK )
	{
		if( item.Val0 > 0 )
		{
			Item@ flask = cr.GetItem( 0, SLOT_HAND1 );
			if( valid( targetItem ) && targetItem.GetProtoId() == PID_BOTTLE_GLASS)
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TRY_DIFFERENTLY );
			}
			else if( valid( targetScen ) )
			{
				PourFlask( cr, item );
			}
			else if( valid( flask ) && item.CritSlot != SLOT_HAND1 && flask.Proto.Type == ITEM_TYPE_FLASK )
			{ 
				FlaskCheck( cr, item, flask );
			}
			else if( valid( targetItem ) )
			{
				if( growing_plants.find( targetItem.GetProtoId() ) != -1 || empty_beds.find( targetItem.GetProtoId() ) != -1 || farm_seeds.find( targetItem.GetProtoId() ) != -1 )
				{
					TryWaterPlant( cr, item, targetItem );
					return true;
				}
			}
			else
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				DrinkFlask( cr, item );
			}
		}
		else
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
		}
		return true;
	}
	
    // Radio
	if( !useOnSelf && pid == PID_RADIO )
	{
		if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_ARMOR && ( targetItem.Proto.Item_Subtype >= ITEM_SUBTYPE_ARMOR_AC20 && targetItem.Proto.Item_Subtype <= ITEM_SUBTYPE_ARMOR_AC50 ) )
		{ 
			InstallRadio( cr, targetItem );
		}
		return true;
	}
	
    if( FLAG( item.Flags, ITEM_RADIO ) && useOnSelf )
	{
        if( cr.IsPlayer() )
		{
            EditRadioSettings( cr, item );
        }
		return true;
    }

    // Explosion
    if( OnUseExplode( cr, item, targetCr, targetItem, targetScen, param ) )
	{
        return true;
	}

	// Drinks
	if( item.GetType() == ITEM_TYPE_DRINK )
	{
		// Plant Watering
		if( valid( targetItem ) )
		{
			if( growing_plants.find( targetItem.GetProtoId() ) != -1 || empty_beds.find( targetItem.GetProtoId() ) != -1 || farm_seeds.find( targetItem.GetProtoId() ) != -1 )
			{
				TryWaterPlant( cr, item, targetItem );
				return true;
			}
		}
		
		if( find_glassed_drinks( item ) )
		{
			uint body = cr.Stat[ ST_BODY_TYPE ];
			if( ( body >= 5 && body <= 9 ) || ( body >= 11 && body <= 29 ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_ANATOMY );
				return true;
			}
			
			if( find_capped_bottles( item ) )
			{
				if( HasBlade( cr ) || hasItem( cr, PID_LIGHTER ) ||  hasItem( cr, PID_FLINT ) )
				{
					cr.AddItem( PID_REAL_BOTTLE_CAPS, 1 );
					map.PlaySound( cap_bottle_open_sounds[ Random( 0, cap_bottle_open_sounds.length() -1 ) ], cr.HexX, cr.HexY, 2 );
				}
				else
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_NOTHING_TO_OPEN_BOTTLE );
					return true;
				}
			}
			else
			{
				PlayGenericSound( map, cr.HexX, cr.HexY, "bottleOpen.ogg", 6 );
			}
			
			uint16 drinkPid = item.GetProtoId();
			int index = glass_bottles[1].find( drinkPid );
			
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_OPEN_BOTTLE, "$proto@msg item " + ( drinkPid * 100 ) + "@\n");
			
			Item@ openedBottle = cr.AddItem( glass_bottles[2][index], 1 );
			
			openedBottle.REMAINING_USES = openedBottle.Proto.Partial_Item;
			openedBottle.DRINK_DNA = openedBottle.Proto.StartValue_1;
			openedBottle.EXTRA_WEIGHT = openedBottle.Proto.Partial_Item * 100;
			openedBottle.Val3 = item.Val3;
			openedBottle.Val4 = item.Val4;
			openedBottle.TOXIN_LEVEL = item.TOXIN_LEVEL;
			openedBottle.Val6 = item.Val6;
			openedBottle.POLUTION_LEVEL = item.POLUTION_LEVEL;
			openedBottle.FASK_TASTE = item.FASK_TASTE;
			openedBottle.SPIRIT_LEVEL = item.SPIRIT_LEVEL;
			
			openedBottle.Update();
			
			string@ lexems = Item_GetLexems( item );
			if( valid( lexems ) )
			{
				openedBottle.SetLexems( lexems );
			}
			
			_SubItem( item, 1 );
			
			Item@ hands = cr.GetItem( 0, SLOT_HAND1 );
			if( valid( hands ) )
			{
				cr.MoveItem( hands.Id, hands.GetCount(), SLOT_INV );
			}
			
			cr.MoveItem( openedBottle.Id, openedBottle.GetCount(), SLOT_HAND1 );
			
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_OPENS_BOTTLE );
			
			return true;
		} 
		
		Item@ flask = _CritGetItemHand( cr );
		if( valid( flask ) )
		{
			if( item.CritSlot != SLOT_HAND1 && flask.GetType() == ITEM_TYPE_FLASK )
			{ 
				FlaskCheck( cr, item, flask );
				return true;
			}
		}
			
		if( item.CritSlot != SLOT_HAND1 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MUST_HOLD_ITEM );
			return true;
		}
		
		if( useOnSelf )
		{
			cr.Action( ACTION_USE_ITEM, 2, item );
			ProccessDrink( cr, cr, item );
		}
		else if( valid( targetCr ) )
		{
			cr.Action( ACTION_USE_ITEM, 1, item );
			ProccessDrink( cr, targetCr, item );
		}
        return true;
    }
	// Bondage
	if( item.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
	{
		if( item.BONDAGE_STATE != BONDAGE_STATE_OFF )
		{
			return false;
		}
		
		if( useOnSelf )
		{
			@targetCr = cr;
		}
		TryBondageTarget( cr, targetCr, item );
		return true;
	}
	// Bondage key
	if( pid == PID_HANDCUFFS_KEY || pid == PID_SHACKLES_KEY )
	{
		if( useOnSelf )
		{
			@targetCr = cr;
		}
		ReleaseTarget( cr, targetCr, item );
		return true;
	}
	// Remove shackles and cuffs
	if( pid == PID_WELDING || pid == PID_ENERGY_WELDIN )
	{
		if( useOnSelf )
		{
			@targetCr = cr;
		}
		TryBreakBonds( cr, targetCr );
		return true;
	}
    // Drugs
    if( item.GetType() == ITEM_TYPE_DRUG || item.GetType() == ITEM_TYPE_FOOD )
	{
    	if( ( useOnSelf && cr.StatBase [ST_BODY_TYPE] == BT_ROBOT) || ( @targetCr != null && targetCr.StatBase [ST_BODY_TYPE] == BT_ROBOT ) )
		{
			return false;
        }

        if( useOnSelf )
		{
			if( heal_items.find( pid ) != -1 ) 
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				UseHealingItem( cr, cr, item );
				return true;
			}
			else
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_CONSUMED, "$proto@msg item " + ( pid * 100 ) + "@" );
			
            	ProccessFood( cr, cr, item );

				UseDrug( cr, item );
				return true;
			}
		}
		else if( valid( targetCr ) )
		{
			if( heal_items.find( pid ) != -1 ) 
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				if( targetCr.IsLife() )
				{
					AskHealingItem( cr, targetCr, item, false );
				}
				else
				{
					UseHealingItem( cr, targetCr, item );
				}
				return true;
			}
			else
			{
				ProccessFood( cr, targetCr, item );
				UseDrugOn( cr, targetCr, item );
			}
			cr.Action( ACTION_USE_ITEM, 1, item );
			//cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_CONSUMED, "$proto@msg item " + ( pid * 100 ) + "@" );
		}
		return true;
    }
	
    //Oil Lamp
	if( pid == PID_OIL_LAMP )
	{
		OilLampUse( cr, item );
		return true;
	}
	//Flashlight
    if( pid == PID_FLASHLIGHT_OFF )
	{
		FlashlightUse( cr, item );
        return true;
    }
		
	// Flashlight charging
	if( ( pid == PID_SMALL_ENERGY_CELL || pid == PID_CUENCELL_LOW ) && valid( targetItem ) && ( targetItem.GetProtoId() == PID_FLASHLIGHT_OFF || targetItem.GetProtoId() == PID_FLASHLIGHT_ON ) )
	{
		targetItem.ITEM_CHARGE = pid == PID_SMALL_ENERGY_CELL ? 480 : 240;
		PlayGenericSound( map, cr.HexX, cr.HexY, "WRJ1XXX1.mp3", 6 ); 
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_RELOAD_FLASHLIGHT );
		_SubItem( item, 1 );
		return true;
	}
	// OilLamp charging
	if( pid == PID_PLANT_OIL && valid( targetItem ) && targetItem.GetProtoId() == PID_OIL_LAMP )
	{
		PlayGenericSound( map, cr.HexX, cr.HexY, "ROBE.mp3", 6 );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_RELOAD_LAMP );
		targetItem.ITEM_CHARGE = 120;
		_SubItem( item, 1 );
		return true;
	}
	// Flare extinguish
	if( pid == PID_ACTIVE_FLARE )
	{
        _SubItem( item, 1 );
		cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_FLARE_OFF );
		PlayGenericSound( map, cr.HexX, cr.HexY, "BUTIN4.mp3", 4 );
        return true;
    }
	// Active Flare
    if( pid == PID_FLARE )
	{
		FlareUse( cr, item );
		return true;
	}
    // Cosmetic
    if( pid == PID_COSMETIC_CASE && cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
	{
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_COSMETIC_USE );
        return true;
    }
	// Fires
	if( ( ( pid == PID_LIGHTER || pid == PID_FLINT ) && valid( targetItem ) && targetItem.GetProtoId() == PID_CHOPPED_FIREWOOD ) )
	{
		return Ignite( cr, item, targetItem );
	}
	// Smoking items
	if( item.GetType() == ITEM_TYPE_SMOKER )
	{
		CheckSmokers( cr, item );
		return true;
	}
    // Towels
	if( pid == PID_TOWEL || pid == PID_OLD_TOWEL )
	{
		if( useOnSelf )
		{
			TowelUse( cr, item );
		}
		else if( valid( targetScen ) )
		{
			TowelWash( cr, item, targetScen );
		}
		return true;
	}
	//Locker removal
    if( ( pid == PID_CROWBAR || pid == PID_MULTI_TOOL ) && @targetItem != null )
	{
        LockerRemoval( cr, item, targetItem );
		return true;
    }
    // Geiger counter
    if( pid == PID_GEIGER_COUNTER && useOnSelf && UseGeiger( cr, item ) )
	{
        return true;
	}
	
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseItemOnGeiger( cr, targetItem, item ) )
	{
        return true;
	}
	//Showel on self to make a bed in GM mode
    if( pid == PID_SHOVEL && useOnSelf )
	{
		UseShovel( cr, item );
        return true;
	}
	// Item use on locker
    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) )
	{
		UseItemOnLocker( cr, targetItem, item );
        return true;
	}

    // Take process to engine
    return false;
}

void informAboutSkill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	string skill_name = "";
	switch( skill )
	{
		case( SK_LOCKPICK ):
			skill_name = "Lockpicking";
			break;
		case( SK_STEAL ):
			skill_name = "Theft";
			break;
		case( SK_TRAPS ):
			skill_name = "Traps";
			break;
		case( SK_FIRST_AID ):
			skill_name = "First Aid";
			break;
		case( SK_DOCTOR ):
			skill_name = "Doctor Skill";
			break;
		case( SK_SCIENCE ):
			skill_name = "Science";
			break;
		case( SK_REPAIR ):
			skill_name = "Repair";
			break;
		default:
			return;
	}
	
	string action_info = crInfo( cr ) + " applies " + skill_name + " on ";
	
	if( valid( targetCr ) )
	{
		action_info += crInfo( targetCr );
	}
	else if( valid( targetItem ) )
	{
		action_info += itemDesc( targetItem );
	}
	else if( valid( targetScen ) )
	{
		action_info += "scenery #" + targetScen.ProtoId;
	}
	else
	{
		action_info += "self";
	}
	SayLog( cr, action_info + "." );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	bool isDog = ( cr.Stat[ ST_BODY_TYPE ] == BT_DOG );
	if( cr.Param[ CR_INIT_SEX ] != 0 )
	{
		skill = SK_SEX;
	}
	
	if( cr.Param[ CR_INIT_DEVOUR ] != 0 )
	{
		skill = SK_HUNTING;
	}

	string exception_catcher = cr.Id + "# in " + (valid(cr.GetMap())?"@"+cr.GetMap().Id:"global") + " used " + skill + " on [" 
		+ (valid(targetCr)?targetCr.Id:0) + ", " 
		+ (valid(targetItem)?targetItem.Id:0) + ":" + (valid(targetItem)?targetItem.GetProtoId():0) + ", " 
		+ (valid(targetScen)?targetScen.ProtoId:0) + "].";
	DebugLog( exception_catcher, 2 );

	informAboutSkill( cr, skill, targetCr, targetItem, targetScen );
	
	if( valid( targetItem ) )
	{
		CheckItemMovement( cr, targetItem, skill );
	}

    bool onSelf = ( ( !valid( targetCr ) ) && ( !valid( targetItem ) ) && ( !valid( targetScen ) ) );

	cr.Wait(GetSkillTime(skill, cr));

    // Geiger counter
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseSkillOnGeiger( cr, targetItem, skill ) )
	{
        return true;
	}
	// homebrew pot interface
	if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_POT_ALCO ) )
	{	
		switch( skill )
		{
			case( SK_REPAIR ):
				LockInPlace( cr, targetItem );
				break;
			case( SKILL_PICK_ON_GROUND ):
			{
				if( !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
				{
					ShowMenuBrew( cr, targetItem );
				}
				else
				{
					PickItem( cr, targetItem );
					ChangeCritterSpeed( cr );
				}
				break;
			}
		}
		return true;
	}
	// empty mushroom bed
	if( valid( targetItem ) && ( targetItem.GetProtoId() ==PID_MUSHBED_EMPTY ) )
	{
			StartMenuMushbed( cr, targetItem );
			return true;
	}
	// Still interface
	if( valid( targetItem ) && IsStill( targetItem ) )
	{
		switch( skill )
		{
			case( SK_REPAIR ):
				LockInPlace( cr, targetItem );
				break;
			case( SKILL_PICK_ON_GROUND ):
				StartMenuStill( cr, targetItem );
				break;
		}
		return true;
	}
	// case for lockpickable containers with interface
	if( skill != SK_LOCKPICK ) 
	{
		if( valid( targetItem ) )
		{
			uint16 Pid = targetItem.GetProtoId();
			// Slots interface
			if( Pid == PID_SLOT_MACHINE || Pid == PID_SLOT_MACHINE2 )
			{
				StartMenuSlotMachine( cr, targetItem );
				return true;
			}
			// Vending Machine Interface
			if( vending_machines.find( Pid ) != -1 )
			{
				StartMenuVendingMachine( cr, targetItem );
				return true;
			}
			// Jukebox Interface
			if( Pid == PID_JUKEBOX1 || Pid == PID_JUKEBOX2 || Pid == PID_JUKEBOX3 || Pid == PID_JUKEBOX4 )
			{
				StartMenuJukebox( cr, targetItem );
				return true;
			}
			// Terminal interface
			if( Pid == PID_TERMINAL )
			{
				StartMenuTerminal( cr, targetItem );
				return true;
			}
			// Farming plants
			if( growing_plants.find( Pid ) != -1 )
			{
				StartMenuPlant( cr, targetItem );
				return true;
			}
			// Anvil interface
			if( Pid == PID_ANVIL )
			{
				switch( skill )
				{
					case( SK_REPAIR ):
						LockInPlace( cr, targetItem );
						break;
					case( SKILL_PICK_ON_GROUND ):
						StartMenuAnvil( cr, targetItem );
						break;
				}
				return true;
			}
			// Smelter interface
			if( Pid == PID_FURNACE_SMALL )
			{
				StartMenuFurnace( cr, targetItem );
				return true;
            }
		}
	}
	// Wells interface
	if( valid( targetItem ) && Wells.find( targetItem.GetProtoId() ) != -1 )
	{
		StartMenuWell( cr, targetItem );
		return true;
	}
	// Waterpump interface
	if( valid( targetItem ) && targetItem.GetProtoId() == PID_OBJECT_WATERPUMP )
	{
		StartMenuWaterPump( cr, targetItem );
		return true;
	}
    // Doors or containers
    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || ( targetItem.GetType() == ITEM_TYPE_CONTAINER && !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) ) ) && skill != SK_REPAIR )
	{
		if( isDog && ( targetItem.GetType() == ITEM_TYPE_DOOR || ( targetItem.GetType() == ITEM_TYPE_CONTAINER && !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) && targetItem.Proto.Container_Changeble ) ) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
			return false;
		}

		UseSkillOnLocker( cr, targetItem, skill );
		return true;
	}
	// Check for all skills for critter
    switch( skill )
    {
		case( SKILL_PICK_ON_GROUND ): 
		{
			// Scenery
			if( valid( targetScen ) )
			{
				// washing
				if( water_sources.find( targetScen.ProtoId ) != -1 )
				{
					Cleaning( cr, 0, targetScen.ProtoId );
					return true;
				}
				// cooking
				if( !isDog && CanCook( targetScen ) )
				{
					AskCooking( cr );
					return true;
				}
			}
			
			// Items
			if( valid( targetItem ) )
			{
				uint16 Pid = targetItem.GetProtoId();

				// Open fire cooking
				if( ( Pid == PID_FIREPLACE2 || Pid == PID_CHOPPED_FIREWOOD ) && targetItem.Val0 >= 1 )
				{	
					AskCooking( cr );
					return true; 
				} 
				// Locked in place firesource
				if( Pid == PID_FIREBARREL || Pid == PID_BRAZIER )
				{	
					StartMenuFireBarrel( cr, targetItem );
					return true; 
				}
				// Light Switches
				if( Pid == PID_SWITCH1_DIR2 || Pid == PID_SWITCH1_DIR3 || Pid == PID_SWITCH2_DIR2 || Pid == PID_SWITCH2_DIR3 || Pid == PID_SWITCH3_DIR2 || Pid == PID_SWITCH3_DIR3 )
				{
					UseLightSwitch( cr, targetItem );
					return true; 
				}
				// Explosion
				if( Pid == PID_ACTIVE_MINE || Pid == PID_ACTIVE_MINE_PLASMA || Pid == PID_ACTIVE_MINE_PULSE )
				{
					OnUseExplode( cr, targetItem, null, null, null, 0 );
					return true;
				}
				// Gather wildplant
				if( Wildplants.find( Pid ) != -1 )
				{
					PickPlant( cr, targetItem );
					return true; 
				}
				// Take sandbag
				if( Sandbags.find( Pid ) != -1 )
				{
					TakeSandbag( cr, targetItem );
					return true; 
				}
				// seeds
				if( Wildplants.find( Pid ) != -1 )
				{
					targetItem.PLANT_GROW_STAGE = 0;
					targetItem.PLANT_BED_DNA = 0;
					targetItem.PLANT_RESOURCE_CAPACITY = 0;
					if( targetItem.PLANT_EVENT != 0 )
					{
						EraseTimeEvent( targetItem.PLANT_EVENT );
						targetItem.PLANT_EVENT = 0;
					}
					targetItem.PLANT_WATERING = 0;
					targetItem.PLANT_FERTILITY = 0;
					
					PickItem( cr, targetItem );
					ChangeCritterSpeed( cr );
					return true; 
				}
				// Any other item
				PickItem( cr, targetItem );
				ChangeCritterSpeed( cr );
				return true; 
			}
			return true; 
		}

		case( SKILL_PUT_CONT ):
		{
			if( cr.ParamBase[ ST_LAST_CONT_ID ] == 0 )
			{
				return false;
			}
			
			Item@ cont = GetItem( cr.ParamBase[ ST_LAST_CONT_ID ] );
			if( !valid( cont ) )
			{
				return false;
			}
			
			if( !canPutItemInContainer( targetItem, cont ) || cont.Id == targetItem.Id )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CONTAINER_TOO_SMALL );
				return true;
			}
			
			uint16 contPid = cont.GetProtoId();
			//Homebrew pot
			if( contPid == PID_POT_ALCO )
			{
				TransferToPot( cr, targetItem, cont );
				return true;
			}	
			//Computer terminal
			if( contPid == PID_TERMINAL )
			{
				TransferToTerminal( cr, targetItem, cont );
				return true;
			}	
			// bootlegging still
			if( contPid == PID_STILL_S )
			{
				TransferToStill( cr, targetItem, cont );
				return true;
			}	
			// hand of cards
			if( contPid == PID_CARDS_HAND )
			{
				TransferToCardsHand( cr, targetItem, cont );
				return true;
			}
			//Cart picture update
			CheckCartPicMap( cont );
			uint[] val = { cont.Id };
			CreateTimeEvent( AFTER( REAL_MS( 10 ) ), "e_UpdateContainer", val, true );
			return false; 
		}
		
		case( SKILL_TAKE_CONT ): 
		{
			uint16 Pid = targetItem.GetProtoId();
			if( targetItem.Accessory == ACCESSORY_CONTAINER || targetItem.CritId == cr.Id )
			{
				if( Cards.find( Pid ) != -1 )
				{
					cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_CARD );
				}
				else
				{
					uint type = targetItem.GetType();
					switch( type )
					{
						case( ITEM_TYPE_ARMOR ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_ARMOR );
							break;
						case( ITEM_TYPE_DRINK ):
						case( ITEM_TYPE_FOOD ):
						case( ITEM_TYPE_CONTAINER ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_CONTAINER, "$proto@msg item " +  ( targetItem.Proto.ProtoId * 100 ) + "@" );
							break;
						case( ITEM_TYPE_WEAPON ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_WEAPON );
							break;
						case( ITEM_TYPE_AMMO ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_AMMO );
							break;
						default:
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_SMTH );
							break;
					}
				}
			}
			
			if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CONTAINER )
			{
				int full_weight = ItemsWeight( targetItem, cr.ItemTransferCount() );
				int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - ItemsWeight( cr );
				if( !isGM( cr ) && freeWeight < full_weight )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_HEAVY_FOR_YOU );
					Item@ cont = GetItem( targetItem.ContainerId );
					if( valid( cont ) )
					{
						ShowContainer( cr, cont, TRANSFER_FAR_CONT );
					}
					return true;
				}
			}
			
			if( cr.ParamBase[ ST_LAST_CONT_ID ] == 0 )
			{
				return false;
			}
			
			Item@ cont = GetItem( cr.ParamBase[ ST_LAST_CONT_ID ] );
			if( !valid( cont ) )
			{
				return false;
			}
			
			uint16 contPid = cont.GetProtoId();
			
			if( contPid == PID_POT_ALCO )
			{
				TransferFromPot( cr, targetItem, cont );
				return true;
			}
			
			if( contPid == PID_TERMINAL )
			{
				TransferFromTerminal( cr, targetItem, cont );
				return true;
			}
			
			if( contPid == PID_CARDS_HAND )
			{
				TransferFromCardsHand( cr, targetItem, cont );
				return true;
			}

			CheckCartPicMap( cont ); // changes cart picture
			uint[] val = { cont.Id };
			CreateTimeEvent( AFTER( REAL_MS( 10 ) ), "e_UpdateContainer", val, true );
			return false; // in order for items to transfer return false!
		}
		
		case( SKILL_TAKE_ALL_CONT ): 
		{
			//Disabled
			return false;
		}
		
		case( SKILL_LOOT_CRITTER ): 
		{
			cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_INSPECTS );
			cr.Action( ACTION_PICK_CRITTER, 0, null );
			
			ShowContainer( cr, targetCr, TRANSFER_CRIT_LOOT );
			return true; 
		}
		
		case( SKILL_PUSH_CRITTER ): 
		{
			cr.Action( ACTION_PICK_CRITTER, 2, null );
			cr.StatBase[ ST_CURRENT_AP ] -= 5000;
			if( ( targetCr.IsPlayer() || ( targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers( null ) == 0 ) ) && targetCr.Mode[MODE_NO_PUSH] == 0 && targetCr.MoveToDir( cr.Dir ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PUSH_TARGET );
				SayLog( cr, crInfo( cr ) + " pushes " + crInfo( targetCr ) + "." );
			}
			else
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TARGET_RESIST );
				SayLog( cr, crInfo( cr ) + " can't push " + crInfo( targetCr ) + "." );
			}
			return true; 
		}

		case( SK_FIRST_AID ): 
		{
			if( isDog )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}
			
			bool alreadyAllowed = false;
			if( valid( targetItem ) || valid( targetScen ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( !valid( targetCr ) )
			{
				@targetCr = cr;
				alreadyAllowed = true;
			}
			
			if( targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( targetCr.IsDead() )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_TARGET_DEAD );
				return true;
			}

			if( cr.IsPlayer() && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
				return true;
			}
			
			AskFirstAid( cr, targetCr, alreadyAllowed );
			return true; 
		}
		
		case( SK_DOCTOR ): 
		{
			if( isDog )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}
			
			if( valid( targetItem ) || valid( targetScen ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( not valid( targetCr ) )
			{
				@targetCr = cr;
			}
			
			if( targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( targetCr.IsDead() )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_TARGET_DEAD );
				return true;
			}

			if( cr.IsPlayer() && cr.Timeout[ TO_SK_DOCTOR ] > 0 )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
				return true;
			}

			ProccessDoctorSkill( cr, targetCr, false );
			return true; 
		}
		
		case( SK_SCIENCE ): 
		{
			if( isDog )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}
			
			if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CRITTER )
			{
				StartMenuAskAction( cr, targetItem );
				return true;
			}
			break; 
		}
		
		case( SK_REPAIR ): 
		{
			if( isDog )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}
			
			if( onSelf )
			{
				@targetCr = cr;
			}
			
			if( valid( targetCr ) )
			{
				if( targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
				{
					if( cr.Timeout[ TO_SK_REPAIR ] > 0 )
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
						return true;
					}
					
					robotRepairSkill( cr, targetCr, false );
					ChangeCritterSpeed( targetCr );
					cr.TimeoutBase[ TO_SK_REPAIR ] = REPAIR_TIMEOUT( cr );
					return true;
					
				}
				else
				{
					if( onSelf )
					{
						return false;
					}
					
					if( cr.Timeout[ TO_SK_STEAL ] > 0 && !isGM( cr ) && targetCr.ModeBase[ MODE_NO_STEAL ] == 0 )
					{
						if( !targetCr.IsDead() )
						{
							targetCr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_RESISTS_TAKE_ITEM );
						}
						cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_TRIES_TAKE_ITEM);
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TIRED_TAKE_ITEM );
						CrimeLog( cr, crInfo( cr ) + " is trying to take item from " + crInfo( targetCr ) );
						return true;
					}

					Item@[] items;
					Item@[] items0;
					Item@[] items1;
					Item@[] items2;
					Item@[] items3;
					uint itemscount = targetCr.GetItems( SLOT_HAND1, items );
					uint itemscount0 = targetCr.GetItems( SLOT_HAND2, items0 );
					uint itemscount1 = targetCr.GetItems( SLOT_HEAD, items1 );
					uint itemscount2 = targetCr.GetItems( SLOT_BACK, items2 );
					uint itemscount3 = targetCr.GetItems( SLOT_MISC, items3 );
					
					if( targetCr.IsKnockout() || targetCr.IsDead() || CantResist( targetCr ) || isGM( cr ) )
					{
						if( itemscount > 0 )
						{
							if( !HandsTied( cr ) )
							{
								targetCr.MoveItem( items[ 0 ].Id, itemscount, SLOT_INV );
							}
						}
						
						if( itemscount0 > 0 )
						{
							if( !HandsTied( cr ) )
							{
								targetCr.MoveItem( items0[ 0 ].Id, itemscount, SLOT_INV );
							}
						}

						if( itemscount1 > 0 )
						{
							Item@ head = items1[0];
							if( valid( head ) )
							{
								int pid = head.GetProtoId();
								if( pid != PID_ACTIVE_SLAVE_COLLAR )
								{
									targetCr.MoveItem( items1[ 0 ].Id, itemscount, SLOT_INV );
								}
							}
						}

						if( itemscount2 > 0 )
						{
							Item@ back = items2[0];
							if( valid( back ) )
							{
								int pid = back.GetProtoId();
								targetCr.MoveItem( items2[ 0 ].Id, itemscount, SLOT_INV );
							}
						}
						
						if( itemscount3 > 0 )
						{
							Item@ misc = items3[0];
							if( valid( misc ) )
							{
								int pid = misc.GetProtoId();
								targetCr.MoveItem( items3[ 0 ].Id, itemscount, SLOT_INV );
							}
						}

						if( StealContainerOrArmor( cr, targetCr, targetItem ) )
						{
							return true;
						}
					}
				}
			}

			uint16 tiPid = targetItem.GetProtoId();
			//X3 container stack decrease
			if( valid( targetItem ) && ContainersX3.find( tiPid ) != -1 )
			{
				TakeX3Container( cr, targetItem );
				return true;
			}
			//X2 container stack decrease
			if( valid( targetItem ) && ContainersX2.find( tiPid ) != -1 )
			{
				TakeX2Container( cr, targetItem );
				return true;
			}
			//Move of locked furniture
			if( valid( targetItem ) && ( tiPid == PID_FIREBARREL || tiPid == PID_BRAZIER ) && targetItem.Val0 == 0 )
			{
				LockInPlace( cr, targetItem );
				return true;
			}
			//Cards deck shuffle
			if( valid( targetItem ) && ( tiPid == PID_CARDS_DECK ) )
			{
				ShuffleDeck( cr, targetItem );
				return true;
			}
			//Cards in hand actions
			if( valid( targetItem ) && ( tiPid == PID_CARDS_HAND ) )
			{
				CheckCardsHand( cr, targetItem );
				return true;
			}
			//Single gamble card action
			if( valid( targetItem ) && Cards.find( tiPid ) != -1 )
			{
				StartMenuCard( cr, targetItem );
				return true;
			}
			//General attempt at repair
			if( targetItem.IsDeteriorable() || targetItem.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
			{
				TryRepairItem( cr, targetItem );
				return true;
			}
			break; 
		}
		
		case( SK_SNEAK ): 
		{
			cr.Say( SAY_NETMSG, "|0xFF0000 Skill disabled." );
			return true; 
		}
		
		case( SK_STEAL ): 
		{
			if( cr.IsPlayer() && cr.Timeout[ TO_SK_STEAL ] > 0 )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
				return true;
			}
			
			if( valid( targetItem ) )
			{
				UseSkillOnLocker( cr, targetItem, SK_STEAL );
				return true;
			}
			
			if( valid( targetCr ) )
			{
				Item@ hands = _CritGetItemHand ( targetCr );
				if( HandsTied( targetCr ) )
				{
					CrimeLog( cr, crInfo( cr ) + " looks at inventory of: " + crInfo( targetCr ) + " who is tied up." );
				}
				else if( targetCr.IsDead() )
				{
					CrimeLog( cr, crInfo( cr ) + " look into inventory of dead: " + crInfo( targetCr ) + "." );
					cr.Action( ACTION_PICK_CRITTER, 0, null );
				}
				else
				{
					CrimeLog( cr, crInfo( cr ) + " checks inventory of: " + crInfo( targetCr ) + ".");
					cr.TimeoutBase[ TO_SK_STEAL ] = STEAL_TIMEOUT( cr );
					cr.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
					cr.StatBase[ ST_STEAL_COUNT ] = 0;
					
					if( !isGM( cr ) )
					{
						int InvCheckCalculation = ( cr.SkillBase[ SK_STEAL ] / 3 ) - ( ( targetCr.SkillBase[ SK_STEAL ] / 24 ) + targetCr.StatBase[ ST_LUCK ] + targetCr.StatBase[ ST_PERCEPTION ] );
						if( Random( 1, 100 ) < InvCheckCalculation )
						{
							CrimeLog( targetCr, crInfo( targetCr ) + " detected his inventory being checked!" );
							targetCr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_NOTIFICATION );
						}
					}
				}
				ShowContainer( cr, targetCr, TRANSFER_CRIT_STEAL );
				return true;
			}
			break;
		}
		
		case( SK_LOCKPICK ): 
		{
			if( onSelf || valid( targetCr ) )
			{
				if( onSelf )
				{
					@targetCr = cr;
				}
				
				Item@ gagItm = _CritGetItemHead( targetCr );
				if( valid( gagItm ) )
				{
					if( gagItm.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
					{
						TryRemoveGag( cr, targetCr, gagItm );
						return true;
					}
				}
			}
			break;
		}
		
		case( SK_TRAPS ): 
		{
			if( valid( targetItem ) )
			{
				uint16 pid = targetItem.GetProtoId();
				if( ( pid == PID_ACTIVE_DYNAMITE || pid == PID_ACTIVE_PLASTIC_EXPLOSIVE || pid == PID_ACTIVE_MINE ) )
				{
					OnUseExplode( cr, targetItem, null, null, null, 0 );
					return true;
				}
				
				if( targetItem.GetType() == ITEM_TYPE_CONTAINER )
				{
					StealContainerOrArmor( cr, targetCr, targetItem );
					return true;
				}
			}
			break; 
		}
		
		case( SK_SEX ):
		{
			cr.ParamBase[ CR_INIT_SEX ] = 0;
			if( valid( targetCr ) && !onSelf )
			{
				StartMenuSexPanel( cr, targetCr );
				return true;
			}
			break;
		}
		
		case( SK_HUNTING ):
		{
			cr.ParamBase[ CR_INIT_DEVOUR ] = 0;
			if( isDog )
			{
				if( valid( targetCr ) && targetCr.IsDead() && !onSelf )
				{
					start_devour( cr, targetCr );
					return true;
				}
			}
			break;
		}
		
		default:
		{
			break;
		}
	}
	return false;
}

void Say( Critter@ target, uint type, string text )
{
	if( valid( target ) )
	{
		target.Say( type, text );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo )
{
	ReloadWeapon( cr, weapon, ammo );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
void critter_init( Critter& cr, bool firstTime )
{
	if( firstTime )
    {
        if( cr.IsPlayer() )
        {
            GameVar@ TotalPlayers = GetGlobalVar( GVAR_total_players );
            if( TotalPlayers.GetValue() < int( cr.Id ) )
			{
                TotalPlayers.opAssign( cr.Id );
            }
			// Input: 7 special, 3 tag skills, 2 traits, age, gender
            uint traits = 0;
            for( uint i = TRAIT_BEGIN; i <= TRAIT_END; i++ )
            {
                if( cr.TraitBase[ i ] != 0 && traits < 2 )
                {
                    cr.TraitBase[ i ] = 1;
                    traits++;
                }
                else
				{
                    cr.TraitBase[ i ] = 0;
				}  
			}

            if( cr.StatBase[ ST_GENDER ] < 0 || cr.StatBase[ ST_GENDER ] > 1 )
			{
                cr.StatBase[ ST_GENDER ] = 0;
            }
			
			if( cr.StatBase[ ST_AGE ] < 14 || cr.StatBase[ ST_AGE ] > 80 )
			{
                cr.StatBase[ ST_AGE ] = 25;
            }
			
			for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
			{
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );
			}
			
            if( ( cr.StatBase[ ST_STRENGTH ] + cr.StatBase[ ST_PERCEPTION ] + cr.StatBase[ ST_ENDURANCE ] +
                  cr.StatBase[ ST_CHARISMA ] + cr.StatBase[ ST_INTELLECT ] + cr.StatBase[ ST_AGILITY ] + cr.StatBase[ ST_LUCK ] ) != __StartSpecialPoints )
            {
                for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
				{
                    cr.StatBase[ i ] = 5;
				}
			}

            cr.StatBase[ ST_EMP_RESIST ] = 500;
        }

        if( cr.TagSkill[ TAG_SKILL1 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL1 ] > int(SKILL_END) )
		{
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
		}
		
        if( cr.TagSkill[ TAG_SKILL2 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL2 ] > int(SKILL_END) )
		{
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
		}
		
        if( cr.TagSkill[ TAG_SKILL3 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL3 ] > int(SKILL_END) )
		{
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;
		}
		
        if( cr.TagSkill[ TAG_SKILL1 ] == cr.TagSkill[ TAG_SKILL2 ] )
		{
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
		}
		
        if( cr.TagSkill[ TAG_SKILL2 ] == cr.TagSkill[ TAG_SKILL3 ] )
		{
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
		}
		
        if( cr.TagSkill[ TAG_SKILL3 ] == cr.TagSkill[ TAG_SKILL1 ] )
		{
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;
		}

        CritterGenerate( cr );
        cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
        
        cr.StatBase[ ST_CURRENT_AP ] = cr.Stat[ ST_ACTION_POINTS ] * 100;

		cr.StatBase[ST_SPEECH_VOLUME] = 25;

        for( uint i = REPUTATION_BEGIN; i < = REPUTATION_END; i++ )
		{
			cr.ParamBase[i]=int( 0x80000000 ); 
		}
		
        if( cr.IsPlayer() )
        {
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
			{
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );
			}
			
            cr.StatBase[ ST_REPLICATION_COST ] = 100;
            cr.StatBase[ ST_REPLICATION_MONEY ] = 0;
            cr.StatBase[ ST_REPLICATION_COUNT ] = 0;
            cr.StatBase[ ST_TEAM_ID ] = 1;
            cr.StatBase[ ST_DAMAGE_TYPE ] = DAMAGE_NORMAL;

            skin( cr, cr.StatBase[ ST_BODY_TYPE ] );
            cr.StatBase[ ST_BODY_TYPE ] = 0;
		}
        else
        {
            cr.ChangeCrType( cr.StatBase[ ST_BASE_CRTYPE ] );
		}
    }
    else
    {
        // Current skin validation
        Item@ armor = _CritGetItemArmor( cr );
        if( cr.Stat[ ST_BASE_CRTYPE ] == 0 )
		{
            cr.StatBase[ ST_BASE_CRTYPE ] = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        }
		
		if( !valid( armor ) )
        {
            uint crType = cr.Stat[ ST_BASE_CRTYPE ];
            if( crType == 0 )
			{
                crType = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
            }
			
			cr.StatBase[ ST_BASE_CRTYPE ] = crType;
            if( cr.CrType != crType )
			{
                cr.ChangeCrType( crType );
			}
		}
        
        // Armor perk validation
        if( !valid( armor ) && cr.Stat[ ST_CURRENT_ARMOR_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_ARMOR_PERK ] )
            {
				case( ARMOR_PERK_POWERED ):
					cr.StatBase[ ST_STRENGTH_EXT ] -= 3;
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 30;
					break;
				case( ARMOR_PERK_COMBAT ):
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 20;
					break;
				case( ARMOR_PERK_ADVANCED_I ):
					cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 60;
					break;
				case( ARMOR_PERK_ADVANCED_II ):
					cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 75;
					break;
				case( ARMOR_PERK_CHARISMA ):
					cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					break;
				case( ARMOR_PERK_ANTIRAD ):
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 70;
					break;
				case( ARMOR_PERK_VERY_COOL ):
					cr.StatBase[ ST_CHARISMA_EXT ] -= 2;
					break;				
				default:
					break;
            }
            cr.StatBase[ ST_CURRENT_ARMOR_PERK ] = 0;
        }
        // Head Item Perk validation
		Item@ head_item = _CritGetItemHead( cr );
        if( !valid( head_item ) && cr.Stat[ ST_CURRENT_HEAD_ITEM_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_HEAD_ITEM_PERK ] )
            {
				case( HEAD_PERK_COOL ):
				{
					cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					break;
				}
				case( HEAD_PERK_GLASSES ):
				{
					if( cr.StatBase[ ST_PERCEPTION_EXT ] >= 2 )
					{
						cr.StatBase[ ST_PERCEPTION_EXT ] -= 2;
					}
					else if( cr.StatBase[ ST_PERCEPTION_EXT ] == 1 )
					{
						cr.StatBase[ ST_PERCEPTION_EXT ] -= 1;
					}
					break;
				}
				case( HEAD_PERK_VERY_COOL ):
				{
					cr.StatBase[ ST_CHARISMA_EXT ] -= 2;
					break;
				}
				case( HEAD_PERK_LUCKY_CHARM ):
				{
					cr.StatBase[ ST_LUCK_EXT ] -= 1;
					break;
				}
				case( HEAD_PERK_COOL_LUCKY_CHARM ):
				{
					cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					cr.StatBase[ ST_LUCK_EXT ] -= 1;
					break;
				}
				case( HEAD_PERK_COOL_GLASSES ):
				{
					if( cr.StatBase[ ST_PERCEPTION_EXT ] >= 2 )
					{
						cr.StatBase[ ST_PERCEPTION_EXT ] -= 2;
					}
					else if( cr.StatBase[ ST_PERCEPTION_EXT ] == 1 )
					{
						cr.StatBase[ ST_PERCEPTION_EXT ] -= 1;
					}
					cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					break;
				}
			}
            cr.StatBase[ ST_CURRENT_HEAD_ITEM_PERK ] = 0;
		}

        // Clear timeouts if too long (happens when saves got removed)
        for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
		{
            if( i != TO_BATTLE && cr.Timeout[ i ] > int( MAXIMUM_TIMEOUT ) )
			{
                cr.TimeoutBase[ i ] = __FullSecond;
			}
		}
        // Erase zero time events
        cr.EraseTimeEvents( 0 );
    }

	if( cr.IsPlayer() )
	{
		cr.ModeBase[ MODE_HIDE ] = 0;
		cr.StatBase[ ST_UNSPENT_PERKS ] = 0;
	}

	if( cr.Stat[ ST_BASE_CRTYPE ] == CRTYPE_GECKO_FIRE && _CritCountItem( cr, PID_FIRE_GECKO_FLAME_WEAPON ) == 0 )
	{
		cr.AddItem( PID_FIRE_GECKO_FLAME_WEAPON, 1 );
	}
	
	if( cr.Stat[ ST_BASE_CRTYPE ] == CRTYPE_PLANT && _CritCountItem( cr, PID_FIRE_GECKO_FLAME_WEAPON ) == 0 )
	{
		cr.AddItem( PID_PLANT_SPIKE, 15 );
	}
	
    ChangeCritterSpeed( cr );

    manager_critter_init( cr, firstTime );

    DllCritterInit( cr, firstTime );
	
	//FoRP - logout on global == dead
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		Location@ loc = GetLocationByPid( LOCATION_Deadloc, 0 );
		if( !valid( loc ) )
		{ 
			Log( "Location does not exist!" );
			return; 
		}
		Map@ map2 = loc.GetMapByIndex( 0 );
		if( !valid( map2 ) )
		{
			Log( "Map does not exist!" ); 
			return; 
		}
		cr.SetWorldPos( loc.WorldX, loc.WorldY );
		cr.TransitToMap( map2.Id, 170, 130, 6 );
	}
	
	if( cr.IsPlayer() )
	{
		if( cr.Param[ LAST_LOGIN_DATE ] > 0 && ( __FullSecond - cr.Param[ LAST_LOGIN_DATE ] >= int( 10 * ( __TimeMultiplier * 60 * 60 * 24 ) ) ) )
		{
			uint[] exceptions = { MAP_UTILITY_START, MAP_HEAVEN, MAP_HELL };
			Map@ map = cr.GetMap();
			if( exceptions.find( map.GetProtoId() ) == -1 )
			{
				kind_tele2( cr, null, 369 );
				cr.AddTimeEvent( "cte_message", REAL_SECOND( 10 ), 0, 0 );
			}
		}
		cr.ParamBase[ LAST_LOGIN_DATE ] = __FullSecond;
	}
}

uint cte_message( Critter& cr, int identifier, uint& rate )
{
	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_OFFLINE_TELEPORT );
	return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish( Critter& cr, bool toDelete )
{
	if( cr.IsPlayer() )
	{
		Map@ map = cr.GetMap();
		if( valid( map ) )
		{
			Item@ shadow = map.AddItem( cr.HexX, cr.HexY, PID_SHADOW, 1 );
			if( valid( shadow ) )
			{
				shadow.Val0 = cr.Id;
			}
		}
		uint year = 
		cr.ParamBase[ LAST_LOGIN_DATE ] = __FullSecond;
	}
    manager_critter_finish( cr, toDelete );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
void critter_idle( Critter& cr )
{
	CritterRegen( cr );
	
	ChangeCritterSpeed( cr );

    manager_critter_idle( cr );
}

void CritterRegen( Critter& cr )
{
	if( cr.IsDead() )
	{
		return;
	}
	
    if( cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT )
	{
		if( cr.Timeout[ TO_HEALING ] == 0 )
		{
			cr.TimeoutBase[ TO_HEALING ] = __FullSecond + REAL_MINUTE( cr.IsKnockout() ? 2 : 4 );
			if( cr.Mode[ MODE_NO_HEAL ] != 0 || cr.StatBase[ ST_CURRENT_HP ] == cr.Stat[ ST_MAX_LIFE ] )
			{
				return;
			}

			int regen = cr.Stat[ ST_HEALING_RATE ], penalty = 0;
			if( FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) )
			{ 
				penalty += 5;
			}
			
			if( FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
			{
				penalty += 5;
			}
			
			regen = CLAMP( regen * ( 10 - penalty ) / 10, 1, regen );
			_testInfo( cr, CR_TEST_MODE_HEALTH, SAY_NETMSG, "You regened " + regen + " HP." );
            cr.StatBase[ ST_CURRENT_HP ] += regen;

            if( cr.StatBase[ ST_CURRENT_HP ] > cr.Stat[ ST_MAX_LIFE ] )
			{
                cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
			}
			else
			{
				if( !cr.IsKnockout() )
				{
					cr.StatBase[ ST_HUNGER ] -= Random( 1, 1 + regen / 5 );
					cr.StatBase[ ST_THIRST ] -= Random( 1, 1 + regen / 5 );
				}
			}
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead( Critter& cr, Critter@ killer )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        Log( "Critter #" + cr.Id + " was killed on global." );
	}
	
    if( cr.IsNpc() )
	{
		cr.DropPlanes();
	}
	
    manager_critter_dead( cr, killer );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn( Critter& cr )
{
    cr.TimeoutBase[ TO_REPLICATION ] = 0;
    if( cr.CrType == 115 )
    {
        uint body = cr.Stat[ ST_BASE_CRTYPE ];
        if( body == 0 )
		{
            body = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        }
		cr.ChangeCrType( body );
    }
    else if( cr.CrType == 81 )
    {
        Item@ weapon = cr.AddItem( PID_FIREBREATH, 1 );
        cr.MoveItem( weapon.Id, 1, SLOT_HAND1 );
        weapon.Update();
    }
    else if( cr.CrType == 51 || cr.CrType == 60 || cr.CrType == 100 )
    {
        Item@ weapon = cr.AddItem( PID_CLAW_EXT, 1 );
        cr.MoveItem( weapon.Id, 1, SLOT_HAND1 );
        weapon.Update();
    }

    if( cr.Param[ ST_PARALYSIS_LEVEL ] != 0 )
	{
        DropParalysisInstant( cr );
	}
	
	if( cr.Param[ ST_POISONING_LEVEL ] != 0 )
	{
        DropPoison( cr );
	}
	
	if( cr.Param[ ST_RADIATION_LEVEL ] != 0 )
	{
        DropRadiation( cr );
	}
	
    if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
		{
            DeleteItem( block );
        }
		cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }

    manager_critter_respawn( cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
		int64 time = ServerTime;
		cr.RunClientScript( "fonline_tnf_client.dll@SetServerTime", time & 0xFFFFFFFF, (time >> 32 ) & 0xFFFFFFFF, 0, null, null );
        qmap_critter_in( map.Id, cr );

        uint16 locPid = map.GetLocation().GetProtoId();
        if( LocIsCity( locPid ) )
        {
            GameVar@ lastCityVar = GetLocalVar( LVAR_last_city, cr.Id );
            if( lastCityVar is null )
			{
                return;
            }
			lastCityVar = locPid;
        }
    }
    manager_map_critter_in( map, cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
	{
        qmap_critter_out( map.Id, cr );
		cr.RunClientScript( "fofmod@__StopAll", 0, 0, 0, null, null );
    }
    manager_map_critter_out( map, cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting( Critter& crFrom, Critter& crTo, bool valUp )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
bool check_trap_look( Map& map, Critter& cr, Item& trap )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( Item& item, Critter& cr, Critter& npc, bool sell )
{
	uint8  itemType = item.GetType();
    uint16 pid = item.GetProtoId();
    float   cost = item.Proto.Cost;

	if( cr.Param[ QST_GAMEMODE ] == GAME_TEST )
	{
		cr.Say( SAY_NETMSG, pid + ": " + cost + "$" );
	}
	
    if( pid == PID_BOTTLE_CAPS || pid == PID_REAL_BOTTLE_CAPS )
	{
        return 1;
	}
	
	if( pid == PID_DOLLAR_100 )
	{
		return 100;
	}
	
	if( pid == PID_DOLLAR_20 )
	{
		return 20;
	}
	
	if( pid == PID_DOLLAR_5 )
	{
		return 5;
	}
	
    if( itemType == ITEM_TYPE_ARMOR || itemType == ITEM_TYPE_WEAPON )
    {
        uint8 brokenCount = item.BrokenCount;
        uint8 brokenFlags = item.BrokenFlags;

        if( FLAG( brokenFlags, BI_NOTRESC ) || FLAG( brokenFlags, BI_BROKEN ) )
		{
            cost *= 0.01;
        }
		else if( FLAG( brokenFlags, BI_HIGHBROKEN ) )
		{
            cost /= 3;
        }
		else if( FLAG( brokenFlags, BI_NORMBROKEN ) )
		{
            cost /= 2;
		}
		else if( FLAG( brokenFlags, BI_LOWBROKEN ) )
		{
            cost /= 1.4;
		}
		else if( brokenCount > 0 )
		{
            cost *= brokenCount != 100 ? brokenCount * 0.01 : 0.01;
		}
		
        if( itemType == ITEM_TYPE_WEAPON && !item.IsStackable() )
        {	
			ProtoItem@ ammo = GetProtoItem( item.AmmoPid );
			if( valid( ammo ) )
			{
				cost += ammo.Cost * item.AmmoCount;
			}
		}
    }
	uint[] partial_pids = { PID_ITSOAP01_PRT, PID_FPSHL6_PRT, PID_CIGARETTES_PRT };
	if( partial_pids.find( pid ) != -1 )
	{
		cost = cost * item.Val0 / 10;
	}
	
	float skill_range = 150;
	
	float price_range = 0.25;

	float skill = CLAMP( cr.SkillBase[ SK_BARTER ] - npc.SkillBase[ SK_BARTER ], -skill_range, skill_range ) * ( 1.0 / skill_range );
	
	if( sell )
	{
		cost = cost * 0.4;
	}
	else
	{
		cost = cost * ( 0.75 - 0.25 * skill );
	}
    return CLAMP( floor( cost ), 1, cost );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter( Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc )
{
    if( npc.Mode[ MODE_BARTER_ONLY_CASH ] > 0 )
    {
		uint[][] money_tiers = 
		{	{}, // extra tier just in case
			{ PID_DOLLAR_100, PID_DOLLAR_20, PID_DOLLAR_5, PID_BOTTLE_CAPS, PID_GOLDEN_COIN },
			{ PID_REAL_BOTTLE_CAPS, PID_MORNING_STAR_MINE, PID_KOKOWEEF_MINE_SCRIP },
		};
		
        for( uint i = 0, j = saleItems.length(); i < j; i++ )
        {
			bool isOk = false;
            Item@ item = saleItems[ i ];
			uint pid = item.GetProtoId();
			if( !valid( item ) )
			{
				continue;
			}
			for( uint k = money_tiers.length() - 1; k > 0; k-- )
			{
				if( money_tiers[k].find( pid ) != -1 )
				{
					if( npc.Mode[ MODE_BARTER_ONLY_CASH ] < int( k ) )
					{
						npc.SayMsg( SAY_NORM_ON_HEAD, TEXTMSG_COMBAT, STR_NEED_BETTER_CASH );
						return false;
					}
					else
					{
						isOk = true;
					}
					break;
				}
			}
			if( !isOk )
			{
				player.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_NO_BARTER );
				return false;
			}
        }
    }
    GameVar@ loan = GetUnicumVar( UVAR_checkLoan, player.Id, npc.Id );
    if( loan == 1 )
    {
        return false;
    }

    ChangeCritterSpeed( player );
    ChangeCritterSpeed( npc );

    return true;
}


// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player craft some items.
// Resources have None accessory and will be deleted after this function if no will be added to some place.
void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter )
{
    ChangeCritterSpeed( crafter );
    int maxDeterioration = 0;
    for( uint i = 0, j = resources.length(); i < j; i++ )
    {
        Item@ item = resources[ i ];
        int   deterioration = GetDeteriorationProcent( item );
        if( deterioration > maxDeterioration )
		{
            maxDeterioration = deterioration;
		}
		
		if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
		{
			uint ammoCount = item.AmmoCount;
			if( ammoCount > 0 )
			{
				Item@ ammo = crafter.AddItem( item.AmmoPid, ammoCount );
				crafter.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_AMMO_EJECTED, "$proto@msg item " + ( ammo.Proto.ProtoId * 100 + 2 ) + "@$count" + ammoCount );
				item.AmmoCount = 0;
				item.Update();
			}
		}
    }

	crafter.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED );
    for( uint i = 0, j = items.length(); i < j; i++ )
    {
        // Unload weapons
        Item@ item = items[ i ];
        if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
        {
            item.AmmoCount = 0;
            item.Update();
        }
        SetDeterioration( item, maxDeterioration );
		crafter.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED_PID, "$proto@msg item " + ( item.Proto.ProtoId * 100 ) + "@" );
	}

    uint16 itemZeroPid = items[ 0 ].GetProtoId();

    switch( itemZeroPid )
    {
		case( PID_LOCKER_LOW ):
		case( PID_LOCKER_MED ):
		case( PID_LOCKER_HARD ):
			items[ 0 ].Val0 = 250 + ABS( ( crafter.SkillBase[ SK_REPAIR ] / 3 ) + ( crafter.SkillBase[ SK_LOCKPICK ] / 2 ) );
			break;
		case( PID_GUNSMITH ):
			items[ 0 ].Val0=crafter.SkillBase [SK_REPAIR];
			break;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.
void player_levelup( Critter& player, uint skillIndex, uint skillUp, uint perkIndex )
{
	if( isDisabledSkill( skillIndex ) )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_DISABLED );
		return;
	}
	
	if( isFarmingSkill( skillIndex ) )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_RAISED_BY_USE );
		return;
	}
	
    if( skillIndex >= SKILL_BEGIN && skillIndex <= SKILL_END )
    {
        for( ; skillUp != 0; skillUp-- )
        {
            int skillVal = player.SkillBase[ skillIndex ];
            if( skillVal >= MAX_SKILL_VAL )
			{
                break;
			}
			
            int needPoints = 1;
            if( skillVal > __SkillModAdd6 )
			{
                needPoints = 6;
            }
			else if( skillVal > __SkillModAdd5 )
			{
                needPoints = 5;
            }
			else if( skillVal > __SkillModAdd4 )
			{
                needPoints = 4;
            }
			else if( skillVal > __SkillModAdd3 )
			{
                needPoints = 3;
            }
			else if( skillVal > __SkillModAdd2 )
			{
                needPoints = 2;
			}
			
            if( player.StatBase[ ST_UNSPENT_SKILL_POINTS ] < needPoints )
			{
                break;
			}
			
            skillVal++;
            if( _CritIsTagSkill( player, skillIndex ) && skillVal < MAX_SKILL_VAL )
			{
				skillVal++;
            }
			player.SkillBase[ skillIndex ] = skillVal;
            player.StatBase[ ST_UNSPENT_SKILL_POINTS ] -= needPoints;
        }
    }
    else if( perkIndex >= PERK_BEGIN && perkIndex <= PERK_END )
    {
        if( PerkCheck( player, perkIndex ) )
        {
            player.PerkBase[ perkIndex ]++;
            player.StatBase[ ST_UNSPENT_PERKS ]--;
        }
    }

    player.StatBase[ ST_REPLICATION_COST ] = player.Stat[ ST_LEVEL ] * 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based
void turn_based_begin( Map& map )
{
    // Try end battle
    if( map.TurnBasedRound > 0 )
    {
        uint[] crittersIds;
        map.GetTurnBasedSequence( crittersIds );

        bool continueBattle = false;
        if( crittersIds.length() >= 2 )
        {
            for( uint i = 0, j = crittersIds.length(); i < j; i++ )
            {
                Critter@ cr = ::GetCritter( crittersIds[ i ] );
                if( !( not valid( cr ) || cr.IsDead() ||
                       ( cr.IsNpc() && cr.GetPlanes( AI_PLANE_ATTACK, null ) == 0 ) ||
                       ( cr.IsPlayer() && ( cr.Mode[ MODE_END_COMBAT ] != 0 || cr.Stat[ ST_CURRENT_HP ] < 1 ) ) ) )
                {
                    continueBattle = true;
                    break;
                }
            }
        }

        if( not continueBattle )
		{
            map.EndTurnBased();
		}
	}
}

// Call on end turn-based battle
void turn_based_end( Map& map )
{
    //
}

// Call on every begin and end turn
void turn_based_process( Map& map, Critter& cr, bool beginTurn )
{
    if( beginTurn )
    {
        cr.StatBase[ ST_MOVE_AP ] = cr.Stat[ ST_MAX_MOVE_AP ];
        cr.StatBase[ ST_TURN_BASED_AC ] = 0;
    }
    else
    {
        bool hthEvade = false;
        cr.StatBase[ ST_TURN_BASED_AC ] = cr.Stat[ ST_CURRENT_AP ] * ( hthEvade ? 2 : 1 );
        if( cr.Stat[ ST_TURN_BASED_AC ] < 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] = 0;
        if( hthEvade && cr.Skill[ SK_UNARMED ] > 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] += cr.Skill[ SK_UNARMED ] / 12;
        cr.StatBase[ ST_MOVE_AP ] = 0;
    }
}

// Call when need generate turns sequence
void turn_based_sequence( Map& map, Critter@[]& critters, Critter@ firstTurnCrit )
{
    // Check first turn critter
    if( valid( firstTurnCrit ) && ( firstTurnCrit.IsDead() || firstTurnCrit.Stat[ ST_CURRENT_AP ] <= 0 ) )
        @firstTurnCrit = null;

    // Collect critters
    SequenceCritter[] sequenceCritters;
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ cr = critters[ i ];
        if( valid( firstTurnCrit ) && firstTurnCrit.Id == cr.Id )
            continue;
        if( cr.IsDead() )
            continue;
        sequenceCritters.resize( sequenceCritters.length() + 1 );
        @sequenceCritters.last().critter = cr;
    }

    // Sort sequence, see SequenceCritter::opCmp below
    SequenceCritterRandom = Random( 0, 1 );
    sequenceCritters.sortDesc();

    // Fill result
    critters.resize( 0 );
    if( valid( firstTurnCrit ) )
        critters.insertLast( firstTurnCrit );
    for( uint i = 0, j = sequenceCritters.length(); i < j; i++ )
        critters.insertLast( sequenceCritters[ i ].critter );
}

// Sequence sorter for turn_based_sequence
int   SequenceCritterRandom = 0;
class SequenceCritter
{
    Critter@ critter;
    int opCmp( SequenceCritter& in other )
    {
        bool result;
        Critter@ cr1 = critter;
        Critter@ cr2 = other.critter;
        int seq1 = cr1.Stat[ ST_SEQUENCE ];
        int seq2 = cr2.Stat[ ST_SEQUENCE ];
        if( seq1 == seq2 )
        {
            int ag1 = cr1.Stat[ ST_AGILITY ];
            int ag2 = cr2.Stat[ ST_AGILITY ];
            if( ag1 == ag2 )
            {
                int lk1 = cr1.Stat[ ST_LUCK ];
                int lk2 = cr2.Stat[ ST_LUCK ];
                if( lk1 == lk2 )
                {
                    if( SequenceCritterRandom == 0 )
					{
                        result = cr1.Id > cr2.Id;
                    }
					else
					{
                        result = cr1.Id < cr2.Id;
					}
				}
                else
				{
                    result = lk1 > lk2;
				}
			}
            else
			{
                result = ag1 > ag2;
			}
		}
        else
		{
            result = seq1 > seq2;
        }
		return result ? int(1) : int(-1);
    }
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save( uint currentIndex, uint[]& deleteIndexes )
{
    // Keep only current and four last saves
    if( currentIndex == 1 )
    {
        deleteIndexes.resize( 5 );
        for( uint i = 0; i < 5; i++ )
		{
            deleteIndexes[ i ] = 9999 - i;
		}
	}
	
    else if( currentIndex > 4 )
    {
        deleteIndexes.resize( 1 );
        deleteIndexes[ 0 ] = currentIndex - 5;
    }

	if( !SaveWorldNextVersion() )
	{
		Log( "World save in memory is not actual." );
	}
	
    qmap_save_all();

    manager_world_save();
}

uint8 NpcCount( Critter@[]& group )
{
    uint8 x = 0;
    for( uint i = 0, len = group.length(); i < len; i++ )
    {
        if( group[ i ] is null or group[ i ].IsPlayer() )
            continue;
        x++;
    }
    return x;
}
// Call on player try register
// Return true to allow, false to disallow
bool player_registration( uint ip, string& name, uint& textMsg, uint& strNum )
{
    return manager_player_registration( ip, name, textMsg, strNum );
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum )
{
    if( !manager_player_login( ip, name, id, textMsg, strNum ) )
	{
        return false;
	}
	
    if ( !DllPlayerLogin( ip, name, id ) )
	{
        return false;
	}
	
    Critter@ cr = GetCritter( id );

    if( !(cr is null) )
    {
        cr.ParamBase[ ST_QMAP ] = 0;
        CreateTimeEvent( __FullSecond + REAL_MS( 100 ), "e_player_after_login", id, false );
    }

    return true;
}

uint e_player_after_login( uint[] @ values )
{
    if( (values is null) || values.length() < 1 )
    {
        Log( "there isn't id in values" );
        return 0;
    }

    uint id = values[ 0 ];

    Critter@ cr = GetCritter( id );

    if( cr is null )
    {
        Log( "can't get player " + id );
        return 0;
    }

    DllPlayerAfterLogin(cr);

    Map@ map = cr.GetMap();

    if( !(map is null) && uint( cr.Param[ ST_QMAP ] ) == 0 )
    {
        qmap_critter_in( map.Id, cr );
    }

    return 0;
}

void SetStartCrTimeEvent( Critter& cr, string func, uint time, int identifier, uint rate )
{
    if( cr.GetTimeEvents( identifier, null, null, null ) > 0 )
    {
        cr.Say( SAY_NETMSG, "erase" );
        cr.EraseTimeEvents( identifier );
    }

    cr.AddTimeEvent( func, time, identifier, rate );

}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess( Critter& player, int access, string& password )
{
    Log( "Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + "." );
    player.StatBase[ ST_ACCESS_LEVEL ] = access;
    return true;
}

bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command )
{
    if( valid( adminPanel ) )
	{
        return true;
	}
	
    switch( command )
    {
		// ACCESS_CLIENT
		case COMMAND_CHANGE_PASSWORD:
		case COMMAND_DELETE_ACCOUNT:
		case COMMAND_EXIT:
		case COMMAND_GETACCESS:
		case COMMAND_MYINFO:
			return true;
		// ACCESS_TESTER
		case COMMAND_DROP_UID:
		case COMMAND_PARAM:
		case COMMAND_TOGLOBAL:
		{
			if( player.GetAccess() >= ACCESS_TESTER )
			{
				return true;
			}
			break;
		}
		// ACCESS_MODER
		case COMMAND_ADDITEM:
		case COMMAND_ADDITEM_SELF:
		case COMMAND_ADDLOCATION:
		case COMMAND_ADDNPC:
		case COMMAND_BAN:
		case COMMAND_CHECKVAR:
		case COMMAND_CRITID:
		case COMMAND_DISCONCRIT:
		case COMMAND_GAMEINFO:
		case COMMAND_KILLCRIT:
		case COMMAND_MOVECRIT:
		case COMMAND_RESPAWN:
		case COMMAND_SETVAR:
		{
			if( isGM( player ) )
			{
				return true;
			}
			break;
		}
		// ACCESS_ADMIN
		case COMMAND_LOADDIALOG:
		case COMMAND_LOADLOCATION:
		case COMMAND_LOADMAP:
		case COMMAND_LOADSCRIPT:
		case COMMAND_LOG:
		case COMMAND_RELOAD_CLIENT_SCRIPTS:
		case COMMAND_RELOADAI:
		case COMMAND_RELOADDIALOGS:
		case COMMAND_RELOADLOCATIONS:
		case COMMAND_RELOADMAPS:
		case COMMAND_RELOADSCRIPTS:
		case COMMAND_RELOADTEXTS:
		case COMMAND_REGENMAP:
		case COMMAND_RUNSCRIPT:
		case COMMAND_SETTIME:
		{
			if( player.GetAccess() == ACCESS_ADMIN )
			{
				return true;
			}
			break;
		}
		// Unknown command
		default:
			player.Say( SAY_NETMSG, "Unknown command." );
			return false;
    }

    player.Say( SAY_NETMSG, "Access denied." );
    return false;
}

// inputbox
void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags )
{
    cr.RunClientScript( "client_screen_inputbox@ShowInputBox", int(textLength), int(flags), 0, funcName, null );
}

// ~desc GM info
void unsafe_ShowFullPopupInfo( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
    Map@ map = player.GetMap();
	if( !valid( map ) ) { 
		return;
	}
	
	Item@ target = map.GetItem(param0);
	if( !valid( target ) ) {
		return;
	}
	
	int id = target.Val0;
	player.Say( SAY_NETMSG, param3 + " [" + ( id != 0 ? checkNull( GetPlayerName(id), "[deleted]" ) + ", id " + id : "ZERO ERROR" ) + "]"  );
	if( target.Val1 == 1 ) {
		map.SetText( player.HexX, player.HexY, COLOR_RGB(0xFF,0x00,0xFF), param3 );
	}
}

// ~desc info
void unsafe_ShowPopup( Critter& player, int itemID, int param1, int param2, string@ text, int[] @ param4 )
{
    Map@ map = player.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	Item@ target = map.GetItem( itemID );
	if( !valid( target ) )
	{
		return;
	}
	if( GetDistantion( target.HexX, target.HexY, player.HexX, player.HexY ) > 0 )
	{ 
		DeleteItem( target );
		return;
	}
	if( target.Val1 == 1 )
	{
		map.SetText( player.HexX, player.HexY, COLOR_RGB(0xFF,0x00,0xFF), text );
	}
	else
	{		
		player.Say( SAY_NETMSG, text );
	}
}

////////////////////////////////////////

void unsafe_swap_invis( Critter& cr, int, int, int, string@, int[]@ )
{
    if( !isGM( cr ) )
	{
		if( !cr.IsBusy() && !cr.IsDead() && cr.StatBase[ST_CURRENT_HP] > 0 )
		{
			cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			cr.Wait( 1500 );
		}
		return;
	}
		
	cr.ParamBase[ QST_INVIS ] = CLAMP( 1 - cr.ParamBase[ QST_INVIS ], 0, 1 );
	cr.RefreshVisible();
	cr.Say( SAY_NETMSG, "|0xFFFFFF GM stealth mode " + ( cr.ParamBase[ QST_INVIS ] == 1 ? "en" : "dis" ) + "abled." );
}

void unsafe_set_aim( Critter& cr, int aim, int, int, string@, int[]@ )
{
   cr.ParamBase[CR_AUTO_AIM] = aim;
}

bool canPutItemInContainer( Item@ item, Item@ container )
{
	if( !valid( item ) || !valid( container ) )
	{
		return false;
	}
	
	uint container_pid = container.GetProtoId();
	uint pid = item.GetProtoId();
	uint type = item.GetType();
	
	
	uint[] proper_paper_containment_pids =
	{
		PID_HOLODISK, PID_MORNING_STAR_MINE, PID_KOKOWEEF_MINE_SCRIP, PID_GOLDEN_COIN, PID_GOLDEN_JEWELRY, PID_BLUE_PASS_KEY, PID_DOG_TAGS,
		PID_BOTTLE_CAPS, PID_REAL_BOTTLE_CAPS, PID_TANKER_PASS, PID_TALISMAN, PID_DOLLAR_100, PID_DOLLAR_20, PID_DOLLAR_5, PID_RPSTUFF2, PID_RPSTUFF4, PID_PICTURE
	};
	
	uint[] paper_container_pids =
	{
		PID_HANDWRITINGS, PID_PORTMONE, PID_CRAFT_RECIPES, PID_PASSPORT, PID_LETTER, PID_POSTMAN_LETTER, PID_PAPERS_JAMMED,
		PID_ELRON_FIELD_REP, PID_CLIPBOARD, PID_FLIST08, PID_FLIST09, PID_StrpBlt, PID_mgzn01
	};
	
	if( ( proper_paper_containment_pids.find(pid) == -1 && type != ITEM_TYPE_KEY ) && paper_container_pids.find( container_pid ) != -1 )
	{
		return false;
	}
	
	uint[] key_container_pids = 
	{
		PID_KEY_BUNCH
	};
	
	if( type != ITEM_TYPE_KEY && key_container_pids.find( container_pid ) != -1 )
	{
		return false;
	}
	
	if( pid == container_pid )
	{
		return false;
	}

	if( type == ITEM_TYPE_CONTAINER )
	{
		if( !FLAG( container.Flags, ITEM_CAN_PICKUP ) )
		{
			return true; 
		}
		
		if( paper_container_pids.find(container_pid) != -1 || key_container_pids.find(container_pid) != -1 )
		{
			return false;
		}
		
		if( paper_container_pids.find( pid ) != -1 || key_container_pids.find( pid ) != -1 )
		{
			return true;
		}
		
		int item_size = -1, container_size = -1;
		
		uint[][] size_table = 
		{
			{ //Large containers:
				PID_BACKPACK,
				PID_STUFF_SUPPLIES,
			},
			{ //Medium containers".
				PID_SUPER_TOOL_KIT,
				PID_repkit3i,
				PID_repkit2i,
				PID_repkit1i,
				PID_FIRST_AID_KIT,
				PID_FIELD_MEDIC_KIT,
				PID_DOCTORS_BAG,
				PID_PARAMEDICS_BAG,
				PID_BRIEFCASE,
				PID_KEIS,
			},
			{ //small containers:
				PID_AMMO_BELT,
				PID_BAG,
				PID_BOX_OF_CIGARS,
				PID_CIGAR_CASE,
			},
			{ // tiny containers
				PID_CARDS_DECK, 
				PID_CARDS_HAND,
			}
		};

		for( uint i = 0, maxSize = size_table.length(); i < maxSize; i++ )
		{
			for( uint j = 0, len = size_table[i].length(); j < len; j++ )
			{
				if( size_table[i][j] == pid )
				{
					item_size = i;
				}
				
				if( size_table[i][j] == container_pid )
				{
					container_size = i;
				}
			}
		}
		
		if( item_size <= container_size )
		{
			return false;
		}
	}
	return true;
}

bool map_init( Map& map, bool isfirst )
{
	map.ProccessSleep = Random( 10, 30 );
	return true;
}

uint e_DelayedRemoval( uint[]@ values )
{
	if( !valid( values ) || values.length() != 2 )
	{
		return 0;
	}
	
	Item@ target = GetItem( values[0] );
	if( valid( target ) )
	{
		DeleteItem( target );
	}
	
	Critter@ cr = GetCritter( values[1] );
	if( valid( cr ) )
	{
		cr.ShowScreen( SCREEN_CLOSE, 0, "" );
	}
	return 0;
}

void unsafe_ItemsWeight( Critter& player, int itemId, int param1, int param2, string@ param3, int[]@ param4 )
{
	Item@ item = GetItem( itemId );
	
	if( !valid( item ) )
	{
		return;
	}
	if( item.GetType() != ITEM_TYPE_CONTAINER )
	{
		return;
	}

    Item@[] list;
	item.GetItems( 0, list );

	for( uint i = 0; i < list.length(); i++ )
	{
		if( list[i].GetType() == ITEM_TYPE_CONTAINER )
		{
			Item@[] sublist;
			list[i].GetItems( 0, sublist );

			for( uint j = 0, jmax = sublist.length(); j < jmax; j++ )
			{
				list.insertLast( sublist[j] );
			}
		}
	}
	
    uint result = 0;
	for( uint i = 0, imax = list.length(); i < imax; i++ )
	{
		if( valid( list[i] ) )
		{
			result += list[i].GetCount() * list[i].Proto.Weight;
			
			if( list[i].Proto.Type == ITEM_TYPE_FLASK )
			{
				result += list[i].Val2;
			}
			
			if( glass_bottles[2].find( list[i].GetProtoId() ) != -1 )
			{
                result += ( list[i].Proto.Weight - ( list[i].Proto.Partial_Item * 100 - list[i].EXTRA_WEIGHT ) );
			}
		}
    }
	
    player.RunClientScript( "client_main@SetItemWeight", itemId, result, 0, null, null );
}

uint e_UpdateContainer( uint[]@ val )
{
	Item@ container = GetItem( val[0] );
	container.Update();
	
	return 0;
}

bool critter_grid_transfer( Critter& cr, Scenery& scen )
{
	ProtoItem@ gridProto = GetProtoItem( scen.ProtoId );
	if( cr.Stat[ ST_BODY_TYPE ] == BT_DOG && gridProto.Grid_Type == GRID_LADDERTOP )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
		return false;
	}
	
	Map@ map = cr.GetMap();
	if( BlockerCheck( cr, map, scen ) )
	{
		return false;
	}
	
	Location@ loc = map.GetLocation();
	Map@ toMap = loc.GetMap( scen.ToMapPid );
	int entireId = scen.ToEntire;
	if( BlockerCheck( cr, toMap, entireId ) )
	{
		return false;
	}
	
	return true;
}
#endif //__MAIN_MODULE__