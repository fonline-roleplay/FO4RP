#ifndef __MAIN_MODULE__
#define __MAIN_MODULE__

#include "_utils.fos"
#include "_global_events.fos"
#include "_ltp.fos"

#include "autodoc_h.fos"
#include "bootlegging_h.fos"
#include "casino_h.fos"
#include "combat_h.fos"
#include "cooking_h.fos"
#include "critter_item_movement_h.fos"
#include "defib_h.fos"
#include "drugs_h.fos"
#include "effects_h.fos"
#include "explode_h.fos"
#include "firestarter_h.fos"
#include "fish_h.fos"
#include "flask_h.fos"
#include "food_h.fos"
#include "furnace_h.fos"
#include "furniture_h.fos"
#include "gateway_h.fos"
#include "gathering_h.fos"
#include "geiger_h.fos"
#include "globalmap_group_h.fos"
#include "handcuffs_h.fos"
#include "heal_h.fos"
#include "homebrew_h.fos"
#include "item_h.fos"
#include "lockers_h.fos"
#include "map_lights_h.fos"
#include "npc_names_holder_h.fos"
#include "npc_planes_h.fos"
#include "paralysis_h.fos"
#include "parameters_h.fos"
#include "perks_h.fos"
#include "plants_h.fos"
#include "poison_h.fos"
#include "radiation_h.fos"
#include "recorder_h.fos"
#include "radio_h.fos"
#include "reload_h.fos"
#include "repair_h.fos"
#include "robot_repair_h.fos"
#include "sandbag_h.fos"
#include "scenery_h.fos"
#include "sex_h.fos"
#include "smithing_h.fos"
#include "smoking_h.fos"
#include "speed_h.fos"
#include "teams_table.fos"
#include "terminal_h.fos"
#include "time_h.fos"
#include "trap_h.fos"
#include "vending_h.fos"
#include "waterworks_h.fos"
#include "wait_time_h.fos"
#include "wildplant_h.fos"

// Imports
import void InitializeGame() from "config";

import void WorldmapInit() from "worldmap";

import void skin( Critter& cr, int crType ) from "skins";

import void TeleportToGameZone( Critter& master, int val ) from "map_start";

import void qmap_critter_in( uint mapId, Critter& cr ) from "qmap";
import void qmap_critter_out( uint mapId, Critter& cr ) from "qmap";
import void qmap_save_all() from "qmap";
import void qmap_load_all() from "qmap";

import bool UseShovel( Critter& cr, Item& item ) from "qmap_farm";

import NpcNamesHolder@ getNpcNamesHolder() from "npc_names_holder";

import void hotkey_critter_anim( Critter& cr, int param0 ) from "general_unsafe";

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitializeGame();
	InitSpeedArray();
}

uint16 GetVersionWorldSave( ::string@ time )
{
    ::array< uint > data;
    if( IsAnyData( "VersionWorldSave" ) && ::GetAnyData( "VersionWorldSave", data ) )
    {
        if( valid( time ) )
		{
            time = "" + data[ 1 ] + "_" + data[ 2 ] + "_" + data[ 3 ] + "_" + data[ 4 ] + "_" + data[ 5 ];
        }
		return data[ 0 ] % 9999;
    }
    return 0;
}

bool SaveWorldNextVersion()
{
    uint16 Year = 0, Month = 0, Day = 0, Hour = 0, Minute = 0, var = 0;
    GetTime( Year, Month, Day, var, Hour, Minute, var, var );
    ::array< uint > data = { GetVersionWorldSave( null ) + 1, Year, Month, Day, var, Hour, Minute };
	file version;
	if( version.open( "WorldVersion","w") != -1 )
	{
		version.writeString( "" + data[0] );
		version.close();
	}
    return ::SetAnyData( "VersionWorldSave", data );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Send info about others critters
    // Remember:
    // - all this info can be hacked in client;
    // - more parameters - more traffic.
    SetSendParameter( ST_GENDER, true );
    SetSendParameter( ST_AGE, true );
    SetSendParameter( ST_FOLLOW_CRIT, true );
	SetSendParameter( PET_OWNER_ID, true );
	SetSendParameter( PET_PROTECT_ID, true );
    //SetSendParameter( ST_PLAYER_KARMA, true );
    // Armor class, uses Agility
    SetSendParameter( ST_ARMOR_CLASS, true );
    // Agility
    SetSendParameter( ST_AGILITY, true );
    // Hit points, uses Strenght and Endurance
    SetSendParameter( ST_MAX_LIFE, true );
	SetSendParameter( ST_MAX_LIFE_EXT, true );
    SetSendParameter( ST_CURRENT_HP, true );
    // Strenght, uses battle timeout
    SetSendParameter( ST_STRENGTH, true );
    // Endurance
    SetSendParameter( ST_ENDURANCE, true );
    // Charisma
    SetSendParameter( ST_CHARISMA, true );
	SetSendParameter( ST_CHARISMA_EXT, true );
	// Skills
	SetSendParameter( SK_UNARMED, true );
    // Player Flags
    SetSendParameter( PLAYER_FLAGS, true );
    // Injures
    SetSendParameter( DAMAGE_EYE, true );
    SetSendParameter( DAMAGE_RIGHT_ARM, true );
    SetSendParameter( DAMAGE_LEFT_ARM, true );
    SetSendParameter( DAMAGE_RIGHT_LEG, true );
    SetSendParameter( DAMAGE_LEFT_LEG, true );
    // Item slots, passed with -
    SetSendParameter( -SLOT_HAND1, true );
	SetSendParameter( -SLOT_HAND2, true );
    SetSendParameter( -SLOT_ARMOR, true );
	SetSendParameter( -SLOT_MISC, true );
	SetSendParameter( -SLOT_HEAD, true );
	SetSendParameter( -SLOT_BACK, true );
    // Some flags for correct client working
    SetSendParameter( MODE_NO_BARTER, true );
    SetSendParameter( MODE_NO_STEAL, true );
    SetSendParameter( MODE_NO_LOOT, true );
    SetSendParameter( MODE_NO_FLATTEN, true );
    SetSendParameter( MODE_NO_TALK, true );
	SetSendParameter( MODE_QUESTGIVER, true );
	// Cover state
	SetSendParameter( CR_IS_RELAXING, true );
	SetSendParameter( CR_IN_COVER, true );
    // Npc talk distance
    SetSendParameter( ST_TALK_DISTANCE, true );
    // Dialog id
    SetSendParameter( ST_DIALOG_ID, true );
    // To see pid of unarmed attack
    SetSendParameter( ST_HANDS_ITEM_AND_MODE, true );
    // Scale factor
    //SetSendParameter( ST_SCALE_FACTOR, true );
    // Walk / Run speed
    SetSendParameter( ST_WALK_TIME, true );
    SetSendParameter( ST_RUN_TIME, true );

    SetSendParameter( SK_BARTER, true );

    SetSendParameter( ST_BODY_TYPE, true );
	SetSendParameter( ST_FACTION, true );
	SetSendParameter( ST_TEAM_ID, true );

	SetSendParameter( ST_AVATAR_INDEX, true );
	SetSendParameter( AVA_HASH_0, true );
	SetSendParameter( AVA_HASH_1, true );
	SetSendParameter( AVA_HASH_2, true );

    SetSendParameter( QST_MEDIUM, true );
    SetSendParameter( QST_GAMEMODE, true );
	SetSendParameter( QST_INVIS, true );

	SetSendParameter( TRAIT_SURE_FOOTED, true );
	SetSendParameter( TRAIT_BLOODY_MESS, true );

	SetSendParameter( CR_IS_AGGRESSIVE, true );
	SetSendParameter( CR_DIRTINESS, true );
	SetSendParameter( CR_TYPING_TIME, true );
	SetSendParameter( CR_AFK_MODE, true );
    SetSendParameter( CR_SINF_MODE, true );
	SetSendParameter( CR_CONTROLLED_GROUP, true );
	SetSendParameter( CR_REMEMBERING_NAME, true );
	SetSendParameter( CR_TALKING_TARGET_ID, true );

	SetSendParameter( MERC_MASTER_ID, true );

    // Send item data masks
    // Look fields in fonline.h 'struct Item::ItemData'
    //               SortValue  Info Indicator    PicMapHash       PicInvHash   AnimWaitBase AStay[2] AShow[2] AHide[2]      Flags      Rate LightDist Inten Flags  LightColor    ScriptId TrapValue       Count             Cost                ScriptValues[10]                                                                                                   										Other 36 bytes
    // ITEM_DATA_MASK_CHOSEN                                                                                           ITEM_DATA_MASK_CHOSEN                                                                                                ITEM_DATA_MASK_CHOSEN
    int8[] mask0 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CRITTER                                                                                          ITEM_DATA_MASK_CRITTER                                                                                               ITEM_DATA_MASK_CRITTER
    int8[] mask1 = {   0,  0,     -1,    0,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0 };
    // ITEM_DATA_MASK_CRITTER_EXT                                                                                      ITEM_DATA_MASK_CRITTER_EXT                                                                                           ITEM_DATA_MASK_CRITTER_EXT
    int8[] mask2 = {   0,  0,     -1,   -1,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CONTAINER                                                                                        ITEM_DATA_MASK_CONTAINER                                                                                             ITEM_DATA_MASK_CONTAINER
    int8[] mask3 = {  -1, -1,     -1,   -1,      0,  0,  0,  0,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_MAP                                                                                              ITEM_DATA_MASK_MAP                                                                                                   ITEM_DATA_MASK_MAP
    int8[] mask4 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,   0,  0,  0,  0,   -1, -1,  -1, -1,  -1, -1,  -1, -1,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    SetItemDataMask( ITEM_DATA_MASK_CHOSEN, mask0 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER, mask1 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER_EXT, mask2 );
    SetItemDataMask( ITEM_DATA_MASK_CONTAINER, mask3 );
    SetItemDataMask( ITEM_DATA_MASK_MAP, mask4 );

    // call all functions added by _starter/START/AddStartCallback
    CallStartCallbacks();

    // old stuff
    qmap_load_all();
    WorldmapInit();

	// Inits

	SetGvar(GVAR_is_first_time, 0);

	GetVersionWorldSave( null );


    // Global Event Manager
    if( !manager_start() )
	{
        return false;
	}

	getNpcNamesHolder().loadNpcNames();

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59

void get_start_time( uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute )
{
    multiplier = 4;
    year = 2248;
    month = 5;
    day = 14;
    hour = 1;
    minute = 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
/*
uint loop() // moved to loop.fos
{
    return manager_loop();
}
*/
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo )
{
	//cr.Say( SAY_NETMSG, "cr.Stat[ ST_CURRENT_AP ] " + cr.Stat[ ST_CURRENT_AP ] );
	if( !cr.IsLife() )
	{
		return;
	}

	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}

	if( !valid( target ) || target.IsDead() )
	{
		return;
	}

	if( cr.Param[ CR_IS_RELAXING ] != 5 )
	{
		cr.ParamBase[ CR_IS_RELAXING ] = 0;
	}

	if( !valid( weapon ) )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_FIGHT );
		return;
	}

	int weaponPerk = weapon.Weapon_Perk;
	int sneak_timeout = SNEAK_TIMEOUT( cr );
	if( FLAG( weaponPerk, WEAPON_PERK_SILENT ) )
	{
		sneak_timeout /= 2;
	}

	cr.ParamBase[ CR_SNEAKING ] = 0;
	cr.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( cr );

	cr.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( cr );
	cr.ParamBase[ CR_SNEAKING ] = 0;
	cr.ParamBase[ CR_IS_RELOADING ] = 0;

	uint8 mode = weaponMode;

	int needAp = attack_ap( cr, weapon, mode );
	//cr.Say( SAY_NORM, "cr.Stat[ ST_CURRENT_AP ] " + cr.Stat[ ST_CURRENT_AP ] + " needAp " + needAp );
	if( ( needAp == 0 || cr.Stat[ ST_CURRENT_AP ] < needAp ) && cr.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 )
	{
		//Log( "needAp " + needAp + " cr.Stat[ ST_CURRENT_AP ] " + cr.Stat[ ST_CURRENT_AP ] + " cr.Param[ CR_AUTO_ROUNDS_FIRED ] " + cr.Param[ CR_AUTO_ROUNDS_FIRED ] );
		return;
	}

	uint windupTime = GetProtoWindupTime( weapon, mode, cr );
	if( cr.Param[ CR_AUTO_AIM ] == HIT_LOCATION_NONE )
	{
		windupTime /= 2;
	}
	
	uint waitTime = _GetProtoWaitTime( weapon, mode );
	//Log( "windupTime " + windupTime + " waitTime " + waitTime  );
	uint[] values = { cr.Id, target.Id, weapon.ProtoId, mode, 0, 0, 0, 0, 0 };
	if( valid( ammo ) )
	{
		values[4] = ammo.ProtoId;
	}

	uint16 hexX = target.HexX, hexY = target.HexY;

	cr.SetDir( GetDirection( cr.HexX, cr.HexY, hexX, hexY ) );
	Item@ realWeapon = _CritGetItemHand( cr );
	uint8 weapon_Subtype = valid( realWeapon ) ? realWeapon.Proto.Item_Subtype : 0;

	uint16 toHx = hexX, toHy = hexY;
    int dist = GetDistantion( cr.HexX, cr.HexY, hexX, hexY );
	RustyGetHexCoord( map, cr.HexX, cr.HexY, toHx, toHy, 0.0f, dist );

	if( hexX != toHx || hexY != toHy )
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_COMBAT_NEED_AIM_BLOCKED );
        return;
    }

	int skillNum = _WeaponSkill( weapon, mode );

	if( skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS )
	{
		cr.Wait( waitTime );
	}
    else if( cr.Param[ CR_IS_WINDUPED ] == 0 && _WeaponAnim2( weapon, mode ) != ANIM2_AUTO )
    {
        cr.Wait( windupTime );
    }
	else if( _WeaponAnim2( weapon, mode ) == ANIM2_AUTO )
	{
		if( cr.Param[ CR_AUTO_ROUNDS_FIRED ] > 0 )
		{
			cr.Wait( _GetProtoWaitTime( weapon, mode ) );
		}
		else
		{
			cr.Wait( windupTime );
		}
	}
    else
    {
        cr.Wait( 10 );
        windupTime = 0;
    }

	if( cr.Param[ CR_AUTO_ROUNDS_FIRED ] == 0 || skillNum == SK_UNARMED || skillNum == SK_MELEE_WEAPONS )
	{
		cr.StatBase[ ST_CURRENT_AP ] -= needAp * 100;
	}

	if( _WeaponAnim2( weapon, mode ) == ANIM2_AUTO )
	{
		cr.ParamBase[ CR_AUTO_ROUNDS_FIRED ] ++;
	}

	if( skillNum == SK_SMALL_GUNS || skillNum == SK_MEDIUM_GUNS || skillNum == SK_BIG_GUNS )
	{
		cr.Action( ACTION_WINDUP, ACTION_FLAG_CHOSEN_INCLUSIVE << 12 | mode, valid( realWeapon ) ? realWeapon : null );
		cr.SetAnims( COND_LIFE, 0, ANIM2_WINDUP );
		if( cr.GetTimeEvents( CTE_SLOWRELOAD, null, null, null ) > 0 )
		{
			cr.EraseTimeEvents( CTE_SLOWRELOAD );
			realWeapon.SetEvent( ITEM_EVENT_MOVE, null );
		}

		CreateTimeEvent( AFTER( REAL_MS( windupTime ) ), "combat@e_DelayedAttack", values, false );
	}
	else
	{
		CombatAttack( cr, target, weapon, mode, ammo, 0, 0, false, false );
		return;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked( Critter& cr, Critter& attacker )
{
    DEBUG_SAY( cr, "Main: " + crInfo( attacker ) + " attacks " + crInfo( cr ) );//DEBUG ONLY

	attacker.ParamBase[ LAST_ATTACKED ] = cr.Id;

	if( manager_critter_attacked( cr, attacker ) )
	{
		DEBUG_SAY( cr, "MANAGER FAILED" );//DEBUG ONLY
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
// //////////////////////////////////////////////////////////////////////////////////////////////////
// LTP for looting critters
bool ltp_inspect_inited = false;
void ltp_inspect_init()
{
	LTPREG( LTP_INSPECT, process_inspect )
	ltp_inspect_inited = true;
}

bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count )
{
	string action_text = item.CritId == thief.Id ? "insert" : "steal";
	if( isGM( thief ) )
	{
		CrimeLog( thief, crInfo( thief ) + " by use of Godly powers managed to " + action_text + " " + itemDesc( item ) + " ,victim: " + crInfo( cr ) );
		return true;
	}
	
	/* Battle & death check */
    if( cr.IsDead() )
    {
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;
		thief.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_INSPECTS );
		if( !ltp_inspect_inited )
		{
			ltp_inspect_init();
		}
		
		thief.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CRITTER_LOOT_DELAY;
		thief.ParamBase[ ST_LTP_SEQUENCE ] = 0;
		StartProcess( thief, LTP_INSPECT, 0, cr.Id, 0, thief.Param[ ST_LTP_SEQUENCE_WAIT ] );
		thief.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
        return false;
    }
	else if( cr.StatBase[ ST_FOLLOW_CRIT ] == int( thief.Id ) )
	{
		return true;
	}
    else if( cr.Mode[ MODE_NO_PVP ] != 0 || thief.Mode[ MODE_NO_PVP ] != 0 )
    {
        thief.Say( SAY_NETMSG, "No PvP." );
        return false;
    }
	else if( !cr.IsLife() )
	{
		return true;
	}

    thief.TimeoutBase[ TO_AGGRESSOR ] = __FullSecond + REAL_MINUTE( 1 );

	/* Target perception & steal skill modifiers */
    int targetPeModifier = cr.Stat[ ST_PERCEPTION ];
    int targetStealModifier = cr.Skill[ SK_STEAL ];

    if( targetPeModifier <= 0 )
    {
        targetPeModifier = 1;
    }

    if( targetStealModifier <= 0 )
    {
        targetStealModifier = 1;
    }

    int basePeModifier = thief.Stat[ ST_PERCEPTION ];
    int baseAgModifier = thief.Stat[ ST_AGILITY ];
    int baseLkModifier = thief.Stat[ ST_LUCK ];
    int baseStealmodifier = thief.Skill[ SK_STEAL ];

    if( basePeModifier <= 0 )
    {
        basePeModifier = 1;
    }

    if( baseAgModifier <= 0 )
    {
        baseAgModifier = 1;
    }

    if( baseLkModifier <= 0 )
    {
        baseLkModifier = 1;
    }

    if( baseStealmodifier <= 0 )
    {
        baseStealmodifier = 1;
    }

    /* Look modifier */
    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX( dir1, dir2 ) - MIN( dir1, dir2 );
    if( kDir > 3 )
	{
        kDir = 6 - kDir;
	}

     /* Steal skill of thief */
    int steal = thief.Skill[ SK_STEAL ];
    if( steal <= 0 )
	{
        steal = 1;
    }

    /* Volume of an item */
	int volume = item.Proto.Volume;
    int volumeModifier = 0;
    if( volume <= 0 )
	{
        volume = 1;
        volumeModifier = 10;
	}
    else if( volume <= 20 && volume > 0 )
    {
        volumeModifier = 10;
    }

    /* Weight of an item */
    int weight = item.Proto.Weight;
    int weightModifier = 0;
    if ( weight <= 0 )
    {
        weight = 1;
        weightModifier = 10;
    }
    else if( weight <= 500 && weight > 0 )
    {
        weightModifier = 10;
    }

    /* Count modifier */
    int kCount = count / steal;
    if( kCount <= 0 )
	{
        kCount = 1;
	}

    /* Steal timer */
    uint lastStealCrId = thief.Stat[ ST_LAST_STEAL_CR_ID ];
    uint stealCount = thief.Stat[ ST_STEAL_COUNT ];
    if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
	{
        steal -= steal * stealCount * 9 / 100;
	}

    /* Final steal chance calculation

       It's a sum of Steal % / 6 + PE + AG + LK
       lowered by target's PE and Steal % / 6.
       If item that's being stolen has volume lower
       than 20 then chance's being raised by 10%.
       Same if weight's lower than 500g then
       additional 10% is being summed up.

       Can't steal items bigger than 100 volume or
       heavier than 2500g                           */

		int StealCalculation = CLAMP( ( ( steal - kDir * 10 ) + basePeModifier + baseAgModifier + baseLkModifier + volumeModifier + weightModifier - targetPeModifier - targetStealModifier ) / kCount, 5, 95 );
		int chance = Random( 1, 100 );
		bool success = ( chance < StealCalculation );

	/* Failed steal attempt because the item's too heavy */
    if( volume > 100 || weight > 2500 )
    {
		thief.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_VOLUME );
        CrimeLog( thief, crInfo( thief ) + " failed to " + action_text + " " + itemDesc( item ) + " ,victim: " + crInfo( cr ) );

		thief.Action( ACTION_PICK_CRITTER, 3, null );
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.Stat[ ST_CURRENT_HP ];
			AddAttackPlane( cr, 0, thief, thiefHp < 10 || Random( 1, 10 ) > cr.Stat[ ST_LUCK ] + 4 || cr.Stat[ ST_CHARISMA ] < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
		return false;
    }
	/* Succesful steal attempt */
	else if( success )
    {
        thief.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_SUCCESS );
		if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
        {
            stealCount++;
            if( stealCount > 11 )
			{
                stealCount = 11;
            }
			thief.StatBase[ ST_STEAL_COUNT ] = stealCount;
        }
        else
        {
            thief.StatBase[ ST_LAST_STEAL_CR_ID ] = cr.Id;
            thief.StatBase[ ST_STEAL_COUNT ] = 0;
        }
		
		thief.TimeoutBase[ TO_STEALING ] = STEAL_TIMEOUT( thief );
		thief.Action( ACTION_PICK_CRITTER, 1, null );
		CrimeLog( thief, crInfo( thief ) + " managed to " + action_text + " " + itemDesc( item ) + " ,victim: " + crInfo( cr ) );
		return true;
    }
	/* Failed steal attempt */
    else
    {
		thief.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_FAIL );
        CrimeLog( thief, crInfo( thief ) + " failed to " + action_text + " " + itemDesc( item ) + " ,victim: " + crInfo( cr ) );

        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.Stat[ ST_CURRENT_HP ];
			AddAttackPlane( cr, 0, thief, thiefHp < 10 || Random( 1, 10 ) > cr.Stat[ ST_LUCK ] + 4 || cr.Stat[ ST_CHARISMA ] < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
		
		return false;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param )
{
	if( !IsHuman( cr ) && !IsRobot( cr ) && !IsMutant( cr ) && item.GetType() != ITEM_TYPE_FOOD && item.GetType() != ITEM_TYPE_DRINK && item.GetType() != ITEM_TYPE_FLASK && item.GetType() != ITEM_TYPE_DRUG )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
		return false;
	}

	if( valid( targetCr ) && targetCr.Param[ PET_OWNER_ID ] == int( cr.Id ) )
	{
		return true;
	}

	string exception_catcher = cr.Id + "# in " + (valid(cr.GetMap())?"@"+cr.GetMap().Id:"global") + " used "
		+ (valid(item)?item.Id:0) + ":" + (valid(item)?item.GetProtoId():0) + " on ["
		+ (valid(targetCr)?targetCr.Id:0) + ", "
		+ (valid(targetItem)?targetItem.Id:0) + ":" + (valid(targetItem)?targetItem.GetProtoId():0) + ", "
		+ (valid(targetScen)?targetScen.ProtoId:0) + "] with param " + param + ".";
	DebugLog( exception_catcher, 2 );

	_testInfo( cr, CR_TEST_MODE_USED, SAY_NETMSG, exception_catcher );

    uint16 pid = item.GetProtoId();
    bool useOnSelf = ( !valid( targetCr ) && !valid( targetItem ) && !valid( targetScen ) );

	cr.Wait(GetProtoTime(item.Proto, 0, cr));
	Map@ map = cr.GetMap();
	uint16 tpid = valid( targetItem ) ? targetItem.GetProtoId() : 0;
	
	string action_info = crInfo( cr ) + " uses " + itemDesc( item ) + " on ";
	if( useOnSelf )
	{
		action_info += "self";
	}
	else
	{
		if( valid( targetCr ) )
		{
			action_info += crInfo( targetCr );
		}

		if( valid( targetItem ) )
		{
			action_info += itemDesc( targetItem );
		}

		if( valid( targetScen ) )
		{
			action_info += "scenery #" + targetScen.ProtoId;
		}
	}
	SayLog( cr, action_info + "." );

	if( !valid( targetScen ) )
	{
		//Planting barrels
		if( farm_seeds.find( pid ) != -1 )
		{
			if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_PLANTBARREL_EMPTY ) )
			{
				TryPlantSeed( cr, item, 0, 0, targetItem );
				return true;
			}
		}
		//Planting hydroponics
		if( hydro_seeds.find( pid ) != -1 )
		{
			if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_HYDRO_NS_EMPTY || targetItem.GetProtoId() == PID_HYDRO_EW_EMPTY ) )
			{
				TryPlantSeed( cr, item, 0, 0, targetItem );
				return true;
			}
		}
		//Planting mushrooms
		if( mushbed_seeds.find( pid ) != -1 )
		{
			if( valid( targetItem ) && targetItem.GetProtoId() == PID_MUSHBED_EMPTY )
			{
				TryPlantSeed( cr, item, 0, 0, targetItem );
				return true;
			}
		}
		// Plant Furtelizing
		if( valid( targetItem ) && fertilizers.find( pid ) != -1 )
		{
			if( growing_plants.find( targetItem.GetProtoId() ) != -1 || empty_beds.find( targetItem.GetProtoId() ) != -1 || farm_seeds.find( targetItem.GetProtoId() ) != -1 )
			{
				FurtilezePlant( cr, item, targetItem );
				return true;
			}
		}
		//Scavenging
		if( PrepareScavenging( cr, item, targetItem ) )
		{
			return true;
		}
		//Mining
		if( PrepareMining( cr, item, targetItem ) )
		{
			return true;
		}
		//Chopping
		if( PrepareChopping( cr, item, targetItem ) )
		{
			return true;
		}
		//Make firewood
		if( TryChopItem( cr, item, targetItem ) )
		{
			return true;
		}
		//Smithing
		if( PrepareSmithing( cr, item, targetItem ) )
		{
			return true;
		}
		//Flasks and other containers for liquids
		if( FlaskCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Slot machine
		if( SlotMachineCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Firesource check
		if( FireCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Sandbag placing check
		if( SandbagCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Container placing check
		if( ContainerCheck( cr, item, targetItem ) )
		{
			return true;
		}
		//Container placing check
		if( BarrelCheck( cr, item, targetItem ) )
		{
			return true;
		}

		//Still check
		if( UseItemOnStill( cr, item, targetItem ) )
		{
			return true;
		}
		//Autodoc biogel charging
		if( ChargeAutodoc( cr, item, targetItem ) )
		{
			return true;
		}
		// Armor painting
		if( valid( item ) && valid( targetItem ) && pid == PID_COLORS && targetItem.GetType() == ITEM_TYPE_ARMOR )
		{
			TryPaintArmor( cr, item, targetItem );
			return true;
		}
		// lock install
		if( valid( item ) && valid( targetItem ) && ( pid == PID_LOCK_LOW || pid == PID_LOCK_MED || pid == PID_LOCK_HARD || pid == PID_LOCK_CODE ) )
		{
			TryInstallLock( cr, item, targetItem );
		}
		//Shiv lex writing
		if( valid( item ) && valid( targetItem ) && pid == PID_SHIV )
		{
			ShivUse( cr, item, targetItem );
			return true;
		}
		//Cards deck
		if( valid( item ) && pid == PID_CARDS_DECK && !valid( targetScen ) )
		{
			if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CONTAINER )
			{
				CardsUse( cr, item, targetItem );
				return true;
			}

			if( valid( targetCr ) && targetCr.IsPlayer() )
			{
				CardsUse( cr, item, targetCr );
				return true;
			}

			if( useOnSelf )
			{
				if( item.CritSlot == SLOT_HAND1 )
				{
					CardsUse( cr, item, cr );
				}
				else
				{
					ShowContainer( cr, item, TRANSFER_SELF_CONT );
				}
				return true;
			}
		}
		//Cards hand
		if( valid( item ) && pid == PID_CARDS_HAND && !valid( targetScen ) && valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CONTAINER )
		{
			ShowCardSHand( cr, item, targetItem );
			return true;
		}
	}
	//Interactions with scenery
	if( valid( targetScen ) )
	{	//Toilets
		if( scenToiletList.find( targetScen.ProtoId ) > -1 )
		{
			FlushToilet( cr, item );
			return true;
		}

		// Gathering dirty water
		if( start_gathering_water( cr, targetScen.ProtoId ) )
		{
			return true;
		}
	}
	//Various Items
	switch( pid )
	{
		case( PID_DICE ):
		case( PID_LOADED_DICE ):
			DiceUse( cr, item );
			return true;
		case( PID_BOTTLE_CAPS ):
			CoinUse( cr, item );
			return true;
		case( PID_TAPE_RECORDER ):
			StartMenuRecorder( cr, item );
			return true;
		case( PID_PHOTO ):
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_MAKES_PICTURE );
			cr.Action( ACTION_PICK_CRITTER, 3, null );
			return true;
		case( PID_FLUTE ):
			FluteUse( cr );
			return true;
		case( PID_MAGIC_8_BALL ):
			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, Random( 1, 2 ) == 1 ? STR_MAGIC_BALL_YES : STR_MAGIC_BALL_NO );
			return true;
		case( PID_SHOVEL ):
		case( PID_SPADE ):
			CheckRemainsRemoval( cr, targetItem );
			return true;
		case( PID_SLAVE_COLLAR_SWITCH ):
			StartMenuSCollar( cr, item );
			return true;
		case( PID_DYNAMITE ):
		case( PID_TNT_PACK ):
		case( PID_TNT_PACK_ACTIVE ):
		case( PID_REMOTE_DETONATOR ):
			SetExplosives( cr, item, param );
			return true;
		case( PID_SMALL_ENERGY_CELL ):
		case( PID_CUENCELL_LOW ):
		{
			Item@ flashlight = _CritGetItemHand( cr );
			if( valid( flashlight ) )
			{
				uint16 flashlight_pid = flashlight.GetProtoId();
				if( flashlight_pid == PID_FLASHLIGHT_ON || flashlight_pid == PID_FLASHLIGHT_HELMET || flashlight_pid == PID_FLASHLIGHT_OFF || flashlight_pid == PID_10MM_PISTOL_FLASHLIGHT )
				{
					ChargeFlashlight( cr, item, flashlight );
					return true;
				}
			}
		}
		case( PID_MICRO_FUSION_CELL ):
		{
			Item@ defib = _CritGetItemHand( cr );
			if( valid( defib ) )
			{
				uint16 defib_pid = defib.GetProtoId();
				if( defib_pid == PID_REANIMATION_KIT )
				{
					ChargeDefib( cr, item, defib );
					return true;
				}
			}
		}
		case( PID_PLANT_OIL ):
		{
			Item@ lamp = _CritGetItemHand( cr );
			if( valid( lamp ) )
			{
				uint16 lamp_pid = lamp.GetProtoId();
				if( lamp_pid == PID_OIL_LAMP )
				{
					ChargeLamp( cr, item, lamp );
					return true;
				}
			}
		}
		case( PID_LIGHTER ):
		{
			if( useOnSelf )
			{
				@targetCr = cr;
			}
			
			if( valid( targetCr ) )
			{
				Item@ smoker = _CritGetItemHand( targetCr );
				if( valid( smoker ) )
				{
					uint16 smoker_pid = smoker.GetProtoId();
					if( Smokers.find( smoker_pid ) != -1 || SmokingPipes.find( smoker_pid ) != -1 )
					{
						IgniteSmoker( cr, targetCr, smoker );
						return true;
					}
				}
				
				@smoker = _CritGetItemHead( targetCr );
				if( valid( smoker ) )
				{
					uint16 smoker_pid = smoker.GetProtoId();
					if( Smokers.find( smoker_pid ) != -1 || SmokingPipes.find( smoker_pid ) != -1 )
					{
						IgniteSmoker( cr, targetCr, smoker );
						return true;
					}
				}
			}
			else if( valid( targetItem ) && tpid == PID_CHOPPED_FIREWOOD )
			{
				return Ignite( cr, item, targetItem );
			}
		}
	}

	//Show single Card
	if( Cards.find( pid ) != -1 )
	{
		ShowCard( cr, item );
		return true;
	}
	//Fishing
	if( ( pid == PID_STRING || pid == PID_HOOK || Bait.find( pid ) != -1 ) && ( hasItem( cr, PID_ROD_STRING_HOOK, SLOT_HAND1 ) || hasItem( cr, PID_ROD_STRING, SLOT_HAND1 ) || hasItem( cr, PID_ROD, SLOT_HAND1 ) ) )
	{
		PrepareFishingRod( cr, item );
		return true;
	}
	//Soap
	if( SoapItems.find( pid ) != -1 )
	{
		Critter@ target = useOnSelf ? @cr : @targetCr;
		if( valid( target ) )
		{
			Cleaning( cr, target, pid, 0 );
			return true;
		}
	}
	// Knife use
	if( CutCheck( cr, item, useOnSelf ? @cr : @targetCr ) )
	{
		return true;
	}
	//Blood wrapping
	if( ( pid == PID_CRAFT_L_RAGS || pid == PID_BANDAGE || pid == PID_TOWEL || pid == PID_OLD_TOWEL ) && valid( targetItem ) && ( targetItem.GetProtoId() >= PID_BLOOD_TINY_0 && targetItem.GetProtoId() <= PID_BLOOD_LARGE_3 ) )
	{
		cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_WIPE_BLOOD );
		cr.Animate( 0, ANIM2_PICKUP, null, false, true );
		targetItem.Val0 -= Random( 1, 3 );
		if( pid == PID_TOWEL )
		{
			item.ChangeProto( PID_OLD_TOWEL );
			item.Update();
		}

		if( targetItem.Val0 < 1 )
		{
			DeleteItem( targetItem );
		}
		
		return true;
	}
	//Doors
	if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_DOOR )
	{
        cr.StatBase[ ST_LAST_DOOR_ID ] = targetItem.Id;
	}
	//Bandage
	if( bandage_items.find( pid ) != -1 )
	{
		if( cr.IsPlayer() && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
			return true;
		}

		cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );

		if( useOnSelf )
		{
			UseBandageItem( cr, cr, item );
		}
		else if( valid( targetCr ) )
		{
			if( targetCr.IsLife() )
			{
				AskHealingItem( cr, targetCr, item, false );
			}
			else
			{
				UseBandageItem( cr, targetCr, item );
			}
		}
        return true;
    }
	//Planting mine on something
	if( valid( targetScen ) && item.GetType() == ITEM_TYPE_TRAP && item.Proto.Item_Subtype == ITEM_SUBTYPE_MINE )
	{
		TryPlantMine( cr, item, targetScen.HexX, targetScen.HexY );
		return true;
	}
	//Skinning
	if( valid( targetCr ) )
	{
		if( SkinningTools.find( pid ) != -1 )
		{
			PrepareSkinning( cr, item, targetCr );
			return true;
		}
	}
    //Containers
	if( cr.IsPlayer() && useOnSelf && item.GetType() == ITEM_TYPE_CONTAINER )
	{
		UseSkillOnLocker( cr, item, SKILL_PICK_ON_GROUND );
        return true;
    }
	//Keybunch
    if( ( pid == PID_KEY_BUNCH || pid == PID_FNKEYBT ) && valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) )
	{
		KeyBunchUse( cr, item, targetItem );
		return true;
    }
    //Hypo Poison
    if( useOnSelf && pid == PID_HYPO_POISON && cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT )
	{
		if( cr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NEUROTOX_SELF );
			AffectParalysis( cr, 50 );
			cr.DeleteItem( PID_HYPO_POISON, 1 );
		}
        return true;
    }

    if( valid( targetCr ) && pid == PID_HYPO_POISON && targetCr.StatBase[ ST_BODY_TYPE ] != BT_ROBOT )
	{
        targetCr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_NEUROTOX_YOU );
        AffectParalysis( targetCr, 50 );
        cr.DeleteItem( PID_HYPO_POISON, 1 );
        return true;
    }
    //Antidote
    if( useOnSelf && pid == PID_ANTIDOTE_2 )
	{
        if( cr.Param[ ST_PARALYSIS_LEVEL ] != 0 || cr.Param[ ST_POISONING_LEVEL ] != 0 ) {
            DropPoison( cr );
            DropParalysis( cr, 50 );
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return true;
        }
		else
		{
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return false;
        }
    }

    if( valid( targetCr ) && pid == PID_ANTIDOTE_2 )
	{
        if( targetCr.Param[ ST_PARALYSIS_LEVEL ] != 0 || targetCr.Param[ ST_POISONING_LEVEL ] != 0 )
		{
			DropPoison( targetCr );
            DropParalysis( targetCr, 50 );
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return true;
        }
		else
		{
            cr.DeleteItem( PID_ANTIDOTE_2, 1 );
			cr.AddItem( PID_HYPODERMIC_NEEDLE, 1 );
            return false;
        }
    }
	//Flasks
	if( item.GetType() == ITEM_TYPE_FLASK )
	{
		if( item.Val0 > 0 )
		{
			Item@ flask = cr.GetItem( 0, SLOT_HAND1 );
			if( valid( targetItem ) && targetItem.GetProtoId() == PID_BOTTLE_GLASS)
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TRY_DIFFERENTLY );
			}
			else if( valid( targetScen ) )
			{
				PourFlask( cr, item );
			}
			else if( valid( flask ) && item.CritSlot != SLOT_HAND1 && flask.Proto.Type == ITEM_TYPE_FLASK )
			{
				FlaskCheck( cr, item, flask );
			}
			else if( valid( targetItem ) )
			{
				if( growing_plants.find( targetItem.GetProtoId() ) != -1 || empty_beds.find( targetItem.GetProtoId() ) != -1 || farm_seeds.find( targetItem.GetProtoId() ) != -1 )
				{
					TryWaterPlant( cr, item, targetItem );
					return true;
				}
			}
			else
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				DrinkFlask( cr, item );
			}
		}
		else
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_FLASK_EMPTY );
		}
		return true;
	}

    // Radio
	if( !useOnSelf && pid == PID_RADIO )
	{
		if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_ARMOR && ( targetItem.Proto.Item_Subtype >= ITEM_SUBTYPE_ARMOR_AC20 && targetItem.Proto.Item_Subtype <= ITEM_SUBTYPE_ARMOR_AC50 ) )
		{
			InstallRadio( cr, targetItem );
		}
		return true;
	}

    if( FLAG( item.Flags, ITEM_RADIO ) && useOnSelf )
	{
        if( cr.IsPlayer() )
		{
			cr.RunClientScript( "radio@ShowEditScreen", item.Id, 0, 0, null, null );
        }
		return true;
    }

	// Drinks
	if( item.GetType() == ITEM_TYPE_DRINK )
	{
		// Plant Watering
		if( valid( targetItem ) )
		{
			if( growing_plants.find( targetItem.GetProtoId() ) != -1 || empty_beds.find( targetItem.GetProtoId() ) != -1 || farm_seeds.find( targetItem.GetProtoId() ) != -1 )
			{
				TryWaterPlant( cr, item, targetItem );
				return true;
			}
		}

		if( find_glassed_drinks( item ) )
		{
			uint body = cr.Stat[ ST_BODY_TYPE ];
			if( ( body >= 5 && body <= 9 ) || ( body >= 11 && body <= 29 ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_WRONG_ANATOMY );
				return true;
			}

			string sound = "bottleOpen.ogg";
			if( find_capped_bottles( item ) )
			{
				cr.AddItem( PID_REAL_BOTTLE_CAPS, 1 );
				sound = _GetOneRandom( cap_bottle_open_sounds );
			}

			PlayGenericSound( map, cr.HexX, cr.HexY, sound, 4 );

			uint16 drinkPid = item.GetProtoId();
			int index = glass_bottles[1].find( drinkPid );

			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_OPEN_BOTTLE, "$proto@msg item " + ( drinkPid * 100 ) + "@\n");

			Item@ openedBottle = cr.AddItem( glass_bottles[2][index], 1 );

			openedBottle.REMAINING_USES = openedBottle.Proto.Partial_Item;
			openedBottle.DRINK_DNA = openedBottle.Proto.StartValue_1;
			openedBottle.EXTRA_WEIGHT = openedBottle.Proto.Partial_Item * 100;
			openedBottle.Val3 = item.Val3;
			openedBottle.Val4 = item.Val4;
			openedBottle.TOXIN_LEVEL = item.TOXIN_LEVEL;
			openedBottle.Val6 = item.Val6;
			openedBottle.POLUTION_LEVEL = item.POLUTION_LEVEL;
			openedBottle.FASK_TASTE = item.FASK_TASTE;
			openedBottle.SPIRIT_LEVEL = item.SPIRIT_LEVEL;

			openedBottle.Update();

			string@ lexems = Item_GetLexems( item );
			if( valid( lexems ) )
			{
				openedBottle.SetLexems( lexems );
			}

			_SubItem( item, 1 );

			Item@ hands = cr.GetItem( 0, SLOT_HAND1 );
			if( valid( hands ) )
			{
				cr.MoveItem( hands.Id, hands.GetCount(), SLOT_INV );
			}

			cr.MoveItem( openedBottle.Id, openedBottle.GetCount(), SLOT_HAND1 );

			cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_OPENS_BOTTLE );

			return true;
		}

		Item@ flask = _CritGetItemHand( cr );
		if( valid( flask ) )
		{
			if( item.CritSlot != SLOT_HAND1 && flask.GetType() == ITEM_TYPE_FLASK )
			{
				FlaskCheck( cr, item, flask );
				return true;
			}
		}

		if( item.CritSlot != SLOT_HAND1 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_MUST_HOLD_ITEM );
			return true;
		}

		if( useOnSelf )
		{
			if( !IsRobot( cr ) )
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				ProccessDrink( cr, cr, item );
			}
		}
		else if( valid( targetCr ) )
		{
			if( !IsRobot( targetCr ) )
			{
				cr.Action( ACTION_USE_ITEM, 1, item );
				ProccessDrink( cr, targetCr, item );
			}
		}
        return true;
    }
	// Defibrilator
	if( !useOnSelf && valid( targetCr ) && pid == PID_REANIMATION_KIT )
	{
		TryReanimate( cr, targetCr, item );
		return true;
	}
	// Bondage
	if( item.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
	{
		if( item.BONDAGE_STATE != BONDAGE_STATE_OFF )
		{
			return false;
		}

		if( useOnSelf )
		{
			@targetCr = cr;
		}

		TryBondageTarget( cr, targetCr, item );
		return true;
	}
	// Bondage key
	if( pid == PID_HANDCUFFS_KEY || pid == PID_SHACKLES_KEY )
	{
		if( useOnSelf )
		{
			@targetCr = cr;
		}
		ReleaseTarget( cr, targetCr, item );
		return true;
	}
	// Remove shackles and cuffs
	if( ( pid == PID_WELDING || pid == PID_ENERGY_WELDIN || pid == PID_MULTI_TOOL || pid == PID_SUPER_TOOL_KIT ) && !valid( targetItem ) )
	{
		if( useOnSelf )
		{
			@targetCr = cr;
		}

		TryBreakBonds( cr, targetCr );
		return true;
	}
    // Drugs
    if( item.GetType() == ITEM_TYPE_DRUG || item.GetType() == ITEM_TYPE_FOOD )
	{
    	if( ( useOnSelf && cr.StatBase [ST_BODY_TYPE] == BT_ROBOT ) || ( @targetCr != null && targetCr.StatBase [ ST_BODY_TYPE ] == BT_ROBOT ) )
		{
			return false;
        }

        if( useOnSelf )
		{
			if( pid == PID_PILLS ) // WIP LOGIC, TO BE MOVED TO GLOBAL CONSUMABLE MODULE
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_CONSUMED, "$proto@msg item " + ( pid * 100 ) + "@" );
				if( cr.Timeout[ TO_PILLS ] == 0 )
				{
					cr.TimeoutBase[ TO_PILLS ] = __FullSecond + REAL_HOUR( 24 );
					if( cr.Stat[ ST_MAX_LIFE_EXT ] < 0 )
					{
						cr.StatBase[ ST_MAX_LIFE_EXT ] ++;
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_RESTORED_MAX_HP, "$regen" + 1 );
					}
				}
				
				cr.AddItem( PID_PHIAL, 1 );
				_SubItem( item, 1 );
				return true;
			}
			
			if( heal_items.find( pid ) != -1 )
			{
				if( cr.IsPlayer() && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
					return true;
				}

				cr.Action( ACTION_USE_ITEM, 2, item );
				UseHealingItem( cr, cr, item );
				return true;
			}
			else
			{
				cr.Action( ACTION_USE_ITEM, 2, item );
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_CONSUMED, "$proto@msg item " + ( pid * 100 ) + "@" );

            	ProccessFood( cr, cr, item );

				UseDrug( cr, item );
				return true;
			}
		}
		else if( valid( targetCr ) )
		{
			if( heal_items.find( pid ) != -1 )
			{
				if( cr.IsPlayer() && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
					return true;
				}

				cr.Action( ACTION_USE_ITEM, 2, item );
				if( targetCr.IsLife() )
				{
					AskHealingItem( cr, targetCr, item, false );
				}
				else
				{
					UseHealingItem( cr, targetCr, item );
				}
				return true;
			}
			else
			{
				ProccessFood( cr, targetCr, item );
				UseDrugOn( cr, targetCr, item );
			}
			cr.Action( ACTION_USE_ITEM, 1, item );
			//cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_CONSUMED, "$proto@msg item " + ( pid * 100 ) + "@" );
		}
		return true;
    }

    //Oil Lamp
	if( pid == PID_OIL_LAMP )
	{
		OilLampUse( cr, item );
		return true;
	}
	//Flashlight
    if( pid == PID_FLASHLIGHT_OFF || pid == PID_10MM_PISTOL_FLASHLIGHT || pid == PID_FLASHLIGHT_HELMET )
	{
		FlashlightUse( cr, item );
        return true;
    }

	// Flashlight charging
	if( ( pid == PID_SMALL_ENERGY_CELL || pid == PID_CUENCELL_LOW ) && tpid != 0 && ( tpid == PID_FLASHLIGHT_OFF || tpid == PID_FLASHLIGHT_ON || tpid == PID_FLASHLIGHT_HELMET || tpid == PID_10MM_PISTOL_FLASHLIGHT ) )
	{
		//ChargeFlashlight( cr, item, targetItem );
		return true;
	}
	// OilLamp charging
	if( pid == PID_PLANT_OIL && valid( targetItem ) && tpid == PID_OIL_LAMP )
	{
		//ChargeLamp( cr, item, targetItem );
		return true;
	}
	// Reanimation Kit charging
	if( pid == PID_MICRO_FUSION_CELL && valid( targetItem ) && tpid == PID_REANIMATION_KIT )
	{
		//ChargeDefib( cr, item, targetItem );
		return true;
	}

	// Flare extinguish
	if( pid == PID_ACTIVE_FLARE )
	{
        _SubItem( item, 1 );
		cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_FLARE_OFF );
		PlayGenericSound( map, cr.HexX, cr.HexY, "BUTIN4.mp3", 4 );
        return true;
    }
	// Active Flare
    if( pid == PID_FLARE )
	{
		FlareUse( cr, item );
		return true;
	}
    // Cosmetic
    if( pid == PID_COSMETIC_CASE && cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
	{
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_COSMETIC_USE );
        return true;
    }
	// Fires
	if( pid == PID_FLINT && valid( targetItem ) && tpid == PID_CHOPPED_FIREWOOD )
	{
		return Ignite( cr, item, targetItem );
	}
	// Smoking items
	if( item.GetType() == ITEM_TYPE_SMOKER )
	{
		CheckSmokers( cr, item );
		return true;
	}
    // Towels
	if( pid == PID_TOWEL || pid == PID_OLD_TOWEL )
	{
		if( useOnSelf )
		{
			TowelUse( cr, item );
		}
		else if( valid( targetScen ) )
		{
			TowelWash( cr, item, targetScen );
		}
		return true;
	}
	//Locker removal
    if( valid( targetItem ) && ( pid == PID_CROWBAR || pid == PID_MULTI_TOOL || pid == PID_SUPER_TOOL_KIT ) 
		&& ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) && targetItem.LOCK_TYPE != LOCK_NONE
		&& FLAG( targetItem.LockerCondition, LOCKER_ISOPEN ) )
	{
        TryRemoveLock( cr, item, targetItem );
		return true;
    }
    // Geiger counter
    if( pid == PID_GEIGER_COUNTER && useOnSelf && UseGeiger( cr, item ) )
	{
        return true;
	}

    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseItemOnGeiger( cr, targetItem, item ) )
	{
        return true;
	}
	//Showel on self to make a bed in GM mode
    if( pid == PID_SHOVEL && useOnSelf )
	{
		UseShovel( cr, item );
        return true;
	}
	// Item use on locker
    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) )
	{
		return UseItemOnLocker( cr, targetItem, item );
	}

    // Take process to engine
    return false;
}

void informAboutSkill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	string skill_name = "";
	switch( skill )
	{
		case( SK_LOCKPICK ):
			skill_name = "Lockpicking";
			break;
		case( SK_STEAL ):
			skill_name = "Theft";
			break;
		case( SK_TRAPS ):
			skill_name = "Traps";
			break;
		case( SK_FIRST_AID ):
			skill_name = "First Aid";
			break;
		case( SK_DOCTOR ):
			skill_name = "Doctor Skill";
			break;
		case( SK_SCIENCE ):
			skill_name = "Science";
			break;
		case( SK_REPAIR ):
			skill_name = "Repair";
			break;
		default:
			return;
	}

	string action_info = crInfo( cr ) + " applies " + skill_name + " on ";

	if( valid( targetCr ) )
	{
		action_info += crInfo( targetCr );
	}
	else if( valid( targetItem ) )
	{
		action_info += itemDesc( targetItem );
	}
	else if( valid( targetScen ) )
	{
		action_info += "scenery #" + targetScen.ProtoId;
	}
	else
	{
		action_info += "self";
	}
	
	SayLog( cr, action_info + "." );
}

uint process_inspect( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_INSPECT )

	Critter@ targetCr = GetCritter( param1 );
    if( !valid( targetCr ) )
	{
		cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
        return 0;
	}
	
	hotkey_critter_anim( cr, 5 );
	ShowContainer( cr, targetCr, TRANSFER_CRIT_LOOT );

	return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	bool isSentientCritter = ( IsHuman( cr ) || IsMutant( cr ) || IsRobot( cr ) );
	if( cr.Param[ CR_INIT_SEX ] != 0 )
	{
		skill = SK_SEX;
	}

	if( cr.Param[ CR_INIT_DEVOUR ] != 0 )
	{
		skill = SK_HUNTING;
	}

	string exception_catcher = cr.Id + "# in " + (valid(cr.GetMap())?"@"+cr.GetMap().Id:"global") + " used " + skill + " on ["
		+ (valid(targetCr)?targetCr.Id:0) + ", "
		+ (valid(targetItem)?targetItem.Id:0) + ":" + (valid(targetItem)?targetItem.GetProtoId():0) + ", "
		+ (valid(targetScen)?targetScen.ProtoId:0) + "].";
	DebugLog( exception_catcher, 2 );

	informAboutSkill( cr, skill, targetCr, targetItem, targetScen );

	if( valid( targetItem ) )
	{
		CheckItemMovement( cr, targetItem, skill );
	}

    bool onSelf = ( ( !valid( targetCr ) ) && ( !valid( targetItem ) ) && ( !valid( targetScen ) ) );

	if( skill != SKILL_PUT_CONT && skill != SKILL_TAKE_CONT )
	{
		cr.Wait( GetSkillTime( skill, cr ) );
	}

    // Geiger counter
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseSkillOnGeiger( cr, targetItem, skill ) )
	{
        return true;
	}
	// homebrew pot interface
	if( valid( targetItem ) && targetItem.GetProtoId() == PID_POT_ALCO )
	{
		switch( skill )
		{
			case( SK_REPAIR ):
				LockInPlace( cr, targetItem );
				break;
			case( SKILL_PICK_ON_GROUND ):
				ShowMenuBrew( cr, targetItem );
				break;
		}
		return true;
	}
	// empty Plant beds
	if( valid( targetItem ) && ( targetItem.GetProtoId() == PID_MUSHBED_EMPTY || targetItem.GetProtoId() == PID_HYDRO_NS_EMPTY || targetItem.GetProtoId() == PID_HYDRO_EW_EMPTY || targetItem.GetProtoId() == PID_PLANTBARREL_EMPTY ) )
	{
		StartMenuPlantBed( cr, targetItem );
		return true;
	}
	// Still interface
	if( valid( targetItem ) && IsStill( targetItem ) )
	{
		switch( skill )
		{
			case( SK_REPAIR ):
				LockInPlace( cr, targetItem );
				break;
			case( SKILL_PICK_ON_GROUND ):
				StartMenuStill( cr, targetItem );
				break;
			default:
				break;
		}
		return true;
	}
	// case for lockpickable containers with interface
	if( skill != SK_LOCKPICK )
	{
		if( valid( targetItem ) )
		{
			uint16 Pid = targetItem.GetProtoId();
			// Slots interface
			if( Pid == PID_SLOT_MACHINE || Pid == PID_SLOT_MACHINE2 )
			{
				StartMenuSlotMachine( cr, targetItem );
				return true;
			}
			// Vending Machine Interface
			if( vending_machines.find( Pid ) != -1 )
			{
				StartMenuVendingMachine( cr, targetItem );
				return true;
			}
			// Jukebox Interface
			if( Pid == PID_JUKEBOX1 || Pid == PID_JUKEBOX2 || Pid == PID_JUKEBOX3 || Pid == PID_JUKEBOX4 )
			{
				StartMenuJukebox( cr, targetItem );
				return true;
			}
			// Terminal interface
			if( Pid == PID_TERMINAL )
			{
				StartMenuTerminal( cr, targetItem );
				return true;
			}
			// Farming plants
			if( growing_plants.find( Pid ) != -1 )
			{
				StartMenuPlant( cr, targetItem );
				return true;
			}
			// Anvil interface
			if( Pid == PID_ANVIL )
			{
				switch( skill )
				{
					case( SK_REPAIR ):
						LockInPlace( cr, targetItem );
						break;
					case( SKILL_PICK_ON_GROUND ):
						StartMenuAnvil( cr, targetItem );
						break;
					default:
						break;
				}
				return true;
			}
			// Smelter interface
			if( Pid == PID_FURNACE_SMALL || Pid == PID_ARC_FURNACE )
			{
				switch( skill )
				{
					case( SK_REPAIR ):
					{
						if( targetItem.STATE == STATE_EXTINGUISHED )
						{
							if( !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
							{
								LockInPlace( cr, targetItem );
							}

							_InitFurniture( targetItem, true );
							targetItem.Update();
							StartMenuFuriture( cr, targetItem );
							break;
						}
					}
					case( SKILL_PICK_ON_GROUND ):
						StartMenuFurnace( cr, targetItem );
						break;
					default:
						break;
				}
				return true;
            }
			// Crusher-3000 interface
			if( Pid == PID_CRUSHER_2000 )
			{
				switch( skill )
				{
					case( SK_REPAIR ):
					{
						if( targetItem.STATE == STATE_OFF )
						{
							if( !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
							{
								LockInPlace( cr, targetItem );
							}

							_InitFurniture( targetItem, true );
							targetItem.Update();
							StartMenuFuriture( cr, targetItem );
							break;
						}
					}
					case( SKILL_PICK_ON_GROUND ):
						StartMenuCrusher( cr, targetItem );
						break;
					default:
						break;
				}
				return true;
            }
		}
	}
	// Wells interface
	if( valid( targetItem ) && Wells.find( targetItem.GetProtoId() ) != -1 )
	{
		StartMenuWell( cr, targetItem );
		return true;
	}
	// Waterpump interface
	if( valid( targetItem ) && targetItem.GetProtoId() == PID_OBJECT_WATERPUMP )
	{
		StartMenuWaterPump( cr, targetItem );
		return true;
	}
    // Doors or containers
    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || ( targetItem.GetType() == ITEM_TYPE_CONTAINER && !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) ) ) && skill != SK_REPAIR )
	{
		if( !isSentientCritter && ( targetItem.GetType() == ITEM_TYPE_DOOR || ( targetItem.GetType() == ITEM_TYPE_CONTAINER && !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) && targetItem.Proto.Container_Changeble ) ) )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
			return false;
		}

		UseSkillOnLocker( cr, targetItem, skill );
		return true;
	}
	// Check for all skills for critter
    switch( skill )
    {
		case( SKILL_PICK_ON_GROUND ):
		{
			// Scenery
			if( valid( targetScen ) )
			{
				// washing
				if( water_sources.find( targetScen.ProtoId ) != -1 )
				{
					Cleaning( cr, 0, targetScen.ProtoId );
					return true;
				}
				// cooking
				if( isSentientCritter && CanCook( targetScen ) )
				{
					AskCooking( cr );
					return true;
				}
			}

			// Items
			if( valid( targetItem ) )
			{
				uint16 Pid = targetItem.GetProtoId();
				// Boom
				if( Pid == PID_TNT_PACK_ACTIVE )
				{
					Explode( targetItem );
					return true;
				}
				// Stationary radio station
				if( FLAG( targetItem.Flags, ITEM_RADIO ) && !FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
				{
					if( cr.IsPlayer() )
					{
						EditRadioSettings( cr, targetItem.Id );
					}
					return true;
				}
				// Open fire cooking
				if( ( Pid == PID_FIREPLACE2 || Pid == PID_CHOPPED_FIREWOOD ) && targetItem.Val0 >= 1 )
				{
					AskCooking( cr );
					return true;
				}
				// Locked in place firesource
				if( Pid == PID_FIREBARREL || Pid == PID_BRAZIER )
				{
					StartMenuFireBarrel( cr, targetItem );
					return true;
				}
				// Power generator
				if( Pid == PID_COAL_POWERGEN )
				{
					StartMenuPowerGen( cr, targetItem );
					return true;
				}
				// Light Switches
				if( Pid == PID_SWITCH1_DIR2 || Pid == PID_SWITCH1_DIR3 || Pid == PID_SWITCH2_DIR2 || Pid == PID_SWITCH2_DIR3 || Pid == PID_SWITCH3_DIR2 || Pid == PID_SWITCH3_DIR3 )
				{
					UseLightSwitch( cr, targetItem );
					return true;
				}
				// Gather wildplant
				if( Wildplants.find( Pid ) != -1 )
				{
					PickPlant( cr, targetItem );
					return true;
				}
				// Take sandbag
				if( Sandbags.find( Pid ) != -1 )
				{
					TakeSandbag( cr, targetItem );
					return true;
				}
				// seeds
				if( Wildplants.find( Pid ) != -1 )
				{
					targetItem.PLANT_GROW_STAGE = 0;
					targetItem.PLANT_BED_DNA = 0;
					targetItem.PLANT_RESOURCE_CAPACITY = 0;
					if( targetItem.PLANT_EVENT != 0 )
					{
						EraseTimeEvent( targetItem.PLANT_EVENT );
						targetItem.PLANT_EVENT = 0;
					}
					targetItem.PLANT_WATERING = 0;
					targetItem.PLANT_FERTILITY = 0;

					PickItem( cr, targetItem );
					ChangeCritterSpeed( cr );
					return true;
				}
				// Any other item
				PickItem( cr, targetItem );
				ChangeCritterSpeed( cr );
				return true;
			}
			return true;
		}

		case( SKILL_PUT_CONT ):
		{
			if( cr.ParamBase[ ST_LAST_CONT_ID ] == 0 )
			{
				return false;
			}

			Item@ cont = GetItem( cr.ParamBase[ ST_LAST_CONT_ID ] );
			if( !valid( cont ) )
			{
				return false;
			}

			if( !canPutItemInContainer( cr, targetItem, cont ) || cont.Id == targetItem.Id )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CONTAINER_TOO_SMALL );
				return true;
			}

			uint16 contPid = cont.GetProtoId();
			//Homebrew pot
			if( contPid == PID_POT_ALCO )
			{
				TransferToPot( cr, targetItem, cont );
				return true;
			}
			//Computer terminal
			if( contPid == PID_TERMINAL )
			{
				TransferToTerminal( cr, targetItem, cont );
				return true;
			}
			//Recorder
			if( contPid == PID_TAPE_RECORDER )
			{
				TransferToRecorder( cr, targetItem, cont );
				return true;
			}
			// bootlegging still
			if( contPid == PID_STILL_S )
			{
				TransferToStill( cr, targetItem, cont );
				return true;
			}
			// hand of cards
			if( contPid == PID_CARDS_HAND )
			{
				TransferToCardsHand( cr, targetItem, cont );
				return true;
			}
			//Cart picture update
			CheckCartPicMap( cont );
			uint[] val = { cont.Id, cr.Id };
			CreateTimeEvent( AFTER( REAL_MS( 10 ) ), "e_UpdateContainer", val, true );
			ChangeCritterSpeed( cr );
			return false;
		}

		case( SKILL_TAKE_CONT ):
		{
			uint16 Pid = targetItem.GetProtoId();
			if( targetItem.Accessory == ACCESSORY_CONTAINER || targetItem.CritId == cr.Id )
			{
				if( Cards.find( Pid ) != -1 )
				{
					cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_CARD );
				}
				else
				{
					uint type = targetItem.GetType();
					switch( type )
					{
						case( ITEM_TYPE_ARMOR ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_ARMOR );
							break;
						case( ITEM_TYPE_DRINK ):
						case( ITEM_TYPE_FOOD ):
						case( ITEM_TYPE_CONTAINER ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_CONTAINER, "$proto@msg item " +  ( targetItem.Proto.ProtoId * 100 ) + "@" );
							break;
						case( ITEM_TYPE_WEAPON ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_WEAPON );
							break;
						case( ITEM_TYPE_AMMO ):
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_AMMO );
							break;
						default:
							cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_TAKE_SMTH );
							break;
					}
				}
			}

			if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CONTAINER )
			{
				int full_weight = ItemsWeight( targetItem, cr.ItemTransferCount() );
				int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - ItemsWeight( cr );
				if( !isGM( cr ) && freeWeight < full_weight )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TOO_HEAVY_FOR_YOU );
					Item@ cont = GetItem( targetItem.ContainerId );
					if( valid( cont ) )
					{
						ShowContainer( cr, cont, TRANSFER_FAR_CONT );
					}
					return true;
				}
			}

			if( cr.ParamBase[ ST_LAST_CONT_ID ] == 0 )
			{
				return false;
			}

			Item@ cont = GetItem( cr.ParamBase[ ST_LAST_CONT_ID ] );
			if( !valid( cont ) )
			{
				return false;
			}

			uint16 contPid = cont.GetProtoId();

			if( contPid == PID_POT_ALCO )
			{
				TransferFromPot( cr, targetItem, cont );
				return true;
			}

			if( contPid == PID_TERMINAL )
			{
				TransferFromTerminal( cr, targetItem, cont );
				return true;
			}

			if( contPid == PID_TAPE_RECORDER )
			{
				TransferFromRecorder( cr, targetItem, cont );
				return true;
			}

			if( contPid == PID_CARDS_HAND )
			{
				TransferFromCardsHand( cr, targetItem, cont );
				return true;
			}

			CheckCartPicMap( cont ); // changes cart picture
			uint[] val = { cont.Id, cr.Id };
			CreateTimeEvent( AFTER( REAL_MS( 10 ) ), "e_UpdateContainer", val, true );
			ChangeCritterSpeed( cr );
			return false; // in order for items to transfer return false!
		}

		case( SKILL_TAKE_ALL_CONT ):
		{
			//Disabled
			return false;
		}

		case( SKILL_LOOT_CRITTER ):
		{
			if( valid( targetCr ) )
			{
				cr.Action( ACTION_PICK_CRITTER, 0, null );
				if( isGM( cr ) )
				{
					hotkey_critter_anim( cr, 5 );
					ShowContainer( cr, targetCr, TRANSFER_CRIT_LOOT );
					return true;
				}
				
				cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_EMOTE_INSPECTS );
				if( !ltp_inspect_inited )
				{
					ltp_inspect_init();
				}
				
				cr.ParamBase[ ST_LTP_SEQUENCE_WAIT ] = CRITTER_LOOT_DELAY * 2;
				cr.ParamBase[ ST_LTP_SEQUENCE ] = 0;
				StartProcess( cr, LTP_INSPECT, 0, targetCr.Id, 0, cr.Param[ ST_LTP_SEQUENCE_WAIT ] );
				cr.SetAnims( COND_LIFE, 0, ANIM2_CROUCH );
			}
			
			return true;
		}

		case( SKILL_PUSH_CRITTER ):
		{
			if( !valid( targetCr ) )
			{
				return false;
			}

			cr.Action( ACTION_PICK_CRITTER, 2, null );
			cr.StatBase[ ST_CURRENT_AP ] -= 5000;

			if( ( targetCr.IsPlayer() || ( targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers( null ) == 0 ) ) && targetCr.Mode[MODE_NO_PUSH] == 0 && targetCr.MoveToDir( cr.Dir ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_PUSH_TARGET );
				SayLog( cr, crInfo( cr ) + " pushes " + crInfo( targetCr ) + "." );
			}
			else
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TARGET_RESIST );
				SayLog( cr, crInfo( cr ) + " can't push " + crInfo( targetCr ) + "." );
			}

			return true;
		}

		case( SK_FIRST_AID ):
		{
			if( !isSentientCritter )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}

			bool alreadyAllowed = false;
			if( valid( targetItem ) || valid( targetScen ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( !valid( targetCr ) )
			{
				@targetCr = cr;
				alreadyAllowed = true;
			}

			if( targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( targetCr.IsDead() )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_TARGET_DEAD );
				return true;
			}

			if( cr.IsPlayer() && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
				return true;
			}

			AskFirstAid( cr, targetCr, alreadyAllowed );
			return true;
		}

		case( SK_DOCTOR ):
		{
			if( !isSentientCritter )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return true;
			}

			if( valid( targetItem ) || valid( targetScen ) )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( !valid( targetCr ) )
			{
				@targetCr = cr;
			}

			if( targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
				return true;
			}

			if( targetCr.IsDead() )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_TARGET_DEAD );
				return true;
			}

			if( cr.IsPlayer() && cr.Timeout[ TO_SK_DOCTOR ] > 0 )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
				return true;
			}

			if( targetCr.IsKnockout() )
			{
				ProccessDoctorSkill( cr, targetCr, true );
			}
			else
			{
				ProccessDoctorSkill( cr, targetCr, false );

			}
			
			return true;
		}

		case( SK_SCIENCE ):
		{
			if( !isSentientCritter )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}
			
			if( valid( targetItem ) )
			{
				if( targetItem.Accessory == ACCESSORY_CRITTER )
				{
					StartMenuAskAction( cr, targetItem );
					return true;
				}
				
				uint16 tiPid = targetItem.GetProtoId();
				if( tiPid == PID_REMOTE_DETONATOR || tiPid == PID_SLAVE_COLLAR_SWITCH || ( tiPid == PID_SLAVE_COLLAR && targetItem.BONDAGE_STATE == BONDAGE_STATE_OFF ) )
				{
					int[] data = {0};
					cr.RunClientScript( "client_screen_numberpad@ShowScreen", targetItem.Id, 0, 0, "Input radio frequency", data );
					return true;
				}
			}

			break;
		}

		case( SK_REPAIR ):
		{
			if( !isSentientCritter )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
				return false;
			}

			if( onSelf )
			{
				@targetCr = cr;
			}

			if( valid( targetCr ) )
			{
				if( targetCr.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
				{
					if( cr.Timeout[ TO_SK_REPAIR ] > 0 )
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
						return true;
					}

					robotRepairSkill( cr, targetCr, false );
					ChangeCritterSpeed( targetCr );
					cr.TimeoutBase[ TO_SK_REPAIR ] = REPAIR_TIMEOUT( cr );
					return true;

				}
				else
				{
					if( onSelf )
					{
						return false;
					}
					
					if( targetCr.IsNpc() && targetCr.IsLife() && !isGM( cr ) )
					{
						return false;
					}
					
					if( cr.Timeout[ TO_SK_STEAL ] > 0 && !isGM( cr ) && targetCr.ModeBase[ MODE_NO_STEAL ] == 0 )
					{
						if( !targetCr.IsDead() )
						{
							targetCr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_RESISTS_TAKE_ITEM );
							targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_RESIST_ITEM );
						}
						
						cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_TRIES_TAKE_ITEM);
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TIRED_TAKE_ITEM );
						CrimeLog( cr, crInfo( cr ) + " is trying to take item from " + crInfo( targetCr ) );
						return true;
					}
					else if( !isGM( cr ) && targetCr.ModeBase[ MODE_NO_STEAL ] != 0 )
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_TARGET_NO_LOOT );
						return true;
					}
					else if( targetCr.IsKnockout() || targetCr.IsDead() || CantResist( targetCr ) )
					{
						bool empty_slots = true;
						Item@ hand = _CritGetItemHand( targetCr );
						Item@ hand_ext = _CritGetItemHandExt( targetCr );
						Item@ misc = _CritGetItemMisc( targetCr );
						Item@ head = _CritGetItemHead( targetCr );
						Item@ back = _CritGetItemBack( targetCr );
						
						if( valid( hand ) )
						{
							if( !HandsTied( cr ) )
							{
								targetCr.MoveItem( hand.Id, hand.GetCount(), SLOT_INV );
								CrimeLog( cr, crInfo( cr ) + " removes hand item from " + crInfo( targetCr ) );
							}
							
							empty_slots = false;
						}
						
						if( valid( hand_ext ) )
						{
							if( !HandsTied( cr ) )
							{
								targetCr.MoveItem( hand_ext.Id, hand_ext.GetCount(), SLOT_INV );
								CrimeLog( cr, crInfo( cr ) + " removes hand_ext item from " + crInfo( targetCr ) );
							}
							
							empty_slots = false;
						}

						if( valid( misc ) )
						{
							if( valid( misc ) )
							{
								if( misc.Proto.Item_Subtype != ITEM_SUBTYPE_BONDAGE && misc.BONDAGE_STATE != BONDAGE_STATE_ON )
								{
									targetCr.MoveItem( misc.Id, misc.GetCount(), SLOT_INV );
									CrimeLog( cr, crInfo( cr ) + " removes misc item from " + crInfo( targetCr ) );
								}
							}
							
							empty_slots = false;
						}

						if( valid( head ) )
						{
							if( valid( head ) )
							{
								if( head.Proto.Item_Subtype != ITEM_SUBTYPE_BONDAGE && head.BONDAGE_STATE != BONDAGE_STATE_ON )
								{
									targetCr.MoveItem( head.Id, head.GetCount(), SLOT_INV );
									CrimeLog( cr, crInfo( cr ) + " removes head item from " + crInfo( targetCr ) );
								}
							}
							
							empty_slots = false;
						}

						if( valid( back ) )
						{
							if( valid( back ) )
							{
								targetCr.MoveItem( back.Id, back.GetCount(), SLOT_INV );
								CrimeLog( cr, crInfo( cr ) + " removes back item from " + crInfo( targetCr ) );
							}
							
							empty_slots = false;
						}
						
						if( !empty_slots )
						{
							cr.SayMsg( SAY_EMOTE, TEXTMSG_TEXT, STR_EMOTE_TAKE_ITEM );
							targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_CANT_RESIST_ITEM );
						}
						
						if( empty_slots )
						{
							Item@ armor = _CritGetItemArmor( targetCr );
							if( valid( armor ) )
							{
								TryToTakeArmor( cr, targetCr, armor );
							}
						}
					}
					
					if( !isGM( cr ) )
					{
						cr.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 15 );
					}
						
					return true;
				}
			}
			
			if( valid( targetItem ) )
			{
				uint16 tiPid = targetItem.GetProtoId();
				//Explosives
				if( tiPid == PID_TNT_PACK_ACTIVE || tiPid == PID_ACTIVE_DYNAMITE )
				{
					Explode( targetItem );
					return true;
				}
				//X3 container stack decrease
				if( ContainersX3.find( tiPid ) != -1 )
				{
					TakeX3Container( cr, targetItem );
					return true;
				}
				//X2 container stack decrease
				if( ContainersX2.find( tiPid ) != -1 )
				{
					TakeX2Container( cr, targetItem );
					return true;
				}
				// take barrel
				if( Barrels.find( tiPid ) != -1 )
				{
					TakeBarrel( cr, targetItem );
					return true;
				}
				//Move of locked furniture
				if( ( tiPid == PID_FIREBARREL || tiPid == PID_BRAZIER ) && targetItem.Val0 == 0 )
				{
					LockInPlace( cr, targetItem );
					return true;
				}
				//Dog bowl
				if( tiPid == PID_DOG_BOWL )
				{
					LockInPlace( cr, targetItem );
					return true;
				}
				//Cards deck shuffle
				if( tiPid == PID_CARDS_DECK )
				{
					ShuffleDeck( cr, targetItem );
					return true;
				}
				//Cards in hand actions
				if( tiPid == PID_CARDS_HAND )
				{
					CheckCardsHand( cr, targetItem );
					return true;
				}
				//Single gamble card action
				if( Cards.find( tiPid ) != -1 )
				{
					StartMenuCard( cr, targetItem );
					return true;
				}
				//General attempt at repair
				if( targetItem.IsDeteriorable() || targetItem.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
				{
					TryRepairItem( cr, targetItem );
					return true;
				}
			}
			
			break;
		}

		case( SK_SNEAK ):
		{
			if( cr.Param[ CR_SNEAKING ] == 0 )
			{
				if( cr.IsPlayer() && cr.Timeout[ TO_SNEAK ] > 0 )
				{
					cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
					return true;
				}
				else
				{
					cr.ParamBase[ CR_SNEAKING ] = 1;
					uint[] index;
					if( cr.GetTimeEvents( CTE_SNEAKING, index, null, null ) == 0 )
					{
						cr.AddTimeEvent( "cte_sneaking", REAL_MS( 500 ), CTE_SNEAKING, 0 );
					}
				}
			}
			else
			{
				cr.TimeoutBase[ TO_SNEAK ] = SNEAK_TIMEOUT( cr );
				cr.ParamBase[ CR_SNEAKING ] = 0;
			}

			LookDataRefresh( cr );
			ChangeCritterSpeed( cr );
			return true;
		}

		case( SK_STEAL ):
		{
			if( cr.IsPlayer() && cr.Timeout[ TO_SK_STEAL ] > 0 )
			{
				cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SK_COOLDOWN );
				return true;
			}

			if( valid( targetItem ) )
			{
				UseSkillOnLocker( cr, targetItem, SK_STEAL );
				return true;
			}

			if( valid( targetCr ) )
			{
				if( HandsTied( targetCr ) )
				{
					CrimeLog( cr, crInfo( cr ) + " looks at inventory of: " + crInfo( targetCr ) + " who is tied up." );
				}
				else if( targetCr.IsDead() )
				{
					CrimeLog( cr, crInfo( cr ) + " look into inventory of dead: " + crInfo( targetCr ) + "." );
				}
				else
				{
					CrimeLog( cr, crInfo( cr ) + " checks inventory of: " + crInfo( targetCr ) + ".");
					cr.TimeoutBase[ TO_SK_STEAL ] = STEAL_TIMEOUT( cr );
					cr.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
					cr.StatBase[ ST_STEAL_COUNT ] = 0;

					if( !isGM( cr ) )
					{
						int InvCheckCalculation = ( ( cr.Skill[ SK_STEAL ] / 3 ) + cr.Stat[ ST_PERCEPTION ] ) - ( ( targetCr.Skill[ SK_STEAL ] / 30 ) + targetCr.Stat[ ST_PERCEPTION ] );
						int roll = Random( 1, 100 );
						//Log("InvCheckCalculation" + InvCheckCalculation);
						if( roll >= InvCheckCalculation )
						{
							CrimeLog( targetCr, crInfo( targetCr ) + " detected his inventory being checked!" );
							targetCr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_STEAL_NOTIFICATION );
						}
					}
				}

				ShowContainer( cr, targetCr, TRANSFER_CRIT_STEAL );
				return true;
			}
			break;
		}

		case( SK_LOCKPICK ):
		{
			if( onSelf || valid( targetCr ) )
			{
				if( onSelf )
				{
					@targetCr = cr;
				}

				Item@ gagItm = _CritGetItemHead( targetCr );
				if( valid( gagItm ) )
				{
					if( gagItm.Proto.Item_Subtype == ITEM_SUBTYPE_BONDAGE )
					{
						TryRemoveGag( cr, targetCr, gagItm );
						return true;
					}
				}

				@gagItm = _CritGetItemHand( targetCr );
				if( valid( gagItm ) )
				{
					if( gagItm.GetProtoId() == PID_HANDCUFFS )
					{
						TryLockpickBondage( cr, targetCr );
						return true;
					}
				}

				@gagItm = _CritGetItemMisc( targetCr );
				if( valid( gagItm ) )
				{
					if( gagItm.GetProtoId() == PID_SHACKLES )
					{
						TryLockpickBondage( cr, targetCr );
						return true;
					}
				}
			}
			else if( valid( targetItem ) )
			{
				if( targetItem.GetType() == ITEM_TYPE_CONTAINER && FLAG( targetItem.LockerCondition, LOCKER_LOCKED ) )
				{
					if( targetItem.Accessory == ACCESSORY_CRITTER )
					{
						cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ITEM_MUST_NOT_BE_INVENTORY );
						return false;
					}

					UseSkillOnLocker( cr, targetItem, SK_LOCKPICK );
					return true;
				}
			}
			break;
		}

		case( SK_TRAPS ):
		{
			if( valid( targetItem ) )
			{
				uint16 pid = targetItem.GetProtoId();
				if( ( pid == PID_ACTIVE_DYNAMITE || pid == PID_TNT_PACK_ACTIVE ) )
				{
					ExplosivesDisarm( cr, targetItem );
					return true;
				}
			}
			break;
		}

		case( SK_SEX ):
		{
			cr.ParamBase[ CR_INIT_SEX ] = 0;
			if( valid( targetCr ) && !onSelf )
			{
				StartMenuSexPanel( cr, targetCr );
				return true;
			}

			if( valid( targetItem ) )
			{
				if( targetItem.GetProtoId() == PID_BLOW_UP_DOLL )
				{
					start_doll_sex( cr, targetItem );
					return true;
				}
			}
			break;
		}

		case( SK_HUNTING ):
		{
			cr.ParamBase[ CR_INIT_DEVOUR ] = 0;
			if( !IsHuman( cr ) )
			{
				if( valid( targetCr ) && targetCr.IsDead() && !onSelf )
				{
					start_devour( cr, targetCr );
					return true;
				}
			}

			break;
		}

		default:
		{
			break;
		}
	}
	return false;
}

void Say( Critter@ target, uint type, string text )
{
	if( valid( target ) )
	{
		target.Say( type, text );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo )
{
	cr.ParamBase[ CR_IS_WINDUPED ] = 0;
	cr.ParamBase[ CR_AUTO_ROUNDS_FIRED ] = 0;
	cr.SetAnims( COND_LIFE, 0, ANIM2_IDLE );
	if( cr.Mode[ MODE_UNLIMITED_AMMO ] > 0 )
	{
		FindAmmo( cr, weapon, 0 );
	}
	else
	{
		ReloadWeapon( cr, weapon, ammo );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
void critter_init( Critter& cr, bool firstTime )
{
	if( firstTime )
    {
        if( cr.IsPlayer() )
        {
            GameVar@ TotalPlayers = GetGlobalVar( GVAR_total_players );
            if( TotalPlayers.GetValue() < int( cr.Id ) )
			{
                TotalPlayers.opAssign( cr.Id );
            }
			// Input: 7 special, 3 tag skills, 2 traits, age, gender
            uint traits = 0;
            for( uint i = TRAIT_BEGIN; i <= TRAIT_END; i++ )
            {
                if( cr.TraitBase[ i ] != 0 && traits < 2 )
                {
                    cr.TraitBase[ i ] = 1;
                    traits++;
                }
                else
				{
                    cr.TraitBase[ i ] = 0;
				}
			}

            if( cr.StatBase[ ST_GENDER ] < 0 || cr.StatBase[ ST_GENDER ] > 1 )
			{
                cr.StatBase[ ST_GENDER ] = 0;
            }

			if( cr.StatBase[ ST_AGE ] < 14 || cr.StatBase[ ST_AGE ] > 80 )
			{
                cr.StatBase[ ST_AGE ] = 25;
            }

			for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
			{
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );
			}

            if( ( cr.StatBase[ ST_STRENGTH ] + cr.StatBase[ ST_PERCEPTION ] + cr.StatBase[ ST_ENDURANCE ] +
                  cr.StatBase[ ST_CHARISMA ] + cr.StatBase[ ST_INTELLECT ] + cr.StatBase[ ST_AGILITY ] + cr.StatBase[ ST_LUCK ] ) != __StartSpecialPoints )
            {
                for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
				{
                    cr.StatBase[ i ] = 5;
				}
			}

            cr.StatBase[ ST_EMP_RESIST ] = 500;
        }

        if( cr.TagSkill[ TAG_SKILL1 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL1 ] > int(SKILL_END) )
		{
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
		}

        if( cr.TagSkill[ TAG_SKILL2 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL2 ] > int(SKILL_END) )
		{
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
		}

        if( cr.TagSkill[ TAG_SKILL3 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL3 ] > int(SKILL_END) )
		{
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;
		}

        if( cr.TagSkill[ TAG_SKILL1 ] == cr.TagSkill[ TAG_SKILL2 ] )
		{
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
		}

        if( cr.TagSkill[ TAG_SKILL2 ] == cr.TagSkill[ TAG_SKILL3 ] )
		{
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
		}

        if( cr.TagSkill[ TAG_SKILL3 ] == cr.TagSkill[ TAG_SKILL1 ] )
		{
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;
		}

        CritterGenerate( cr );
        cr.StatBase[ ST_CURRENT_HP ] = ( cr.Stat[ ST_MAX_LIFE ] + cr.Stat[ ST_MAX_LIFE_EXT ] );

        cr.StatBase[ ST_CURRENT_AP ] = cr.Stat[ ST_ACTION_POINTS ] * 100;

		cr.StatBase[ ST_SPEECH_VOLUME ] = 25;
		cr.StatBase[ ST_LTP_SEQUENCE ] = -1;

        for( uint i = REPUTATION_BEGIN; i < = REPUTATION_END; i++ )
		{
			cr.ParamBase[i]=int( 0x80000000 );
		}

        if( cr.IsPlayer() )
        {
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
			{
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );
			}

            cr.StatBase[ ST_REPLICATION_COST ] = 100;
            cr.StatBase[ ST_REPLICATION_MONEY ] = 0;
            cr.StatBase[ ST_REPLICATION_COUNT ] = 0;
            cr.StatBase[ ST_TEAM_ID ] = 1;
            cr.StatBase[ ST_DAMAGE_TYPE ] = DAMAGE_NORMAL;
			cr.ParamBase[ CR_AVATAR_RENDER_MODE ] = 1;

            skin( cr, cr.StatBase[ ST_BODY_TYPE ] );
            cr.StatBase[ ST_BODY_TYPE ] = 0;

			SETFLAG( cr.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_RADIO_SAFETY );
			SETFLAG( cr.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_NPC_ICONS );
			//SETFLAG( cr.ParamBase[ PLAYER_FLAGS ], PLAYER_FLAG_RTS );
		}
        else
        {
            cr.ChangeCrType( cr.StatBase[ ST_BASE_CRTYPE ] );
		}
    }
    else
    {
		if( cr.IsPlayer() )
		{
			Item@[] stuff;
			Item@ flashlight = null;
			cr.GetItems( -1, stuff );
			for( uint i = 0, len = stuff.length(); i < len; i++ )
			{
				@flashlight = stuff[i];
				if( valid( flashlight ) )
				{
					uint16 flashlight_pid = flashlight.GetProtoId();
					if( ( flashlight_pid == PID_FLASHLIGHT_ON || flashlight_pid == PID_FLASHLIGHT_HELMET || flashlight_pid == PID_FLASHLIGHT_OFF || flashlight_pid == PID_10MM_PISTOL_FLASHLIGHT ) && flashlight.ITEM_CHARGE == 0 )
					{
						UNSETFLAG( flashlight.Flags, ITEM_LIGHT );
						UNSETFLAG( flashlight.Flags, ITEM_COLORIZE );
						UNSETFLAG( flashlight.Flags, ITEM_COLORIZE_INV );
						flashlight.ITEM_STATE = 0;
						if( flashlight.ITEM_EVENT > 0 )
						{
							EraseTimeEvent( flashlight.ITEM_EVENT );
							flashlight.ITEM_EVENT = 0;
						}

						flashlight.Update();
					}
				}
			}
			stuff.resize( 0 );
		}

        // Current skin validation
        Item@ armor = _CritGetItemArmor( cr );
        if( cr.Stat[ ST_BASE_CRTYPE ] == 0 )
		{
            cr.StatBase[ ST_BASE_CRTYPE ] = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        }

		if( !valid( armor ) )
        {
            uint crType = cr.Stat[ ST_BASE_CRTYPE ];
            if( crType == 0 )
			{
                crType = cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F;
            }

			cr.StatBase[ ST_BASE_CRTYPE ] = crType;
            if( cr.CrType != crType )
			{
                cr.ChangeCrType( crType );
			}
		}

        // Armor perk validation
        if( !valid( armor ) && cr.Stat[ ST_CURRENT_ARMOR_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_ARMOR_PERK ] )
            {
				case( ARMOR_PERK_POWERED ):
				{
					cr.StatBase[ ST_STRENGTH_EXT ] -= 3;
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 30;
					break;
				}
				case( ARMOR_PERK_COMBAT ):
				{
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 20;
					break;
				}
				case( ARMOR_PERK_ADVANCED_I ):
				{
					cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 60;
					break;
				}
				case( ARMOR_PERK_ADVANCED_II ):
				{
					cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 75;
					break;
				}
				case( ARMOR_PERK_CHARISMA ):
				{
					if( cr.Stat[ ST_CHARISMA ] > 1 )
					{
						cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					}
					break;
				}
				case( ARMOR_PERK_ANTIRAD ):
				{
					cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 70;
					break;
				}
				case( ARMOR_PERK_VERY_COOL ):
				{
					if( cr.Stat[ ST_CHARISMA ] > 1 )
					{
						cr.StatBase[ ST_CHARISMA_EXT ] -= 2;
					}
					break;
				}
				default:
					break;
            }
            cr.StatBase[ ST_CURRENT_ARMOR_PERK ] = 0;
        }
        // Head Item Perk validation
		Item@ head_item = _CritGetItemHead( cr );
        if( !valid( head_item ) && cr.Stat[ ST_CURRENT_HEAD_ITEM_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_HEAD_ITEM_PERK ] )
            {
				case( HEAD_PERK_COOL ):
				{
					if( cr.Stat[ ST_CHARISMA ] > 1 )
					{
						cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					}
					
					break;
				}
				case( HEAD_PERK_VERY_COOL ):
				{
					if( cr.Stat[ ST_CHARISMA ] > 1 )
					{
						cr.StatBase[ ST_CHARISMA_EXT ] -= 2;
					}
					
					break;
				}
				case( HEAD_PERK_LUCKY_CHARM ):
				{
					cr.StatBase[ ST_LUCK_EXT ] -= 1;
					break;
				}
				case( HEAD_PERK_COOL_LUCKY_CHARM ):
				{
					if( cr.Stat[ ST_CHARISMA ] > 1 )
					{
						cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
					}
	
					cr.StatBase[ ST_LUCK_EXT ] -= 1;
					break;
				}
			}
            cr.StatBase[ ST_CURRENT_HEAD_ITEM_PERK ] = 0;
		}

        // Clear timeouts if too long (happens when saves got removed)
        for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
		{
            if( i != TO_BATTLE && cr.Timeout[ i ] > int( MAXIMUM_TIMEOUT ) )
			{
                cr.TimeoutBase[ i ] = __FullSecond;
			}
		}
        // Erase zero time events
        cr.EraseTimeEvents( 0 );
    }

	if( cr.IsPlayer() )
	{
		cr.ModeBase[ MODE_HIDE ] = 0;
		cr.StatBase[ ST_UNSPENT_PERKS ] = 0;
	}

    ChangeCritterSpeed( cr );

    manager_critter_init( cr, firstTime );

    DllCritterInit( cr, firstTime );

	//FoRP - logout on global == dead
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		Location@ loc = GetLocationByPid( LOCATION_Deadloc, 0 );
		if( !valid( loc ) )
		{
			Log( "Location does not exist!" );
			return;
		}

		Map@ map2 = loc.GetMapByIndex( 0 );
		if( !valid( map2 ) )
		{
			Log( "Map does not exist!" );
			return;
		}
		cr.SetWorldPos( loc.WorldX, loc.WorldY );
		cr.TransitToMap( map2.Id, 170, 130, 6 );
	}

	if( cr.IsPlayer() )
	{
		if( cr.Param[ LAST_LOGIN_DATE ] > 0 && ( __FullSecond - cr.Param[ LAST_LOGIN_DATE ] >= int( 10 * ( __TimeMultiplier * 60 * 60 * 24 ) ) ) )
		{
			uint[] exceptions = { MAP_UTILITY_START, MAP_HEAVEN, MAP_HELL };

			if( exceptions.find( map.GetProtoId() ) == -1 )
			{
				TeleportToGameZone( cr, MAP_snd2_2 );
				cr.AddTimeEvent( "cte_message", REAL_SECOND( 10 ), 0, 0 );
			}
		}
		cr.ParamBase[ LAST_LOGIN_DATE ] = __FullSecond;
	}

	LookDataRefresh( cr );
}

uint cte_message( Critter& cr, int identifier, uint& rate )
{
	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_OFFLINE_TELEPORT );
	return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish( Critter& cr, bool toDelete )
{
	if( cr.IsPlayer() )
	{
		Map@ map = cr.GetMap();
		if( valid( map ) )
		{
			Item@ shadow = map.AddItem( cr.HexX, cr.HexY, PID_SHADOW, 1 );
			if( valid( shadow ) )
			{
				shadow.Val0 = cr.Id;
			}
		}
		uint year =
		cr.ParamBase[ LAST_LOGIN_DATE ] = __FullSecond;
	}
    manager_critter_finish( cr, toDelete );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
void critter_idle( Critter& cr )
{
	CritterRegen( cr );
    manager_critter_idle( cr );
}

void CritterRegen( Critter& cr )
{
	if( cr.IsDead() )
	{
		return;
	}

    if( cr.Stat[ ST_BODY_TYPE ] != BT_ROBOT )
	{
		if( cr.Timeout[ TO_HEALING ] == 0 )
		{
			cr.TimeoutBase[ TO_HEALING ] = __FullSecond + REAL_MINUTE( cr.IsKnockout() ? 2 : 4 );
			if( cr.Mode[ MODE_NO_HEAL ] != 0 )
			{
				return;
			}

			RecoverMaxHP( cr );
			
			int max_life = cr.Param[ ST_MAX_LIFE ];
			if( cr.Stat[ ST_CURRENT_HP ] == max_life )
			{
				return;
			}

			int regen = cr.Stat[ ST_HEALING_RATE ];
			int penalty = 0;
			if( cr.Param[ CR_PAINKILLER ] <= 0 )
			{
				if( FLAG( cr.Stat[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) )
				{
					penalty += 5;
				}

				if( FLAG( cr.Stat[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) )
				{
					penalty += 5;
				}
			}
			
			regen = CLAMP( regen * ( 10 - penalty ) / 10, 1, regen );
            cr.StatBase[ ST_CURRENT_HP ] += regen;
			cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_REGENERATED_HP, "$regen" + regen );

            if( cr.StatBase[ ST_CURRENT_HP ] > max_life )
			{
                cr.StatBase[ ST_CURRENT_HP ] = max_life;
			}
			else
			{
				if( !cr.IsKnockout() )
				{
					cr.StatBase[ ST_HUNGER ] -= regen;
					cr.StatBase[ ST_THIRST ] -= regen;
				}
			}
		}
	}
}

void RecoverMaxHP( Critter& cr )
{
	if( cr.Stat[ ST_CURRENT_HP ] < ( cr.Stat[ ST_MAX_LIFE ] + cr.Stat[ ST_MAX_LIFE_EXT ] ) )
	{
		return;
	}

	if( cr.StatBase[ ST_MAX_LIFE_EXT ] >= 0 )
	{
		cr.StatBase[ ST_HP_RECOVERY ] = 0;
		return;
	}

	bool malnourishment = cr.Stat[ ST_HUNGER ] < 500 || cr.Stat[ ST_THIRST ] < 500;
	bool illness = cr.Param[ ST_POISONING_LEVEL ] != 0 || cr.Param[ ST_RADIATION_LEVEL ] > 100 || cr.Param[ ST_PARALYSIS_LEVEL ] != 0;
	bool wounds = FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_BULLET_OVER ) || FLAG( cr.StatBase[ ST_CRSTATUS ], CR_STATUS_HEAVY_DMG ) || cr.IsInjured();

	if( malnourishment || illness || wounds )
	{
		return;
	}

	int regen = cr.Stat[ ST_HEALING_RATE ];
	
	if( cr.StatBase[ ST_CHARISMA ] >= 5 )
	{
		regen += cr.StatBase[ ST_CHARISMA ];
	}
	
	cr.StatBase[ ST_HP_RECOVERY ] += regen;
	cr.StatBase[ ST_HUNGER ] -= 1;
	cr.StatBase[ ST_THIRST ] -= 1;

	if( cr.Stat[ ST_HP_RECOVERY ] >= MAX_HP_RESTORE_TRIGGER )
	{
		cr.StatBase[ ST_HP_RECOVERY ] = 0;
		cr.StatBase[ ST_MAX_LIFE_EXT ] ++;
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_RESTORED_MAX_HP, "$regen" + 1 );
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead( Critter& cr, Critter@ killer )
{
    Map@ map = cr.GetMap();
    if( !valid( map ) )
	{
        Log( "Critter #" + cr.Id + " was killed on global." );
	}

    if( cr.IsNpc() )
	{
		cr.DropPlanes();
	}

    manager_critter_dead( cr, killer );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn( Critter& cr )
{
    cr.TimeoutBase[ TO_REPLICATION ] = 0;
    if( cr.CrType == 115 )
    {
        uint body = cr.Stat[ ST_BASE_CRTYPE ];
        if( body == 0 )
		{
            body = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
        }
		cr.ChangeCrType( body );
    }

    if( cr.Param[ ST_PARALYSIS_LEVEL ] != 0 )
	{
        DropParalysisInstant( cr );
	}

	if( cr.Param[ ST_POISONING_LEVEL ] != 0 )
	{
        DropPoison( cr );
	}

	if( cr.Param[ ST_RADIATION_LEVEL ] != 0 )
	{
        DropRadiation( cr );
	}

    if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
		{
            DeleteItem( block );
        }
		cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }

    manager_critter_respawn( cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
		int64 time = ServerTime;
		cr.RunClientScript( "fonline_tnf_client.dll@SetServerTime", time & 0xFFFFFFFF, (time >> 32 ) & 0xFFFFFFFF, 0, null, null );
        qmap_critter_in( map.Id, cr );

        uint16 locPid = map.GetLocation().GetProtoId();
        if( LocIsCity( locPid ) )
        {
            GameVar@ lastCityVar = GetLocalVar( LVAR_last_city, cr.Id );
            if( lastCityVar is null )
			{
                return;
            }
			lastCityVar = locPid;
        }
    }
    manager_map_critter_in( map, cr );
	LookDataRefresh( cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
	{
        qmap_critter_out( map.Id, cr );
		cr.RunClientScript( "fofmod@__StopAll", 0, 0, 0, null, null );
    }
    manager_map_critter_out( map, cr );

	LookDataRefresh( cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting( Critter& crFrom, Critter& crTo, bool valUp )
{

}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
bool check_trap_look( Map& map, Critter& cr, Item& trap )
{
    if( isGM( cr ) || uint( trap.TRAP_OWNER ) == cr.Id )
	{
		return true;
    }

	if( trap.GetProtoId() == PID_RADIATION_MARKER )
	{
		return false;
	}

	if( trap.GetProtoId() == PID_GAS_MARKER )
	{
		return false;
	}

	if( FLAG( trap.Flags, ITEM_TRAP ) )
    {
        int baseST = cr.Stat[ ST_PERCEPTION ] / 2;

        int roll = cr.Skill[ SK_TRAPS ] - trap.TrapValue;

        if( roll < -200 )
		{
            roll = -200;
        }

        if( roll > 200 )
		{
            roll = 200;
        }

        roll = int( roll * 0.05f );

        int min_dist = CLAMP( baseST + roll, 1, baseST * 2 );

        int dist = GetDistantion( cr.HexX, cr.HexY, trap.HexX, trap.HexY );

        return dist <= min_dist;
    }
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( Item& item, Critter& cr, Critter& npc, bool sell )
{
	return CalculateItemCost( item, cr, npc, sell );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter( Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc )
{
    if( npc.Mode[ MODE_BARTER_ONLY_CASH ] > 0 )
    {
		uint[][] money_tiers =
		{	{}, // extra tier just in case
			{ PID_DOLLAR_100, PID_DOLLAR_20, PID_DOLLAR_5, PID_BOTTLE_CAPS, PID_GOLDEN_COIN, PID_PREWAR_DOLLAR_100, PID_PREWAR_DOLLAR_20, PID_PREWAR_DOLLAR_5, PID_PREWAR_DOLLAR_1 },
			{ PID_REAL_BOTTLE_CAPS, PID_MORNING_STAR_MINE, PID_KOKOWEEF_MINE_SCRIP },
		};

        for( uint i = 0, j = saleItems.length(); i < j; i++ )
        {
			bool isOk = false;
            Item@ item = saleItems[ i ];
			uint pid = item.GetProtoId();
			if( !valid( item ) )
			{
				continue;
			}
			for( uint k = money_tiers.length() - 1; k > 0; k-- )
			{
				if( money_tiers[k].find( pid ) != -1 )
				{
					if( npc.Mode[ MODE_BARTER_ONLY_CASH ] < int( k ) )
					{
						npc.SayMsg( SAY_NORM_ON_HEAD, TEXTMSG_COMBAT, STR_NEED_BETTER_CASH );
						return false;
					}
					else
					{
						isOk = true;
					}
					break;
				}
			}
			if( !isOk )
			{
				player.SayMsg( SAY_NETMSG, TEXTMSG_COMBAT, STR_NO_BARTER );
				return false;
			}
        }
    }
    GameVar@ loan = GetUnicumVar( UVAR_checkLoan, player.Id, npc.Id );
    if( loan == 1 )
    {
        return false;
    }

    ChangeCritterSpeed( player );
    ChangeCritterSpeed( npc );

    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player craft some items.
// Resources have None accessory and will be deleted after this function if no will be added to some place.
void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter )
{
    int maxDeterioration = 0;
    for( uint i = 0, j = resources.length(); i < j; i++ )
    {
        Item@ item = resources[ i ];
        int   deterioration = GetDeteriorationProcent( item );
        if( deterioration > maxDeterioration )
		{
            maxDeterioration = deterioration;
		}

		if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
		{
			uint ammoCount = item.AmmoCount;
			if( ammoCount > 0 )
			{
				Item@ ammo = crafter.AddItem( item.AmmoPid, ammoCount );
				crafter.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_AMMO_EJECTED, "$proto@msg item " + ( ammo.Proto.ProtoId * 100 + 2 ) + "@$count" + ammoCount );
				item.AmmoCount = 0;
				item.Update();
			}
		}
    }

	crafter.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED );
    for( uint i = 0, j = items.length(); i < j; i++ )
    {
        // Unload weapons
        if( items[ i ].GetType() == ITEM_TYPE_WEAPON && items[ i ].Proto.Weapon_MaxAmmoCount > 0 )
        {
            items[ i ].AmmoCount = 0;
        }

		//Set complexity
		if( items[ i ].GetProtoId() == PID_HANDCUFFS || items[ i ].GetProtoId() == PID_SHACKLES )
		{
			items[ i ].LockerComplexity = crafter.Skill[ SK_LOCKPICK ];
		}

        SetDeterioration( items[ i ], maxDeterioration );
		crafter.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_YOU_CRAFTED_PID, "$proto@msg item " + ( items[ i ].Proto.ProtoId * 100 ) + "@" );
		items[ i ].Update();
	}

	ChangeCritterSpeed( crafter );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.
void player_levelup( Critter& player, uint skillIndex, uint skillUp, uint perkIndex )
{
	if( isDisabledSkill( skillIndex ) )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_DISABLED );
		return;
	}

	if( isFarmingSkill( skillIndex ) )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_RAISED_BY_USE );
		return;
	}

    if( skillIndex >= SKILL_BEGIN && skillIndex <= SKILL_END )
    {
        for( ; skillUp != 0; skillUp-- )
        {
            int skillVal = player.SkillBase[ skillIndex ];
            if( skillVal >= MAX_SKILL_VAL )
			{
                break;
			}

            int needPoints = 1;
            if( skillVal > __SkillModAdd6 )
			{
                needPoints = 6;
            }
			else if( skillVal > __SkillModAdd5 )
			{
                needPoints = 5;
            }
			else if( skillVal > __SkillModAdd4 )
			{
                needPoints = 4;
            }
			else if( skillVal > __SkillModAdd3 )
			{
                needPoints = 3;
            }
			else if( skillVal > __SkillModAdd2 )
			{
                needPoints = 2;
			}

            if( player.StatBase[ ST_UNSPENT_SKILL_POINTS ] < needPoints )
			{
                break;
			}

            skillVal++;
            if( _CritIsTagSkill( player, skillIndex ) && skillVal < MAX_SKILL_VAL )
			{
				skillVal++;
            }
			player.SkillBase[ skillIndex ] = skillVal;
            player.StatBase[ ST_UNSPENT_SKILL_POINTS ] -= needPoints;
        }
    }
    else if( perkIndex >= PERK_BEGIN && perkIndex <= PERK_END )
    {
        if( PerkCheck( player, perkIndex ) )
        {
            player.PerkBase[ perkIndex ]++;
            player.StatBase[ ST_UNSPENT_PERKS ]--;
        }
    }

    player.StatBase[ ST_REPLICATION_COST ] = player.Stat[ ST_LEVEL ] * 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based
void turn_based_begin( Map& map )
{
    // Try end battle
    if( map.TurnBasedRound > 0 )
    {
        uint[] crittersIds;
        map.GetTurnBasedSequence( crittersIds );

        bool continueBattle = false;
        if( crittersIds.length() >= 2 )
        {
            for( uint i = 0, j = crittersIds.length(); i < j; i++ )
            {
                Critter@ cr = ::GetCritter( crittersIds[ i ] );
                if( !( not valid( cr ) || cr.IsDead() ||
                       ( cr.IsNpc() && cr.GetPlanes( AI_PLANE_ATTACK, null ) == 0 ) ||
                       ( cr.IsPlayer() && ( cr.Mode[ MODE_END_COMBAT ] != 0 || cr.Stat[ ST_CURRENT_HP ] < 1 ) ) ) )
                {
                    continueBattle = true;
                    break;
                }
            }
        }

        if( not continueBattle )
		{
            map.EndTurnBased();
		}
	}
}

// Call on end turn-based battle
void turn_based_end( Map& map )
{
}

// Call on every begin and end turn
void turn_based_process( Map& map, Critter& cr, bool beginTurn )
{
}

// Call when need generate turns sequence
void turn_based_sequence( Map& map, Critter@[]& critters, Critter@ firstTurnCrit )
{
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save( uint currentIndex, uint[]& deleteIndexes )
{
    // Keep only current and four last saves
    if( currentIndex == 1 )
    {
        deleteIndexes.resize( 5 );
        for( uint i = 0; i < 5; i++ )
		{
            deleteIndexes[ i ] = 9999 - i;
		}
	}

    else if( currentIndex > 4 )
    {
        deleteIndexes.resize( 1 );
        deleteIndexes[ 0 ] = currentIndex - 5;
    }

	if( !SaveWorldNextVersion() )
	{
		Log( "World save in memory is not actual." );
	}

    qmap_save_all();

    manager_world_save();
}

uint8 NpcCount( Critter@[]& group )
{
    uint8 x = 0;
    for( uint i = 0, len = group.length(); i < len; i++ )
    {
        if( group[ i ] is null or group[ i ].IsPlayer() )
            continue;
        x++;
    }
    return x;
}
// Call on player try register
// Return true to allow, false to disallow
bool player_registration( uint ip, string& name, uint& textMsg, uint& strNum )
{
    return manager_player_registration( ip, name, textMsg, strNum );
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum )
{

	Critter@ player = GetCritter( id );
	if( valid( player ) )
	{
		if( player.ParamBase[ ST_LTP_SEQUENCE ] == 0 )
		{
			player.ParamBase[ ST_LTP_SEQUENCE ] = -1; // defence from gui null ptr
		}
		// character already in game thing
		if( _IsOnline( player ) && player.GetCurrentIp() == ip )
		{
			player.Disconnect();
			textMsg = TEXTMSG_GAME;
			strNum = STR_SAME_IP_LOGIN;
			return false;
		}
	}

    if( !manager_player_login( ip, name, id, textMsg, strNum ) )
	{
        return false;
	}

    if ( !DllPlayerLogin( ip, name, id ) )
	{
        return false;
	}

    if( valid( player ) )
    {
        player.ParamBase[ ST_QMAP ] = 0;
        CreateTimeEvent( __FullSecond + REAL_MS( 100 ), "e_player_after_login", id, false );
    }

    return true;
}

uint e_player_after_login( uint[] @ values )
{
    if( (values is null) || values.length() < 1 )
    {
        Log( "there isn't id in values" );
        return 0;
    }

    uint id = values[ 0 ];

    Critter@ cr = GetCritter( id );

    if( !valid( cr ) )
    {
        Log( "can't get player " + id );
        return 0;
    }

    DllPlayerAfterLogin(cr);

    Map@ map = cr.GetMap();

    if( valid( map ) && uint( cr.Param[ ST_QMAP ] ) == 0 )
    {
        qmap_critter_in( map.Id, cr );
    }

    return 0;
}

void SetStartCrTimeEvent( Critter& cr, string func, uint time, int identifier, uint rate )
{
    if( cr.GetTimeEvents( identifier, null, null, null ) > 0 )
    {
        cr.Say( SAY_NETMSG, "erase" );
        cr.EraseTimeEvents( identifier );
    }

    cr.AddTimeEvent( func, time, identifier, rate );
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess( Critter& player, int access, string& password )
{
    Log( "Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + "." );
    player.StatBase[ ST_ACCESS_LEVEL ] = access;
    return true;
}

bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command )
{
    if( valid( adminPanel ) )
	{
        return true;
	}

    switch( command )
    {
		// ACCESS_CLIENT
		case COMMAND_DELETE_ACCOUNT:
			player.Say( SAY_NETMSG, "Command Disabled." );
			return false;
		case COMMAND_CHANGE_PASSWORD:
		case COMMAND_EXIT:
		case COMMAND_GETACCESS:
		case COMMAND_MYINFO:
			return true;
		// ACCESS_TESTER
		case COMMAND_DROP_UID:
		case COMMAND_PARAM:
		case COMMAND_TOGLOBAL:
		{
			if( player.GetAccess() >= ACCESS_TESTER )
			{
				return true;
			}
			break;
		}
		// ACCESS_MODER
		case COMMAND_ADDITEM:
		case COMMAND_ADDITEM_SELF:
		case COMMAND_ADDLOCATION:
		case COMMAND_ADDNPC:
		case COMMAND_BAN:
		case COMMAND_CHECKVAR:
		case COMMAND_CRITID:
		case COMMAND_DISCONCRIT:
		case COMMAND_GAMEINFO:
		case COMMAND_KILLCRIT:
		case COMMAND_MOVECRIT:
		case COMMAND_RESPAWN:
		case COMMAND_SETVAR:
		{
			if( isGM( player ) )
			{
				return true;
			}
			break;
		}
		// ACCESS_ADMIN
		case COMMAND_LOADDIALOG:
		case COMMAND_LOADLOCATION:
		case COMMAND_LOADMAP:
		case COMMAND_LOADSCRIPT:
		case COMMAND_LOG:
		case COMMAND_RELOAD_CLIENT_SCRIPTS:
		case COMMAND_RELOADAI:
		case COMMAND_RELOADDIALOGS:
		case COMMAND_RELOADLOCATIONS:
		case COMMAND_RELOADMAPS:
		case COMMAND_RELOADSCRIPTS:
		case COMMAND_RELOADTEXTS:
		case COMMAND_REGENMAP:
		case COMMAND_RUNSCRIPT:
		case COMMAND_SETTIME:
		{
			if( player.GetAccess() == ACCESS_ADMIN )
			{
				return true;
			}
			break;
		}
		// Unknown command
		default:
			player.Say( SAY_NETMSG, "Unknown command." );
			return false;
    }

    player.Say( SAY_NETMSG, "Access denied." );
    return false;
}

// inputbox
void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags )
{
    cr.RunClientScript( "client_screen_inputbox@ShowInputBox", int( textLength ), int( flags ), 0, funcName, null );
}

////////////////////////////////////////

void unsafe_swap_invis( Critter& cr, int, int, int, string@, int[]@ )
{
    if( !isGM( cr ) )
	{
		if( !cr.IsBusy() && !cr.IsDead() && cr.StatBase[ST_CURRENT_HP] > 0 )
		{
			cr.Animate( 0, ANIM2_PICKUP, null, false, true );
			cr.Wait( 1500 );
		}
		return;
	}

	cr.ParamBase[ QST_INVIS ] = CLAMP( 1 - cr.ParamBase[ QST_INVIS ], 0, 1 );
	cr.RefreshVisible();
	cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, ( cr.ParamBase[ QST_INVIS ] == 1 ? STR_GM_STEALTH_MODE_ON : STR_GM_STEALTH_MODE_OFF ) );
}

void unsafe_set_aim( Critter& cr, int aim, int, int, string@, int[]@ )
{
   cr.ParamBase[CR_AUTO_AIM] = aim;
}

bool canPutItemInContainer( Critter& cr, Item@ item, Item@ container )
{
	if( !valid( item ) || !valid( container ) )
	{
		return false;
	}

	uint container_pid = container.GetProtoId();
	uint pid = item.GetProtoId();
	uint type = item.GetType();
	uint subtype = item.Proto.Item_Subtype;

	if( container_pid == pid )
	{
		return false;
	}

	if( container_pid == PID_AMMO_PACK )
	{
		if( type != ITEM_TYPE_AMMO )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_PACK_FOR_AMMO );
			return false;
		}
	}

	if( container_pid == PID_AMMO_BELT )
	{
		if( item.Proto.Volume > 25 )
		{
			cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_ITEM_TOO_LARGE );
			return false;
		}
	}

	if( subtype == ITEM_SUBTYPE_FURNITURE || subtype == ITEM_SUBTYPE_VENDING || subtype == ITEM_SUBTYPE_TERMINAL )
	{
		return false;
	}

	uint[] proper_paper_containment_pids =
	{
		PID_HOLODISK, PID_MORNING_STAR_MINE, PID_KOKOWEEF_MINE_SCRIP, PID_GOLDEN_COIN, PID_GOLDEN_JEWELRY, PID_BLUE_PASS_KEY, PID_DOG_TAGS, PID_BOTTLE_CAPS, PID_REAL_BOTTLE_CAPS, PID_TANKER_PASS, PID_TALISMAN, PID_DOLLAR_100, PID_DOLLAR_20, PID_DOLLAR_5,
		PID_RPSTUFF2, PID_RPSTUFF4, PID_PICTURE, PID_PREWAR_DOLLAR_1, PID_PREWAR_DOLLAR_5, PID_PREWAR_DOLLAR_20, PID_PREWAR_DOLLAR_100, PID_BP_COLT6520, PID_BP_MOUSER, PID_BP_45REVOLVER, PID_BP_SIG14MM, PID_BP_DEAGLE, PID_BP_COLT1911, PID_BP_ANACONDA,
		PID_BP_INJECTOR, PID_BP_GAUSSPIS, PID_BP_223PISTOL, PID_BP_SMG10MM, PID_BP_GGUN, PID_BP_P90, PID_BP_G11, PID_BP_DOMINION_ROBUR, PID_BP_DOMINION_LATENS, PID_BP_HUNTING, PID_BP_XL5MM, PID_BP_SNIPER223, PID_BP_AK112, PID_BP_FNFL, PID_BP_TOMMYGUN,
		PID_BP_GAUSSGUN, PID_BP_DOUBLESHOTGUN, PID_BP_COMBSHOTGUN, PID_BP_CAWS, PID_BP_JHUMMER, PID_BP_REMINGTON870, PID_BP_LASPIST, PID_BP_PLASPIST, PID_BP_PULSEPIST, PID_BP_LASRIFLE, PID_BP_PLASRIFLE, PID_BP_PULSERIFLE, PID_BP_GATLING, PID_BP_AUCUSTIC,
		PID_BP_EMP_PROBOINIK, PID_BP_FLAMER, PID_BP_MINIGUN, PID_BP_BAZOOKA, PID_BP_VINDICATOR, PID_BP_M60, PID_BP_LSW, PID_BP_BOZAR, PID_BP_AUTOCANNON, PID_BP_M32, PID_BP_RAIDER_CANNON, PID_BP_SHOCKER, PID_BP_PFIST, PID_BP_SSLEDGE, PID_BP_RIPPER,
		PID_BP_HAND_SAW, PID_BP_ESSENCE, PID_BP_FRAG_GRENADE, PID_BP_PLAS_GRENADE, PID_BP_EMP_GRENADE, PID_BP_THROW_KNIFE, PID_BP_40MM, PID_BP_FRAGMIS, PID_BP_KRAKMIS, PID_BP_CASELESS, PID_BP_GAUSAMMO, PID_BP_FREACTOR, PID_BP_TESLA_ARMOR, PID_BP_CA_ARMOR,
		PID_BP_PA_ARMOR, PID_BP_APA_ARMOR, PID_BP_HOUND_ARMOR, PID_BP_DEFIB, PID_BP_FPRESS, PID_BP_CENTRF, PID_BP_MENTATS, PID_BP_BUFFOUT, PID_BP_RADAWAY, PID_BP_RAD_LX, PID_BP_PSYCHO, PID_BP_EXTRACT, PID_BP_HYPO_POISON, PID_BP_TRAUMATIN,
		PID_RUIN_MAP, PID_RAIDERS_MAP, PID_RANGER_MAP, PID_MAP, PID_PACKAGE_CHEK,
		PID_HANDWRITINGS, PID_WALLET, PID_CRAFT_RECIPES, PID_PASSPORT, PID_LETTER, PID_POSTMAN_LETTER, PID_PAPERS_JAMMED,
		PID_ELRON_FIELD_REP, PID_CLIPBOARD, PID_FLIST08, PID_FLIST09, PID_StrpBlt, PID_mgzn01, PID_CONFIRMATION_FORM
	};

	uint[] paper_container_pids =
	{
		PID_HANDWRITINGS, PID_WALLET, PID_CRAFT_RECIPES, PID_PASSPORT, PID_LETTER, PID_POSTMAN_LETTER, PID_PAPERS_JAMMED, PID_ELRON_FIELD_REP, PID_CLIPBOARD, PID_FLIST08, PID_FLIST09, PID_StrpBlt, PID_mgzn01, PID_MAILBOX
	};

	if( ( proper_paper_containment_pids.find( pid ) == -1 && type != ITEM_TYPE_KEY ) && paper_container_pids.find( container_pid ) != -1 )
	{
		return false;
	}

	uint[] key_container_pids =
	{
		PID_KEY_BUNCH, PID_FNKEYBT
	};

	if( type != ITEM_TYPE_KEY && key_container_pids.find( container_pid ) != -1 )
	{
		return false;
	}

	if( pid == container_pid )
	{
		return false;
	}

	if( type == ITEM_TYPE_CONTAINER )
	{
		if( !FLAG( container.Flags, ITEM_CAN_PICKUP ) )
		{
			return true;
		}

		if( paper_container_pids.find( container_pid ) != -1 || key_container_pids.find( container_pid ) != -1 )
		{
			return false;
		}

		if( paper_container_pids.find( pid ) != -1 || key_container_pids.find( pid ) != -1 )
		{
			return true;
		}

		int item_size = -1, container_size = -1;

		uint[][] size_table =
		{
			{ //Large containers:
				PID_BACKPACK,
				PID_TRAVEL_BAG,
			},
			{ //Medium containers".
				PID_SUPER_TOOL_KIT,
				PID_repkit3i,
				PID_repkit2i,
				PID_repkit1i,
				PID_FIRST_AID_KIT,
				PID_FIELD_MEDIC_KIT,
				PID_DOCTORS_BAG,
				PID_PARAMEDICS_BAG,
				PID_BRIEFCASE,
				PID_KEIS,
				PID_BAG,
			},
			{ //small containers:
				PID_AMMO_BELT,
				PID_BOX_OF_CIGARS,
				PID_CIGAR_CASE,
			},
			{ // tiny containers
				PID_CARDS_DECK,
				PID_CARDS_HAND,
			}
		};

		for( uint i = 0, maxSize = size_table.length(); i < maxSize; i++ )
		{
			for( uint j = 0, len = size_table[i].length(); j < len; j++ )
			{
				if( size_table[i][j] == pid )
				{
					item_size = i;
				}

				if( size_table[i][j] == container_pid )
				{
					container_size = i;
				}
			}
		}

		if( item_size <= container_size )
		{
			return false;
		}
	}

	return true;
}

bool map_init( Map& map, bool isfirst )
{
	map.ProccessSleep = Random( 10, 30 );
	LookDataRefresh( map );
	return true;
}

uint e_DelayedRemoval( uint[]@ values )
{
	if( !valid( values ) || values.length() != 2 )
	{
		return 0;
	}

	Item@ target = GetItem( values[0] );
	if( valid( target ) )
	{
		DeleteItem( target );
	}

	Critter@ cr = GetCritter( values[1] );
	if( valid( cr ) )
	{
		cr.ShowScreen( SCREEN_CLOSE, 0, "" );
	}
	return 0;
}

void unsafe_ItemsWeight( Critter& player, int itemId, int param1, int param2, string@ param3, int[]@ param4 )
{
	Item@ item = GetItem( itemId );

	if( !valid( item ) )
	{
		return;
	}

	if( item.GetType() != ITEM_TYPE_CONTAINER )
	{
		return;
	}

    Item@[] list;
	item.GetItems( 0, list );

	for( uint i = 0; i < list.length(); i++ )
	{
		if( list[i].GetType() == ITEM_TYPE_CONTAINER )
		{
			Item@[] sublist;
			list[i].GetItems( 0, sublist );

			for( uint j = 0, jmax = sublist.length(); j < jmax; j++ )
			{
				list.insertLast( sublist[j] );
			}
		}
	}

    uint result = 0;
	for( uint i = 0, imax = list.length(); i < imax; i++ )
	{
		if( valid( list[i] ) )
		{
			result += list[i].GetCount() * list[i].Proto.Weight;

			if( list[i].Proto.Type == ITEM_TYPE_FLASK )
			{
				result += list[i].Val2;
			}

			if( glass_bottles[2].find( list[i].GetProtoId() ) != -1 )
			{
                result += ( list[i].Proto.Weight - ( list[i].Proto.Partial_Item * 100 - list[i].EXTRA_WEIGHT ) );
			}
		}
    }

    player.RunClientScript( "client_main@SetItemWeight", itemId, result, 0, null, null );
}

uint e_UpdateContainer( uint[]@ val )
{
	Item@ container = GetItem( val[0] );
	if( valid( container ) )
	{
		container.Update();
	}

	Critter@ cr = GetCritter( val[1] );
	if( valid( cr ) )
	{
		cr.ParamBase[ CR_ITEMS_WEIGHT ] = ItemsWeight( cr );
	}

	return 0;
}

bool critter_grid_transfer( Critter& cr, Scenery& scen )
{
	ProtoItem@ gridProto = GetProtoItem( scen.ProtoId );
	if( !IsHuman( cr ) && !IsMutant( cr ) && !IsMonster( cr ) && !IsRobot( cr ) && gridProto.Grid_Type == GRID_LADDERTOP )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_DOGS_CANT_DO_THAT );
		return false;
	}

	Map@ map = cr.GetMap();
	if( BlockerCheck( cr, map, scen ) )
	{
		return false;
	}

	Location@ loc = map.GetLocation();
	Map@ toMap = loc.GetMap( scen.ToMapPid );
	if( !valid( toMap ) )
	{
		return false;
	}

	int entireId = scen.ToEntire;
	if( BlockerCheck( cr, toMap, entireId ) )
	{
		return false;
	}

	return true;
}

void LookDataRefresh( Critter& cr )
{
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}

	bool IsSneaking = cr.Param[ CR_SNEAKING ] > 0;
	int skill = cr.Skill[ SK_SNEAK ];

	LookData@ look = cr.Look;

	if( map.GetProtoId() == MAP_UTILITY_START )
	{
		if( cr.IsPlayer() )
		{
			look.HideViewMultiplier = 0;
			look.HideHearMultiplier = 0;
		}
	}
	else
	{
		int perception = cr.Stat[ ST_PERCEPTION ];
		look.MaxView = int( ( 10 + perception * 5 ) * HelmetViewEffect( cr ) );
		if( IsRobot( cr ) )
		{
			look.MaxHear = 10 + perception * 5;
		}
		else
		{
			look.MaxHear = int( ( 5 + perception ) * HelmetHearEffect( cr ) );
		}

		look.Vision = cr.Param[ QST_VISION ];
		look.Invis = cr.Param[ QST_INVIS ];

		look.ViewDirMultiplier_0 = 100;
		look.ViewDirMultiplier_1 = 85;
		look.ViewDirMultiplier_2 = 50;
		look.ViewDirMultiplier_3 = 5;

		if( cr.Param[ CR_IS_WINDUPED ] > 0 )
        {
			Item@ hand = _CritGetItemHand( cr );
			if( valid( hand ) )
			{
				uint16 pid = hand.GetProtoId();
				if( FLAG( hand.Proto.Weapon_Perk, WEAPON_PERK_SCOPE_RANGE ) || pid == PID_BINOCULARS || pid == PID_optics1 || pid == PID_optics2 || pid == PID_optics3 || pid == PID_optics4 )
                {
					look.ViewDirMultiplier_0 = 200;
                    look.ViewDirMultiplier_1 = 5;
                    look.ViewDirMultiplier_2 = 0;
                    look.ViewDirMultiplier_3 = 0;
                }
            }
        }

		look.HearDirMultiplier_0 = 80;
		look.HearDirMultiplier_1 = 100;
		look.HearDirMultiplier_2 = 100;
		look.HearDirMultiplier_3 = 70;

		look.RunningNoiseMultiplier = 150;
		look.RunningHearMultiplier = 50;

		if( !IsSneaking )
		{
			look.HideViewDirMultiplier_0 = 100;
			look.HideViewDirMultiplier_1 = 100;
			look.HideViewDirMultiplier_2 = 100;
			look.HideViewDirMultiplier_3 = 100;
			look.HideViewDirMultiplier_4 = 100;
			look.HideViewDirMultiplier_5 = 100;
		}
		else
		{
			int hdvm = ( 320 - skill ) * 100 / 320;
			look.HideViewDirMultiplier_0 = ( GET_COVER_TYPE( 3, cr.Param[ CR_IN_COVER ] ) != 0 ) ? hdvm : 100;
			look.HideViewDirMultiplier_1 = ( GET_COVER_TYPE( 4, cr.Param[ CR_IN_COVER ] ) != 0 ) ? hdvm : 100;
			look.HideViewDirMultiplier_2 = ( GET_COVER_TYPE( 5, cr.Param[ CR_IN_COVER ] ) != 0 ) ? hdvm : 100;
			look.HideViewDirMultiplier_3 = ( GET_COVER_TYPE( 0, cr.Param[ CR_IN_COVER ] ) != 0 ) ? hdvm : 100;
			look.HideViewDirMultiplier_4 = ( GET_COVER_TYPE( 1, cr.Param[ CR_IN_COVER ] ) != 0 ) ? hdvm : 100;
			look.HideViewDirMultiplier_5 = ( GET_COVER_TYPE( 2, cr.Param[ CR_IN_COVER ] ) != 0 ) ? hdvm : 100;
		}

		look.HideHearDirMultiplier_0 = 100;
		look.HideHearDirMultiplier_1 = 100;
		look.HideHearDirMultiplier_2 = 100;
		look.HideHearDirMultiplier_3 = 100;
		look.HideHearDirMultiplier_4 = 100;
		look.HideHearDirMultiplier_5 = 100;

		look.HideViewMultiplier = IsSneaking ? int( 100 - ( skill / 20 ) ) : 100;
		look.HideHearMultiplier = int( 100 * ArmorNoisePenalty( cr ) * ( IsSneaking ? ( 300 - skill ) / 300 : 1 ) + ( cr.Param[ CR_TYPING_TIME ] > 0 ? cr.Param[ ST_SPEECH_VOLUME ] * 2 : 0 ) );
	}

	cr.LookData_Update();
}

float ArmorNoisePenalty( Critter& cr )
{
	float modifier = 1;
	Item@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		uint material = _GetItemMaterial( armor );
		switch( material )
		{
			case( MATERIAL_FABRIC ):
			case( MATERIAL_LEATHER ):
				modifier = 1;
				break;
			case( MATERIAL_ARMORED_LEATHER ):
				modifier = 1.1;
				break;
			case( MATERIAL_METAL ):
				modifier = 1.5;
				break;
			case( MATERIAL_POLYMER ):
				modifier = 1.25;
				break;
			case( MATERIAL_COMPOSITE ):
				modifier = 2;
				break;
			default:
				modifier = 1;
				break;
		}
	}

	return modifier;
}

float HelmetHearEffect( Critter& cr )
{
	float modifier = 1;
	Item@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		uint pid = head.GetProtoId();
		switch( pid )
		{
			case( PID_HELMET_PA_TRIBAL ):
				modifier = 0.5;
				break;
			case( PID_HELMET_CA ):
				modifier = 0.9;
				break;
			case( PID_HELMET_METAL ):
				modifier = 0.8;
				break;
			case( PID_HELMET_TANK ):
			case( PID_HELMET_TANK2 ):
				modifier = 0.2;
				break;
			case( PID_HELMET_PA ):
			case( PID_HELMET_HPA ):
			case( PID_HELMET_APA ):
			case( PID_HELMET_HYENA ):
				modifier = 2;
				break;
			case( PID_EAR_DEFENDERS ):
				modifier = 0;
				break;
			case( PID_SANDBAG_EMPTY ):
				modifier = 0.3;
				break;
			default:
				modifier = 1;
				break;
		}
	}

	return modifier;
}

float HelmetViewEffect( Critter& cr )
{
	float modifier = 1;
	Item@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		uint pid = head.GetProtoId();
		switch( pid )
		{	
			case( PID_SANDBAG_EMPTY ):
				modifier = 0;
				break;
			case( PID_CIVIL_GAS_MASK ):
			case( PID_GASMASK ):
				modifier = 0.6;
				break;
			case( PID_WELGLASSES ):
				modifier = 0.1;
				break;
			case( PID_SPECTACLES ):
			case( PID_VINTAGE_SPECTACLES ):
			case( PID_GLASSBIT ):
			case( PID_STA_VISOR ):
			{
				if( cr.Stat[ ST_PERCEPTION ] <= 3 )
				{
					modifier = 1.4;
				}
				else if( cr.Stat[ ST_PERCEPTION ] == 4 )
				{
					modifier = 1.15;
				}

				break;
			}
			default:
				modifier = 1;
				break;
		}
	}

	return modifier;
}

void LookDataRefresh( Map& map )
{
	LookData@ look = map.Look;

	look.MaxView = 0;
	look.MaxHear = 0;

	look.ViewDirMultiplier_0 = 100;
	look.ViewDirMultiplier_1 = 100;
	look.ViewDirMultiplier_2 = 100;
	look.ViewDirMultiplier_3 = 100;

    look.HearDirMultiplier_0 = 100;
    look.HearDirMultiplier_1 = 100;
    look.HearDirMultiplier_2 = 100;
    look.HearDirMultiplier_3 = 100;

    look.RunningNoiseMultiplier = 100;
    look.RunningHearMultiplier = 100;

	Critter@[] critters;
	for( uint i = 0, iend = map.GetCritters( 0, FIND_ALL, critters); i < iend; i++ )
	{
		critters[i].LookData_Update();
	}
}

void LookDataRefreshAllMaps( Critter& , int, int, int )
{
	Log( "LookDataRefreshAllMaps" );
	Map@[] maps;
	for( uint i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++ )
	{
		LookDataRefresh( maps[i] );
	}
}

uint cte_sneaking( Critter& cr, int identifier, uint& rate )
{
	if( MovementState( cr ) == MOVE_STATE_RUN )
	{
		cr.ParamBase[ CR_SNEAKING ] = 0;
		LookDataRefresh( cr );
		ChangeCritterSpeed( cr );
		return 0;
	}

	if( cr.Param[ CR_SNEAKING ] == 0 )
	{
		LookDataRefresh( cr );
		ChangeCritterSpeed( cr );
		return 0;
	}

	if( cr.Param[ CR_IN_COVER ] > 0 )
	{
		LookDataRefresh( cr );
		ChangeCritterSpeed( cr );
	}

	return REAL_MS( 500 );
}

#endif //__MAIN_MODULE__
