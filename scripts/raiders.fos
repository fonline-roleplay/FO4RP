#include "_utils.fos"

#include "entire.fos"
#include "pids_groups.fos"
#include "_npc_pids.fos"
#include "_teams.fos"
#include "_bags.fos"
#include "npc_planes_h.fos"

#define GuardPID        ( 128 )
#define CRITTER_TEAM    ( 128 )

import void GM_MobInit( Critter& npc ) from "mob";

void unsafe_setControl( Critter& player, int ID, int groupFlag, int p2, string@ p3, int[]@ p4 )
{
	if( isGM( player ) )
		setControl( player, ID, groupFlag, p2, p3, p4 );
}

void setControl( Critter& player, int ID, int groupFlag, int p2, string@ p3, int[]@ p4 )
{
	Mob( ID ).setControl( player.Id, groupFlag );
}

void unsafe_AdvancedSpawnNPC( Critter& player, int type, int weapon, int AI_type, string@ p3, int[]@ args )
{
	if( isGM( player ) )
		AdvancedSpawnNPC( player, type, weapon, AI_type, p3, args );
}

void AdvancedSpawnNPC( Critter& player, int type, int weapon, int AI_type, string@ p3, int[]@ args )
{
    if( !valid( player ) )
        return;
    Map @ map = player.GetMap();
    AdvancedSpawn( player, map, type, weapon, AI_type, args[ 0 ], args[ 1 ] );
}

void AdvancedSpawn( Critter& player, Map& map, int type, int weapon, int AI_type, uint16 hexX, uint16 hexY ) //TODO: rework
{
    if( type == 0 )
    {
        player.Say( SAY_NETMSG, " #spawn [тип] [оружие] [AI]" );	
        player.Say( SAY_NETMSG, "Тип:" );
        player.Say( SAY_NETMSG, "1 - крыса" );
        player.Say( SAY_NETMSG, "2 - мантис" );
        player.Say( SAY_NETMSG, "3 -  муравей" );
        player.Say( SAY_NETMSG, "4 -  свинокрыс" );
        player.Say( SAY_NETMSG, "5 -  кротокрыс" );
        player.Say( SAY_NETMSG, "6 -  большой кротокрыс" );
        player.Say( SAY_NETMSG, "7 -  гекко" );
        player.Say( SAY_NETMSG, "8 -  золотой гекко" );
        player.Say( SAY_NETMSG, "9 -  собака" );
        player.Say( SAY_NETMSG, "10 -  малый скорпион" );
        player.Say( SAY_NETMSG, "11 -  большой скорпион" );
        player.Say( SAY_NETMSG, "12 -  брамин" );
        player.Say( SAY_NETMSG, "13 -  чужой" );
        player.Say( SAY_NETMSG, "14 -  малый коготь" );
        player.Say( SAY_NETMSG, "15 -  большой коготь" );
        player.Say( SAY_NETMSG, "16 -  кентавр" );
        player.Say( SAY_NETMSG, "17 -  летун" );
        player.Say( SAY_NETMSG, "18 -  огнегекко" );
        player.Say( SAY_NETMSG, "19 -  кентавр2" );
        player.Say( SAY_NETMSG, "20 -  каннибал" );
        player.Say( SAY_NETMSG, "21 -  каннибал ж" );
        player.Say( SAY_NETMSG, "22 -  рейдер" );
        player.Say( SAY_NETMSG, "23 -  рейдер ж" );
        player.Say( SAY_NETMSG, "24 -  работорг" );
        player.Say( SAY_NETMSG, "25 -  работорг ж" );
        player.Say( SAY_NETMSG, "26 -  мародер" );
        player.Say( SAY_NETMSG, "27 -  мародер ж" );
        player.Say( SAY_NETMSG, "28 -  гуль" );
        player.Say( SAY_NETMSG, "29 -  супермутант" );
        player.Say( SAY_NETMSG, "30 -  раб" );
        player.Say( SAY_NETMSG, "31 -  раб ж" );
        player.Say( SAY_NETMSG, "32 -  мальчик" );
        player.Say( SAY_NETMSG, "33 -  девочка" );
        player.Say( SAY_NETMSG, "34 -  путешественник" );
        player.Say( SAY_NETMSG, "35 -  путешественница" );
        player.Say( SAY_NETMSG, "Оружие:" );
        player.Say( SAY_NETMSG, "1-без оружия" );		
        player.Say( SAY_NETMSG, "1-нож" );
        player.Say( SAY_NETMSG, "2-кастет" );
        player.Say( SAY_NETMSG, "3-копье" );
        player.Say( SAY_NETMSG, "10-лоу револьвер" );
        player.Say( SAY_NETMSG, "14-самопал винт." );
        player.Say( SAY_NETMSG, "18-лоу смг" );
        player.Say( SAY_NETMSG, "19-большая пушка" );
        player.Say( SAY_NETMSG, "20 - 10мм" );
        player.Say( SAY_NETMSG, "21 -  маузер" );
        player.Say( SAY_NETMSG, "22 -  дисерт игл" );
        player.Say( SAY_NETMSG, "23 -  охотка" );
        player.Say( SAY_NETMSG, "AI:" );
        player.Say( SAY_NETMSG, "0-контроль" );
        player.Say( SAY_NETMSG, "1-моб" );
        player.Say( SAY_NETMSG, "2-гарнизонМодока" );
        player.Say( SAY_NETMSG, "3-нейтрал" );
        player.Say( SAY_NETMSG, "4-моб-Лидер" );
        player.Say( SAY_NETMSG, "5-моб-миньон" );
        return;
    }
    int NPC1 = NPC_PID_RegularRat + type;
    if( type >= 36 )
        NPC1 = type;
	player.ParamBase[ MERC_DEFEND_MASTER ] = NPC1;//Команда #spawn pid теперь можнт быть легко повторена через ГМ-меню "повтор спауна".
    Critter@ cr = map.AddNpc( NPC1, hexX, hexY, Random( 0, 5 ), null, null, null );
    if( valid( cr ) )
    {
        cr.ParamBase[ ST_FACTION ] = player.ParamBase[ CR_VAL3 ];
		cr.ParamBase[ CR_IS_AGGRESSIVE ] = player.ParamBase[ CR_VAL4 ]; // 0 ? "Пассив" : "Актив"
		cr.StatBase[ ST_TEAM_ID ] = player.ParamBase[ CR_VAL5 ];
		
		cr.StatBase[ ST_AI_ID ] = 207;
        cr.StatBase[ ST_REPLICATION_TIME ] = -1;//__FullSecond + REAL_HOUR( 2 );
        cr.ModeBase[ MODE_NO_HOME ] = 0;	
        cr.ModeBase[ MODE_UNLIMITED_AMMO ] = 1;
        if( type >= 20 )
        {
            int weapon2;
            switch( weapon )
            {
            case 0:
                weapon2 = 0;
                break;
            case 1:
                weapon2 = PID_REVKNIFE1;
                break;
            case 2:
                weapon2 = PID_REVFIST1;
                break;
            case 3:
                weapon2 = PID_SPEAR_P;
                break;
            case 4:
                weapon2 = PID_KNIFE;
                break;
            case 5:
                weapon2 = PID_CHAIN;
                break;
            case 6:
                weapon2 = PID_CROWBAR;
                break;
            case 7:
                weapon2 = PID_SPEAR;
                break;
            case 8:
                weapon2 = PID_SHIV;
                break;
            case 9:
                weapon2 = PID_SWITCHBLADE;
                break;
            case 10:
                weapon2 = PID_REVOLVER_LOW;
                break;
            case 11:
                weapon2 = PID_PISTOL_LOW;
                break;
            case 12:
                weapon2 = PID_SHOTPISTOL_LOW;
                break;
            case 13:
                weapon2 = PID_REV_RIFLE_LOW;
                break;
            case 14:
                weapon2 = PID_SPRINGER_RIFLE;
                break;
            case 15:
                weapon2 = PID_ZIP_GUN;
                break;
            case 16:
                weapon2 = PID_SNIPER_GUN_LOW;
                break;
            case 17:
                weapon2 = PID_SMOKE_GUN_LOW;
                break;
            case 18:
                weapon2 = PID_DRUM_GUN_LOW;
                break;
            case 19:
                weapon2 = PID_BIGGUN_LOW;
                break;
            case 20:
                weapon2 = PID_10MM_PISTOL;
                break;
            case 21:
                weapon2 = PID_9MM_MAUSER;
                break;
            case 22:
                weapon2 = PID_DESERT_EAGLE;
                break;
            case 23:
                weapon2 = PID_HUNTING_RIFLE;
                break;
            }
            if( weapon > 23 )
                cr.AddItem( weapon, 1 );
            else if( weapon2 > 0 )
                cr.AddItem( weapon2, 1 );
        }
        if( AI_type == 0 && valid( player ) )
        {
            controlMob( player, cr.Id, 0, 0, null, null );
        }
        else if( AI_type == 1 )
        {
            GM_MobInit( cr);
        }
        else if( AI_type == 2 )
        {
            Critter@[] players, guards;
            Map@ map2 = player.GetMap();
            if( valid( player ) && valid( cr ) && map2.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players ) > 0 )
            {
                cr.StatBase[ ST_VAR7 ] =  CRITTER_TEAM;
                for( uint j = 0, jj = players.length(); j < jj; j++ )
                {
					AddAttackPlane( cr, 0, players[ j ], __RunOnCombat );
					cr.AddEnemyInStack( players[ j ].Id );
                }
            }
		}		
    }
}

void controlMob( Critter& player, int ID, int, int, string@, int[]@ )
{
	Critter@ target = GetCritter( ID );
	if ( !valid( target ) ) 
	{
		return;
	}
	
    player.RunClientScript( "client_gui@_SetControlCritters", ID, 0, 0, null, null );
	target.ParamBase[ MERC_MASTER_ID ] = player.Id;
}

void unsafe_stopMob( Critter& player, int x, int y, int p2, string@ p3, int[]@ IDs )
{
	if( isGM( player ) )
		stopMob( player, x, y, p2, p3, IDs );
}

void stopMob( Critter& player, int x, int y, int p2, string@ p3, int[]@ IDs )
{
	if( !valid( IDs ) ) 
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).stop( x, y );
    }
}

void unsafe_moveMob( Critter& player, int x, int y, int runFlag, string@ param3, int[]@ IDs )
{
	if( isGM( player ) )
		moveMob( player, x, y, runFlag, param3, IDs );
}

void moveMob( Critter& player, int x, int y, int runFlag, string@, int[]@ IDs )
{
	if( !valid( IDs ) ) 
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).move( x, y, ( runFlag != 0 ) );
    }
}

void unsafe_attackMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( isGM( player ) )
		attackMob( player, p0, p1, p2, p3, IDs );
}

void attackMob( Critter& player, int target_id, int p1, int p2, string@ p3, int[]@ IDs )
{
    Critter@ target = GetCritter( target_id );
	
	if( !valid( IDs ) || !valid( target ) )
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).attack( target );
    }
}

void unsafe_assaultMob( Critter& player, int p0, int p1, int p2, string@ p3, int[] @ vals )
{
	if( isGM( player ) )
		assaultMob( player, p0, p1, p2, p3, vals );
}

void assaultMob( Critter& player, int p0, int p1, int p2, string@ p3, int[] @ IDs )
{
 	if( !valid( IDs ) ) 
	{
		return;
	}
	
	Critter@[] players;
    Map@ map = player.GetMap();
	if( !valid( map ) || map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players ) == 1 ) //ignore self
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).assault( players );
    }
}

void unsafe_deleteMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( isGM( player ) )
		deleteMob( player, p0, p1, p2, p3, IDs );
}

void deleteMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( !valid( IDs ) ) 
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).delete();
    }
}

void unsafe_FreeMobById( Critter& player, int ID, int groupFlag, int, string@, int[]@ )
{
	Mob( ID ).free( groupFlag );
}

void unsafe_HomeMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( isGM( player ) ) 
		HomeMob( player, p0, p1, p2, p3, IDs );
}

void HomeMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( !valid( IDs ) ) 
	{
		return;
	}
	
	player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_GM_ZH_COMMAND );

    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).setHome();
    }
}

void unsafe_chaseMob( Critter& player, int ID, int p1, int p2, string@ p3, int[] @ IDs )
{
	if( isGM( player ) )
		chaseMob( player, ID, p1, p2, p3, IDs );
}

void chaseMob( Critter& player, int ID, int p1, int p2, string@ p3, int[] @ IDs )
{
    Critter@ target = GetCritter( ID );
	
	if( !valid( IDs ) || !valid( target ) ) 
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		Mob( IDs[i] ).chase( target );
    }
}

void unsafe_GatherMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( isGM( player ) )
		GatherMob( player, p0, p1, p2, p3, IDs );
}

void GatherMob( Critter& player, int p0, int p1, int p2, string@ p3, int[]@ IDs )
{
	if( !valid( IDs ) || !valid( player.GetMap() ) )
	{
		return;
	}
	
    for( uint i = 0, l = IDs.length(); i < l; i++ )
    {
		GatherMob( IDs[i], player );
    }
}

bool GatherMob( uint id, Critter& player )
{
	return GatherMob( GetCritter( id ), player );
}

bool GatherMob( Critter@ cr, Critter& player )
{
	Map@ map = player.GetMap();
	
	if( !valid( cr ) || !valid( map ) )
	{
		return false;
	}

	if( cr.IsPlayer() && cr.Param[ QST_GAMEMODE ] == GAME_START )
	{
		player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_GM_ZG_COMMAND, "$name" + crInfo( cr ) );
		return false;
	}

	Location@ loc = map.GetLocation();
	if( !valid(loc) )
	{		
		return false;
	}

	uint8 temp_dir = player.Dir;
	for( uint j = 0; j < 6; j++ )
	{
		uint16 hexX = player.HexX, hexY = player.HexY;
		map.MoveHexByDir( hexX, hexY, ( temp_dir + j ) % 6, 2 );
		
		if( !map.IsHexPassed( hexX, hexY ) )
		{
			continue;
		}			
		
		cr.SetWorldPos( loc.WorldX, loc.WorldY );
		cr.TransitToMap( map.Id, hexX, hexY, 0 );
		
		break;
	}
	
	return true;
}

uint follow( Critter& cr, int master, uint& rate )//TODO: rework
{
    int8     y = 0;
    cr.ClearEnemyStack();
    Critter@ daddy = GetCritter( cr.Stat[ ST_KILLER_PERSON ] );
    Map@     daddymap = null;
    Map@     crmap = cr.GetMap();
    if( valid( daddy ) )
        @daddymap = daddy.GetMap();
    else
	{
		cr.ModeBase[MODE_NO_HOME] = 0;
        return REAL_SECOND( 30 );
	}
    cr.ErasePlane( -1, true );

    if( ( !valid( daddymap ) ) && ( valid( crmap ) ) )
    {
        cr.TransitToGlobalGroup( daddy.Id );
    }
    else if( ( valid( daddymap ) ) && ( valid( crmap ) ) && ( daddymap.Id == crmap.Id ) )
    {
        AddWalkPlane( cr, 0, daddy.HexX, daddy.HexY, GetDirection( cr.HexX, cr.HexY, daddy.HexX, daddy.HexY ), GetDistantion( cr.HexX, cr.HexY, daddy.HexX, daddy.HexY ) > 5, 2 );
		
		cr.SetHomePos( daddy.HexX, daddy.HexY, daddy.Dir );
		cr.ModeBase[MODE_NO_HOME] = 1;		
    }
    else if( ( valid( daddymap ) ) && ( valid( crmap ) ) && ( crmap.Id != daddymap.Id ) )
    {
        uint8 findPos = 1;
        while( findPos <= 10 )
        {
            if( daddymap.IsHexPassed( daddy.HexX + findPos, daddy.HexY + findPos ) )
            {
                cr.TransitToMap( daddymap.Id, daddy.HexX + findPos, daddy.HexY + findPos, Random( 0, 5 ) );
                break;
            }
            findPos++;
        }
    }
    return REAL_SECOND( 5 );
}

class Mob
{
	Critter@ cr;
	
	Mob( int id )
	{
		@cr = GetCritter( id );
	}
	
	Mob( Critter@ cr )
	{
		@this.cr = cr;
	}
	
	bool Valid()
	{
		if( !valid( cr ) || cr.IsPlayer() )
		{			
			return false;
		}
		
		return true;
	}
	
	void clearPlans()
	{
		cr.ErasePlane( -1, true );
		cr.ClearEnemyStack();
	}
	
	bool stop( int x, int y )
	{
		if( !Valid() ) 
		{			
			return false;
		}
		
		clearPlans();
		cr.EraseTimeEvents( CTE_ROTTEN );
		cr.SetDir( GetDirection( cr.HexX, cr.HexY, x, y ) );
		return true;
	}
	
	bool move( int x, int y, bool runFlag )
	{
		if( !Valid() ) 
		{			
			return false;
		}
		
		cr.ModeBase[ MODE_NO_HOME ] = 1;
		clearPlans();
		AddWalkPlane( cr, 1, x, y, GetDirection( cr.HexX, cr.HexY, x, y ), runFlag, 0 );
		return true;
	}
	
	bool attack( Critter@ target )
	{
		if( !valid( target ) )
		{
			return false;
		}
		
		cr.ModeBase[ MODE_NO_HOME ] = 1;
		clearPlans();
		AddAttackPlane( cr, 0, target, __RunOnCombat );
		cr.AddEnemyInStack( target.Id );
		
		return true;
	}

	bool assault( Critter@[] targets )
	{
		if( !Valid() ) 
		{			
			return false;
		}
		
		for( uint i = 0, l = targets.length(); i < l; i++ )
		{
			AddAttackPlane( cr, 0, targets[i], __RunOnCombat );
			cr.AddEnemyInStack( targets[i].Id );
		}
		
		return true;
	}
	
	bool delete()
	{
		if( !Valid() || cr.Stat[ ST_DIALOG_ID ] != 0 )
		{
			return false;
		}
		
		DeleteNpc( cr );	
		
		return true;
	}
	
	bool setHome()
	{
		if( !Valid() ) 
		{			
			return false;
		}
		
		cr.SetHomePos( cr.HexX, cr.HexY, cr.Dir );
		cr.ModeBase[ MODE_NO_HOME ] = 0;
		
		return true;
	}
	
	bool free( int groupFlag )
	{
		if( !Valid() ) 
		{			
			return false;
		}
		
		cr.ParamBase[ CR_CONTROLLED_GROUP ] &= ~( 1 << groupFlag );
		if( groupFlag != 0 || cr.ParamBase[ CR_CONTROLLED_GROUP ] == 0 )
		{
			cr.ModeBase[ MODE_NO_HOME ] = 0;
			cr.ParamBase[ MERC_MASTER_ID ] = 0;
		}
		
		return true;
	}
	
	bool chase( Critter@ target )
	{
		if( !Valid() || !valid( target ) )
		{
			return false;
		}
		
		clearPlans();

		if( cr.StatBase[ ST_KILLER_PERSON ] == int( target.Id ) )
		{
			cr.EraseTimeEvents( CTE_ROTTEN );
			cr.StatBase[ ST_KILLER_PERSON ] = 0;
			cr.ModeBase[ MODE_NO_HOME ] = 0;
		}
		else
		{
			cr.ModeBase[ MODE_NO_HOME ] = 1;
			cr.StatBase[ ST_KILLER_PERSON ] = target.Id;
			cr.AddTimeEvent( "raiders@follow", REAL_SECOND( 1 ), CTE_ROTTEN );
		}

		return true;
	}

	bool setControl( int ownerId, uint groupFlag ) 
	{
		if( !Valid() )
		{
			return false;
		}
		
		if( cr.ParamBase[ MERC_MASTER_ID ] != ownerId )
		{
			if( cr.ParamBase[ MERC_MASTER_ID ] != 0 )
			{
				Critter@ lastOwner = GetCritter( cr.ParamBase[ MERC_MASTER_ID ] );
				if( valid( lastOwner ) )
				{
					lastOwner.RunClientScript( "client_gui@_LostCritterControl", cr.Id, 0, 0, null, null );
				}
			}
			
			cr.ParamBase[ CR_CONTROLLED_GROUP ] = 0;
		}
		
		cr.ParamBase[ CR_CONTROLLED_GROUP ] |= 1 << groupFlag;
		cr.ParamBase[ MERC_MASTER_ID ] = ownerId;
		
		return true;
	}
}

