                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

import void InjureCritter(Critter&cr,uint dmg,uint dmgType,uint8 dir,uint attackerId)from"combat";   

bool IsTree(Scenery@scen)
{
	if(not(@scen!=null))
	return false;
	uint16 pid=scen.ProtoId;
	return pid==2066||pid==2316||pid==2317||pid==2318||pid==2319||pid==2320||pid==2321||pid==2945||pid==2946||pid==2947||
	pid==3842||pid==3843||
	(pid>=4562&&pid<=4572)
	;
} 

bool UseAxeOnTree(Critter@cr,Scenery@tree) 

{   
	
	if(not(@cr!=null))
	{
		Log("Critter is not valid.");
		return false;
	}
	if(not(@tree!=null))
	{
		Log("Scenery (tree) is not valid.");
		return false;
	}
	bool damArmL=cr.Damage[(504)]!=0;
	bool damArmR=cr.Damage[(503)]!=0;
	bool damLegL=cr.Damage[(506)]!=0;
	bool damLegR=cr.Damage[(505)]!=0;
	
	uint8 randNum_tree=(tree.HexX*tree.HexY)%100+1;
	uint8 randNum_crit=cr.Id%100+1;
	uint8 randNum_time=(__FullSecond/10)%100+1;
	uint8 randNum=(randNum_tree*randNum_crit*randNum_time)%100;
	uint8 crLuck=cr.Stat[(6)];
	
	uint8 penalty=0;
	if(cr.Damage[(502)]!=0)
	penalty=10;
	
	if((20+crLuck*2-penalty)>randNum)
	{
		
		if(damArmL&&damArmR)
		{
			cr.SayMsg((11),(0),2200);
			
			return true;
		}
		
		int32 axeLastTime_value=0;
		GameVar@axeLastTime=GetLocalVar((4800),cr.Id);
		if((@axeLastTime!=null))
		axeLastTime_value=axeLastTime.GetValue();
		else
		Log("LVAR_scenery_axe_lasttime is not valid.");
		
		if(axeLastTime_value>__FullSecond-((15-cr.Stat[(2)])*__TimeMultiplier))
		{
			cr.SayMsg((11),(0),2201);
			
			return true;
		}
		
		if((@axeLastTime!=null))
		axeLastTime=__FullSecond;
		
		if(!damArmL&&!damArmR&&Random(1,crLuck*20+((((cr.Stat[(5)])>(10))?(10):(((cr.Stat[(5)])<(4))?(4):(cr.Stat[(5)])))-4)*10)==1)
		{
			if(Random(1,10)==1)
			cr.DamageBase[(503)]=1;
			else
			cr.DamageBase[(504)]=1;
			cr.SayMsg((11),(0),2202);
			uint8 dir=GetDirection(tree.HexX,tree.HexY,cr.HexX,cr.HexY);
			InjureCritter(cr,Random(10,10+cr.Stat[(0)]*2),(1),dir,0);
			
			return true;
		} 
		
		uint8 count=((randNum_tree%10)+crLuck)/4;
		uint16 mapPID=0;
		Map@map=cr.GetMap();
		if((@map!=null))
		mapPID=map.GetProtoId();
		else
		Log("Map is not valid.");
		if(damArmL||damArmR)
		count=2;  
		
		if(mapPID!=6)
		
		{
			int8 countEnc=((((cr.Skill[(217)])>(100))?(100):(((cr.Skill[(217)])<(49))?(49):(cr.Skill[(217)])))-40)/10;
			if(damLegL)
			count--;
			if(damLegR)
			count--;
			if(damArmL||damArmR)
			count-=2;
			count+=(((countEnc)>(6))?(6):(((countEnc)<(0))?(0):(countEnc)));
		}
		ProtoItem@proto=GetProtoItem((286));
		uint32 itemsWeight=cr.ItemsWeight();
		uint32 carryWeight=cr.Stat[(11)];
		count=Random(1,count);
		
		if(cr.ItemsWeight()+proto.Weight*count<=carryWeight)
		{
			if(not(@cr.AddItem((286),count)!=null))
			{
				Log("AddItem fail.");
				return false;
			}
			cr.SayMsg((11),(0),2203);
		}
		
		else if(itemsWeight+proto.Weight<=carryWeight)
		{
			uint8 countDrop=count;
			count=(carryWeight-itemsWeight)/proto.Weight;
			countDrop-=count;
			if(not(@cr.AddItem((286),count)!=null))
			{
				Log("cr.AddItem fail.");
				return false;
			}
			if(not(@map.AddItem(cr.HexX,cr.HexY,(286),countDrop)!=null))
			{
				Log("map.AddItem fail.");
				return false;
			}
			cr.SayMsg((11),(0),2204);
		}
		
		else
		{
			if(not(@map.AddItem(cr.HexX,cr.HexY,(286),count)!=null))
			{
				Log("map.AddItem fail.");
				return false;
			}
			cr.SayMsg((11),(0),2205);
		}
		
		return true;
	}
	return false;
}    

import int RollVsSkill(Critter&cr,uint skillIndex,int bonus)from"stdlib";  

import bool IsSuccessRvS(int val)from"stdlib";  

import bool IsCriticalRvS(int val)from"stdlib";  

import void HealCritter(Critter&player)from"stdlib";  

import bool TransitToLoc(Critter&cr,uint16 locPid,uint mapIndex,uint entranceNum)from"stdlib";  

import bool TransitToMap(Critter&cr,uint16 mapPid,uint entranceNum)from"stdlib";  

import bool TransitToNewLocation(Critter&cr,uint16 locPid)from"stdlib";  

import void InfoMessage(Critter&player,Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageNorm(Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageShout(Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageWhisp(Critter&npc,uint strNum)from"stdlib";  

import void NpcMessageEmo(Critter&npc,uint strNum)from"stdlib";        

import void TimeoutSet(Critter&npc,int timeoutNumber,uint gameHours)from"stdlib";  

import void TimeoutSub(Critter&npc,uint gameHoursSub)from"stdlib";  

import void TimeoutAdd(Critter&npc,uint gameHoursAdd)from"stdlib";  

import void GroupSetVar(Critter&player,uint16 varId,int value)from"stdlib";  

import void Warn(Critter&player,int npcRole)from"stdlib";  

import void DoorControl(Critter&player,uint entireNum,bool toOpen)from"stdlib";  

import bool DialogNpc(Critter&player,int role)from"stdlib";  

import Critter@GetNearCritterWithRole(Map@map,uint16 hexX,int hexY,uint radius,int role)from"stdlib";              

import void DropDrugEffects(Critter&cr)from"drugs";
import void DropRadiation(Critter&cr)from"radiation";  

bool s_Dialog(Critter&player,Scenery&scenery,int skill,Item@item,int dialogId)
{
	
	if(skill==-1&&not(@item!=null))
	{
		return RunDialog(player,dialogId,scenery.HexX,scenery.HexY,false);
	}
	return false;
}

bool s_DoorControl(Critter&player,Scenery&scenery,int skill,Item@item,int entireNum,int toOpen)
{
	if(toOpen==1)
	{
		DoorControl(player,entireNum,true);
	}
	else
	{
		DoorControl(player,entireNum,false);
	}
	return true;
}

bool s_Water(Critter&player,Scenery&scenery,int skill,Item@item)
{
	if(!(item is null)){
		uint pid=0;
		if(item.GetProtoId()==(542)){
			pid=(106);
		}else if(item.GetProtoId()==(532)){
			pid=(533);
		}else{
			player.Say((11),"Не подходящий предмет.");
		}
		
		return true;
	}
	
	return false;
}     

