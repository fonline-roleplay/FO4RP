#ifndef ENERGY
#define ENERGY

#include "_utils.fos"
#include "energy_h.fos"


class BatteryRule
{
	// Exception rule for a specific pair (target group + battery type).
	RechargeGroup TargetGroup;	// Target rechargeable group.
	uint16 BatteryPid;			// Battery/energy cell PID.
	bool Allowed;				// Whether charging is allowed.
	float Coef;					// Charge multiplier (1.0 = unchanged).
	
	BatteryRule( RechargeGroup group, uint16 batteryPid, bool allowed, float coef )
	{
		TargetGroup = group;
		BatteryPid  = batteryPid;
		Allowed     = allowed;
		Coef        = coef;
	}
}


// Exception rules table (initialized in InitBatteryRules)
BatteryRule@[] BatteryRules;


void InitBatteryRules()
{
	// Populates the rules table once. 
	// Keeps all exceptions in one place and avoids heavy global initialization.	
    if (BatteryRules.length() != 0)
        return;

	// BatteryRules.insertLast( @BatteryRule( RG_Sensor, 		      PID_CUENCELL_LOW,      true,   0.5f ) ); 	// Example. Sensor charge debuff if use PID_CUENCELL_LOW
	BatteryRules.insertLast( @BatteryRule( RG_FlashlightBuiltIn,   PID_MICRO_FUSION_CELL,	false,  1.0f ) ); 	// Example. Flashlights cannot be charged from an PID_MICRO_FUSION_CELL
	BatteryRules.insertLast( @BatteryRule( RG_FlashlightBuiltIn,   PID_ATOMIC_CELL, 		false,  1.0f ) ); 	// Example. Flashlights cannot be charged from an PID_ATOMIC_CELL
}


BatteryRule@ GetRechargeRule( uint16 batteryPid, Item& rechargeableItem )
{
	// Looks up an exception rule for (batteryPid + rechargeableItem group).
	// Returns null if no rule exists (meaning "use default behavior").
	
	RechargeGroup targetGroup = GetRechargeGroup( rechargeableItem );
	
	if ( targetGroup == RG_None )
	{
		return null;
	}
	
	for ( uint i = 0; i < BatteryRules.length(); i++ )
	{
		// if find rule for group
		if ( BatteryRules[i].TargetGroup == targetGroup && BatteryRules[i].BatteryPid == batteryPid )
		{
			BatteryRule@ item_rule = BatteryRules[i];
			return item_rule;
		}
		
	}

	return null;
}


int GetEnergyChargeFromBattery( uint16 batteryPid, Item& rechargeableItem )
{
	// Public entry point.
	// Returns how much charge batteryPid provides for rechargeableItem,
	// applying exception rules (deny/multiplier).
	
	if( energyCells.find( batteryPid ) == -1 )
	{
		return 0;
	}
	
	float multiplier = 1.0f;
	if( valid( rechargeableItem ) )
	{
		BatteryRule@ rule = GetRechargeRule( batteryPid, rechargeableItem );
		if ( valid( rule ) )
		{
			if ( !rule.Allowed )
			{
				return 0;
			}
			
			multiplier = rule.Coef;
		}
	}
	
	int charge_value = int( float( GetChargeByBatteryPid( batteryPid ) ) * multiplier );
	return charge_value;
}


bool CanChargeItem( Critter& cr, Item& batteryItem, Item& rechargeableItem )
{
	// Public entry point.
	// Validates whether a rechargeable item can be charged from the given battery before performing the charge.
	// Checks item validity, resolves the item's recharge group, verifies battery compatibility (provided charge),
	// and ensures current charge is below the max; sends a user-facing message on failure.
	if( !valid( batteryItem ) || !valid( rechargeableItem ) )
	{
		return false;
	}
	
	RechargeGroup rechargeable_group = GetRechargeGroup( rechargeableItem );
	if ( rechargeable_group == RG_None )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_RECHARGE_DEVICE_WRONG_CHARGE_TYPE );
		return false;
	}
	
	int battery_energy = GetEnergyChargeFromBattery( batteryItem.GetProtoId(), rechargeableItem );
	if ( battery_energy == 0 )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_RECHARGE_DEVICE_WRONG_CHARGE_TYPE );
		return false;
	}
	
	int charge_max = int ( GetMaxChargeForGroup( rechargeable_group ) );
	if ( rechargeableItem.ITEM_CUR_CHARGE >= charge_max )
	{
		cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_RECHARGE_DEVICE_CHARGED );
		return false;
	}
	
	return true;
}


bool ChargeItem( Critter& cr, Item& batteryItem, Item& rechargeableItem )
{
	// Public entry point for applying a battery to a rechargeable item.
	// Internally dispatches to a charging handler based on the item's recharge group.
	
	if ( !CanChargeItem( cr, batteryItem, rechargeableItem ) )
	{
		return false;
	}
	
	int battery_energy = GetEnergyChargeFromBattery( batteryItem.GetProtoId(), rechargeableItem );
	RechargeGroup rechargeableGroup = GetRechargeGroup( rechargeableItem );
	
	int charge_max = GetMaxChargeForGroup( rechargeableGroup );
	rechargeableItem.ITEM_CUR_CHARGE += battery_energy;
	
	if ( rechargeableItem.ITEM_CUR_CHARGE > charge_max )
	{
		rechargeableItem.ITEM_CUR_CHARGE = charge_max;
	}
	
	string rechargeable_item_name = itemName( rechargeableItem );
	string charge_info = rechargeable_item_name + " |0xFFFF00 " + rechargeableItem.ITEM_CUR_CHARGE + "|0x3CF800 /" + "|0xFFFF00 " + charge_max + "|0x3CF800 .";
	cr.SayMsg( SAY_EMOTE, TEXTMSG_GAME, STR_EMOTE_RECHARGE_DEVICE_PROCESS, "$itemName" + rechargeable_item_name );
	cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_RECHARGE_DEVICE_PROCESS, "$value" + charge_info );

	_SubItem( batteryItem, 1 );
	rechargeableItem.Update();
	
	Map@ map = cr.GetMap();
	if( valid( map ) )
	{
		PlayGenericSound( map, cr.HexX, cr.HexY, "WRJ1XXX1.mp3", 6 );
	}
	
	return true;
}
#endif // ENERGY
