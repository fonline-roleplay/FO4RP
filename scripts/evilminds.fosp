                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

class CIMP
{
	bool Destroible;
	
	uint16 TileGroup;
	
	uint16 HexX;
	uint16 HexY;
	uint Hash;
	
	Item@Object;
	
	CIMP()
	{
		@Object=null;
		
		HexX=0;
		HexY=0;
		Hash=0;
		
		Destroible=false;
	}
	
	CIMP(uint hash,Item&item,bool destroible)
	{
		Hash=hash;
		@Object=item;
		
		Destroible=destroible;
		
		if(SetPic())
		{
			HexX=Object.HexX;
			HexY=Object.HexY;
		}
	}
	
	CIMP(uint hash,Map&map)
	{
		Spawn(map);
		SetPic(hash);
	}
	
	bool Spawn(Map&map)
	{
		uint16 hexX=0,hexY=0,tempX=0,tempY=0;
		uint hash=0;
		
		map.GetEntireCoords(255,0,hexX,hexY);
		
		tempX=hexX;
		tempY=hexY;
		
		uint count=0;
		bool condition=false;
		
		if(!tileInited)
		{
			InitTiles();
		}
		
		do
		{
			hexX=Random(tempX+1,tempX+(150)-1);
			hexY=Random(tempY+1,tempY+(150)-1);  
			
			hash=map.GetTile(((hexX)>>1),((hexY)>>1));
			
			for(uint i=1;i<=32;++i)
			{
				if((((TileGroup)&(pow(2,i)))!=0))
				{
					condition=IsTileAvalible(hash,i);
					if(condition)
					{
						Log("cond");
						break;
					}
				}
			}
			
			count++;  
			
		}
		while(!map.IsHexPassed(hexX,hexY));
		
		@Object=map.AddItem(hexX,hexY,(904),1);
		
		if(!(Object is null))
		{
			Object.SetEvent((4),"cimp@e_SkillImp");
		}   
		
		HexX=hexX;
		HexY=hexY;
		
		return(!(Object is null));
	}
	
	private bool SetMapPic(uint hash)
	{
		if(Object is null)
		return false;
		
		Object.SetMapPic(hash);
		Object.Update();
		return true;
	}
	
	bool SetPic()
	{
		return SetMapPic(Hash);
	}
	
	bool SetPic(uint hash)
	{
		return SetMapPic(hash);
		
	}  
	
	Item@GetObject()
	{
		return@Object;
	}   
	
}

bool e_SkillImp(Item&item,Critter&cr,int skill)
{
	
	if(skill==(-3))
	{
		Item@[]items;
		item.GetItems(-1,items);
		if(items.length()==1)
		{
			DeleteItem(item);
			return true;
		}
	}
	return false;
}

class CLO:CIMP
{
	
	int RechLevel;
	uint16 GroupType;
	
	RespawnedItemGroup@Group;
	
	CLO()
	{
		Destroible=false;
		RechLevel=0;
		GroupType=uint16(-1);
		@Group=null;
	}
	
	CLO(uint16 groupType,int rechLvl,bool destroible)
	{
		Destroible=false;
		RechLevel=rechLvl;
		GroupType=groupType;
		
		@Group=GetItemGroup(GroupType);
		TileGroup=Group.TileGroup;
		Destroible=destroible;  
		
		if(Group is null)
		Log("NULL!!"); 
		
	}
	
	bool SpawnInto()
	{
		if(Group is null||Object is null)
		{
			Log("NULL!!");
			return false;
		}
		
		Map@map=GetMap(Object.MapId);
		if(map is null)
		{
			return false;
		}
		else
		{
			if(Group.MapProtos.find(map.GetProtoId())==-1)
			{
				
				DeleteItem(Object);
				return false;
			}
		}
		
		int len=RechLevel;
		
		if(RechLevel==-1)
		len=Group.Length();
		
		for(uint16 i=0;i<len;++i)
		{
			uint8 chance=Random(0,95);
			uint16 index=(RechLevel!=-1?Random(0,Group.Length()-1):i);
			
			if(Group.RespItems[index].Chance<chance)
			continue;
			
			uint8 count=0;
			uint16 pid=0;
			
			Group.GetItem(index,pid,count);  
			
			if(GetObject()is null)
			{
				Log("NULL!!OBJ");
				return false;
			}
			count=(RechLevel!=-1?Random(1,count):count);
			Object.AddItem(pid,count,0);
		}
		
		return true;
		
	}
	
	bool SpawnMap(Map&map)
	{
		return Spawn(map);
		
	}
	
	bool Add(Map&map)
	{
		return Spawn(map)&&SetPic(GetLOHash(GroupType))&&SpawnInto();
		
	}
}

class RespawnedItem
{
	uint8 Chance;
	uint8 Count;
	uint16 Pid;
	
	RespawnedItem()
	{
		Chance=0;
		Count=0;
		Pid=0;
	}
	
	RespawnedItem(uint16 pid,uint8 chance,uint8 count)
	{
		Chance=chance;
		Count=count;
		Pid=pid;
	} 
	
}

class RespawnedItemGroup
{
	RespawnedItem[]RespItems;
	uint[]MapProtos;
	uint TileGroup;
	
	RespawnedItemGroup()
	{
		RespItems.resize(0);
	}
	
	uint16 Length()
	{
		return RespItems.length();
	}
	
	bool GetItem(uint16 index,uint16&pid,uint8&count)
	{
		if(index>=RespItems.length())
		return false;
		
		pid=RespItems[index].Pid;
		count=RespItems[index].Count;
		
		return true;
	}
}                                                                                          

class GroupRock:RespawnedItemGroup
{
	GroupRock()
	{
		
		RespItems.insertLast(RespawnedItem((19),50,5));
		RespItems.insertLast(RespawnedItem((536),3,1));
		RespItems.insertLast(RespawnedItem((537),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
	}
} 

class GroupAnimalCorpse:RespawnedItemGroup
{
	GroupAnimalCorpse()
	{
		
		RespItems.insertLast(RespawnedItem((539),1,2));
		RespItems.insertLast(RespawnedItem((1440),3,3));
		RespItems.insertLast(RespawnedItem((449),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
	}
} 

class GroupSmallTrash:RespawnedItemGroup
{
	GroupSmallTrash()
	{
		
		RespItems.insertLast(RespawnedItem((439),3,5));
		RespItems.insertLast(RespawnedItem((98),3,2));
		RespItems.insertLast(RespawnedItem((532),2,5));
		RespItems.insertLast(RespawnedItem((542),2,5));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),1,2));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupTrash:RespawnedItemGroup
{
	GroupTrash()
	{
		
		RespItems.insertLast(RespawnedItem((439),3,2));
		RespItems.insertLast(RespawnedItem((98),3,1));
		RespItems.insertLast(RespawnedItem((532),5,2));
		RespItems.insertLast(RespawnedItem((542),4,2));
		RespItems.insertLast(RespawnedItem((519),15,10));
		RespItems.insertLast(RespawnedItem((534),2,5));
		RespItems.insertLast(RespawnedItem((475),2,1));
		RespItems.insertLast(RespawnedItem((227),1,1));
		RespItems.insertLast(RespawnedItem((226),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
} 

class GroupSleeper:RespawnedItemGroup
{
	GroupSleeper()
	{
		
		RespItems.insertLast(RespawnedItem((572),5,3));
		RespItems.insertLast(RespawnedItem((40),1,1));
		RespItems.insertLast(RespawnedItem((48),1,1));
		RespItems.insertLast(RespawnedItem((259),1,1));
		RespItems.insertLast(RespawnedItem((4),1,1));
		RespItems.insertLast(RespawnedItem((314),1,1));
		RespItems.insertLast(RespawnedItem((315),1,1));
		RespItems.insertLast(RespawnedItem((316),1,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupBox:RespawnedItemGroup
{
	GroupBox()
	{
		
		RespItems.insertLast(RespawnedItem((227),3,1));
		RespItems.insertLast(RespawnedItem((226),3,1));
		RespItems.insertLast(RespawnedItem((79),1,1));
		RespItems.insertLast(RespawnedItem((98),3,3));
		RespItems.insertLast(RespawnedItem((475),1,2)); 
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}  

class GroupMetalTrash:RespawnedItemGroup
{
	GroupMetalTrash()
	{ 
		
		RespItems.insertLast(RespawnedItem((297),3,1));
		RespItems.insertLast(RespawnedItem((475),3,1));
		RespItems.insertLast(RespawnedItem((1475),3,1));
		RespItems.insertLast(RespawnedItem((538),3,1));
		RespItems.insertLast(RespawnedItem((50),3,1));
		RespItems.insertLast(RespawnedItem((1508),3,1));
		RespItems.insertLast(RespawnedItem((1502),3,1));
		RespItems.insertLast(RespawnedItem((1504),3,1));
		RespItems.insertLast(RespawnedItem((1505),3,1));
		RespItems.insertLast(RespawnedItem((1509),3,1));
		RespItems.insertLast(RespawnedItem((1510),3,1));
		RespItems.insertLast(RespawnedItem((1507),3,1));
		RespItems.insertLast(RespawnedItem((1506),3,1));
		RespItems.insertLast(RespawnedItem((1503),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupNewspMachine:RespawnedItemGroup
{
	GroupNewspMachine()
	{
		
		RespItems.insertLast(RespawnedItem((41),3,2));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=4;
	}
}

class GroupBottleBox:RespawnedItemGroup
{
	GroupBottleBox()
	{
		
		RespItems.insertLast(RespawnedItem((532),10,2));
		RespItems.insertLast(RespawnedItem((542),15,3));
		RespItems.insertLast(RespawnedItem((124),2,3));
		RespItems.insertLast(RespawnedItem((125),2,3));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupPlant:RespawnedItemGroup
{
	GroupPlant()
	{ 
		
		RespItems.insertLast(RespawnedItem((271),100,2));
		RespItems.insertLast(RespawnedItem((272),100,3));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=2;
		
	}
}

class GroupCorpse:RespawnedItemGroup
{
	GroupCorpse()
	{
		
		RespItems.insertLast(RespawnedItem((4),1,1));
		RespItems.insertLast(RespawnedItem((532),3,1));
		
		uint[]tempPids={60,63,65,67,69,71,73,75,77,79,81,83};
		MapProtos=tempPids;
		
		TileGroup=7;
		
	}
}

class GroupEvilMinds:RespawnedItemGroup
{
	GroupEvilMinds()
	{
		RespItems.insertLast(RespawnedItem((349),100,1));
		
		RespItems.insertLast(RespawnedItem((401),100,1));
		RespItems.insertLast(RespawnedItem((1036),100,1));
		RespItems.insertLast(RespawnedItem((405),100,1));
		
		RespItems.insertLast(RespawnedItem((35),100,10));
		RespItems.insertLast(RespawnedItem((1035),100,24));
		RespItems.insertLast(RespawnedItem((39),100,100));
		
	}
} 

uint GetLOHash(uint16 groupType)
{
	string temp="art\\scenery\\";
	string[]tempAdd;
	switch(groupType)
	{                            
		
		case(100):
		tempAdd.insertLast("locker5.frm");
		break;
		
		case(10):
		tempAdd.insertLast("dead01.frm");
		tempAdd.insertLast("dead02.frm");
		tempAdd.insertLast("dead03.frm");
		tempAdd.insertLast("dead04.frm");
		tempAdd.insertLast("v13bones.frm");
		tempAdd.insertLast("bone01.frm");
		tempAdd.insertLast("bone03.frm");
		break;
		
		case(9): 
		
		tempAdd.insertLast("weed06.frm");
		tempAdd.insertLast("weed07.frm");
		break;
		
		case(8):
		tempAdd.insertLast("crate01.frm");
		tempAdd.insertLast("crate02.frm");
		tempAdd.insertLast("crate03.frm");
		break;
		
		case(7):
		tempAdd.insertLast("mailbx.frm");
		tempAdd.insertLast("newsp1.frm");
		tempAdd.insertLast("newsp2.frm");
		tempAdd.insertLast("newsp3.frm");
		tempAdd.insertLast("newsp4.frm");
		tempAdd.insertLast("newsp5.frm");
		tempAdd.insertLast("newsp6.frm");
		tempAdd.insertLast("novbud1.frm");
		tempAdd.insertLast("novbud2.frm");
		break;
		
		case(6):
		tempAdd.insertLast("junk1.frm");
		tempAdd.insertLast("junk2.frm");
		tempAdd.insertLast("junk3.frm");
		tempAdd.insertLast("junk4.frm");
		tempAdd.insertLast("junk5.frm");
		break;
		
		case(5):
		tempAdd.insertLast("boxes1.frm");
		tempAdd.insertLast("boxes2.frm");
		tempAdd.insertLast("boxes3.frm");
		tempAdd.insertLast("boxes4.frm");
		tempAdd.insertLast("njunk5.frm");
		tempAdd.insertLast("njunk6.frm");
		tempAdd.insertLast("boxes02.frm");
		tempAdd.insertLast("boxes03.frm");
		tempAdd.insertLast("boxes04.frm");
		break;
		
		case(4):
		tempAdd.insertLast("bed1.frm");
		tempAdd.insertLast("bed2.frm");
		tempAdd.insertLast("bed3.frm");
		tempAdd.insertLast("bed4.frm");
		tempAdd.insertLast("bed5.frm");
		tempAdd.insertLast("bed6.frm");
		tempAdd.insertLast("bed7.frm");
		tempAdd.insertLast("bed8.frm");
		break;
		
		case(3):
		tempAdd.insertLast("trashcn.frm");
		tempAdd.insertLast("kont1.frm");
		tempAdd.insertLast("kontsmet.frm");
		tempAdd.insertLast("weed05.frm");
		break;
		
		case(2):
		tempAdd.insertLast("weed06.frm");
		tempAdd.insertLast("weed07.frm");
		tempAdd.insertLast("weed08.frm");
		tempAdd.insertLast("weed09.frm");
		tempAdd.insertLast("weed15.frm");
		tempAdd.insertLast("weed16.frm");
		tempAdd.insertLast("weed17.frm");
		tempAdd.insertLast("trash1.frm");
		tempAdd.insertLast("trash2.frm");
		tempAdd.insertLast("trash3.frm");
		break;
		
		case(1):
		tempAdd.insertLast("bone05.frm");
		tempAdd.insertLast("bone04.frm");
		tempAdd.insertLast("bone02.frm");
		break;
		
		case(0):
		tempAdd.insertLast("rock01.frm");
		tempAdd.insertLast("rock02.frm");
		tempAdd.insertLast("rock04.frm");
		tempAdd.insertLast("rock05.frm");
		tempAdd.insertLast("rock09.frm");
		tempAdd.insertLast("rock10.frm");
		tempAdd.insertLast("rubble1.frm");
		tempAdd.insertLast("drock1.frm");
		tempAdd.insertLast("drock2.frm");
		tempAdd.insertLast("drock3.frm");
		tempAdd.insertLast("drock4.frm");
		tempAdd.insertLast("drock8.frm");
		break;
		
		default:
		break;
	}
	
	temp+=tempAdd[Random(0,tempAdd.length()-1)]; 
	
	return GetStrHash(temp);
} 

RespawnedItemGroup@GetItemGroup(uint16 groupType)
{
	RespawnedItemGroup@temp;
	switch(groupType)
	{    
		
		case(100):
		@temp=GroupEvilMinds();
		break;
		
		case(10):
		@temp=GroupCorpse();
		break;
		case(9):
		@temp=GroupPlant();
		break;
		case(8):
		@temp=GroupBottleBox();
		break;
		case(7):
		@temp=GroupNewspMachine();
		break;
		case(6):
		@temp=GroupMetalTrash();
		break;
		case(5):
		@temp=GroupBox();
		break;
		case(4):
		@temp=GroupSleeper();
		break;
		case(3):
		@temp=GroupTrash();
		break;
		case(2):
		@temp=GroupSmallTrash();
		break;
		case(1):
		@temp=GroupAnimalCorpse();
		break;
		case(0):
		@temp=GroupRock();
		break;
		default:
		@temp=null;
		break;
	}
	
	if(temp is null)
	Log("NULL!!!");
	
	return@temp;
}

bool tileInited=false;

uint[][]tileGroups((8));

void InitTiles()
{ 
	
	uint[]@data=tileGroups[(1)];
	
	data.resize(0);            
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"road0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=10;i<=43;++i)
	{
		string temp=("art/tiles/")+"road"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(3)];
	data.resize(0);
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"curb0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=1;i<=5;++i)
	{
		string temp=("art/tiles/")+"road0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(2)];
	data.resize(0);
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg100"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg200"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=1;++i)
	{
		string temp=("art/tiles/")+"edg300"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=8;++i)
	{
		string temp=("art/tiles/")+"edg400"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=8;++i)
	{
		string temp=("art/tiles/")+"edg500"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=9;++i)
	{
		string temp=("art/tiles/")+"edg600"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=1;++i)
	{
		string temp=("art/tiles/")+"edg601"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"edg700"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=4;++i)
	{
		string temp=("art/tiles/")+"eds00"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(6)];
	data.resize(0);  
	
	data.insertLast(GetStrHash(("art/tiles/")+"cav4008"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4009"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4010"+(".frm")));
	data.insertLast(GetStrHash(("art/tiles/")+"cav4011"+(".frm"))); 
	
	@data=tileGroups[(7)];
	data.resize(0);
	
	for(uint8 i=1;i<=6;++i)
	{
		for(uint8 j=1;j<=7;++j)
		{
			string temp=("art/tiles/")+"bld_floor_"+i+"_"+j+(".png");
			data.insertLast(GetStrHash(temp));
		}
	}
	
	for(uint8 i=1;i<=5;++i)
	{
		string temp=("art/tiles/")+"bld_floor_7_"+i+(".png");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=3;i<=5;++i)
	{
		string temp=("art/tiles/")+"bld_floor_8_"+i+(".png");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(5)];
	data.resize(0);
	
	for(uint8 i=0;i<=9;++i)
	{
		string temp=("art/tiles/")+"cav100"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=3;++i)
	{
		string temp=("art/tiles/")+"cav200"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=5;++i)
	{
		string temp=("art/tiles/")+"cav300"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=0;i<=7;++i)
	{
		string temp=("art/tiles/")+"cav400"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	@data=tileGroups[(4)];
	data.resize(0);
	
	for(uint8 i=1;i<=9;++i)
	{
		string temp=("art/tiles/")+"brick0"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	for(uint8 i=10;i<=13;++i)
	{
		string temp=("art/tiles/")+"brick"+i+(".frm");
		data.insertLast(GetStrHash(temp));
	}
	
	tileInited=true;     
	
}                               

bool IsTileAvalible(uint hash,uint8 group)
{
	uint[]@data=tileGroups[group];
	
	for(uint16 i=0,j=data.length();i<j;++i)
	{
		
		if(data[i]==hash)
		{
			Log("hash "+data[i]+":"+hash);
			return true;
		}
	}
	
	return false;
}

bool IsTileGround(uint hash)
{
	return IsTileAvalible(hash,(6));
}                                                                                                                                                                                                                                                                                                                                                                                                                   

import void ExplodeEx(Map&map,uint16 hexX,uint16 hexY,uint16 effectPid,uint effectRadius,uint damage,uint damageType,uint damageRadius,uint ownerId)from"explode";
import uint GetAllPlayers(Critter@[]&crs)from"manager";  

uint messageTEId=0;

void iniciate(Critter&cr,int,int,int)
{           
	
	Item@item=main();
	if(item is null)
	return;  
	
	cr.TransitToMap(item.MapId,item.HexX-1,item.HexY-1,cr.Dir);
	
}

Item@main()
{
	Item@item=SpawnContainer();
	
	if(item is null)
	{
		Log("null item");
		return null;
	}
	
	item.SetEvent((4),"evilminds@e_ContSkill");
	
	messageTEId=CreateTimeEvent(__FullSecond+1,"e_Message",item.Id,false);
	
	return@item;
}

void SetParam(Critter&cr)
{
	for(uint8 i=0;i<6;i++)
	{
		cr.ParamBase[i]=15;
	}
	
	cr.ParamBase[(8)]+=10;
	cr.ParamBase[(72)]=cr.Param[(7)];
	
	for(uint8 i=200;i<203;i++)
	{
		cr.ParamBase[i]=200;
	}
	
}

void e_Dead(Critter&cr,Critter@killer)
{
	Item@[]items;
	cr.GetItems(-1,items);
	DeleteItems(items);
}

bool e_ContSkill(Item&item,Critter&cr,int skill)
{
	
	cr.TimeoutBase[(237)]=__FullSecond+((120)*__TimeMultiplier);
	
	CreateTimeEvent(__FullSecond+((1)*__TimeMultiplier*60),"e_ExplodeCont",item.Id,false);
	cr.AddTimeEvent("cte_KillCritter",((15)*__TimeMultiplier),(38),0);
	item.SetEvent((4),"");
	cr.SetEvent((2),"e_Dead");
	
	EraseTimeEvent(messageTEId);
	
	cr.Say((11),"|0xffff0000Каждое убийство +30 секунд. Время тикает...");
	SetParam(cr); 
	
	return false; 
	
}

uint e_Message(uint[]@values)
{
	Item@cont=GetItem(values[0]);
	
	if(!(cont is null))
	{
		
		Map@map=GetMap(cont.MapId);
		
		if(!(map is null))
		{
			
			Critter@[]crs;
			GetAllPlayers(crs);
			
			for(uint8 i=0,j=crs.length();i<j;++i)
			{
				Critter@cr=crs[i];
				
				int x=0,
				y=0;   
				
				x=(((x)>(1))?(1):(((x)<(-1))?(-1):(x)));
				y=(((y)>(1))?(1):(((y)<(-1))?(-1):(y)));
				
				string msg="|0xffff0000Вы слышите голос : Иди ко мне..."; 
				
				if(cr.GetMap().Id==map.Id)
				{
					x=cont.HexX-cr.HexX;
					y=cont.HexY-cr.HexY;
					
					switch(x)
					{
						
						case 0:
						msg+="Я близко! ";
						break;
						case 1:
						msg+="Западней...";
						break;
						default:
						msg+="Восточней...";
						break;
					}
					
					switch(y)
					{
						
						case 0:
						msg+="Совсем рядом! ";
						break;
						case 1:
						msg+="На юг...";
						break;
						default:
						msg+="На север...";
						break;
					}
				}
				else
				{
					msg+="Ищи меня в другом месте..."; 
					
				}                   
				
				cr.Say((11),msg);
			}
		}
	}
	
	return 10;
}

uint e_ExplodeCont(uint[]@values)
{
	
	Item@item=GetItem(values[0]);
	
	if(!(item is null))
	{
		
		uint mapId=item.MapId,
		hexX=item.HexX,
		hexY=item.HexY;
		
		DeleteItem(item);
		
		ExplodeEx(GetMap(mapId),hexX,hexY,(4011),15,1000,(4),15,0); 
		
		main();
	}
	
	return 0;
}

uint cte_KillCritter(Critter&cr,int identifier,uint&rate)
{
	
	if(cr.Timeout[(237)]>0)
	return(((6)*__TimeMultiplier));
	cr.ToDead(Random((110),(119)),null);
	return 0;
}

Item@SpawnContainer()
{
	
	uint8 mapId=0;
	Map@map;
	CLO@clo; 
	
	mapId=Random(20,24);
	@map=GetMap(mapId);
	if(!(map is null))
	{
		@clo=CLO((100),-1,true);
	}  
	
	if(!(clo is null))
	{
		clo.Add(map);
	} 
	
	return@clo.GetObject();
	
}
