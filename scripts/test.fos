#ifndef TEST_MODULE
#define TEST_MODULE

#include "_utils.fos"
#include "local_population_h.fos"
#include "npc_planes_h.fos"
#include "radiation_h.fos"
#include "poison_h.fos"
#include "furniture_h.fos"
#include "drugs_h.fos"
#include "explode_h.fos"
#include "gm_h.fos"
#include "entire_h.fos"


import bool TransitToNewLocation( Critter& cr, uint16 locPid ) from "stdlib";

import uint8 checkSand( Map& map, uint16 tx, uint16 ty ) from "qmap_sand";

#define MAP_EDGE_ENTIRE				( 255 )
#define MAP_SIZE               		( 150 ) 

//~run test showLetters number 0 0
//~run test showLetters start end 0
void showLetters( Critter& cr, int start, int end, int )
{
	if( ( start == 0 && end == 0 ) || ( end != 0 && start > end ) )
	{
		cr.Say( SAY_NETMSG, "Usage:" + 
			"\n" + "~run test showLetters start end 0" + 
			"\n" + "~run test showLetters char 0 0" +
			"" );
	}
	
	if( end == 0 )
	{
		end = start;
	}
	
	showLetters( cr, start, end );
}

void showLetters( Critter& cr, int start, int end )
{
	string line = "0";
	for( int i = start; i <= end; i++ )
	{
		line[0] = uint(i);
		cr.Say( SAY_NETMSG, "#" + i + ") '" + line + "'" );
	}
}
	
//~run test TestReplaceWith id pid count
void TestReplaceWith( Critter& cr, int id, int pid, int count )
{
	if( id == 0 || pid == 0 || count == 0 )
	{
		InformWarning( cr, "~run test TestReplaceWith id pid count" + EoL + UINTColor(COLOR_GREEN) +
			"Arguments for testing of picture replace script:" + EoL + UINTColor(COLOR_YELLOW) +
			" 1) id - replacable item ID;" + EoL +
			" 2) pid - ProtoId of object that will replace;" + EoL +
			" 3) count - amount of items to be replaced;"
		);
		
		return;
	}
	
	Item@ item = GetItem( id );
	if( !valid( item ) )
	{
		InformError( cr, "item #" + id + " not found." );
		return;
	}
	
	string result = ReplaceWith( item, pid, count ) ? UINTColor(COLOR_GREEN) + "SUCCESS" : UINTColor(COLOR_RED) + "FAILED";
	Inform( cr, "ReplaceWith( " + id + ", " + pid + ", " + count + " ) = " + result );
	
	Inform( cr, " now it's: " + itemDesc( item ) );
}

//~run test getset action wait id
void getset( Critter& cr, int action, int wait, int ID )
{
	uint id = ID == 0 ? cr.Param[CR_VAL0] : ID;
	
	switch( action )
	{
		case( 1 ):
		{
			if( id != 0 )
			{
				uint duration = 0;
				uint[] values;
				if( GetTimeEvent( id, duration, values ) )
				{
					InformError( cr, "Existing time event �" + id + " was deleted, next tick: " + DeltaTime_HMS(duration/__TimeMultiplier) + ", parameters: " + enlistUINT( values ) );
					EraseTimeEvent( id );
				}

				id = 0;
			}
			
			uint[] values = { cr.Id, 0, Random( 0, 100 ) };
			values[1] = Random( 0, values[2] );
			id = CreateTimeEvent( AFTER( REAL_SECOND( 5 ) ), "e_getset", values, true );
			
			cr.ParamBase[CR_VAL0] = id;
			InformWarning( cr, "TE #" + id + " created, with: " + enlistUINT( values ) );
		}
		break;
		
		case( 2 ):
		{
			if( id != 0 )
			{
				uint duration = 0;
				uint[] values;
				if( GetTimeEvent( id, duration, values ) )
				{
					InformWarning( cr, "Existing TE #" + id + ", next tick within: " + DeltaTime_HMS(duration/__TimeMultiplier) + ", parameters: " + enlistUINT( values ) );
					if( wait == 0 && SetTimeEvent( id, duration, values ) )
					{
						InformError( cr, "It continues." );
					}
					else
					{
						InformError( cr, "It stops." );
					}
				}
				else
				{
					InformWarning( cr, "There is no #" + id + " TE." );
				}
			}
			else
			{
				InformWarning( cr, "Create TE." );
			}
		}
		break;
		
		case( 3 ):
		{
			if( id != 0 )
			{
				uint duration = 0;
				uint[] values;
				if( GetTimeEvent( id, duration, values ) )
				{
					InformWarning( cr, "Existing TE #" + id + ", next tick within: " + DeltaTime_HMS(duration/__TimeMultiplier) + ", parameters: " + enlistUINT( values ) );
					
					duration += REAL_SECOND( Random( -5, 5 ) );
					if( values.length() > 2 )
					{
						values[1] -= Random( 5, 10 );
						values[2] += Random( 1, 5 );
					}
					bool result = SetTimeEvent( id, duration, values );
					
					InformError( cr, ( result ? "Did" : "Did not" ) + " manage to change TE of critter." );
					
					getset( cr, 2, 0, 0 );//GET call to see current stats
				}
				else
				{
					InformWarning( cr, "There is no TE #" + id + "." );
				}
			}
			else
			{
				InformWarning( cr, "Create TE." );
			}
		}
		break;
		
		case( 4 ):
		{
			if( id != 0 )
			{
				uint duration = 0;
				uint[] values;
				if( GetTimeEvent( id, duration, values ) )
				{
					InformWarning( cr, "Existing TE #" + id + " was deleted, next tick would have been in: " + DeltaTime_HMS(duration/__TimeMultiplier) + ", params: " + enlistUINT( values ) );
					
					EraseTimeEvent( id );
				}
				else
				{
					InformWarning( cr, "TE �" + id + " does not exist." );
					cr.ParamBase[CR_VAL0] = 0;
				}				
			}
			else
				InformWarning( cr, "There is no TE to be deleted" );
		}
		break;
		
		default:
		{
			InformWarning( cr, "~run test getset action wait id" + EoL +
							"First function argument:" + EoL +
							" 1) CreateTimeEvent (creates empty TR subfoo);" + EoL + 
							" 2) GetTimeEvent (shows vallues of event);" + EoL + 
							" 3) SetTimeEvent (does nothing yet);" + EoL +
							" 4) EraseTimeEvent (deletes TE);" + repeat( 2, EoL ) +
							"Second argument of func - wait:" + EoL + 
							"if GetTimeEvent is created and is not 0 - then TE is paused." + EoL + 
							"if third argument id is 0 - then test func saves TE id in cr.Param[CR_VAL0]." 
							); 
			break;
		}
	}
}

bool subfoo( uint[] &values )
{
	values[1] = 1;
	values[2] = 5;

	return true;
}

uint e_getset( uint[]@ values )																			
{
	if( !valid( values ) || values.length() != 3 )
	{
		Log( "!values" );
		return 0;
	}
	
	Critter@ cr = GetCritter( values[0] );
	if( !valid( cr ) ) 
	{
		Log( "!cr" );
		return 0;
	}
	
	Inform( cr, "Param: " + values[1] + "/" + values[2] );
	
	values[1]++;
	
	if( values[1] > values[2] )
	{
		Inform( cr, "Event ended. " );
		return 0;
	}
	
	return REAL_SECOND( 5 );
}

//~run test setAllMobSpawn amount 0 0
void setAllMobSpawn( Critter& player, int amount, int, int )
{
	Map@[] maps;
	for( int n = 0, max = GetAllMaps( 0, maps ); n < max; n++ )
	{
		for( uint i = 0, l = mob_spawns.length(); i < l; i++ )
		{
			GetLocalVar( mob_spawns[i], maps[n].Id ).opAssign( amount );
		}
		
		for( uint i = 0, l = beast_spawns.length(); i < l; i++ )
		{
			GetLocalVar( beast_spawns[i], maps[n].Id ).opAssign( amount );
		}
		AddCritter( maps[n] );
	}
}

//#run test checksand clear showall
void unsafe_checksand( Critter& cr, int p0, int p1, int p2, string@, int[]@ args ) 
{
	CheckSand( cr, p0, p1, p2 );
}

void CheckSand(Critter& player, int param0, int param1, int param2)
{
    if( param1 != 0 )
	{
		Map@[] maps;
		for( int i = 0, iend = GetAllMaps( 0, maps ); i < iend; i++ )
		{   
			player.Say( SAY_NETMSG, "Map #" + maps[i].GetProtoId() + " has " + maps[i].CountEntire( MAP_EDGE_ENTIRE ) + "." );
		}
		return;
	}
	
	Map@ map = player.GetMap();
	int count = map.CountEntire( MAP_EDGE_ENTIRE );
	player.Say( SAY_NETMSG, "Map #" + map.GetProtoId() + " has " + count + "." );
	
	if( count != 1 )
	{
		player.Say( SAY_NETMSG, "More than 1 entire, Test Stoped!" );
		return;
	}
	
	uint16 hexX=0, hexY=0;
	if( !map.GetEntireCoords( MAP_EDGE_ENTIRE, 0, hexX, hexY ) )
	{
		player.Say( SAY_NETMSG, "FAILED" );
		return;
	}

    Item@[] marks;
    int marks_count = 0;
	marks_count += map.GetItems( PID_SMOKE, marks );
	marks_count += map.GetItems( PID_STEAM, marks );
	map.GetItems( PID_ROCK, marks );
	for( int i = 0, l = marks.length(); i < l; i++ )
	{
		DeleteItem( marks[i] );
	}
	
	if( param0 != 0 )
	{
		return;
	}
	
	int x, y;
	int new_count = 0;
	for( int dx = 0; dx < MAP_SIZE - 1; dx++ )
	{
		for( int dy = 0; dy < MAP_SIZE - 2; dy++ )
		{
			x = hexX + dx;
			y = hexY + dy;
			
			bool sand = checkSand( map, H2T( x ), H2T( y ) ) != 0;
			if( !sand )
			{
				Item@ mark = map.AddItem( x, y, PID_ROCK, 1 );
				SETFLAG( mark.Flags, ITEM_ALWAYS_VIEW );
				continue;
			}
			
			bool passed = map.IsHexPassed( x, y );
			Item@ mark = map.AddItem( x, y, passed ? PID_STEAM : PID_SMOKE, 1 );
			SETFLAG( mark.Flags, ITEM_ALWAYS_VIEW );
			new_count++;
		}
	}
	player.Say( SAY_NETMSG, "Deleted " + marks_count + ", found " + new_count + " marks." );
}

//~run test t_tele x y id
void t_tele( Critter& cr, int x, int y, int id ) 
{
	Critter@ target = GetCritter( id );
	if( !valid( target ) )
	{
		return;
	}
	target.TransitToHex( x, y, target.Dir );
}

//#run2 test mines TrapValue
void unsafe_mines( Critter& cr, int TrapValue, int p1, int p2, string@, int[]@ args ) 
{
	if( !valid( args ) || args.length() != 4 )
	{
		return;
	}
	
	int x = args[0];
	int y = args[1];
	int id = args[2];
	
	cr.Say( SAY_NETMSG, "Starting [" + x + ", " + y + "] #" + id + "." );

	if( id != 0 )
	{
		Item@ item = GetItem( id );
		item.TrapValue = TrapValue;
		item.Update();
		
		cr.Say( SAY_NETMSG, "Done with #" + id + "." );
		return;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) ) return;
	
	Item@[] items;
	uint count = map.GetItems( x, y, items );
	
	for( uint i = 0; i < count; i++ )
	{
		items[i].TrapValue = TrapValue;
		items[i].Update();
	}
	
	if( count == 0 )
	{
		Item@ item = map.AddItem( x, y, PID_TNT_PACK_ACTIVE, 1 );
		item.TrapValue = TrapValue;
		item.Update();

		cr.Say( SAY_NETMSG, "Created item." );
	}
	else
	{
		cr.Say( SAY_NETMSG, "Done " + count + " items." );
	}
}

//#run2 test setItemFlags flags itemID
void unsafe_setItemFlags( Critter& cr, int flags, int itemID, int, string@, int[]@ args )  
{ 
	if( !isGM( cr ) )
	{
		return;
	}
	
	if( itemID != 0 )
	{
		setItemFlags( cr, itemID, flags, 0 );
		return;
	}

	if( !valid( args ) || args.length() != 4 )
	{	
		return;
	}
	
	int x = args[0];
	int y = args[1];
	int id = args[2];
	
	if( id != 0 )
	{
		setItemFlags( cr, id, flags, 0 );
		return;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
	Item@[] items;
	uint count = map.GetItems( x, y, items );
	
	for( uint i = 0; i < count; i++ )
	{
		setItemFlags( cr, items[i].Id, flags, 0 );
	}
}

//~run test setItemFlags itemID flags 0 0
void setItemFlags( Critter& cr, int itemID, int flags, int ) 
{
	if( !SetItemFlags( cr, itemID, flags ) )
	{
		cr.Say( SAY_NETMSG, "Item #" + itemID + " not found." );
	}
	else
	{
		cr.Say( SAY_NETMSG, "The item: " + itemNameID( itemID ) + " has altered flags." );
	}
}

bool SetItemFlags( Critter& cr, int itemID, int flags )
{
	Item@ item = GetItem( itemID );
	if( !valid( item ) )
	{
		return false;
	}	
	item.Flags = flags;
	return true;
}

void unsafe_GM_ChangeItemPicture( Critter& player, int itemId, int hash, int , string@ , int[]@ )
{
	if( !isGM( player ) )
	{
		return;
	}
	
	Item@ item = GetItem( itemId );
	if( @item !is null )
	{
		item.PicMap = hash;
		item.PicInv = hash;
		item.Update( );
	}
}

//#run2 test setItemPic pid itemID
void unsafe_setItemPic( Critter& cr, int pid, int itemID, int, string@, int[]@ args )  
{ 
	if( !isGM( cr ) )
	{
		return;
	}
	
	if( itemID != 0 )
	{
		setItemPic( cr, itemID, pid, 0 );
		return;
	}

	if( !valid( args ) || args.length() != 4 )
	{
		return;
	}
	
	int x = args[0];
	int y = args[1];
	int id = args[2];
	
	if( id != 0 )
	{
		setItemPic( cr, id, pid, 0 );
		return;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
	Item@[] items;
	uint count = map.GetItems( x, y, items );
	
	for( uint i = 0; i < count; i++ )
	{
		setItemPic( cr, items[i].Id, pid, 0 );
	}
}

//~run test setItemPic itemID pid 0 0
void setItemPic( Critter& cr, int itemID, int pid, int ) 
{
	if( !SetItemPic( cr, itemID, pid ) )
	{
		cr.Say( SAY_NETMSG, "Item #" + itemID + " not found." );
	}
	else
	{
		cr.Say( SAY_NETMSG, "The item " + itemNameID( itemID ) + " has altered picture." );
	}
}

bool SetItemPic( Critter& cr, int itemID, int pid )
{
	Item@ item = GetItem( itemID );
	if( !valid( item ) )
	{
		return false;
	}
	
	uint mapHash = 0, invHash = 0;
	ProtoItem@ proto = GetProtoItem( pid );
	if( @proto !is null )
	{
        mapHash = proto.PicMap;
        invHash = proto.PicInv;
    }		
	
	if( mapHash != 0 )
	{
		item.PicMap = mapHash;
        item.PicInv = ( 0 == invHash || 1130487561 == invHash ) ? mapHash : invHash;
		item.Update();
		return true;
	}
	
	cr.Say( SAY_NETMSG, "target pid #" + pid + " not found." );
	return true;
}

/*
// Planes types
#define AI_PLANE_MISC                            ( 0 )
#define AI_PLANE_ATTACK                          ( 1 )
#define AI_PLANE_WALK                            ( 2 )
#define AI_PLANE_PICK                            ( 3 )
#define AI_PLANE_PATROL                          ( 4 ) // WIP
#define AI_PLANE_COURIER                         ( 5 ) // WIP

// Planes deault priority
#define AI_PLANE_MISC_PRIORITY                   ( 10 )
#define AI_PLANE_ATTACK_PRIORITY                 ( 50 )
#define AI_PLANE_WALK_PRIORITY                   ( 20 )
#define AI_PLANE_PICK_PRIORITY                   ( 35 )
#define AI_PLANE_PATROL_PRIORITY                 ( 25 )
#define AI_PLANE_COURIER_PRIORITY                ( 30 )
*/

//~run test CheckNPCBag id setTime 0
void CheckNPCBag( Critter& cr, int targetId, int setTime, int ) 
{
	Critter@ target = GetCritter( targetId );
	if( !valid( target ) || target.IsPlayer() )
	{
		return; 
	}
	
	uint minutes = target.GetBagRefreshTime();
	
	if( setTime != 0 )
	{
		target.SetBagRefreshTime( setTime );
	}
	
	cr.Say( SAY_NETMSG, "Until bag #" + target.Stat[ST_BAG_ID] + " restart: " + minutes + ( setTime != 0 ? " was, now " + setTime : "" ) );
}

//~run test CrShowContainer 0 0 0
void CrShowContainer(Critter& cr, int, int, int ) 
{ 
	ShowContainer( cr, cr.GetItem( 0, SLOT_HAND1 ), TRANSFER_SELF_CONT );
}

//~run test setDir dir 0 0
void setDir(Critter& cr, int dir, int, int ) 
{ 
	cr.SetDir( dir );
	cr.Say( SAY_NETMSG, "" + cr.Dir );
}

//~run test r_log itemID action 0
void r_log(Critter& cr, int itemID, int action, int ) 
{ 
	LogItemMovement( cr, GetItem( itemID ), "#" + action ); 
}

//~run test testWeight 0 0 0
void testWeight( Critter& cr, int, int, int )
{
	cr.Say( SAY_NORM, "" + ItemsWeight( cr ) );
}

void unsafe_log_itemMovement(Critter& cr, int itemID, int action, int, string@, int[]@ ) 
{ 
	LogItemMovement( cr, GetItem( itemID ), "#" + action ); 
}

//~run test getDeathHitpoints crId 0 0 
void getDeathHitpoints( Critter& cr, int crId, int p1, int p2 )
{
	Critter@ target = getTarget( cr, crId );
	cr.Say( SAY_NETMSG, "" + getDeathHitPoints(target) );
}

void testCut( Critter& cr, int val, int depth, int ceiled )
{
	cr.Say( SAY_NETMSG, "" + cutLesserDigits( val * 0.00001, depth, ceiled == 1 ) );
}

void setVALs( Critter& cr, int start = 0, int end = 9, int val = 0 )
{
	if( start < 0 || end > CR_VAL9 )
	{
		return;
	}
	
	for( int i = CR_VAL0 + start; i < CR_VAL0 + end; i++ )
	{
		cr.ParamBase[ i ] = val;
	}
}

//~run test test_findLast 0 0 0
void test_findLast( Critter& cr, int, int, int )
{
	string text = "12345678901234567890";
	string f = "" + Random( 0, 9 );
	int first = findFirst ( text, f, 0 );
	int last = findFirst( text, f, first + 1 ); //findLast always returns -1
	cr.Say( SAY_NORM, "Searching '" + f + "' is " + first + " to " + last );
}

//~run test makeBackup year month day
void makeBackup( Critter& cr, int year, int month, int day )
{
    file source, dest;
	string word = "";
	string name = "saylog_" + ( year < 10 ? "0" + year : "" + year ) + "_" + ( month < 10 ? "0" + month : "" + month ) + "_" + ( day < 10 ? "0" + day : "" + day ) + ".txt";
    if( source.open( "logs\\saylog.txt", "r" ) >= 0 && dest.open( "logs\\" + name, "a" ) >= 0 )
    {
        //f.setPos( 0 );
        while( !source.isEndOfFile() )
        {
			source.readLine( word );
			dest.writeString( word );
        }
        source.close();
		dest.close();
		if( source.open( "logs\\saylog.txt", "w" ) >= 0 )
		{
			cr.Say( SAY_NETMSG, "Saved to: '" + name + "'" );
			source.close();
		}
		else
			cr.Say( SAY_NETMSG, "Failed to erase saylog!" );
    }
    else
        Log( "Can't open files!" );
}

void unsafe_GM_showDescs( Critter& cr, int x, int y, int r, string@, int[]@ )
{
	if( !isGM( cr ) ) return;
	
	Map@ map = cr.GetMap();
	if(!valid(map)) return;

	Item@[] descs;
	uint count = map.GetItems( PID_POPUP, descs );
	for( uint i = 0; i < count; i++ )
	{
		if( GetDistantion( x, y, descs[i].HexX, descs[i].HexY ) < uint( r ) )
		{ 
			if( FLAG( descs[i].Flags, ITEM_HIDDEN ) ) 
			{
				//descs[i].PicMap = visible;			
				UNSETFLAG( descs[i].Flags, ITEM_HIDDEN );
				descs[i].Val7 = 1;
			}
			else 
			{
				//descs[i].PicMap = hidden;			
				SETFLAG( descs[i].Flags, ITEM_HIDDEN );
				descs[i].Val7 = 0;
			}
			descs[i].Update();
		}
	}
}

void unsafe_GM_respawn( Critter& cr, int id, int, int, string@, int[]@ )
{
	if( !isGM( cr ) ) return;
	Critter@ target = id != 0 ? GetCritter( id ) : @cr;
	if( valid(target) )
	{
		target.ToLife();
		target.ParamBase[ CR_VAL0 ];
	}
}

void unsafe_Copy( Critter& cr, int crId, int itemId, int, string@, int[]@ )
{
	_Copy( cr, crId, itemId, 0 );
	cr.ParamBase[ CR_TARGET_CONTAINER_ID ] = 0;
}

void _Copy( Critter& cr, int crId, int itemId, int )
{
	bool hasTarget = true;
	
	Critter@ target = GetCritter( crId );
	if( valid( target ) )
	{
		if( target.IsPlayer() )
		{
			if( cr.Param[ QST_GAMEMODE ] != GAME_TEST )
			{
				InformWarning( cr, "In order to fully copy stats and items of target critter switch to TEST mode." );
				return;
			}
			
			clearInv( cr );
			FullClone( cr, target );
			DublicateLoot( cr, target );
		}
		else
		{
			Critter@ mob = CopyMob( cr, target );			
			
			if( valid( mob ) )
			{				
				switch( cr.ParamBase[CR_VAL2] )
				{
					case( 1 ): { mob.SetScript( "mob@_MobInit" ); break; }//animal
					case( 2 ): { mob.SetScript( "ai_guards@_AiGuardsInit" ); break; }//sentient
				}				
			}
		}
		
		return;
	}
	else hasTarget = false;
		
	
	bool hasItem = true;
	
	Item@ item = GetItem( itemId );
	if( valid( item ) )
	{
		DublicateItem( cr.AddItem( item.GetProtoId(), item.GetCount() ), item );
	}
	else hasItem = false;
	
	
	if( !hasTarget && !hasItem )
	{
		InformWarning( cr, "Move cursor on target critter or item. Command works on inventory screen as well." );
	}
}

void toggle_Armor( Critter& cr )
{
	Item@ armor = _CritGetItemArmor( cr );
	if( valid( armor ) )
	{
		cr.MoveItem( armor.Id, 1, SLOT_INV );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_OFF );
		cr.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 1;
		return;
	} 
	
	Item@[] armors;
	uint count = cr.GetItemsByType( ITEM_TYPE_ARMOR, armors );
	if( count > 0 )
	{
		@ armor = armors[0];
		cr.MoveItem( armor.Id, 1, SLOT_ARMOR );
		cr.SetFavoriteItem( SLOT_ARMOR, armor.GetProtoId() );
		cr.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 0;
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_ON );
	}
}

void toggle_head( Critter& cr )
{
	Item@ head = _CritGetItemHead( cr );
	if( valid( head ) )
	{
		cr.MoveItem( head.Id, 1, SLOT_INV );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_OFF );
		return;
	} 
	
	Item@[] items;
	uint count = cr.GetItemsByType( ITEM_TYPE_MISC, items );
	bool found = false;
	for( uint i = 0; i < count; i++ )
	{
		@ head = items[i];
		if( valid( head ) && head.Proto.Slot == SLOT_HEAD )
		{
			found = true;
			break;
		}
	}
	
	if( valid( head ) && found )
	{
		cr.MoveItem( head.Id, 1, SLOT_HEAD );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_ON );
	}
}

void toggle_back( Critter& cr )
{
	Item@ back = _CritGetItemBack( cr );
	if( valid( back ) )
	{
		cr.MoveItem( back.Id, 1, SLOT_INV );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_OFF );
		return;
	} 
	
	Item@[] items;
	uint count = cr.GetItemsByType( ITEM_TYPE_CONTAINER, items );
	bool found = false;
	for( uint i = 0; i < count; i++ )
	{
		@ back = items[i];
		if( valid( back ) && back.Proto.Slot == SLOT_BACK )
		{
			found = true;
			break;
		}
	}
	
	if( valid( back ) && found )
	{
		cr.MoveItem( back.Id, 1, SLOT_BACK );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_ON );
	}
}

void toggle_misc( Critter& cr )
{
	Item@ misc = _CritGetItemMisc( cr );
	if( valid( misc ) )
	{
		cr.MoveItem( misc.Id, 1, SLOT_INV );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_OFF );
		return;
	} 
	
	Item@[] items;
	uint count = cr.GetItemsByType( ITEM_TYPE_CONTAINER, items );
	count += cr.GetItemsByType( ITEM_TYPE_MISC, items );
	bool found = false;
	for( uint i = 0; i < count; i++ )
	{
		@ misc = items[i];
		if( valid( misc ) && misc.Proto.Slot == SLOT_MISC )
		{
			found = true;
			break;
		}
	}
	
	if( valid( misc ) && found )
	{
		cr.MoveItem( misc.Id, 1, SLOT_MISC );
		cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_ARMOR_ON );
	}
}

void updateFavoriteWeapon( Critter& cr )
{
	Item@[] wpn;
	uint count = cr.GetItemsByType( ITEM_TYPE_WEAPON, wpn );
	if( count == 0 )
	{
		return;
	}
	
	uint n = 0, max = 0, skill;
	for( uint i = 0; i < count; i++ )
	{
		skill = cr.Skill[ wpn[i].Proto.Weapon_Skill_0 ];
		if( skill > max )
		{
			n = i;
			max = skill;
		}
	}
	cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_COMBAT, STR_EMOTE_WEAPON_CHECK );
	cr.SetFavoriteItem( SLOT_HAND1, wpn[n].GetProtoId() );
	cr.StatBase[ ST_LAST_WEAPON_ID ] = wpn[n].Id;
}

Item@ ArmFavoriteWeapon(Critter& critter)
{
    uint16 pid = critter.GetFavoriteItem( SLOT_HAND1 );

    Item@  weapon = critter.GetItem(pid, -1);

    if( valid( weapon ) )
	{
        critter.MoveItem( weapon.Id, 1, SLOT_HAND1 );
		critter.StatBase[ ST_LAST_WEAPON_ID ] = weapon.Id;
    }

	critter.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 0;
    return weapon;
}

Item@ RemoveFavoriteWeapon(Critter& critter)
{
    uint16 pid = critter.GetFavoriteItem(SLOT_HAND1);

    Item@  weapon = critter.GetItem( pid, -1 );

    if(valid(weapon))
    {
        critter.MoveItem( weapon.Id, 1, SLOT_INV );
		critter.StatBase[ ST_LAST_WEAPON_ID ] = weapon.Id;
    }
	
	critter.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 1;
    return weapon;
}

void unsafe_head_update( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			toggle_head( crit );
		}
	}
}

void unsafe_back_update( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			toggle_back( crit );
		}
	}
}

void unsafe_misc_update( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			toggle_misc( crit );
		}
	}
}

void unsafe_armor_update( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			toggle_Armor( crit );
		}
	}
}

void unsafe_weapon_update( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			updateFavoriteWeapon( crit );
		}
	}
}

void unsafe_weapon_show( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			ArmFavoriteWeapon( crit );
		}
	}
}

void unsafe_weapon_hide( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) )
	{
		return;
	}
	
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
		{
			RemoveFavoriteWeapon( crit );
		}
	}
}

//~run test _SetFavWpn id slot pid
void _SetFavWpn( Critter& cr, int id, int slot, int pid )
{
	if( id == 0 || slot == 0 )
	{
		cr.Say( SAY_NETMSG, "Function arguments for favorite weapon: critterID, slot, weaponPID." );
		return;
	}
	Critter@ target = GetCritter( id );
	if( !valid( target ) )
	{
		cr.Say( SAY_NETMSG, "Target #" + id + " not found." );
		return;
	}
	target.SetFavoriteItem( slot, pid );
	target.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 0;
}

//~run test _GetFavWpn id slot 0
void _GetFavWpn( Critter& cr, int id, int slot, int )
{
	if( id == 0 || slot == 0 )
	{
		cr.Say( SAY_NETMSG, "Function arguments for favorite weapon: critterID, slot, weaponPID." );
		return;
	}
	Critter@ target = GetCritter( id );
	if( !valid( target ) )
	{
		cr.Say( SAY_NETMSG, "Target #" + id + " not found." );
		return;
	}
	cr.Say( SAY_NETMSG, "Favorite weapon for slot #" + slot + " is " + target.GetFavoriteItem( slot ) );
}

//#run2 test FindItem action id
void unsafe_FindItem( Critter& cr, int action, int id, int p2, string@, int[]@ args ) 
{ 
	if( !isGM( cr ) )
	{
		return;
	}
	
	if( id != 0 )
	{
		FindItem( cr, action, id, 0 );
		return;
	}

	if( !valid( args ) || args.length() != 4 )
	{
		return;
	}
	
	int x = args[0];
	int y = args[1];
	id = args[2];
	
	if( id != 0 )
	{
		FindItem( cr, action, id, 0 );
		return;
	}
	
	Map@ map = cr.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	
	Item@[] items;
	uint count = map.GetItems( x, y, items );
	
	if( count > 0 )
	{
		FindItem( cr, items[0].Id, action, 0 );
	}
}

//~run test FindItem action id 0
void FindItem( Critter& player, int action, int id, int )
{
	if( id == 0 )
	{
		player.Say( SAY_NETMSG, "item search function.\ncass synthax: id target item, action, 0.\ntype action: 0 (show info), 1 (teleport to object), 2 (take object), 3 (gm menu for object)." );
		return;
	}
	Item@ target = GetItem( id );
	if( !valid(target) )
	{
		player.Say( SAY_NETMSG, "item not found!" );
		return;
	}
	switch( action )
	{
		case( 0 ):
			player.Say( SAY_NETMSG, ItemState( target, true ) );
			break;
		case( 1 ):
		{
			switch( target.Accessory )
			{
				case( ACCESSORY_CRITTER ):
					TeleToTarget( player, GetCritter( target.CritId ) );
					break;
				case( ACCESSORY_CONTAINER ):
				{
					@target = GetItem( target.ContainerId );
				}
				case( ACCESSORY_HEX ):
					TeleToTarget( player, target );
					break;
				default:
					player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_THIS_DID_NOTHING);
					break;
			}
			break;
		}
		case( 2 ):
			MoveItem( target, target.GetCount(), player );
			break;
		case( 3 ):
			GM_PANNEL_ITEM( player, target.Id, 0, 0, null, null );
			break;
		default:
			player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_THIS_DID_NOTHING);
			break;
	}
}

void TeleToTarget( Critter& player, Critter@ target )
{
	Map@ map = target.GetMap();
	if( !valid( map ) )
	{
		return;
	}
	TeleToTarget( player, map, target.HexX, target.HexY );
}

void TeleToTarget( Critter& player, Item@ target )
{
	Map@ map = GetMap( target.MapId );
	if( !valid( map ) )
	{
		return;
	}
	TeleToTarget( player, map, target.HexX, target.HexY );
}

void TeleToTarget( Critter& player, Map@ map, uint16 x, uint16 y )
{
	bool success = false;

	if(!valid(map))
	{
		if( player.IsPlayer() )
		{
			player.Say( SAY_NETMSG, "Map unavailable!" );
		}
		return;
	}

	for( int dx = -1; dx < 2; dx++ )
	{
		for( int dy = -1; dy < 2; dy++ )
		{
			if( map.IsHexPassed( x + dx, y + dy ) )
			{
				player.TransitToMap ( map.Id, x + dx, y + dy, player.Dir, 2, false );
				success = true;
				break;
			}
		}
	}
	
	if( player.IsPlayer() && isGM( player ) )
	{
		if( success )
		{
			player.Say( SAY_NETMSG, "|0xFFFF00 Teleport successfull." );
		}
		else
		{
			player.Say( SAY_NETMSG, "|0xFFFF00 You failed to teleport to target." );
		}
	}
}

uint[] _ItemFlags = 
{
	ITEM_HIDDEN								,// 0x00000001 )
	ITEM_FLAT                                ,// 0x00000002 )
	ITEM_NO_BLOCK                            ,// 0x00000004 )
	ITEM_SHOOT_THRU                          ,// 0x00000008 )
	ITEM_LIGHT_THRU                          ,// 0x00000010 )
	ITEM_TWO_HANDS                           ,// 0x00000080 )
	ITEM_BIG_GUN                             ,// 0x00000100 )
	ITEM_ALWAYS_VIEW                         ,// 0x00000200 )
	ITEM_HAS_TIMER                           ,// 0x00000400 )
	ITEM_BAD_ITEM                            ,// 0x00000800 )
	ITEM_NO_HIGHLIGHT                        ,// 0x00001000 )
	ITEM_SHOW_ANIM                           ,// 0x00002000 )
	ITEM_SHOW_ANIM_EXT                       ,// 0x00004000 )
	ITEM_LIGHT                               ,// 0x00008000 )
	ITEM_GECK                                ,// 0x00010000 )
	
	// Group2
	ITEM_TRAP                                ,// 0x00020000 )
	ITEM_NO_LIGHT_INFLUENCE                  ,// 0x00040000 )
	ITEM_NO_LOOT                             ,// 0x00080000 )
	ITEM_NO_STEAL                            ,// 0x00100000 )
	ITEM_GAG                                 ,// 0x00200000 )
	ITEM_COLORIZE                            ,// 0x00400000 )
	ITEM_COLORIZE_INV                        ,// 0x00800000 )
	ITEM_CAN_USE_ON_SMTH                     ,// 0x01000000 )
	ITEM_CAN_LOOK                            ,// 0x02000000 )
	ITEM_CAN_TALK                            ,// 0x04000000 )
	ITEM_CAN_PICKUP                          ,// 0x08000000 )
	ITEM_CAN_USE                             ,// 0x10000000 )
	ITEM_HOLODISK                            ,// 0x20000000 )
	ITEM_RADIO                               // 0x40000000 )
};

void unsafe_ShowFlags( Critter& player, int id, int, int, string@, int[]@ )
{
	ShowFlags( player, id, 0, 0 );
}

void ShowFlags( Critter& player, int id, int p1, int p2 )
{
	//player.Say( SAY_NETMSG, "" );

	if( id == 0 || p1 != 0 || p2 != 0 )
	{
		player.Say( SAY_NETMSG, "first func argument has to be item id, rest are 0." );
		return;
	}
	
	Item@ item = GetItem( id );
	if( !valid(item) )
	{
		player.Say( SAY_NETMSG, "Item not fond." );
		return;
	}
	
	player.Say( SAY_NORM, "" + item.Flags );
}

void unsafe_MakeFurniture( Critter& cr, int id, int, int, string@ , int[]@ data )
{
	if( !isGM( cr ) || id == 0 )
	{
		return;
	}
	
	Item@ source = GetItem( id );

	Item@ frm = null;
	if( valid( source ) && ( source.Proto.Item_Subtype == ITEM_SUBTYPE_FURNITURE || isContainer( source ) ) )
	{
		@frm = cr.AddItem( source.GetProtoId(), 1 );
	}
	else
	{
		@frm = cr.AddItem( PID_FRM_ITEM, 1 );
	}
	
	if( !valid( frm ) )
	{
		return;
	}
	
	if( !valid( source ) )
	{
		if( !valid( data ) || data.length() != 3 )
		{
			cr.Say( SAY_NETMSG, "Move cursor on an object" );
			return;
		}
		
		frm.Val9 = data[0];
		frm.PicMap = data[1];
		frm.PicInv = data[2] == 1130487561 ? data[1] : data[2]; // 1130487561 == [ERROR] picture.
	}
	else
	{
		string@ lexems = Item_GetLexems( source );
		if( valid( lexems ) )
			frm.SetLexems( lexems );

		if( source.Info == 11 )
		{
			frm.Val9 = source.Val9 != 0 ? source.Val9 : PID_FRM_ITEM;//simple imitation.
			frm.Flags = source.Flags;
		}
		else
		{
			frm.Val9 = source.GetProtoId();
			
			uint[] furnuture_default_flags = { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0 };
			for( uint i = 0; i < furnuture_default_flags.length(); i++ )
			{
				if( furnuture_default_flags[i] == 0 )
				{
					UNSETFLAG( frm.Flags, _ItemFlags[i] );
				}
				else
				{
					SETFLAG( frm.Flags, _ItemFlags[i] );
				}
			}		
		}
		
		frm.PicMap = source.PicMap;
		frm.PicInv = source.PicInv == 0 ? source.PicMap : source.PicInv;
		
		if( isContainer( source ) )
		{
			DublicateLoot( frm, source );
		}
	}

	frm.Info = 11;
	frm.Update( );
	
	cr.Say( SAY_NETMSG, "Furniture copied to your inventory." );
}

#define DIVIDER		"::"

uint getSlotItemCost( Critter& player, Critter& cr, uint slot, string info )
{
	uint summ = 0;
	Item@[] items;
	uint count = cr.GetItems( slot, items );
	if( count > 0 )
	{
		player.Say( SAY_NETMSG, info );
		for( uint i = 0, len = items.length(); i < len; i++ )
			summ += ShowItemsCost( player, items[i], " " );
	}
	
	return summ;
}

void unsafe_getCost( Critter& player, int itemId, int x, int y, string@ , int[]@ )
{
	if( !isGM( player ) )
	{
		if( player.IsBusy() || player.IsDead() || player.IsKnockout() ) return;

		if( player.Timeout[ TO_SK_STEAL ] > 0 )
		{
			player.Say( SAY_NETMSG, "you are too tired, try again." );
			return;
		}

		player.Say( SAY_NETMSG, "this action is not available to players." );
		return;
	}
	
	Map@ map = player.GetMap();
	if( !valid( map ) ) return;
	
    uint16   hx = player.HexX, hy = player.HexY;
    map.MoveHexByDir( hx, hy, player.Dir, 1 );
	
	if( x != 0 )
		hx = x;
	
	if( y != 0 )
		hy = y;

	map.SetText( hx, hy, COLOR_SAND, "|0xFF828a96 :noise:" );
	player.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 2 );
	player.Animate( 0, ANIM2_PICKUP, null, true, true );
	player.Wait( 1000 );

	Item@[] loot;
	uint count = map.GetItems( hx, hy, loot );
	Critter@ target = map.GetCritter( hx, hy );
	if( !valid( target ) && count == 0 )
	{
		player.Say( SAY_NETMSG, "Empty. Face target 1 hex away." );
		return;
	}
	
	uint summ = 0;
	if( valid( target ) )
	{
		summ += getSlotItemCost( player, target, SLOT_INV,   "inventory:" );
		summ += getSlotItemCost( player, target, SLOT_HAND1, "left hand:" );
		summ += getSlotItemCost( player, target, SLOT_HAND2, "right hand:" );
		summ += getSlotItemCost( player, target, SLOT_ARMOR, "armor:" );
		summ += getSlotItemCost( player, target, SLOT_MISC, "misc:" );
		summ += getSlotItemCost( player, target, SLOT_HEAD, "head:" );
		summ += getSlotItemCost( player, target, SLOT_BACK, "back:" );
	}

	for( uint i = 0; i < count; i++ )
		summ += ShowItemsCost( player, loot[i], "" );
	
	player.Say( SAY_NETMSG, "Total: " + summ + "$" );
}

uint ShowItemsCost( Critter& player, Item@ item, string prefix )
{
	if( !valid( item ) ) return 0;
	
	int v, n;
	uint count = 0;
	Item@[] loot;
	
	if( item.GetType() != ITEM_TYPE_CONTAINER )
	{
		v = item.Proto.Cost;
		n = item.GetCount();
		Talk( player, SAY_NETMSG, prefix + itemName( item ) + ": " + v + " * " + n + " = " + ( v * n ) + "$" );
		return v * n;
	}

	count = item.GetItems( uint(-1), loot );

	uint summ = 0;
	if( count > 0 )
	{
		player.Say( SAY_NETMSG, prefix + "there is " + itemName( item ) + " inside:" );
		for( uint i = 0, len = loot.length(); i < len; i++ )
		{
			summ += ShowItemsCost( player, loot[i], prefix + " " + i + ") " );
		}
		player.Say( SAY_NETMSG, prefix + "Container total: " + summ + "$" );
	}
	else
	{
		v = item.Proto.Cost;
		n = item.GetCount();
		player.Say( SAY_NETMSG, prefix + itemName( item ) + ": " + v + " * " + n + " = " + ( v * n ) + "$"	);
	}
	
	return summ;
}

//~run test getVolume id 0 0
void getVolume( Critter& cr, int p0, int p1, int p2 )
{
	if( p0 == 0 ) return;
	Item@ item = GetItem( p0 );
	if( !valid( item ) ) return;
	int v = item.Proto.Volume;
	int n = item.GetCount();
	cr.Say( SAY_NETMSG, "This is #" + item.Id + "/" + item.GetProtoId() + ": " + v + " * " + n + " = " + ( v * n ) );
}

string name( uint pid )
{
	return DIVIDER + pid * 100 + DIVIDER;
}

string desc( uint pid, uint number = 0 )
{
	return DIVIDER + ( pid * 100 + 1 + number * 2 ) + DIVIDER;
}

//~run test TestTalk 0 0 0
void TestTalk( Critter& cr, int, int, int )
{
	Talk( cr, SAY_NETMSG, "You see " + name( PID_ROCK ) + " in front of you. Taking a closer look you are certain that:\n" + desc( PID_ROCK ) );
}

void Talk( Critter& cr, int say_type, string@ text )
{
	cr.RunClientScript( "client_main@__Talk", say_type, 0, 0, text, null );
}

void unsafe_CritterSay( Critter& cr, int say_type, int p1, int p2, string@ text, int[]@ data )
{
	cr.Say( say_type, text );
}


void clearCashe( Critter& cr, int npc_id, int player_id, int param2 )
{
	if( npc_id == 0 && player_id == 0 && param2 == 0 )
	{
		cr.Say( SAY_NETMSG, "Arguments:  NPC Id, Player Id, 0" );
		return;
	}
	
	Critter@ npc = GetCritter( npc_id );
	Critter@ player = GetCritter( player_id );
	if(!valid(npc)&&!valid(player))
	{
		cr.Say( SAY_NETMSG, "Didnt work.");
		return;
	}
	
	if(valid(npc))
	{
		npc.ClearEnemyStack();
		if(valid(player))
		{
			EraseAttackPlane(npc,player);
		}
		cr.Say( SAY_NETMSG, "Success.");
		return;
	}

	cr.Say( SAY_NETMSG, "Fail.");
}

void test( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    if( not valid( map ) )
        return;
    Item@ car = map.AddItem( p0, p1, PID_HUMMER, 1 );
    // if(not valid(car)) return;
    SETFLAG( car.Flags, ITEM_GECK );
    car.Update();
}

class Example
{
    int    a;
    int8   b;
    uint16 c;
    uint64[] arr;
    string str;
}

#include "serializator.fos"
void test2( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    e.a = -100;
    e.b = 123;
    e.c = 60000;
    e.str = "Example!";
    e.arr.resize( 5000 );

    for( uint i = 0; i < 10; i++ )
    {
        Serializator save;
        save.Set( e.arr ).Set( e.a ).Set( e.b ).Set( e.c ).Set( e.str ).Save( "Example_" + i );
    }

    cr.Say( SAY_NETMSG, "0<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void test3( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    for( uint i = 0; i < 10; i++ )
    {
        Serializator load;
        if( load.Load( "Example_" + i ) )
            load.Get( e.arr ).Get( e.a ).Get( e.b ).Get( e.c ).Get( e.str );
    }

    cr.Say( SAY_NETMSG, "1<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void zero( Critter& cr, int p0, int p1, int p2 )
{
    float t = 1.0f / 0.9f;
    cr.Say( SAY_NETMSG, "!!!!!!!!!!!!!!" );
}

void test4( Critter& cr, int p0, int p1, int p2 )
{
    uint16 year = 0;
    uint16 month = 0;
    uint16 day_of_week = 0;
    uint16 day = 0;
    uint16 hour = 0;
    uint16 minute = 0;
    uint16 second = 0;
    GetGameTime( __FullSecond, year, month, day, day_of_week, hour, minute, second );
    uint   fm = GetFullSecond( year, month, day, hour, minute, second );

    Log( "Real: " + "FullSecond " + __FullSecond + " Year " + __Year + " Month " + __Month + " Day " + __Day + " Hour " + __Hour + " Minute " + __Minute + " Second " + __Second );
    Log( "Calc: " + "FullSecond " + fm + " Year " + year + " Month " + month + " Day " + day + " Hour " + hour + " Minute " + minute + " Second " + second + " DayOfWeek " + day_of_week );
}

void inventory( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_INVENTORY, 0, "" );
}

void cha( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CHARACTER, 0, "" );
}

void fixboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
}

void pipboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_PIPBOY, 0, "" );
}

void minimap( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_MINIMAP, 0, "" );
}

void close( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CLOSE, 0, "" );
}

void DLog( string& str )
{
    Log( str );
}

class SomeClassA
{
    int A;

    ~SomeClassA()
    {
        Log( "destruct" );
    }
}

class SomeClassB
{
    SomeClassA@ nullptr;
    SomeClassB( SomeClassA@ aPtr )
    {
        this.nullptr.A = 100;       // Null pointer access, but after this class a is destroyed
    }
}

void test10( Critter& crit, int p0, int p1, int p2 )
{
    SomeClassA a;
    SomeClassB( a );
}

void _Begin( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "Begin, reason: " + reason + "." );
}

void _End( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "End, reason: " + reason + "." );
}

void test13( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    Log( "begin" );
    if( map.Reload() )
        Log( "ok" );
}

void test14( Critter& cr, int p0, int p1, int p2 )
{
    Map@ location = cr.GetMap();
    Log( "begin loc" );
    if( location.Reload() )
        Log( "ok" );
}

void test15( Critter& cr, int p0, int p1, int p2 )
{
    cr.RunClientScript( "__Test", p0, p1, p2, null, null );
}

void test16( Critter& cr, int p0, int p1, int p2 )
{
    uint[] ui( 3 );
    ui[ 0 ] = p0;
    ui[ 1 ] = p1;
    ui[ 2 ] = p2;
    CreateTimeEvent( __FullSecond + 5 * 60, "e_Test", ui, true );
}

uint e_Test( uint[] @ values )
{
    Log( "Values (" + values.length() + "): " + values[ 0 ] + ", " + values[ 1 ] + ", " + values[ 2 ] + "." );
    return REAL_SECOND( 5 );
}

void test17( Critter& cr, int p0, int p1, int p2 )
{
    Log( "Show callback." );
}

void testGroup( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;
    Critter@ npc2 = GetCritter( uint( p1 ) + 5000000 );
    if( not valid( npc2 ) )
        return;

    Critter@[] group( 2 );
    @group[ 0 ] = npc;
    @group[ 1 ] = npc2;

    cr.TransitToGlobal( group );
}

void testLex( Critter& cr, int p0, int p1, int p2 )
{
    Item@[] items;
    cr.GetItems( -1, items );
    for( uint i = 0; i < items.length(); i++ )
        items[ i ].SetLexems( "$Number" + Random( 100, 200 ) );

    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    npc.SetLexems( "$name" + "Dude" );
    Log( "Done" );
}

void testFly( Critter& cr, int p0, int p1, int p2 )
{
    Log( "x " + cr.HexX + " y " + cr.HexY );
    cr.GetMap().RunFlyEffect( p0, null, null, cr.HexX, cr.HexY, p1, p2 );
}

void testDelItem( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cl = GetCritter( uint( p0 ) );
    if( not valid( cl ) )
        return;
    DeleteItem( cl.GetItem( 0, p1 ) );
}

void testSwap( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr1 = GetCritter( uint( p0 ) );
    Critter@ cr2 = GetCritter( uint( p1 ) );
    SwapCritters( cr1, cr2, true, true );
}

void test_find( Critter& cr, int p0, int p1, int param2 )
{
    Map@ map = cr.GetMap();
    int  f = 0;
    switch( p0 )
    {
    case 0:
        f = FIND_LIFE;
        break;
    case 1:
        f = FIND_KO;
        break;
    case 2:
        f = FIND_DEAD;
        break;
    case 3:
        f = FIND_LIFE_AND_KO;
        break;
    case 4:
        f = FIND_LIFE_AND_DEAD;
        break;
    case 5:
        f = FIND_KO_AND_DEAD;
        break;
    case 6:
        f = FIND_ALL;
        break;
    }
    uint count = map.GetNpcCount( param2, f );
    for( uint i = 0; i < count; i++ )
    {
        Critter@ cow = map.GetNpc( param2, f, i );
        map.SetText( cow.HexX, cow.HexY, COLOR_RGB( 255, 0, 0 ), "" + count );
    }
    cr.Say( SAY_NORM_ON_HEAD, "" + f );
}


void testPlague( Critter& cr, int isRad, int value, int p2 )
{
    if( isRad != 0 )
        AffectRadiation( cr, value );
    else
        AffectPoison( cr, value );
    cr.Say( SAY_NETMSG, "rad " + cr.Stat[ ST_RADIATION_LEVEL ] );
    cr.Say( SAY_NETMSG, "psn " + cr.Stat[ ST_POISONING_LEVEL ] );
}

void LocInfo( Critter& cr, int isRad, int value, int p2 )
{
    Location@ loc = cr.GetMap().GetLocation();
    cr.Say( SAY_NETMSG, "MapPid " + cr.GetMap().GetProtoId() );
    cr.Say( SAY_NETMSG, "LocPid " + loc.GetProtoId() );
    cr.Say( SAY_NETMSG, "Visible " + ( loc.Visible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckVisible " + ( loc.GeckVisible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "AutoGarbage " + ( loc.AutoGarbage ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckCount " + loc.GeckCount );
    cr.Say( SAY_NETMSG, "Radius " + loc.Radius );
}

void GetCrIds( Critter& cr, int onlyNpc, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] critters;
        for( uint i = 0, j = map.GetCritters( 0, FIND_ALL | ( onlyNpc == 1 ? FIND_ONLY_NPC : 0 ), critters ); i < j; i++ )
            cr.Say( SAY_NETMSG, critters[ i ].Name + " " + critters[ i ].Id );
    }
}

void CrAddItem( Critter& cr, int crId, int pid, int count )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.AddItem( pid, count );
}

void AddExp( Critter& cr, int crId, int val, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ ST_EXPERIENCE ] += val;
}

void SetStat( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ num ] = val;
}

void SetSkill( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.SkillBase[ num ] = val;
}

void SetPerk( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.PerkBase[ num ] = val;
}

void CrClearInv( Critter& cr, int crId, int, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        Item@[] items;
        toCr.GetItems( -1, items );
        for( uint i = 0, j = items.length(); i < j; i++ )
            DeleteItem( items[ i ] );
    }
}

void SetType( Critter& cr, int crId, int crType, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ChangeCrType( crType );
        toCr.StatBase[ ST_BASE_CRTYPE ] = crType;
    }
}

void AllToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void NpcToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void AllToDead( Critter& cr, int deadType, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToDead( deadType, null );
    }
}

void ShowIds( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "My id is " + critters[ i ].Id );
}

void Transit( Critter& cr, int hx, int hy, int )
{
    cr.TransitToHex( hx, hy, 6 );
}

void GlobalCar( Critter& iam, int crId, int, int )
{
    Critter@ cr = ::GetCritter( crId );
    if( valid( cr ) )
    {
        Item@[] items;
        cr.GetItemsByType( ITEM_TYPE_CAR, items );
        for( uint i = 0; i < items.length(); i++ )
        {
            Item@ car = items[ i ];
            car.Charge = car.Proto.Car_TankVolume;
            car.Deterioration = 0;
            car.Update();
            iam.Say( SAY_NETMSG, "Done." );
        }
    }
}

void TestLexem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.SetLexems( "test test test" );
        item.Update();
    }
}

void TestScriptTimeout( Critter& cr, int, int, int )
{
    Test2();
}
void Test2()
{
    Test3();
}
void Test3()
{
    int ggg = 1;
    do
    {
        ggg = Random( 1, 100 );
    }
    while( ggg != 0 );
}

void TestNullptr( Critter&, int, int, int )
{
    Critter@ cr;
    Log( "begin" );
    uint     id = cr.Id;
    Log( "end" );
}

// Synchronizer TestLocker;
void TestScriptConcurrent( Critter& cr, int test, int, int )
{
    // TestLocker.Lock();

    Synchronize();
    Map@ map = cr.GetMap();
    Resynchronize();

    if( test == 1 )
        Resynchronize();             // Invalid call
    else if( test == 2 )
        Synchronize();               // Call without Resynchronize

    if( test == 5 )
    {
        for( int i = 0; i < 1000; i++ )
            CreateTimeEvent( 0, "e_TestScriptConcurrent", true );
    }
}

int Data = 0;
uint e_TestScriptConcurrent( uint[] @ values )
{
    // TestLocker.Lock();

    if( Data == 0 )
        Data++;
    else if( Data == 1 )
        Data--;
    else
        Log( "Fail!" );
    return 1;
}

void TestLog( Critter& cr, int, int, int )
{
    for( uint i = 0; i < 10000; i++ )
        Log( "Test message " + i );
}

void TestMapLoop( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetEvent( MAP_EVENT_LOOP_3, "_MapLoopEvent" );
    map.SetLoopTime( 3, 1000 );
    Log( "ok" );
}

void _MapLoopEvent( Map& map )
{
    Log( "_MapLoopEvent " + map.Id );
}

void TestBlockItem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_RADIO, 1 );
    item.SetEvent( ITEM_EVENT_SKILL, "_ChangeMode" );
    UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
}

bool _ChangeMode( Item& item, Critter& cr, int skill )
{
    if( FLAG( item.Flags, ITEM_NO_BLOCK ) )
    {
        UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    else
    {
        SETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    item.Update();
    return false;
}

void DeleteTimeEvent( Critter& cr, int id, int, int )
{
    ::EraseTimeEvent( uint( id ) );
}

void HandToGround( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
        ::MoveItem( item, 0, cr.GetMap(), cr.HexX, cr.HexY );
}

void ColorizeHandItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightIntensity = Random( 30, 80 );
        item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        item.LightDistance = ( dist != 0 ? dist : Random( 5, 15 ) );
        item.LightFlags = 0;

        if( ( flags % 10 ) == 1 )
        {
            _LightSetIgnoreDir( item, 0 );
            _LightSetIgnoreDir( item, 2 );
            _LightSetIgnoreDir( item, 4 );
        }
        else if( ( flags % 10 ) == 2 )
        {
            _LightSetIgnoreDir( item, 1 );
            _LightSetIgnoreDir( item, 3 );
            _LightSetIgnoreDir( item, 5 );
        }
        if( ( flags / 10 ) == 1 )
            _LightSetInverse( item );

        SETFLAG( item.Flags, ITEM_LIGHT );
        item.Update();
    }
}

void ColorizeHandItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void ColorizeLegsItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        // SETFLAG(item.Flags,ITEM_COLORIZE);
        item.Update();
    }
}

void ColorizeLegsItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_COLORIZE ) )
            UNSETFLAG( item.Flags, ITEM_COLORIZE );
        else
            SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void ItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = cr.GetMap().GetItems( cr.HexX, cr.HexY, items );
    for( uint i = 0; i < count; i++ )
        cr.Say( SAY_NETMSG, "item " + items[ i ].GetProtoId() + " flags " + items[ i ].Flags );
}

void CheckAccess( Critter& cr, int, int, int )
{
    Map@[] maps;
    uint mapsCount = ::GetAllMaps( 0, maps );
    for( uint i = 0; i < mapsCount; i++ )
    {
        Map@ map = maps[ i ];
        Critter@[] players;
        uint count = map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, players );
        for( uint j = 0; j < count; j++ )
        {
            Critter@ player = players[ j ];
            if( player.GetAccess() > 0 )
                cr.Say( SAY_NETMSG, "Player " + player.Name + " access " + player.GetAccess() + "." );
        }
    }
    cr.Say( SAY_NETMSG, "Search complete." );
}

void AddLoc( Critter& cr, int pid, int x, int y )
{
    if( ::CreateLocation( pid, x, y, null ) != 0 )
        cr.Say( SAY_NETMSG, "Success." );
    else
        cr.Say( SAY_NETMSG, "Fail." );
}

void DeleteNpc( Critter& cr, int crId, int, int )
{
    DeleteNpc( GetCritter( crId ) );
}

void EndTB( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetTurnBasedAvailability( false );
    map.EndTurnBased();
}

void TestTE( Critter& cr, int set, int, int )
{
    uint num = CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_TestTE", -8, true );
    Log( "created " + num );

    uint duration = 0;
    uint[] values;
    if( GetTimeEvent( num, duration, values ) )
    {
        Log( "get ok+ duration " + duration );
        for( uint i = 0; i < values.length(); i++ )
            Log( i + ") " + values[ i ] );
        Log( "get ok-" );

        if( set != 0 )
        {
            values[ 0 ] = 123;
            uint value = 456;
            values.insertLast( value );
            if( SetTimeEvent( num, duration, values ) )
            {
                Log( "set ok+" );
                for( uint i = 0; i < values.length(); i++ )
                    Log( i + ") " + values[ i ] );
                Log( "set ok-" );
            }
        }
    }
}

uint e_TestTE( int[] @ values )
{
    Log( "e_TestTE+" );
    for( uint i = 0; i < values.length(); i++ )
        Log( i + ") " + values[ i ] );
    Log( "e_TestTE-" );
    return 0;
}

void DoorKey( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;
    map.MoveHexByDir( hx, hy, cr.Dir, 1 );
    Item@ door = map.GetDoor( hx, hy );
    if( not valid( door ) )
        return;
    Item@ key = cr.AddItem( PID_TEMPLE_KEY, 1 );
    if( not valid( key ) )
        return;
    key.LockerId = door.LockerId;
    key.Update();
}

void HandToInv( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        if( cr.MoveItem( item.Id, 0, SLOT_INV ) )
            Log( "ok" );
        else
            Log( "fail" );
    }
}

void KillSpawn( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;

    map.MoveHexByDir( hx, hy, cr.Dir, 1 );

    Critter@ oldNpc = map.GetCritter( hx, hy );
    if( not valid( oldNpc ) )
        return;

    DeleteNpc( oldNpc );

    uint[] values = { map.Id, hx, hy };
    CreateTimeEvent( __FullSecond + REAL_MS( 50 ), "e_KillSpawn", values, true );
}

uint e_KillSpawn( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
        map.AddNpc( 20 + Random( 0, 10 ), values[ 1 ], values[ 2 ], 2, null, null, null );
    return 0;
}

void DropDrugs( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < 10; i++ )
    {
        map.MoveHexByDir( hx, hy, iam.Dir, 1 );
        Critter@ cr = map.GetCritter( hx, hy );
        if( valid( cr ) )
        {
            DropDrugEffects( cr );
            cr.Say( SAY_NORM, "Drugs dropped." );
            break;
        }
    }
}

void ClearItems( Critter& iam, int lineLen, int skipLen, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.GetItems( hx, hy, items );
        }
    }

    DeleteItems( items );
}

void SetAnim1( Critter& cr, int value, int, int )
{
    cr.SetAnims( 0, value, 0 );
}

void Pos( Critter& cr, int newPos, int, int )
{
    // 0 - stand, 1 - crouch, 2 - prone
    int curPos = ( ( cr.Anim1Life & ANIM1_CROUCH ) != 0 ? 1 : ( ( cr.Anim1Life & ANIM1_PRONE ) != 0 ? 2 : 0 ) );
    switch( curPos )
    {
    case 0:
        switch( newPos )
        {
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_PRONE, null, false, true );
            break;
        default:
            break;
        }
        break;
    case 1:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_STAND, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_PRONE, null, true, true );
            break;
        default:
            break;
        }
        break;
    case 2:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_STAND, null, false, true );
            break;
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }
    switch( newPos )
    {
    case 0:
        cr.SetAnims( 0, 0, 0 );
        break;
    case 1:
        cr.SetAnims( 0, ANIM1_CROUCH, 0 );
        break;
    case 2:
        cr.SetAnims( 0, ANIM1_PRONE, 0 );
        break;
    default:
        break;
    }
}

void ColorOffset( Critter& cr, int skin, int hair, int armor )
{
    cr.SetAnims( 0, ANIM1_COLOR_SKIN( skin ) | ANIM1_COLOR_HAIR( hair ) | ANIM1_COLOR_ARMOR( armor ), 0 );
}

void Shield( Critter& cr, int on, int, int )
{
    if( on != 0 )
        cr.SetAnims( 0, ANIM1_SHIELD, 0 );
    else
        cr.SetAnims( 0, 0, 0 );
}

void Palette( Critter& cr, int index, int, int )
{
    cr.SetAnims( 0, ANIM1_PALETTE( index ), 0 );
}

void SetWalk( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_WALK_TIME ] = time;
    cr.ModeBase[ MODE_NO_WALK ] = off;
}

void SetRun( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_RUN_TIME ] = time;
    cr.ModeBase[ MODE_NO_RUN ] = off;
}

void excep0( Critter& cr, int, int, int )
{
    Log( "excep0" );
    excep1( cr );
}
void excep1( Critter& cr )
{
    Log( "excep1" );
    int y = 100;
    excep2( 6 );
}
void excep2( int i )
{
    Log( "excep2" );
    for( int k = 0; k < 10; k++ )
        excep3();
}
void excep3()
{
    Log( "excep3" );
    int h = 0;
    int k = 10 / h;
}

void toDead( Critter& cr, int, int, int )
{
    cr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, null );
}
void toLife( Critter& cr, int, int, int )
{
    cr.ToLife();
}
void toKO( Critter& cr, int, int, int )
{
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, cr.HexX, cr.HexY );
}

#pragma bindfunc "bool TestScriptCallNative(string&, string&) -> fonline_test.dll TestScriptCallNative"
void testScriptCall( Critter&, int, int, int )
{
    if( TestScriptCallNative( "test", "double TestScriptCallAS(int v1, uint64 v2, float v3, string@ v4)" ) )
        Log( "testScriptCall success." );
    else
        Log( "testScriptCall fail." );
}
double TestScriptCallAS( int v1, uint64 v2, float v3, string@ v4 )
{
    Log( "TestScriptCall: " + v1 + ", " + v2 + ", " + v3 + ", " + v4 + "." );
    return 1.234567890;
}

#pragma bindfunc "void StringExample() -> fonline_test.dll StringExample"
void testStringExample( Critter&, int, int, int )
{
    StringExample();
}

void animate( Critter& cr, int anim1, int anim2, int )
{
    cr.Animate( anim1, anim2, null, true, true );
}

void flooder( Critter& cr, int id, int, int )
{
    Critter@ npc = cr.GetMap().AddNpc( id, cr.HexX - 3, cr.HexY - 3, 0, null, null, null );
	npc.ParamBase[ST_VAR0] = 0;
	uint[] data = { npc.Id };
	CreateTimeEvent( __FullSecond + REAL_SECOND(1), "_flooder_Idle", data, true );
}

string@[] shake = {"Over hill, over dale,",
"Thorough bush, thorough brier,",
"Over park, over pale,",
"Thorough flood, thorough fire!",
"I do wander everywhere,",
"Swifter than the moon's sphere;",
"And I serve the Fairy Queen,",
"The cowslips tall her pensioners be;",
"In their gold coats spots you see;",
"Those be rubies, fairy favours;",
"In those freckles live their savours;",
"I must go seek some dewdrops here,",
"And hang a pearl in every cowslip's ear."};

uint _flooder_Idle( uint[] @ values ) {
	uint len = shake.length();
	Critter@ npc = GetCritter(values[0]);
	if(npc is null) {
		return 0;
	}
	npc.Say(SAY_NORM, shake[npc.ParamBase[ST_VAR0]%len]);
	npc.ParamBase[ST_VAR0] += 1;
	return REAL_SECOND(1);
}
/*
# pragma bindfunc "void Q3TestHexFlags(Map& map, uint16 hexX, uint16 hexY, bool raked, bool passed) -> rust_dll/server.dll test_hex_flags"
void hex_flags( Critter& cr, int steps, int, int ) {
	Map@ map = cr.GetMap();
	if (map is null)
		return;
	uint16 hexX = cr.HexX;
	uint16 hexY = cr.HexY;
	map.MoveHexByDir(hexX, hexY, cr.Dir, steps);
	bool raked = map.IsHexRaked(hexX, hexY);
	bool passed = map.IsHexPassed(hexX, hexY);
	Q3TestHexFlags(map, hexX, hexY, raked, passed);
}
*/

void dist( Critter& cr, int toX, int toY, int ) {
	Map@ map = cr.GetMap();
	if (map is null)
		return;
	uint16 hexX = cr.HexX;
	uint16 hexY = cr.HexY;
	uint dist = GetDistantion(hexX, hexY, toX, toY);
	cr.Say( SAY_NETMSG, "Distnace: "+dist );
}

void can_see( Critter& player, int p0, int p1, int p2 )
{
    Map@ map = player.GetMap();
    if( map is null )
    {
        player.Say( SAY_NETMSG, "map is null" );
        return;
    }
    Critter@ cr = map.GetCritter( p0 );
    if( cr is null )
    {
        player.Say( SAY_NETMSG, "opponent is null" );
        return;
    }
    bool result = check_look( map, player, cr );
    if( result )
        player.Say( SAY_NETMSG, "I can see it!" );
    else
        player.Say( SAY_NETMSG, "Oh no! Where is it?" );
}
void seen_by( Critter& player, int p0, int p1, int p2 )
{
    Map@ map = player.GetMap();
    if( map is null )
    {
        player.Say( SAY_NETMSG, "map is null" );
        return;
    }
    Critter@ cr = map.GetCritter( p0 );
    if( cr is null )
    {
        player.Say( SAY_NETMSG, "opponent is null" );
        return;
    }
    bool result = check_look( map, cr, player );
    if( result )
        player.Say( SAY_NETMSG, "It can see me!" );
    else
        player.Say( SAY_NETMSG, "Oh no! Where i am" );
}

void reload_config( Critter& player, int p0, int p1, int p2 )
{
	DllReloadConfig();
}

// to test RunClientScript from inside dll
void unsafe_test_api( Critter& cr, int, int, int, string@, int[]@ )
{
	cr.Say( SAY_NETMSG, "unsafe_test_api" );
}

// to travel to new temporary location
void trans_new_loc( Critter& player, int p0, int p1, int p2 ) {
	TransitToNewLocation(player, p0);
}

// to test new function Item_GetLexems that returns lexems assigned by item.SetLexems
void test_get_lexems( Critter& player, int p0, int p1, int p2 ) {
	Item@ item = player.AddItem( 19, 1);
	if( item is null ) {
		return;
	}
	item.SetLexems("text_lexems");
    lexems_show(player, item);
	item.SetLexems("");
    lexems_show(player, item);
	item.SetLexems(null);
    lexems_show(player, item);
}

void lexems_show( Critter& player, Item& item) {
	string@ lexems = Item_GetLexems(item);
    if( lexems !is null) {
        player.Say(SAY_NETMSG, "lexems: " + lexems);
    } else {
		player.Say(SAY_NETMSG, "lexems are null");
	}
}

// ************ Null pointer ScriptString test ************ //
// should fail with Script exception, was UB crash before

void null_string_assign( Critter& player, int p0, int p1, int p2 ) {
	string@ str = null;
	string str2 = string(str);
}

void null_string_copy( Critter& player, int p0, int p1, int p2 ) {
	string@ str = null;
	null_string_inner(player, str);
}

void null_string_inner(Critter& player, string str) {
	Log(str);
}

// AngelScript is broken, won't fix
void null_dict_assign( Critter& player, int p0, int p1, int p2 ) {
	dictionary@ dict = null;
	dictionary dict2 = dict;
}
// ******************************************************** //

// To test NETMSG_ANIMATE_ITEM
void animate_item( Critter& player, int p0, int p1, int p2 )
{
	Item@ item = GetItem(p0);
	if( item is null )
	{
		player.Say(SAY_NETMSG, "item is null");
	}
	item.Animate(uint8(p1), uint8(p2));
}

// To test PreviousHex from rust_dll
void prev_hex( Critter& player, int p0, int p1, int p2 )
{
	uint16 hx = 0, hy = 0;
	uint ticks = PreviousHex(player, hx, hy);
	player.Say(SAY_NETMSG, "ticks: "+ticks+" hx: "+hx+" hy: "+hy);
}

//~run test rest id 0 0
void rest( Critter& cr, int id, int, int )
{
	if( id == 0 )
	{
		cr.EraseTimeEvents( CTE_TIRED );
		cr.Say( SAY_NETMSG, "CTE_TIRED reset." );
		return;
	}

	Critter@ target = GetCritter( id );
	if( !valid( target ) )
	{
		cr.Say( SAY_NETMSG, "Target not found." );
		return;
	}

	target.EraseTimeEvents( CTE_TIRED );
	cr.Say( SAY_NETMSG, "target CTE_TIRED reset." );
	target.Say( SAY_NETMSG, "CTE_TIRED reset." );
}

void LookCheckOld( Critter& critter, int, int, int )
{
	__LookChecks = 0;							// See Look checks in _defines.fos - managed by rust.dll
    __LookChecks |= LOOK_CHECK_DIR;				// Nerfe look by directions of look - managed by rust.dll
    __LookDir0 = 0;								// Nerf 0% of look radius with direct look - managed by rust.dll
    __LookDir1 = 0;								// Nerf 20% of look radius with front side look - managed by rust.dll
    __LookDir2 = 0;                         	// Nerf 40% of look radius with back side look - managed by rust.dll
    __LookDir3 = 0;                         	// Nerf 60% of look radius with back look - managed by rust.dll
    __LookDir4 = 0;                         	// Nerf 60% of look radius with back look (Square geometry) - managed by rust.dll
    // __LookChecks |= LOOK_CHECK_SNEAK_DIR; 	// Nerf opponent sneak by directions of look - managed by rust.dll
    __LookSneakDir0 = 90;						// Nerf 90% of opponent sneak with direct look
    __LookSneakDir1 = 60;						// Nerf 60% of opponent sneak with front side look
    __LookSneakDir2 = 30;                    	// Nerf 30% of opponent sneak with back side look
    __LookSneakDir3 = 0;                     	// Nerf 0% of opponent sneak with back look
    __LookSneakDir4 = 0;                     	// Nerf 0% of opponent sneak with back look (Square geometry)
    __LookChecks |= LOOK_CHECK_SNEAK_WEIGHT;	// Nerf sneak by current weight
    __LookWeight = 10;							// Lost 1 sneak point per 10 gramm
    __LookChecks |= LOOK_CHECK_TRACE;			// Tracing for wall aviablility
    __LookChecks |= LOOK_CHECK_SCRIPT;      	// Allow bool check_look(...) in main.fos, all other defines ignored
    __LookChecks |= LOOK_CHECK_ITEM_SCRIPT;		// Allow bool check_trap_look(...) in main.fos, for items with ITEM_TRAP flag
}

void LookCheckNew( Critter& critter, int, int, int )
{
	__LookChecks = 0;							// See Look checks in _defines.fos - managed by rust.dll
    __LookChecks |= LOOK_CHECK_DIR;				// Nerfe look by directions of look - managed by rust.dll
    __LookDir0 = 0;								// Nerf 0% of look radius with direct look - managed by rust.dll
    __LookDir1 = 0;								// Nerf 20% of look radius with front side look - managed by rust.dll
    __LookDir2 = 0;                         	// Nerf 40% of look radius with back side look - managed by rust.dll
    __LookDir3 = 0;                         	// Nerf 60% of look radius with back look - managed by rust.dll
    __LookDir4 = 0;                         	// Nerf 60% of look radius with back look (Square geometry) - managed by rust.dll
    // __LookChecks |= LOOK_CHECK_SNEAK_DIR; 	// Nerf opponent sneak by directions of look - managed by rust.dll
    __LookSneakDir0 = 90;						// Nerf 90% of opponent sneak with direct look
    __LookSneakDir1 = 60;						// Nerf 60% of opponent sneak with front side look
    __LookSneakDir2 = 30;                    	// Nerf 30% of opponent sneak with back side look
    __LookSneakDir3 = 0;                     	// Nerf 0% of opponent sneak with back look
    __LookSneakDir4 = 0;                     	// Nerf 0% of opponent sneak with back look (Square geometry)
    __LookChecks |= LOOK_CHECK_SNEAK_WEIGHT;	// Nerf sneak by current weight
    __LookWeight = 10;							// Lost 1 sneak point per 10 gramm
    __LookChecks |= LOOK_CHECK_TRACE;			// Tracing for wall aviablility
    __LookChecks |= LOOK_CHECK_SCRIPT;      	// Allow bool check_look(...) in main.fos, all other defines ignored
    __LookChecks |= LOOK_CHECK_ITEM_SCRIPT;		// Allow bool check_trap_look(...) in main.fos, for items with ITEM_TRAP flag

	bool LookDataActivation = true;
	if( LookDataActivation )
	{
		__LookChecks |= LOOK_CHECK_LOOK_DATA;
		
		WallMaterialHearMultiplier[MATERIAL_GLASS] = 75;
		WallMaterialHearMultiplier[MATERIAL_METAL] = 50;
		WallMaterialHearMultiplier[MATERIAL_PLASTIC] = 100;
		WallMaterialHearMultiplier[MATERIAL_WOOD] = 80;
		WallMaterialHearMultiplier[MATERIAL_DIRT] = 100;
		WallMaterialHearMultiplier[MATERIAL_STONE] = 10;
		WallMaterialHearMultiplier[MATERIAL_CEMENT] = 10;
		WallMaterialHearMultiplier[MATERIAL_LEATHER] = 100;
		WallMaterialHearMultiplier[MATERIAL_ARMORED_LEATHER] = 100;
		WallMaterialHearMultiplier[MATERIAL_POLYMER] = 100;
		WallMaterialHearMultiplier[MATERIAL_COMPOSITE] = 100;
		WallMaterialHearMultiplier[MATERIAL_FABRIC] = 100;
		WallMaterialHearMultiplier[MATERIAL_COPPER] = 100;
		WallMaterialHearMultiplier[MATERIAL_LEAD] = 100;
		WallMaterialHearMultiplier[MATERIAL_GOLD] = 100;
		WallMaterialHearMultiplier[MATERIAL_ORGANIC] = 100;
		WallMaterialHearMultiplier[MATERIAL_PAPER] = 100;
	}
}

void DebugMessage( string& str, Critter@ critter = null )
{
	Log( str );
	if( critter !is null )
		critter.Say(SAY_NETMSG, str );
}

// ~run test LookDataDebug
void LookDataDebug( Critter& critter, int id, int ismap, int mode )
{
	Critter@ debug_critter = ( ( id == 0 ) ? @critter : GetCritter(id) );
	if( debug_critter is null )
		return;
	switch( mode )
	{
		case 1:
		{
			HotLookData_0 = critter.Look;
			HotLookData_1 = debug_critter.Look;
			HotLookData_0.WorkCritter( critter );
			HotLookData_1.WorkCritter( debug_critter );
			bool isView, isHear, isLook = CheckLook( critter.GetMap(), HotLookData_0, HotLookData_1, isView, isHear );
			DebugMessage( "#### LookDataDebug ####", critter );
			DebugMessage( "isView " + isView + " isHear " + isHear + " isLook " + isLook, critter );			
		}	break;
		
		default:
		{
			LookData@ look = null;
			if( ismap != 0 )
			{
				Map@ map = debug_critter.GetMap();
				if( map is null )
					return;
				
				@look = map.Look;
			}
			else
			{
				@look = debug_critter.Look;
			}
			
			DebugMessage( "#### LookDataDebug #### map:" + (ismap != 0), critter );
			
			DebugMessage( "MaxView: " + look.MaxView, critter );
			DebugMessage( "MaxHear: " + look.MaxHear, critter );

			DebugMessage( "Vision: " + look.Vision, critter );
			DebugMessage( "Invis: " + look.Invis, critter );
				
			DebugMessage( "ViewDirMultiplier_0: " + look.ViewDirMultiplier_0 , critter );
			DebugMessage( "ViewDirMultiplier_1: " + look.ViewDirMultiplier_1 , critter );
			DebugMessage( "ViewDirMultiplier_2: " + look.ViewDirMultiplier_2 , critter );
			DebugMessage( "ViewDirMultiplier_3: " + look.ViewDirMultiplier_3 , critter );

			DebugMessage( "HearDirMultiplier_0: " + look.HearDirMultiplier_0 , critter );
			DebugMessage( "HearDirMultiplier_1: " + look.HearDirMultiplier_1 , critter );
			DebugMessage( "HearDirMultiplier_2: " + look.HearDirMultiplier_2 , critter );
			DebugMessage( "HearDirMultiplier_3: " + look.HearDirMultiplier_3 , critter );

			DebugMessage( "RunningNoiseMultiplier: " + look.RunningNoiseMultiplier , critter );
			DebugMessage( "RunningHearMultiplier: " + look.RunningHearMultiplier , critter );

			DebugMessage( "HideViewDirMultiplier_0: " + look.HideViewDirMultiplier_0 , critter );
			DebugMessage( "HideViewDirMultiplier_1: " + look.HideViewDirMultiplier_1 , critter );
			DebugMessage( "HideViewDirMultiplier_2: " +  look.HideViewDirMultiplier_2 , critter );
			DebugMessage( "HideViewDirMultiplier_3: " + look.HideViewDirMultiplier_3 , critter );
			DebugMessage( "HideViewDirMultiplier_4: " + look.HideViewDirMultiplier_4 , critter );
			DebugMessage( "HideViewDirMultiplier_5: " + look.HideViewDirMultiplier_5 , critter );

			DebugMessage( "HideHearDirMultiplier_0: " + look.HideHearDirMultiplier_0 , critter );
			DebugMessage( "HideHearDirMultiplier_1: " + look.HideHearDirMultiplier_1 , critter );
			DebugMessage( "HideHearDirMultiplier_2: " + look.HideHearDirMultiplier_2 , critter );
			DebugMessage( "HideHearDirMultiplier_3: " + look.HideHearDirMultiplier_3 , critter );
			DebugMessage( "HideHearDirMultiplier_4: " + look.HideHearDirMultiplier_4 , critter );
			DebugMessage( "HideHearDirMultiplier_5: " +  look.HideHearDirMultiplier_5 , critter );

			DebugMessage( "HideViewMultiplier: " + look.HideViewMultiplier , critter );
			DebugMessage( "HideHearMultiplier: " + look.HideHearMultiplier , critter );
			
			DebugMessage( "#### ############# ####", critter );
		} break;
	}
}


void CheckHexSeeMe( Critter& critter, int hexX, int hexY, int dir, string@, int[]@ )
{
	CheckHexSeeMe( critter, hexX, hexY, dir );
	// GetDirection( hexX, hexY, critter.HexX, critter.HexY )
}

// ~run test LookDataDebug
void CheckHexSeeMe( Critter& critter, int hexX, int hexY, int dir )
{
	HotLookData_0 = critter.Look;
	HotLookData_1 = critter.Look;
	HotLookData_0.WorkCritter( critter );
	HotLookData_1.WorkCritter( critter );

	HotLookData_0.WorkHexX = hexX;
	HotLookData_0.WorkHexY = hexY;
	HotLookData_0.WorkDir = dir;

	HotLookData_0.Vision = HotLookData_1.Vision = 0;
	HotLookData_0.Invis = HotLookData_1.Invis = 0;
	HotLookData_0.WorkAccess = HotLookData_1.WorkAccess = 0;

	bool isView, isHear, isLook = CheckLook( critter.GetMap(), HotLookData_0, HotLookData_1, isView, isHear );
	DebugMessage( "#### LookDataDebug ####", critter );
	DebugMessage( "isView " + isView + " isHear " + isHear + " isLook " + isLook, critter );
		
}

#endif // TEST_MODULE