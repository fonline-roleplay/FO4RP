// Author: cvet
// For test reasons, can be exluded in any time

#include "_macros.fos"
#include "_maps.fos"
#include "_colors.fos"

import bool isGM( Critter& player ) from "gm";
import uint GetAllPlayers( Critter@[]& crs ) from "manager";

void test_findLast( Critter& cr, int, int, int )
{
	string text = "12345678901234567890";
	string f = "" + Random( 0, 9 );
	int first = findFirst ( text, f, 0 );
	int last = findFirst( text, f, first + 1 ); //findLast глючит, и всегда возвращает -1
	cr.Say( SAY_NORM, "Searching '" + f + "' is " + first + " to " + last );
}

void unsafe_reboot( Critter& player, int, int, int, string@, int[]@ )
{
	if( player.GetAccess() < ACCESS_ADMIN )
	{
		player.Say( SAY_NETMSG, "Вы залезли туда, куда не следовало." );
		player.Say( SAY_NORM, "Ой.." );
		player.ToDead( ANIM2_DEAD_EXPLODE, player );
		return;
	}
	Log( "Доступ на сервер закрыт." );
	player.Say( SAY_NETMSG, "Вы запустили обратный отсчёт на 30 секунд." );
	uint[] values = { 0, 30, 0 };
	CreateTimeEvent( __FullSecond, "e_kickAll", values, true );
}	

void KickAll( bool skipGMS )
{
    Critter@[] crs;
    uint count = GetAllPlayers( crs );
	
	for( uint i = 0; i < count; i++ )
	{
		if( isGM( crs[i] ) && !skipGMS ) 
		{
			crs[i].Say( SAY_WHISP_ON_HEAD, "Server is rebooting!" );
			continue;
		}
		
		crs[i].Say( SAY_NETMSG, "Доступ на сервер закрыт, ожидайте." );
		crs[i].Disconnect();
	}
	
}
	
uint e_kickAll( uint[]@ values )
{
	if( !valid(values) || values.length() != 3 ) return 0;
	
	KickAll( values[2] != 0 );
	
	values[0]++;
	if( values[0] > values[1] )
	{
		Log( "Доступ на сервер открыт." );
		return 0;
	}
	
	return REAL_SECOND(1);
}


void unsafe_toglobal( Critter& cr, int, int, int, string@, int[]@ )
{
	if( isGM(cr) )
		cr.TransitToGlobal(false);
}

void TeleToMapPos( Critter& cr, int mapPID, int x, int y )
{
	Map @map = GetMapByPid( mapPID, 0 );
	if(!valid(map))
	{
		cr.Say( SAY_NETMSG, "Такой карты нет." );
		return;
	}
	cr.TransitToMap( map.Id, x, y, cr.Dir, false );
}

//~run test makeBackup day month year
void makeBackup( Critter& cr, int day, int month, int year )
{
    file source, dest;
	string word = "";
	string name = "saylog_" + ( day < 10 ? "0" + day : "" + day ) + "_" + ( month < 10 ? "0" + month : "" + month ) + "_" + ( year < 10 ? "0" + year : "" + year ) + ".txt";
    if( source.open( "logs\\saylog.txt", "r" ) >= 0 && dest.open( "logs\\" + name, "a" ) >= 0 )
    {
        //f.setPos( 0 );
        while( !source.isEndOfFile() )
        {
			source.readLine( word );
			dest.writeString( word );
        }
        source.close();
		dest.close();
		if( source.open( "logs\\saylog.txt", "w" ) >= 0 )
		{
			cr.Say( SAY_NETMSG, "Saved to: '" + name + "'" );
			source.close();
		}
		else
			cr.Say( SAY_NETMSG, "Failed to erase saylog!" );
    }
    else
        Log( "Can't open files!" );
}

#define ENERGY_REGULAR	-1
#define ENERGY_SUSPENDED 0

void SwitchDayCycle( Critter& cr, int p0, int p1, int p2 )
{
	Map@ map = cr.GetMap();
	if(!valid(map)) return;

	int time = map.GetTime();
	string mode = ( time == ENERGY_REGULAR ? "стандартный" : "ночной" );
	string action = ( time == ENERGY_REGULAR ? "вечная ночь" : "вернуть дефолт" );
	string[] data = { "test@answer_SwitchTankerEnergy", "В данный момент, на карте установлен " + mode + " режим.", action };
	DIALOG_MENU( cr, data);
}

void answer_SwitchTankerEnergy( Critter& cr, uint answerI, string& answerS )
{
	Map@ map = cr.GetMap();
	if(!valid(map)) return;

	Location@ loc = GetLocationByPid( LOCATION_tanker, 0 );
	if(!valid(loc)) return;
	Map@[] maps;
	uint count = loc.GetMaps(maps);
	uint[] ignored_map_pids = { MAP_TANKER_ONBOARD, MAP_TANKER_TOWER_BRIDGE };
	bool isIgnored = ignored_map_pids.find( map.GetProtoId() ) != -1;

	int time = map.GetTime();
	bool isTanker = false;
	for( uint i = 0; i < count; i++ )
		if( maps[i].Id == map.Id )
		{
			if( isIgnored && valid( maps[0] ) )
				time = maps[0].GetTime(); //Костыль, учитывающий энергосбережение, даже если игрок находитя на картах, игнорирущих его.

			cr.Say( SAY_NETMSG, "На свой страх и риск, вы дёрнули рубильник переключающий режим энергообеспечения танкера." );
			time = ( time == ENERGY_REGULAR ? ENERGY_SUSPENDED : ENERGY_REGULAR ); //В этой строке мы УЖЕ переключили режим!
			isTanker = true;
			break;
		}
		
	if( isTanker )
	{
		for( uint i = 0; i < count; i++ )
			if( ignored_map_pids.find( maps[i].GetProtoId() ) != -1 ) //На этих картах естественный источник освещения (палуба), либо освещение нельзя отключать (башня).
				maps[i].SetTime( ENERGY_REGULAR ); 
			else
				maps[i].SetTime( time );
	}
	else
		map.SetTime( time );
		
	string mode = ( time == ENERGY_REGULAR ? "стандартный" : "энергосберегающий" );
	string action = ( time == ENERGY_REGULAR ? "экономим !" : "хватит !" );
	string[] data = { "test@answer_SwitchTankerEnergy", "В данный момент, на " + ( isTanker ? "танкере" : "карте" ) + " установлен " + mode + " режим.", action };
	DIALOG_MENU( cr, data);
}


#include "_ltp.fos"

bool ltp_inited = false;
void ltp_init()
{
    LTPREG( LTP_CLEANING, process_cleaning )
    ltp_inited = true;
}

uint process_cleaning( Critter@ cr, int& param0, int& param1, int& param2 )
{
    LTPROCESSD( LTP_CLEANING )
	cr.Say( SAY_EMOTE_ON_HEAD, "Моет" + ( param0 == 1 ? " руки" : "ся" ) );
	cr.ParamBase[ CR_DIRTINESS ] -= 1 + Random( 0, cr.ParamBase[ CR_DIRTINESS ] * 0.2 );
	
	if( cr.ParamBase[ CR_DIRTINESS ] <= 0 )
	{
		cr.Say( SAY_NETMSG, "Вы помылись." );
		return 0;
	}
    return 2000;
}

//import void start_cleaning( Critter& player, bool handsOnly ) from "test";
void start_cleaning( Critter& player, bool handsOnly ) //exported
{
    if( !ltp_inited )
        ltp_init();
	StartProcess( player, LTP_CLEANING, handsOnly ? 1 : 0, 1000 );
}


import void GM_PANNEL_ITEM( Critter& player, int itemId, int param1, int param2, string@ param3, int[] @ param4 ) from "gm";

void tired( Critter& cr, int hour, int mins, int secs )
{
	cr.TimeoutBase[ TO_TIREDNESS ] = __FullSecond + REAL_HOUR(hour) + REAL_MINUTE( mins ) + REAL_SECOND( secs );
}

void unsafe_GM_showDescs( Critter& cr, int x, int y, int r, string@, int[]@ )
{
	Map@ map = cr.GetMap();
	if(!valid(map)) return;
	
	//uint hidden = 0, visible = 0;
	//ProtoItem@ proto = GetProtoItem( PID_POPUP );
	//if( !valid(proto) ) return;
	//hidden = proto.PicMap;

	//@proto = GetProtoItem( 3637 );
	//if( !valid(proto) ) return;
	//visible = proto.PicMap;

	Item@[] descs;
	uint count = map.GetItems( PID_POPUP, descs );
	for( uint i = 0; i < count; i++ )
	{
		if( GetDistantion( x, y, descs[i].HexX, descs[i].HexY ) < r )
		{
			if( FLAG( descs[i].Flags, ITEM_HIDDEN ) ) 
			{
				//descs[i].PicMap = visible;			
				UNSETFLAG( descs[i].Flags, ITEM_HIDDEN );
				descs[i].Val7 = 1;
			}
			else 
			{
				//descs[i].PicMap = hidden;			
				SETFLAG( descs[i].Flags, ITEM_HIDDEN );
				descs[i].Val7 = 0;
			}
			descs[i].Update();
		}
	}
}

void unsafe_GM_respawn( Critter& cr, int id, int, int, string@, int[]@ )
{
	if( !isGM( cr ) ) return;
	Critter@ target = id != 0 ? GetCritter( id ) : @cr;
	if( valid(target) )
		target.ToLife();
}

void unsafe_SetChatTarget( Critter& cr, int id, int, int, string@, int[]@ )
{
	if( cr.StatBase[ ST_FOLLOW_CRIT ] == id || cr.StatBase[ ST_FOLLOW_CRIT ] == cr.Id )
		cr.StatBase[ ST_FOLLOW_CRIT ] = 0;
	else
		cr.StatBase[ ST_FOLLOW_CRIT ] = id;
	
	if( !isGM( cr ) ) return;
	cr.ParamBase[ CR_TALKING_TARGET_ID ] = cr.StatBase[ ST_FOLLOW_CRIT ];
}

//import void unsafe_ChatSay( Critter& cr, int sayType, int x, int y, string@ message, int[]@ ) from "test";
void unsafe_ChatSay( Critter& cr, int sayType, int x, int y, string@ message, int[]@ ) //exported
{
	if( cr.ParamBase[ CR_TALKING_TARGET_ID ] != cr.StatBase[ ST_FOLLOW_CRIT ] )
		return;

		Critter@ target = GetCritter( cr.StatBase[ ST_FOLLOW_CRIT ] );
	if( !valid( target ) ) @target = @cr;
	
	if( !valid(target) || target.IsDead() ) return;
	
	bool approved = isGM( cr ) || ( cr.Stat[ ST_LEVEL ] >= 12 && ABS( x - cr.HexX ) < 3 && ABS( y - cr.HexY ) < 3 );

	if( cr.StatBase[ ST_FOLLOW_CRIT ] == cr.Id )
	{
		if( !approved ) return;
		Map@ map = target.GetMap();
		if(!valid(map)) return;
		map.SetText( x, y, isGM( cr ) ? COLOR_GRAY : COLOR_LGRAY, message );
	}
	else
	{
		if( target.Stat[ ST_CURRENT_HP ] < 0 || target.IsKnockout() )
		{
			Map@ map = target.GetMap();
			if(!valid(map)) return;
			//map.SetText( target.HexX, target.HexY, COLOR_TEXT, "|0x00000000 :" + target.Id + ":|0xf9fa94 " + message );
			map.SetText( target.HexX, target.HexY, COLOR_TEXT, "|0xf9fa94 " + message );
		}
		else
			target.Say( sayType, message );
	}
}

void unsafe_CopyMob( Critter& cr, int id, int, int, string@, int[]@ )
{
	_CopyMob( cr, id, 0, 0 );
}

void _CopyMob( Critter& cr, int id, int, int )
{
	Critter@ target = GetCritter( id );
	if( !valid( target) || target.IsPlayer() ) return;
	
	CopyMob( cr, target );
}

void CopyMob( Critter& master, Critter& slave )
{
	Map@ map = master.GetMap();
	if( !valid(map) ) return;
	
	int[] params = { ST_DIALOG_ID, slave.StatBase[ST_DIALOG_ID], ST_BAG_ID, slave.StatBase[ST_BAG_ID], ST_TEAM_ID, slave.StatBase[ST_TEAM_ID], ST_REPLICATION_TIME, -1 };
	
	Critter@ mob = map.AddNpc( slave.GetProtoId(), master.HexX, master.HexY, Random( 0, 5 ), null, null, null );
	master.RunClientScript( "client_gui@_SetControlCritters", mob.Id, 0, 0, null, null );
	FullClone( mob, slave );
	DublicateLoot( mob, slave );
}

void DublicateLoot( Critter& target, Critter& source )//export
{
	Item@[] item;
	uint count = source.GetItems( -1, item );
	
	for( uint i = 0; i < count; i++ )
		target.AddItem( item[i].GetProtoId(), item[i].GetCount() );
}

//import void FullClone( Critter& target, Critter& source ) from "test";
void FullClone( Critter& target, Critter& source )//export
{
	target.ChangeCrType( source.StatBase[ST_BASE_CRTYPE] );

	uint attr;
	for( attr = 0; attr < 200; attr++ )
		target.StatBase[attr] = source.StatBase[attr];

	for( attr = SKILL_BEGIN; attr < SKILL_END; attr++ )
		target.SkillBase[attr] = source.SkillBase[attr];

	target.TagSkillBase[TAG_SKILL1] = source.TagSkillBase[TAG_SKILL1];
	target.TagSkillBase[TAG_SKILL2] = source.TagSkillBase[TAG_SKILL2];
	target.TagSkillBase[TAG_SKILL3] = source.TagSkillBase[TAG_SKILL3];
	target.TagSkillBase[TAG_SKILL4] = source.TagSkillBase[TAG_SKILL4];

	for( attr = TIMEOUT_BEGIN; attr < TIMEOUT_END; attr++ )
		target.TimeoutBase[attr] = source.TimeoutBase[attr];
	
	for( attr = KILL_BEGIN; attr < KILL_END; attr++ )
		target.KillBase[attr] = source.KillBase[attr];
	
	for( attr = PERK_BEGIN; attr < PERK_END; attr++ )
		target.PerkBase[attr] = source.PerkBase[attr];
	
	for( attr = ADDICTION_BEGIN; attr < ADDICTION_END; attr++ )
		target.AddictionBase[attr] = source.AddictionBase[attr];
	
	for( attr = KARMA_BEGIN; attr < KARMA_END; attr++ )
		target.KarmaBase[attr] = source.KarmaBase[attr];

	for( attr = DAMAGE_BEGIN; attr < DAMAGE_END; attr++ )
		target.DamageBase[attr] = source.DamageBase[attr];

	for( attr = MODE_BEGIN; attr < MODE_END; attr++ )
		target.ModeBase[attr] = source.ModeBase[attr];
	
	for( attr = TRAIT_BEGIN; attr < TRAIT_END; attr++ )
		target.TraitBase[attr] = source.TraitBase[attr];

	for( attr = REPUTATION_BEGIN; attr < REPUTATION_END; attr++ )
		target.ReputationBase[attr] = source.ReputationBase[attr];
	
	for( attr = 700; attr < 800; attr++ )
		target.ParamBase[attr] = source.ParamBase[attr];

	for( attr = MERC_BEGIN; attr < MERC_END; attr++ )
		target.MercBase[attr] = source.MercBase[attr];
	
	if( !target.IsPlayer() )
	{
		target.SetFavoriteItem( SLOT_HAND1, source.GetFavoriteItem(SLOT_HAND1) );
		target.SetFavoriteItem( SLOT_HAND2, source.GetFavoriteItem(SLOT_HAND2) );
		target.SetFavoriteItem( SLOT_ARMOR,   source.GetFavoriteItem(SLOT_ARMOR) );
	}
}



void updateFavoriteWeapon( Critter& cr )
{
	Item@[] wpn;
	uint count = cr.GetItemsByType( ITEM_TYPE_WEAPON, wpn );
	
	uint n = 0, max = 0, skill;
	for( uint i = 0; i < count; i++ )
	{
		skill = cr.Skill[ wpn[i].Proto.Weapon_Skill_0 ];
		if( skill > max )
		{
			n = i;
			max = skill;
		}
	}
	
	cr.Say( SAY_EMOTE_ON_HEAD, "проверяет оружие" );
	cr.SetFavoriteItem( SLOT_HAND1, wpn[n].GetProtoId() );
}

Item@ ArmFavoriteWeapon(Critter& critter)
{
    uint16 pid = critter.GetFavoriteItem(SLOT_HAND1);

    Item@  weapon = critter.GetItem(pid, -1);

    if(valid(weapon))
    {
        critter.MoveItem(weapon.Id, 1, SLOT_HAND1);
    }

	critter.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 0;
    return weapon;
}

Item@ RemoveFavoriteWeapon(Critter& critter)
{
    uint16 pid = critter.GetFavoriteItem(SLOT_HAND1);

    Item@  weapon = critter.GetItem(pid, -1);

    if(valid(weapon))
    {
        critter.MoveItem(weapon.Id, 1, SLOT_INV);//SLOT_HAND2);
    }
	
	critter.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 1;
    return weapon;
}

void unsafe_weapon_update( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) ) return;
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
			updateFavoriteWeapon( crit );
	}
}

void unsafe_weapon_show( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) ) return;
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
			ArmFavoriteWeapon( crit );
	}
}

void unsafe_weapon_hide( Critter& cr, int id, int, int, string@, int[]@ critters )
{
	if( !valid(critters) ) return;
	for( uint i = 0; i < critters.length(); i++ )
	{
		Critter@ crit = GetCritter( critters[i] );
		if( valid( crit ) && !crit.IsPlayer() )
			RemoveFavoriteWeapon( crit );
	}
}

void _SetFavWpn( Critter& cr, int id, int slot, int pid )
{
	if( id == 0 || slot == 0 )
	{
		cr.Say( SAY_NETMSG, "Аргументы вызова ф-ии установки 'любимого оружия': critterID, slot, weaponPID." );
		return;
	}
	Critter@ target = GetCritter( id );
	if( !valid( target ) )
	{
		cr.Say( SAY_NETMSG, "Цель №" + id + " не найдена." );
		return;
	}
	target.SetFavoriteItem( slot, pid );
	target.ModeBase[ MODE_NO_FAVORITE_ITEM ] = 0;
}

void _GetFavWpn( Critter& cr, int id, int slot, int )
{
	if( id == 0 || slot == 0 )
	{
		cr.Say( SAY_NETMSG, "Аргументы вызова ф-ии установки 'любимого оружия': critterID, slot, weaponPID." );
		return;
	}
	Critter@ target = GetCritter( id );
	if( !valid( target ) )
	{
		cr.Say( SAY_NETMSG, "Цель №" + id + " не найдена." );
		return;
	}
	cr.Say( SAY_NETMSG, "Предпочитаемое оружие для слота №" + slot + " это " + target.GetFavoriteItem( slot ) );
}

void unsafe_stopTyping( Critter& cr, int, int, int, string@, int[]@ )
{
	StopTyping(cr);
}

void unsafe_ShowTyping( Critter& cr, int, int, int, string@, int[]@ )
{
	ShowTyping(cr);	
}

void ShowTyping( Critter& cr )
{
	if( isGM( cr ) && cr.ParamBase[ QST_INVIS ] != 0 ) return;

	Critter@ target = @cr;
	if( cr.StatBase[ ST_FOLLOW_CRIT ] != 0 && cr.ParamBase[ CR_TALKING_TARGET_ID ] == cr.StatBase[ ST_FOLLOW_CRIT ] )
		@target = GetCritter( cr.StatBase[ ST_FOLLOW_CRIT ] );
	
	if(!valid(target) ) return;
	
	target.ParamBase[CR_TYPING_TIME] = __TypingDelay;
	if( target.GetTimeEvents( CTE_TYPING, null, null, null ) == 0 )
		target.AddTimeEvent( "cte_ShowTyping", REAL_SECOND( 5 ), CTE_TYPING, 0 );	
}

void StopTyping( Critter& cr )
{
	if( isGM( cr ) && cr.ParamBase[ QST_INVIS ] != 0 ) return;

	Critter@ target = @cr;
	if( cr.StatBase[ ST_FOLLOW_CRIT ] != 0 && cr.ParamBase[ CR_TALKING_TARGET_ID ] == cr.StatBase[ ST_FOLLOW_CRIT ] )
		@target = GetCritter( cr.StatBase[ ST_FOLLOW_CRIT ] );

	if(!valid(target) ) return;

	target.ParamBase[CR_TYPING_TIME] = 0;
	target.EraseTimeEvents( CTE_TYPING );
}

uint cte_ShowTyping( Critter& cr, int identifier, uint& rate ) 
{
	if( isGM( cr ) && cr.ParamBase[ QST_INVIS ] != 0 ) return 0;

	if( cr.ParamBase[CR_TYPING_TIME] > 0 )
	{
		string text = "|0xFF828a96 ";
		for( int i = 0; i <= rate % 3; i++ )
			text += " .";
		rate++;
		
		Map@ map = cr.GetMap();
		if(!valid(map))
			cr.Say( SAY_NORM_ON_HEAD, text );
		else
			map.SetText( cr.HexX, cr.HexY, COLOR_LGRAY, text ); //Нужно написать модуль, который отображал текст над именем криттера всем кто его видит, плюс учитывал дистанцию и рассеивание звуков.

		cr.ParamBase[CR_TYPING_TIME]--;
		return REAL_MS(500);
	}
	return 0;
}


void SetProcessingDialog( Critter& cr, int item_id, int dialog_id, int state)
{
	Item@ item = GetItem(item_id);
	if( !valid( item ) ) return;
	item.Val0 = dialog_id;
	item.Val1 = state;
	item.Val2 = 0; //'is not busy'
	item.Val3 = 0; //'elapsed time'
	item.Val4 = 0; //'current programm'
    item.SetScript( "_InitProcessingDialog" );
    item.Update();
}

void _InitProcessingDialog( Item& item, bool firstTime )
{
    item.SetEvent( ITEM_EVENT_SKILL, "e_ProcessingDialog_skill" );
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "e_ProcessingDialog_item" );	
}

bool e_ProcessingDialog_skill( Item& item, Critter& cr, int skill )
{
   if( item.Accessory != ACCESSORY_HEX ) return false;
   
   switch( skill )
   {
		case( SKILL_PICK_ON_GROUND ):
			if( item.Val1 != 0 )
				cr.Say( SAY_NETMSG, "Состояние станка: " + ProcessingState(item) );
			else
				runProcessingDialog( cr, item );
			break;
		case( SK_STEAL ):
			cr.ShowContainer( null, item, TRANSFER_FAR_CONT );
			break;
		case SKILL_TAKE_ALL_CONT: 
			return false;
		case( SK_SCIENCE):
		case( SK_REPAIR ):
			cr.Say( SAY_NETMSG, "Состояние станка: " + ProcessingState(item) );
			break;
		default:
			cr.Say( SAY_NETMSG, "Пристальный осмотр не дал результатов." );
			break;
   }
   return true;
}

//В случае разрастания, конечно лучше будет перенести логику в ООП: 
//ProcessingState( Item ) -> return (new Manufacture( item )).state();
string ProcessingState( Item& item )
{
	int type = item.Val0;
	int state = item.Val1;

	string[][] states = { 
		{ "вроде в порядке", "обесточен", "заклинило", "кончилась смазка", "перегорели платы", "неизвестный тип поломки" } //PID_CRUSHER_3000
	};
	
	uint[] states_pid = { PID_CRUSHER_3000 };

	uint pid = item.GetProtoId();
	for( uint i = 0; i < states_pid.length(); i++ )
		if( pid == states_pid[i] )
			return "Модель №" + type + ", " + states[0][ CLAMP( state, 0, states[0].length() - 1 ) ] + ".";

	return "Неизвестно.";
}

bool e_ProcessingDialog_item( Item& item, Critter& cr, Item@ usedItem )
{
	cr.Say( SAY_NETMSG, "Вы использовали предмет по назначению." );
	MoveItem( usedItem, 1, item, 0 );
	return true;
}

void runProcessingDialog( Critter& cr, Item& item )
{
	if( item.Val0 == 0 )
		cr.Say( SAY_NETMSG, "Аппарат не работает." );
	else
	{
		cr.ParamBase[ ST_LAST_CONT_ID ] = item.Id;
		RunDialog( cr, item.Val0, cr.HexX, cr.HexY, true );
	}
}

//~run test SetHaron id 0 0
void SetHaron( Critter& cr, int targetID, int, int )
{
	if( targetID == 0 )
	{
		cr.Say( SAY_NETMSG, "Первый аргумент - номер целевого криттера, из которого вы хотите сделать Харона." );
		return;
	}
	Critter@ target = GetCritter( targetID );
	if(!valid(target) )
	{
		cr.Say( SAY_NETMSG, "Целевой криттер - не найден." );
		return;
	}
	if( target.IsPlayer() )
	{
		cr.Say( SAY_NETMSG, "Целевой криттер - не НПЦ." );
		return;
	}
	target.StatBase[ ST_DIALOG_ID ] = 5119;
	target.StatBase[ ST_BASE_CRTYPE ] = 28;
	target.ChangeCrType( 28 );
	target.EraseTimeEvents( CTE_SLEEPING );
	target.AddTimeEvent( "cte_HaronLoop", 0, CTE_SLEEPING, 0 );	
}

#define ALARM_FREQ		( 5 )
#define MIN_ALARM_TIME	( 60 )
uint cte_HaronLoop( Critter& cr, int identifier, uint& rate ) {
	if ( cr.IsDead() || cr.IsKnockout() ) return REAL_MINUTE( 1 );
	
	string emote = "";
	
	if( cr.ParamBase[ CR_VAL0 ] > 0 )
	{
		cr.ParamBase[ CR_VAL0 ]--;
		emote += "считает деньги";
	}

	if( cr.ParamBase[ CR_VAL1 ] > 0 )
	{
		cr.ParamBase[ CR_VAL1 ]--;
		if( emote.length() > 1 )
			emote += " и ";
		emote += "недовольно ворчит";
	}
	
    uint16 year = 0, month = 0, day = 0, dayOfWeek = 0, hour = 0, minute = 0, second = 0;
    ::GetGameTime( __FullSecond, year, month, day, dayOfWeek, hour, minute, second );

	int target_hour = 0;
	uint[] target_hours = { 6, 11, 14, 21, 6 + 24 };
	for( uint i = 0; i < target_hours.length(); i++ )
		if( target_hours[i] > hour ) {
			target_hour = target_hours[i];
			break;
		}

	int elapsed_time = ( 60 - minute ) + ( target_hour - hour - 1 ) * 60;
	
	if( elapsed_time <= ALARM_FREQ * 3 )
	{
		cr.Say( SAY_SHOUT, "Отплываем! Все на борт!" );
		if( elapsed_time <= ALARM_FREQ )
		{
			cr.ParamBase[ CR_VAL2 ] = 0;
			cr.ParamBase[ CR_VAL1 ] = 0;
			cr.ParamBase[ CR_VAL0 ] = 0;
			TheySeeMeRolling(cr);//ТПшит всех на танкер или обратно. С питомцами.
		}
	}
	if( elapsed_time <= MIN_ALARM_TIME )
	{
		cr.Say( SAY_NORM, "Пошевеливаемся! Челнок отправляется через " + elapsed_time + " минут!" );
	}
	else if( emote.length() > 1 )
		cr.Say( SAY_EMOTE, emote );

	return GAME_MINUTE( ALARM_FREQ );
}

void TestRolling( Critter& cr, int id, int, int )
{
	if( id == 0 )
	{
		cr.Say( SAY_NETMSG, "Первый аргумент - номер целевого криттера (Харона), которого вы хотите отправить на другую сторону (Пирс или Танкер)." );
		return;
	}
	Critter@ target = GetCritter( id );
	if(!valid(target) )
	{
		cr.Say( SAY_NETMSG, "Целевой криттер - не найден." );
		return;
	}
	if( target.IsPlayer() )
	{
		cr.Say( SAY_NETMSG, "Целевой криттер - не НПЦ." );
		return;
	}
	if( target.StatBase[ ST_DIALOG_ID ] != 5119 )
	{
		cr.Say( SAY_NETMSG, "Целевой криттер - не Харон!" );
		return;
	}
	target.ParamBase[ CR_VAL2 ] = 0;
	target.ParamBase[ CR_VAL1 ] = 0;
	target.ParamBase[ CR_VAL0 ] = 0;
	cr.Say( SAY_NETMSG, "Харон отправлен на карту №" + TheySeeMeRolling(target) + "." );
}

import bool d_freeRide( Critter& player, Critter@ npc ) from "dialog";

int TheySeeMeRolling( Critter& driver )
{
	Map @map = driver.GetMap();
	if(!valid(map))
	{
		if( driver.IsPlayer() )
			driver.Say( SAY_NETMSG, "Ну не с глобала же!" );
		return 0;
	}

	int x1, x2, y1, y2, dir;
	
	Critter@[] crs;
	uint count = map.GetCrittersHex( driver.HexX, driver.HexY, 15, FIND_ALL, crs );

	switch( map.GetProtoId() )
	{
		case( MAP_PIERCE_SF ): {
			//driver.Say( SAY_EMOTE, "-> TANKER" );
			@map = GetMapByPid( MAP_TANKER_ONBOARD, 0 );
			x1 = 235; y1 = 242;
			x2 = 230; y2 = 241;
			dir = 0;
			break; }
		case( MAP_TANKER_ONBOARD ): {
			//driver.Say( SAY_EMOTE, "-> PIERCE" );
			@map = GetMapByPid( MAP_PIERCE_SF, 0 );
			x1 = 151; y1 = 156;
			x2 = 165; y2 = 155;
			dir = 3;
			break; }
		default:
			if( driver.IsPlayer() )
				driver.Say( SAY_NETMSG, "Доступно лишь на Пирсе и верхней палубе танкера!" );
		break;
	}
	driver.TransitToMap( map.Id, x1, y1, dir, false );
	if( !driver.IsPlayer() )
		driver.SetHomePos( x1, y1, dir );
	
	int total_pet_count = 0;
	int total_passed = 0;
	
	for( uint i = 0; i < count; i++ )
	{
		if( !crs[i].IsPlayer() )
			continue;
		
		if( !d_freeRide( crs[i], null ) )
		{
			if( crs[i].CountItem( PID_DOG_TAGS ) < 1 )
				continue;
			
			Item@ ticket = crs[i].GetItem( PID_KOKOWEEF_MINE_SCRIP, -1 );
			if( !valid(ticket) )
				continue;
			_SubItem( ticket, 1 );
		}		
		
		Critter@[] pets;
		uint pet_count = crs[i].GetFollowGroup( FIND_LIFE, pets );
		for( uint j = 0; j < pet_count; j++ ) {
			TeleToTarget( pets[j], map, x2, y2 );
			total_pet_count++;
		}

		TeleToTarget( crs[i], map, x2, y2 );
		total_passed++;
	}

	if( driver.IsPlayer() )
		driver.Say( SAY_NETMSG, "Пассажиров: " + total_passed + " + " + total_pet_count );
	
	return map.GetProtoId();
}

void t_EnterHex( Critter& cr, Scenery& trigger, bool entered, uint8 dir )
{
	if( entered )
		cr.Say( SAY_EMOTE, "Скрип лифта" );
}

void t_EnterHex( Critter& cr, Scenery& trigger, bool entered, uint8 dir, int val )
{
	if( entered )
		cr.Say( SAY_EMOTE, "Скрип лифта" );
}

string enlist( uint[] list )
{
	uint len = list.length();
	if( len == 0 ) return "[empty]";
	
	string result = list[0];
	for( uint i = 1; i < len; i++ )
		result += ", " + list[i];
	
	return result;
}

void CheckPidsRange( Critter& cr, int start, int end, int showExisting )
{
	bool empty = showExisting == 0;
	uint[] exists;
	for( uint i = start; i < end; i++ )
	{
		Item@ testItem = cr.AddItem( i, 1 );
		if( valid( testItem ) )
		{
			DeleteItem( testItem );
			if( !empty )
				exists.insertLast(i);
		}
		else if( empty )
			exists.insertLast(i);
	}
	cr.Say( SAY_NETMSG, ( empty ? "Свободные" : "Занятые" ) + " позиции: " + enlist(exists) + "." );
}

//~run test FindItem 0 0 0
void FindItem( Critter& player, int id, int action, int p2 )
{
	if( id == 0 || p2 != 0 )
	{
		player.Say( SAY_NETMSG, "Функция поиска предмета.\nСинтаксис вызова: id целевого объекта, action, 0.\nТипы action: 0 (вывести инфу), 1 (переместиться к объекту), 2 (взять объект), 3 (отГМить объект)." );
		return;
	}
	Item@ target = GetItem( id );
	if( !valid(target) )
	{
		player.Say( SAY_NETMSG, "Объект не найден!" );
		return;
	}
	string info;
	switch( action )
	{
		case( 0 ):
			info = "Объкт №" + target.Id + ":" + target.GetProtoId() + " находится ";
			switch( target.Accessory )
			{
				case( ACCESSORY_NONE ): info += "в нигде"; break;
				case( ACCESSORY_CRITTER ): info += "у криттера №" + target.CritId + " в слоте №" + target.CritSlot; break;
				case( ACCESSORY_HEX ): info += "на карте №" + target.MapId + " в позиции (" + target.HexX + ", " + target.HexY + ")"; break;
				case( ACCESSORY_CONTAINER ): info += "внутри контейнера №" + target.ContainerId; break;
				default: info += "в нигде"; break;
			}
			player.Say( SAY_NETMSG, info + "." );
		break;
		case( 1 ):
			switch( target.Accessory )
			{
				case( ACCESSORY_CRITTER ): TeleToTarget( player, GetCritter( target.CritId ) ); break;
				case( ACCESSORY_CONTAINER ): @target = GetItem( target.ContainerId );
				case( ACCESSORY_HEX ): TeleToTarget( player, target ); break;
				default: player.Say( SAY_NETMSG, "Из этого ничего не вышло." ); break;
			}
		break;
		case( 2 ): MoveItem( target, target.GetCount(), player ); break;
		case( 3 ): GM_PANNEL_ITEM( player, target.Id, 0, 0, null, null ); break;
		default: player.Say( SAY_NETMSG, "Из этого ничего не вышло." );
	}
}

void TeleToTarget( Critter& player, Critter@ target )
{
	Map@ map = target.GetMap();
	if(!valid(map)) return;
	TeleToTarget( player, map, target.HexX, target.HexY );
}

void TeleToTarget( Critter& player, Item@ target )
{
	Map@ map = GetMap( target.MapId );
	if(!valid(map)) return;
	TeleToTarget( player, map, target.HexX, target.HexY );
}

void TeleToTarget( Critter& player, Map@ map, uint16 x, uint16 y )
{
	bool success = false;

	if(!valid(map))
	{
		if( player.IsPlayer() )
			player.Say( SAY_NETMSG, "Карта недоступна!" );
		return;
	}

	for( int dx = -1; dx < 2; dx++ )
		for( int dy = -1; dy < 2; dy++ )
			if( map.IsHexPassed( x + dx, y + dy ) )
			{
				player.TransitToMap ( map.Id, x + dx, y + dy, player.Dir, false );
				success = true;
				break;
			}
	
	if( player.IsPlayer() && isGM( player ) )
	{
		if( success )
			player.Say( SAY_NETMSG, "Вы переместились к цели." );
		else
			player.Say( SAY_NETMSG, "Вы не смогли переместиться к цели." );
	}
}

void unsafe_shout_all( Critter& cr, int, int, int, string@ message, int[]@ )
{
	uint dist = ( isGM( cr ) ? 999 : cr.Stat[ ST_STRENGTH ] * 10 );

	Map@ map = cr.GetMap();
	if(!valid(map)) return;
	
	Critter@[] crs;
	uint count = map.GetCrittersHex(cr.HexX, cr.HexY, dist, FIND_ALL, crs);

    Critter@[] seeing;
	Critter@[] source = { cr };
	uint count2 = map.GetCrittersSeeing( source, true, FIND_ALL | FIND_ONLY_PLAYERS, seeing );

	bool isSkipping;
	for( uint i = 0; i < count; i++ )
	{
		isSkipping = false;
		for( uint j = 0; j < count2; j++ )
			if( crs[i].Id == seeing[j].Id )
			{
				isSkipping = true;
				break;
			}
		if( isSkipping )
			continue;
		
		uint dist = GetDistantion( cr.HexX, cr.HexY, crs[i].HexX, crs[i].HexY );
		if( dist <= crs[i].Stat[ ST_PERCEPTION ] * 10 )
			crs[i].Say( SAY_NETMSG, "???: |0x00FF0000 " + strupr( message ) );
	}
}

void unsafe_setCombatState( Critter& cr, int state, int, int, string@, int[]@ )
{
	if( state == 1 && cr.GetTimeEvents( CTE_AGGRESSION, null, null, null ) == 0 ) {
		if( cr.Timeout[ TO_BATTLE ] > 0 || cr.IsKnockout() || cr.IsDead() )
			return;
			
		cr.AddTimeEvent( "cte_aggression", REAL_SECOND( 3 ), CTE_AGGRESSION );
		if ( cr.Stat[ ST_BODY_TYPE ] == BT_ROBOT || cr.Stat[ ST_BODY_TYPE ] == BT_PLANT )
		{
			//ничего
		}
		else if( cr.Stat[ ST_BODY_TYPE ] == BT_MANTI || cr.Stat[ ST_BODY_TYPE ] == BT_RADSCORPION || cr.Stat[ ST_BODY_TYPE ] == BT_GIANT_ANT ) 
			cr.Say( SAY_EMOTE_ON_HEAD, "угрожающе стрекочет" ); 
		else if( cr.Stat[ ST_BODY_TYPE ] >= BT_BRAHMIN && cr.Stat[ ST_BODY_TYPE ] <= MAX_BODY_TYPES ) 
			cr.Say( SAY_EMOTE_ON_HEAD, "скалится" ); 
		else
			cr.Say( SAY_EMOTE_ON_HEAD, "прищурил" + ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? "ся" : "ась" ) );
	
	}
	if( state == 0 ) {
		if( cr.ParamBase[ CR_IS_AGGRESSIVE ] > 1 )
			cr.Say( SAY_EMOTE_ON_HEAD, "успокаивается" );
		cr.EraseTimeEvents( CTE_AGGRESSION );
	}
	cr.ParamBase[ CR_IS_AGGRESSIVE ] = state;
}

uint cte_aggression( Critter& cr, int identifier, uint& rate )
{
	cr.ParamBase[ CR_IS_AGGRESSIVE ] = 2;
	
	if( cr.Timeout[ TO_BATTLE ] > 0 || cr.IsKnockout() || cr.IsDead() ) return 0;
	
	string[][] emote = { //GENDER_MALE == 0 || GENDER_FEMALE == 1 
		{ "напряжен", "напряжена" }, //40%
		{ "выглядит угрожающе", "выглядит угрожающе"}, //30%
		{ "озирается", "озирается" }, //20%
		{ "хищно ухмыляется", "хищно ухмыляется"}, //3%
		{ "ищет жертву взглядом", "ищет жертву взглядом" }, //3%
		{ "скрипит зубами", "скрипит зубами" } //3%
	};
	
	uint[] grade = { 40, 30, 20, 3, 3, 3 };
	
	if( grade.length() != emote.length() )
		return 0;
	
	uint i, maxval = 0;
	for( i = 0; i < grade.length(); i++ )
		maxval += grade[i];
		
	uint roll = Random( 0, maxval );
	for( i = 0; i < grade.length(); i++ )
		if( roll <= grade[i] )
			break;
		else
			roll -= grade[i];
			
	cr.Say( SAY_EMOTE, emote[CLAMP(i, 0, rate)][cr.Stat[ ST_GENDER ]] );
	
	if( rate < emote.length() ) rate++;
	
	return REAL_SECOND( Random( 3, 9 ) );
}

void unsafe_GM_Hear_Radio( Critter& cr, int, int, int, string@ message, int[]@ )
{
	if( cr.CountItem( PID_RADIO ) < 1 )
		return;
	
    Critter@[] crs;
    GetAllPlayers( crs );

    string str = GetPlayerName(cr.Id) + ": |0xFFFFFFFF .." + message +  "..";

    for( uint i = 0, j = crs.length(); i < j; i++ )
    {
        if( crs[ i ] is null or !isGM( crs[ i ] ) )
            continue;
		if( crs[i].Id == cr.Id )
			continue;
        crs[ i ].Say( SAY_NETMSG, str );
    }
}

void unsafe_GM_Hear_Whisper( Critter& cr, int, int, int, string@ message, int[]@ )
{
    Critter@[] crs;
    GetAllPlayers( crs );
	
	Map @map = cr.GetMap();
	if(!valid(map)) return;

    for( uint i = 0, j = crs.length(); i < j; i++ )
    {
        if( crs[ i ] is null or !isGM( crs[ i ] ) )
            continue;
		if( crs[i].Id == cr.Id )
			continue;
		
		Map@ map1 = crs[i].GetMap();
		if( !valid(map1) || map1.Id != map.Id ) continue;
		
		if( GetDistantion( cr.HexX, cr.HexY, crs[i].HexX, crs[i].HexY ) < __WisperDist )
			continue;
		
		crs[ i ].RunClientScript( "rp_client@__HearWhisper", cr.HexX, cr.HexY, 0, GetPlayerName(cr.Id) + "@" + message, null );
    }
}

uint[] _ItemFlags = 
{
	ITEM_HIDDEN								,// 0x00000001 )
	ITEM_FLAT                                ,// 0x00000002 )
	ITEM_NO_BLOCK                            ,// 0x00000004 )
	ITEM_SHOOT_THRU                          ,// 0x00000008 )
	ITEM_LIGHT_THRU                          ,// 0x00000010 )
	ITEM_TWO_HANDS                           ,// 0x00000080 )
	ITEM_BIG_GUN                             ,// 0x00000100 )
	ITEM_ALWAYS_VIEW                         ,// 0x00000200 )
	ITEM_HAS_TIMER                           ,// 0x00000400 )
	ITEM_BAD_ITEM                            ,// 0x00000800 )
	ITEM_NO_HIGHLIGHT                        ,// 0x00001000 )
	ITEM_SHOW_ANIM                           ,// 0x00002000 )
	ITEM_SHOW_ANIM_EXT                       ,// 0x00004000 )
	ITEM_LIGHT                               ,// 0x00008000 )
	ITEM_GECK                                ,// 0x00010000 )
	
	// Group2
	ITEM_TRAP                                ,// 0x00020000 )
	ITEM_NO_LIGHT_INFLUENCE                  ,// 0x00040000 )
	ITEM_NO_LOOT                             ,// 0x00080000 )
	ITEM_NO_STEAL                            ,// 0x00100000 )
	ITEM_GAG                                 ,// 0x00200000 )
	ITEM_COLORIZE                            ,// 0x00400000 )
	ITEM_COLORIZE_INV                        ,// 0x00800000 )
	ITEM_CAN_USE_ON_SMTH                     ,// 0x01000000 )
	ITEM_CAN_LOOK                            ,// 0x02000000 )
	ITEM_CAN_TALK                            ,// 0x04000000 )
	ITEM_CAN_PICKUP                          ,// 0x08000000 )
	ITEM_CAN_USE                             ,// 0x10000000 )
	ITEM_HOLODISK                            ,// 0x20000000 )
	ITEM_RADIO                               // 0x40000000 )
};

void unsafe_ShowFlags( Critter& player, int id, int, int, string@, int[]@ )
{
	ShowFlags( player, id, 0, 0 );
}

void ShowFlags( Critter& player, int id, int p1, int p2 )
{
	//player.Say( SAY_NETMSG, "" );

	if( id == 0 || p1 != 0 || p2 != 0 )
	{
		player.Say( SAY_NETMSG, "Первый аргумент ф-и - айди объекта. Остальные должны быть нулевыми." );
		return;
	}
	
	Item@ item = GetItem( id );
	if( !valid(item) )
	{
		player.Say( SAY_NETMSG, "Предмет не найден." );
		return;
	}
	
	player.Say( SAY_NORM, "" + item.Flags );
}


/* Печки:
    Пока горит - преобразует рандомно 1 предмет в себе и тратит 1 бревно.
    Когда печка горячая - взаимодействовать с ней можно лишь лопатой (совком).
    Тикает раз в 10 секунд, но после розжига разогревается минуту. Разжигается зажигалкой.
    Что бы потушить тратится бутылка воды. Если нет дров - тухнет сам. Остывает минуту. Дрова выгребаются монтировкой.
 Тёплая печка имеет стандартный функционал "плиты для готовки". Использование науки на печку даёт подсказку.
 Остальные навыки лишь показывают её состояние (греется-остывает) и температуру: обжигающая, тёплая или холодная.
 Слитки: золотой (PID 1682), железный (PID 1474).
*/

void MakeFurnace( Critter& player, int id, int p1, int p2 )
{
	if( id == 0 || p1 != 0 || p2 != 0 )
	{
		player.Say( SAY_NETMSG, "Введите айди контейнера, который станет печкой, остальные 2 аргумента должны быть равны 0." );
		return;
	}
	Item@ target = GetItem( id );
	if(!valid(target))
	{
		player.Say( SAY_NETMSG, "Объект не обнаружен. Используйте #sinf 119 что бы видеть айди объектов!" );
		return;
	}
	if( target.GetType() != ITEM_TYPE_CONTAINER )
	{
		player.Say( SAY_NETMSG, "Выбранный вами объект - не контейнер!" );
		return;
	}
	
	player.Say( SAY_NETMSG, "Вы активировали печку." );
    target.SetScript( "test@_FurnaceInit" );
    target.Update();
}

void _FurnaceInit(Item& item, bool firstTime){ //old flags were: 269226496
    item.SetEvent( ITEM_EVENT_SKILL, "_FurnaceSkill" ); //нельзя трогать руками, если нагрета, впрочем можно на ней готовить
    item.SetEvent( ITEM_EVENT_USE_ON_ME, "_FurnaceOnMe" ); //лом, вода, зажигалка, или лопата
}

import bool ShowMenu(Critter& cr) from "cooking";

bool _FurnaceSkill( Item& item, Critter& cr, int skill )
{
	if( skill == SKILL_PICK_ON_GROUND )
	{
		if( item.Val1 == 0 ) {
			cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
			cr.ShowContainer( null, item, TRANSFER_HEX_CONT_DOWN );
		}
		else
			ShowMenu(cr);
	}
	else
	{
		if( skill == SK_SCIENCE )
			if( item.Val1 == 0 )
				cr.Say( SAY_NETMSG, "Нужно загрузить дров и использовать зажигалку, что бы растопить печку." );
			else
			{
				Item @wood = item.GetItem( PID_FIREWOOD, 0 );
				cr.Say( SAY_NETMSG, "Что бы потушить печку, используйте воду. Сейчас в ней " + ( valid( wood ) ? ( "" + wood.GetCount() ) : "нет" ) + " дров." );
			}
		else
		{
			string temp = ( item.Val1 > 0 ? ( item.Val1 > 1 ? "обжигающая" : "горячая" ) : "холодная" );
			cr.Say( SAY_NETMSG, "Печка " + ( item.Val0 == 1 ? "греется" : "остывает" ) + ", она " + temp + "." );
		}
	}
    return true;
}

bool _FurnaceOnMe( Item& item, Critter& cr, Item@ usedItem )
{
	//Т.к. внутри switch-case нельзя объявлять переменные, объявляем их здесь:
	Item@ wood;
	uint[] values = { item.Id };
	
	switch( usedItem.GetProtoId() )
	{
		case( PID_BOTTLE_FULL ):
			if( item.Val0 == 0 ) return false;
			cr.Say( SAY_EMOTE_ON_HEAD, "тушит огонь водой" );
			_SubItem( usedItem, 1 );
			cr.AddItem( PID_BOTTLE_EMPTY, 1 );
			item.Val0 = 0; //Гасим огонь
		break;
		case( PID_GLASS_BOTTLE_FULL ):
			if( item.Val0 == 0 ) return false;
			cr.Say( SAY_EMOTE_ON_HEAD, "тушит огонь водой" );
			_SubItem( usedItem, 1 );
			cr.AddItem( PID_BOTTLE_GLASS, 1 );
			item.Val0 = 0; //Гасим огонь
		break;		
		case( PID_LIGHTER ):
			if( item.Val0 == 1 ) return false;
			@wood = item.GetItem( PID_FIREWOOD, 0 );
			if( !valid( wood ) )
			{
				cr.Say( SAY_NETMSG, "В печке нет дров для розжига." );
				return false;
			}
			cr.Say( SAY_EMOTE_ON_HEAD, "разжигает огонь в печи" );
			item.Val0 = 1; //разжигаем огонь в печи
			EraseTimeEvent( item.Val2 ); //удаляет старый ивент, что бы печка одновременно не грелась-остужалась
			item.Val2 = CreateTimeEvent( __FullSecond, "e_FurnaceBurn", values, true );
		break;
		case( PID_SHOVEL ):
			cr.Say( SAY_EMOTE_ON_HEAD, "орудует совком" );
			cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
			cr.ShowContainer( null, item, TRANSFER_HEX_CONT_DOWN );
		break;
		case( PID_CROWBAR ):
			cr.Say( SAY_EMOTE_ON_HEAD, "выгребает дрова" );
			@wood = item.GetItem( PID_FIREWOOD, 0 );
			if( !valid( wood ) ) return false;
			MoveItem( wood, wood.GetCount(), cr.GetMap(), cr.HexX, cr.HexY ); //выгребаем дрова под себя
		break;
		default:
			cr.Say( SAY_EMOTE_ON_HEAD, "бросает что-то в печь" );
			MoveItem( usedItem, 1, item, 0 );
		break;
	}
    return true;
}

uint[][] FurnaceResourceTransfer = { //Таблица соответствий, что во что плавится/готовится:
	//[RESOURCE] PID COUNT  == [RESULT] PID COUNT
	{ PID_METAL_ORE, 1, PID_IRON_BAR, 2 },
	{ PID_GOLD_NUGGET, 1, PID_GOLDEN_BAR, 2 }, //GOLD_BAR
	
	{ PID_MEAT, 1, PID_COOKED_MEAT, 1 },
	{ PID_COOKED_MEAT, 1, PID_COOKED_MEAT, 0 },
	
	//Добавить: еду, плавку железяк, патронов, труб, оружия, крышек, денег и т.п.
};

uint e_FurnaceBurn( uint[]@ values )
{
	if( !valid(values) ) return 0;
	
	Item@ furnace = GetItem( values[0] );
	if( !valid(furnace) ) return 0;
	
	Map@ map = GetMap( furnace.MapId );
	if( !valid(map) ) return 0;
	
	Item@ wood = furnace.GetItem( PID_FIREWOOD, 0 );
	if( furnace.Val0 == 1 ) //огонь горит
	{
		if( valid( wood ) )
		{
			_SubItem( wood, 1 ); //топливо горит
		}
		else
		{
			furnace.Val0 = 0; //гаснет от нехватки топлива
		}
	}		

	
	bool isOn = furnace.Val0 == 1; //нагревается или остывает)
	int temp = furnace.Val1; //0 остыла, 1 - нагревается/остывает (нельзя трогать руками), 2 - нагрета (идёт процесс)
	
	if( !isOn ) {
		if( temp == 2 ) {
			map.SetText( furnace.HexX, furnace.HexY, COLOR_GRAY, ":печь затухла:" );
			furnace.Val1 = 1;
			return REAL_SECOND( 30 );
		}
		if( temp == 1 ) {
			map.SetText( furnace.HexX, furnace.HexY, COLOR_GRAY, ":печь остывает:" );	
			furnace.Val1 = 0;
			return REAL_SECOND( 30 );
		}
		if( temp == 0 ) {
			map.SetText( furnace.HexX, furnace.HexY, COLOR_GRAY, ":печь остыла:" );	
			return 0;
		}
	}
	else
	{
		if( temp == 0 ) {
			map.SetText( furnace.HexX, furnace.HexY, COLOR_GRAY, ":огонь разгорается в печи:" );	
			furnace.Val1 = 1;
			return REAL_SECOND( 30 );
		}
		if( temp == 1 ) {
			map.SetText( furnace.HexX, furnace.HexY, COLOR_GRAY, ":печь нагревается:" );	
			furnace.Val1 = 2;
			return REAL_SECOND( 30 );
		}
		if( temp == 2 ) {
			string[] desc = { "громкий треск огня в печи", "от печи исходит жар", "мерцание пламени в печи", "из печи валит дым" };
			map.SetText( furnace.HexX, furnace.HexY, COLOR_GRAY, ":" + desc[Random( 0, desc.length() - 1 )] + ":" );	
			//Готовка происходит тут:
			Item@[] resources;
			int count = furnace.GetItems( 0, resources );
			if( count > 0 ) 
			{
				int n = Random( 0, count - 1 );
				for( uint i = 0; i < FurnaceResourceTransfer.length(); i++ )
				{
					if( valid(FurnaceResourceTransfer[i]) && FurnaceResourceTransfer[i].length() == 4
						&& resources[n].GetProtoId() == FurnaceResourceTransfer[i][0] 
						&& resources[n].GetCount() >= FurnaceResourceTransfer[i][1] )
					{
						_SubItem( resources[n], FurnaceResourceTransfer[i][1] );
						furnace.AddItem( FurnaceResourceTransfer[i][2], FurnaceResourceTransfer[i][3], 0 );
					}
				}
			}
			return REAL_SECOND( 60 );
		}
	}
	return 0;
}

import void DIALOG_MENU( Critter& cr, string[] data ) from "gm";
import void GlobalCellSpawnLo() from "globalmap_group";
import void GlobalCellGatherLo( Critter& player ) from "globalmap_group";
import bool SpawnItemCell( uint mapId ) from "local_population";
import void lock( Critter& player, int itemId, int complexity, int lockId ) from "debug";
//import uint EraseAttackPlane( Critter& npc, Critter& target ) from "npc_planes"; //Вот хуй проссыт, где он откопал другое объявление..

/* //Темплашка для мини-тестов неочевидных атомарных операций, которые РЕЗКО-ВНЕЗАПНО ведут себя не как ожидается.
void uber( Critter& cr, int param0, int param1, int param2 )
{
	int i = 10;
	i++;
	++i;
	cr.Say( SAY_NETMSG, "" + i );
}
*/

void unsafe_ClearHex( Critter& player, int x, int y, int , string@ , int[]@ )
{
	if( !isGM( player ) )
		return;
	
	Map@ map = player.GetMap();
	if(!valid(map)) return;
	
	Item@[] items;
	uint count = map.GetItems( x, y, items );
	for( uint i = 0; i < count; i++ )
	{
		DeleteItem( items[i] );
	}
	player.Say( SAY_NETMSG, "Предметов удалено: " + count );
}

void unsafe_MakeFurniture( Critter& player, int hash, int , int , string@ , int[]@ )
{
	if( !isGM( player ) )
		return;

	Item@ item = player.AddItem( 580, 1 ); //Мешок-мебель.
	if( @item is null ) return;
		
	item.PicMap = hash;
	item.Info = 1;
	item.Val9 = PID_FRM_ITEM;
	
	uint[] furnuture_default_flags = { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0 };
	for( uint i = 0; i < furnuture_default_flags.length(); i++ )
		if( furnuture_default_flags[i] == 0 )
			UNSETFLAG( item.Flags, _ItemFlags[i] );
		else
			SETFLAG( item.Flags, _ItemFlags[i] );

	item.Update( );
	
	player.Say( SAY_NETMSG, "Мебель откопирована вам в инвентарь." );
}

void unsafe_testBag( Critter& player, int itemId, int x, int y, string@ , int[]@ )
{
	Map@ map = player.GetMap();
	if( !valid(map) )
	{
		player.Say( SAY_NETMSG, "На глобале нельзя." );
		return;
	}
	
	if( player.CountItem( PID_BAG ) < 1 )
	{
		player.Say( SAY_NETMSG, "Вам нужен мешок для того что бы собрать в него вещи из под ног." );
		return;
	}

    Item@ bag = player.GetItem( 0, SLOT_HAND1 );
    if( !valid( bag ) || bag.GetProtoId() != PID_BAG )
	{
		player.Say( SAY_NETMSG, "Вы должны держать мешок в руке." );
		return;
	}
	
	Item@[] loot;
	uint count = bag.GetItems( uint(-1), loot );
	if( count > 0 )
	{
		player.Say( SAY_NETMSG, "Данная операция возможна лишь с пустым мешком." );
		return;
	}
	
	count = map.GetItems( player.HexX, player.HexY, loot );
	if( count == 0 )
	{
		player.Say( SAY_NETMSG, "Вы не нашли ничего вокруг." );
		return;
	}
	
	uint subcount;
	uint summary = 0;
	uint weight = 0;
	uint volume = 0;
	
	player.Say( SAY_EMOTE, "Собирает что-то в мешок" );
	player.Animate( 0, ANIM2_PICKUP, null, false, true );
	MoveItem( bag, 1, map, player.HexX, player.HexY );
	
	for( uint i = 0; i < count; i++ )
	{
		if( loot[i].GetType() == ITEM_TYPE_CONTAINER || loot[i].GetType() == ITEM_TYPE_DOOR )
			continue;
		
		subcount = loot[i].GetCount();
		summary += subcount;
		weight += int( loot[i].Proto.Weight * subcount );
		volume += int( loot[i].Proto.Volume * subcount );
		MoveItem( loot[i], subcount, bag, 0 );		
	}

	player.Say( SAY_NETMSG, "Вы собрали в мешок вещи. Всего: " + summary + " объектов, весом " + weight + " грамм, объём " + volume + "/30." );
	
	bag.SetScript( "test@_BagInit" );
	bag.Update();
	
	player.ParamBase[ ST_LAST_CONT_ID ] = 0;
	player.ShowContainer( null, bag, TRANSFER_HEX_CONT_DOWN );
}

void _BagInit(Item& bag, bool firstTime){ //old flags were: 269226496
	bag.SetEvent( ITEM_EVENT_SKILL, "_showContainment" );
}

bool _showContainment( Item& bag, Critter& cr, int skill )
{
	if( skill == SKILL_PICK_ON_GROUND )
	{
		Item@[] loot;
		uint volume = 0;
		uint count = bag.GetItems( uint(-1), loot );
		for( uint i = 0; i < count; i++ )
			volume += loot[i].Proto.Volume * loot[i].GetCount();

		if( volume > 30 )
		{
			cr.Say( SAY_NETMSG, "Мешок переполнен, его не поднять." );
			cr.ParamBase[ ST_LAST_CONT_ID ] = 0;
			cr.ShowContainer( null, bag, TRANSFER_HEX_CONT_DOWN );
			return true;
		}

		bag.SetEvent( ITEM_EVENT_SKILL, null );
		return false;
	}
	return false;
}

//Ф-я, вызывавшаяся окном cr.Say( SHOW_BAG, 0, "test@answer_testBag" );
//В том окне игрок мог выбрать предмет из инвентаря, чей прототип передавался в answerI
void answer_testBag( Critter& cr, uint answerI, string& answerS )
{
    Item @ item = GetItem( answerI );
	int itemId = valid(item) ? item.Id : 0;
    cr.Say( SAY_NETMSG, "Вы выбрали предмет №" + answerI + ":" + itemId + "." );
}

//import void unsafe_GM_ChangeItemPicture( Critter& player, int itemId, int hash, int , string@ , int[]@ ) from "test";
void unsafe_GM_ChangeItemPicture( Critter& player, int itemId, int hash, int , string@ , int[]@ ) //exported
{
	if( !isGM( player ) )
		return;

		Item@ item = GetItem( itemId );
	if( @item !is null )
	{
		item.PicMap = hash;
		item.Update( );
	}
}

void clearCashe( Critter& cr, int npc_id, int player_id, int param2 )
{
	if( npc_id == 0 && player_id == 0 && param2 == 0 )
	{
		cr.Say( SAY_NETMSG, "Аргументы: ИД НПЦ, ИД игрока, 0" );
		return;
	}
	Critter@ npc = GetCritter( npc_id );
	Critter@ player = GetCritter( player_id );
	if(!valid(npc)&&!valid(player)) {
		cr.Say( SAY_NETMSG, "Не вышло.");
		return;
	}
	if(valid(npc))
	{
		npc.ClearEnemyStack();
		if(valid(player))
			EraseAttackPlane(npc,player);
		cr.Say( SAY_NETMSG, "Успех.");
		return;
	}
	cr.Say( SAY_NETMSG, "Провал.");
}

//TODO: Урезать паки анимаций. Возможно - проигрывать их не по всем направлениям, а чередовать через 2-3 направления.
//Создаёт 6 мобов, которые спаммят в лог своим скином и анимацией.
void tsk( Critter& cr, int start, int count, int stop )
{
	if( start == 0 && count == 0 && stop == 0 )
	{
		cr.Say( SAY_NETMSG, "Функция шоукейс для ГМа. Спаунит 6 мобов, которые проигрывают анимации в разных направлениях.\n\nПервый аргумент: стартовый скин.\nВторой: количество (0-6)\nТретий: режим.\n\nРежимы:\n0) показать и двигаться;\n1) удалить мобов;\n2) без анимаций или выключить анимации.\n\nПри нажатии на НПЦ, он срёт в лог и пишет вам в чат свой номер скина и анимации." );
		return;
	}
	
	Map@ map = cr.GetMap();
	if(!valid(map)) {
		cr.Say( SAY_NETMSG, "На глобале нельзя." );
		return;
	}
	
	int crtype = start;

	Critter@ mob;
	for( uint i = 0; i < 3; i++ ) {
		if( i >= count ) break;

		@mob = map.GetCritter( uint16 (cr.HexX + 3 - i*2), uint16 (cr.HexY + 3) );
		if( !valid( mob ) )
			@mob = map.AddNpc( 311, cr.HexX + 3 - i*2, cr.HexY + 3, 1, null, null, null );
		else if( stop == 1 ) {
			DeleteNpc( mob );
			continue;
		}
		
		mob.EraseTimeEvents( CTE_TESTING1 );
		mob.EraseTimeEvents( CTE_TESTING2 );

		if( stop == 0 )
		{
			mob.StatBase[ ST_DIALOG_ID ] = 390;
			mob.SetEvent( CRITTER_EVENT_TALK, "_test_skin_talk" );
			mob.AddTimeEvent( "cte_testing_skin", 0, CTE_TESTING1, ANIM2_IDLE );
		}

		mob.StatBase[ ST_BASE_CRTYPE ] = crtype;
		mob.ChangeCrType( crtype );
		crtype++;

		mob.Say( SAY_EMOTE, "<" + cr.StatBase[ ST_BASE_CRTYPE ] + ">" );
	}
	
	for( uint i = 0; i < 3; i++ ) {
		if( i + 3 >= count ) break;

		@mob = map.GetCritter( uint16 (cr.HexX + 2 - i*2), uint16 (cr.HexY - 2) );
		if( !valid( mob ) )
			@mob = map.AddNpc( 311, cr.HexX + 2 - i*2, cr.HexY - 2, 5, null, null, null );
		else if( stop == 1 ) {
			DeleteNpc( mob );
			continue;
		}

		mob.EraseTimeEvents( CTE_TESTING1 );
		mob.EraseTimeEvents( CTE_TESTING2 );

		if( stop == 0 )
		{
			mob.StatBase[ ST_DIALOG_ID ] = 390;
			mob.SetEvent( CRITTER_EVENT_TALK, "_test_skin_talk" );
			mob.AddTimeEvent( "cte_testing_skin", 0, CTE_TESTING1, ANIM2_IDLE );
		}

		mob.StatBase[ ST_BASE_CRTYPE ] = crtype;
		mob.ChangeCrType( crtype );
		crtype++;

		mob.Say( SAY_EMOTE, "<" + cr.StatBase[ ST_BASE_CRTYPE ] + ">" );
	}
	
	cr.Say( SAY_NETMSG, "Кликайте по НПЦ, если они имеют глючный скин/анимацию." );

	// cr.AddTimeEvent( "cte_testing_skin", REAL_SECOND( 5 ), CTE_TESTING1, 0 );
	// cr.SetEvent( CRITTER_EVENT_TALK, "_test_skin_talk" );
}

#define turning_rounds 1
#define turning_delay 250

void _test_skin( Critter& cr, int p0, int p1, int p2 )
{
	cr.EraseTimeEvents( CTE_TESTING1 );
	cr.EraseTimeEvents( CTE_TESTING2 );
	cr.AddTimeEvent( "cte_testing_skin", 0, CTE_TESTING1, p0 );
}

//Меняет скин:
uint cte_testing_skin( Critter& cr, int identifier, uint& rate )
{
	rate++;
	if( rate > ANIM2_DEAD_BURN_RUN ) return 0;

	cr.Say( SAY_EMOTE_ON_HEAD, "[" + cr.StatBase[ ST_BASE_CRTYPE ] + ":" + rate + "]" );
	
	cr.EraseTimeEvents( CTE_TESTING2 );
	cr.AddTimeEvent( "cte_testing_anim", 0, CTE_TESTING2, 0 );
	
	cr.ParamBase[ CR_VAL0 ] = rate;
	
	return REAL_MS( turning_rounds * 6 * turning_delay );
}

void rollup( Critter& cr, int p0, int p1, int p2 )
{
	cr.EraseTimeEvents( CTE_TESTING2 );
	cr.ParamBase[ CR_VAL0 ] = p0;
	cr.AddTimeEvent( "cte_testing_anim", 0, CTE_TESTING2, 0 );
}

//Меняет анимацию:
uint cte_testing_anim( Critter& cr, int identifier, uint& rate )
{
	cr.Animate( 0, cr.ParamBase[ CR_VAL0 ], null, true, true );
	cr.SetDir( ( cr.Dir + 1 ) % 6 );
	
	rate++;
	if( rate > 6 * turning_rounds ) return 0;
	return REAL_MS( turning_delay );
}
	
bool _test_skin_talk( Critter& npc, Critter& player, bool attach, uint talkCount ) // выбор режима игры
{
	player.Say( SAY_NETMSG, "Вы отметили дефектный скин №" + npc.StatBase[ ST_BASE_CRTYPE ] + " и анимацию №" + npc.ParamBase[ CR_VAL0 ] + "." );
	Log( "Anim #" + npc.ParamBase[ CR_VAL0 ] + " at skin #" + npc.StatBase[ ST_BASE_CRTYPE ] + " is defected." );
	return false;
}

void LootingTimelapse( Critter& player, int param0, int param1, int param2 )
{
	Map@ map = player.GetMap();
	if(!valid(map)) 
	{
		player.Say( SAY_NETMSG, "На глобале нельзя." );
		return;
	}
	
	//Оружка:
	Item@ storage = map.AddItem( player.HexX + 1, player.HexY, PID_ICE_CHEST_LEFT, 1 );
	if(!valid(storage)) return; //Всё пошло по пизде.
	lock( player, storage.Id, 0, 1 );
	player.ParamBase[ CR_VAL0 ] = storage.Id;
	storage.LockerOpen();
	storage.LockerClose();
	
	//Наркота + патроны:
	@storage = map.AddItem( player.HexX, player.HexY + 1, PID_ICE_CHEST_RIGHT, 1 );
	if(!valid(storage)) return; //Всё пошло по пизде.
	lock( player, storage.Id, 0, 2 );
	player.ParamBase[ CR_VAL1 ] = storage.Id;
	storage.LockerOpen();
	storage.LockerClose();

	//Остальное:
	@storage = map.AddItem( player.HexX + 1, player.HexY + 1, PID_FOOTLOCKER_CLEAN_LEFT, 1 );
	if(!valid(storage)) return; //Всё пошло по пизде.
	lock( player, storage.Id, 0, 3 );
	player.ParamBase[ CR_VAL2 ] = storage.Id;
	storage.LockerOpen();
	storage.LockerClose();
	
	player.ParamBase[ CR_VAL3 ] = 1; //Означает, что режим "лутать весь мир".

	string[] data = { "test@answer_LootingTimelapse", 
		" !!! ВНИМАНИЕ !!!\n !!! ДАННАЯ ФУНКЦИЯ ОПАСНА !!!\nВ ходе проверки дропа, лут во всём Саттере обновится 10 раз! Будут обобраны ВСЕ незапертые контейнеры!", "Стандарт", "ONLY Статик", "ONLY Динамик" };
	DIALOG_MENU( player, data);
}	

void answer_LootingTimelapse( Critter& cr, uint answerI, string& answerS )
{
	GameVar@ style = GetGlobalVar( GVAR_LootingStyle );
	if( valid(style) ) style.opAssign ( answerI );

	cr.Say( SAY_EMOTE, "использует машину времени" );
	for( uint time = 0; time < 10; time++ )
	{
		uint[] data = { 0, cr.Id };
		CreateTimeEvent( __FullSecond + REAL_SECOND(time*4), "e_GlobalRespawn", data, true );
	}

	uint[] data = { cr.Id };
	CreateTimeEvent( __FullSecond + REAL_SECOND(46), "e_GlobalResults", data, true );
}

uint e_GlobalResults( uint[] @ values )
{
	if( !valid(values) || values.length()!=1 || values[0]==0 )
		return 0;
	
	Critter@ cr = GetCritter( values[0] );
	if(!valid(cr)) return 0;
	
	cr.Say( SAY_NETMSG, "Итого, за 10 игровых суток, т.е. " + (10*24/__TimeMultiplier) + " ИРЛ часов, можно налутать следующее [экипировка, наркота, прочее]:" );
	CheckLoot( cr, cr.ParamBase[ CR_VAL0 ], 0, 0 );
	CheckLoot( cr, cr.ParamBase[ CR_VAL1 ], 0, 0 );
	CheckLoot( cr, cr.ParamBase[ CR_VAL2 ], 0, 0 );
	
	Item@ storage = GetItem( cr.ParamBase[ CR_VAL0 ] );
	if(valid(storage)) storage.LockerOpen();

	@storage = GetItem( cr.ParamBase[ CR_VAL1 ] );
	if(valid(storage)) storage.LockerOpen();

	@storage = GetItem( cr.ParamBase[ CR_VAL2 ] );
	if(valid(storage)) storage.LockerOpen();
	
	cr.ParamBase[ CR_VAL3 ] = 0; //Выключаем режим "Лутать весь мир"
	
	DifferLoot( cr, cr.ParamBase[ CR_VAL0 ], cr.ParamBase[ CR_VAL1 ], cr.ParamBase[ CR_VAL2 ] );
	return 0;
}

uint e_GlobalRespawn( uint[] @ values )
{
	if( valid(values) && values.length() == 2 && values[1] != 0 )
	{
		if( values[0] < 1 )
		{
			GlobalCellSpawnLo();
			values[0]++;
			return REAL_SECOND(2);
		}
		if( values[0] == 1 )
		{
			Critter@ cr = GetCritter( values[1] );
			if( valid( cr ) )
				GlobalCellGatherLo( cr );
			return 0;
		}
	}
    return 0;
}

void CountUnstackables( Critter& player, int param0, int param1, int param2 )
{
	Item@[] loot;
	if( param0 != 0 ) 
	{
		Map@ map = player.GetMap();
		if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
		Item@ LootBox = map.GetItem( param0 );
		if( !valid(LootBox) ) { player.Say( SAY_NETMSG, "Контейнер не найден!" ); return; }
		LootBox.GetItems( uint( -1 ), loot );
	}
	else
		player.GetItems( -1, loot );
	
	Item@ item = null;
	uint allc = 0, allp = 0, price = 0;
	uint[][] stackables = { {}, {}, {}, {} }; //pid, count, price, proto-price
	
	uint k = 0;
	for( uint i = 0, iEnd = loot.length(); i < iEnd; i++ ) 
	{
		@item = @loot[i];
		uint pid = item.GetProtoId();
		
		uint count = item.Proto.Stackable ? item.GetCount() : 1; 
		if( !item.Proto.Stackable )
		{
			price = item.Proto.Cost;
			count = 1;
			
			uint index = stackables[0].find( pid );
			if( index > -1 )
			{
				stackables[1][index]++;
				stackables[2][index] += price;
			}
			else
			{
				stackables[0].insertLast( pid );
				stackables[1].insertLast( 1 );
				stackables[2].insertLast( price );
				stackables[3].insertLast( item.Proto.Cost );
			}
			
		}
		else
		{
			price = item.GetCost();
			player.Say( SAY_NETMSG, k + ") " + pid + " x" + count + "(" + item.Proto.Cost + "$) " + price + "$" );
			k++;
		}
		
		allc += count;
		allp += price;
	}
	
	for( uint i = 0; i < stackables[0].length(); i++ )
		player.Say( SAY_NETMSG, (k + i) + ") " + stackables[0][i] + " x" + stackables[1][i] + "(" + stackables[3][i] + "$) " + stackables[2][i] + "$" );
	
	player.Say( SAY_NETMSG, "Всего " + allc + " объектов общей стоимостью " + allp + "$" );
}

void CheckLoot( Critter& player, int param0, int param1, int param2 )
{
	Item@[] loot;
	if( param0 != 0 ) 
	{
		Map@ map = player.GetMap();
		if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
		Item@ LootBox = map.GetItem( param0 );
		if( !valid(LootBox) ) { player.Say( SAY_NETMSG, "Контейнер не найден!" ); return; }
		LootBox.GetItems( uint( -1 ), loot );
	}
	else
		player.GetItems( -1, loot );
	Item@ item = null;
	uint count = 0, allc = 0, allp = 0, price = 0, pid = 0;
	for(uint i = 0, iEnd = loot.length(); i < iEnd; i++ ) 
	{
		@item = @loot[i];
		pid = item.GetProtoId();
		count = item.Proto.Stackable ? item.GetCount() : 1; 
		price = item.GetCost();// * count;
		player.Say( SAY_NETMSG, i + ") " + pid + " x" + count + "(" + item.Proto.Cost + "$) " + price + "$" );
		allc += count;
		allp += price;
	}
	player.Say( SAY_NETMSG, "Всего " + allc + " объектов общей стоимостью " + allp + "$" );
}

void DifferLoot( Critter& player, int param0, int param1, int param2 )
{
	if( param0 == 0 || param0 == 1 || param2 == 0 ) 
	{ 
		player.Say( SAY_NETMSG, "Укажите id для трёх целевых контейнеров сортировки:\n1) Оружие и броня.\n2) Ключи, наркотики и патроны.\n3) Остальное."); 
		return; 
	}
	
	Map@ map = player.GetMap();
	
	if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
	
	Item@ GearBox = map.GetItem(param0);
	Item@ DrugBox = map.GetItem(param1);
	Item@ StuffBox = map.GetItem(param2);
	
	if( !valid(GearBox) || !valid(StuffBox) || !valid(StuffBox) ) { player.Say( SAY_NETMSG, "Отсутствует один из контейнеров!" ); return; }

    Item@ item;
	Item@[] items;
    player.GetItems( -1, items );

	uint16 count, c1, c2, c3, allc, i, pid;
	uint32 price, p1, p2, p3, allp;
	count = c1 = c2 = c3 = allc = i = pid = price = p1 = p2 = p3 = allp = 0; //Очистка от мусора, а то хрень вылезала.
	for( i = 0; i < items.length(); i++ ) 
	{
		@item = @items[i];
		pid = item.GetProtoId();
		count = GetProtoItem(pid).Stackable ? item.GetCount() : 1;
		price = item.GetCost();
		switch( items[i].GetType() )
		{
			case(ITEM_TYPE_ARMOR):
			case(ITEM_TYPE_WEAPON):
					c1 += count;
					p1 += price;
					MoveItem( item, count, GearBox, 0 );//StackId || SpecialId ?
				break;
			case(ITEM_TYPE_DRUG):
			case(ITEM_TYPE_AMMO):
			case(ITEM_TYPE_KEY):
			case(ITEM_TYPE_FOOD):
					c2 += count; 
					p2 += price;
					MoveItem( item, count, DrugBox, 0 );//StackId || SpecialId ?
				break;
			case(ITEM_TYPE_MISC):
			//case(ITEM_TYPE_MISC2): //not declared!
					c3 += count;
					p3 += price;
					MoveItem( item, count, StuffBox, 0 );//StackId || SpecialId ?
				break;
			default: continue;
		}
	}
	allc = c1 + c2 + c3;
	allp = p1 + p2 + p3;
	player.Say( SAY_NETMSG, "Вы распределили " + i + " стэков по категориям:" + 
						"\n1) Оружие и броня x" + c1 + " на " + p1 + "$" + 
						"\n2) Ключи, наркотики и патроны x" + c2 + " на " + p2 + "$" +
						"\n3) Остальное x" + c3 + " на " + p3 + "$" +
						"\n Итого x" + allc + " объектов на сумму в " + allp + "$");
}

//Сегмент с грязным ненужным кодом старой версии "машины времени":
void PlayerLooting( Critter& player, Map& map )
{
	Item@[] container, loot;
	map.GetItemsByType( ITEM_TYPE_CONTAINER, container );
	uint len = container.length();

	int locked = 0;
	for( uint i = 0; i < len; i++ )
	{
		if( !FLAG( container[i].LockerCondition, LOCKER_LOCKED ) )
		{
			container[i].GetItems( uint(-1), loot );
			MoveItems( loot, player );
			loot.resize(0);
		}
		else locked++;
	}
	player.Say( SAY_NETMSG, "Вы облутали " + len + " контейнеров, кроме " + locked + " приватных." );
}

void FastRegen( Critter& player, int mode, int times, int style )
{
	Map@ map = player.GetMap();
	if(!valid(map)) return;
	
	GameVar@ styleVar = GetGlobalVar( GVAR_LootingStyle );
	if( valid(styleVar) ) styleVar.opAssign ( style );

	if( times <= 0 )
		times == 1;
	
	for( uint i = 0; i < times; i++ )
	{
		bool looting = ( mode % 100 ) / 10 == 1;
		uint[] data = { map.Id, looting ? 0 : -1, player.Id };
		CreateTimeEvent( __FullSecond + REAL_SECOND(i*2), "e_generateLoot", data, true );
	}
	
	bool checking = ( mode % 10 ) == 1;
	if( checking )
	{
		uint[] data = { player.Id };
		CreateTimeEvent( __FullSecond + REAL_SECOND(times*2 + 2), "e_checkLoot", data, true );
	}
		
	player.Say( SAY_NETMSG, "Fast regen done." );
}

uint e_checkLoot( uint[] @ values )
{
	if( valid(values) && values.length() == 1 && values[0] != 0 )
	{
		Critter@ player = GetCritter( values[0] );
		if( valid( player ) )
			CheckLoot( player, 0, 0, 0 );
	}
	return 0;
}

uint e_generateLoot( uint[] @ values )
{
	if( valid(values) && values.length() == 3 && values[0] != 0 && values[2] != 0 )
	{
		if( values[1] < 1 )
		{
			SpawnItemCell( values[0] );
			values[1]++;
			return REAL_SECOND(1);
		}
		if( values[1] == 1 )
		{
			Critter@ player = GetCritter( values[2] );
			if( valid( player ) )
				FastLoot( player, 0, 0, 0 );
			return 0;
		}
	}
    return 0;
}
	
void FastLoot( Critter& player, int param0, int param1, int param2 )
{
    Map@ map = player.GetMap();
	if( player.ParamBase[ CR_VAL3 ] != 0 )
	{
		Location@ loc;
		for( uint i = 13; i < 26; i++ ) //Все карты Саттера
		{
			@loc = GetLocation( i );
			if( !valid( loc ) ) continue;
			@map = loc.GetMapByIndex( 0 );
			if( !valid( map ) ) continue;
			
			player.Say( SAY_NETMSG, i +" ) Залутана карта №" + map.Id );
			PlayerLooting( player, map );
		}
		player.Say( SAY_NETMSG, "Залутан мир." );
	}
	else
	{
		if( !valid(map) ) { player.Say( SAY_NETMSG, "На глобале нельзя!" ); return; }
		PlayerLooting( player, map );
	}

	if( param0 != 0 && param1 != 0 && param2 != 0 )
		DifferLoot( player, param0, param1, param2 );
}
//Конец сегмента с грязным ненужным кодом старой версии машины времени.

void unsafe_rolling( Critter& cr, int p0, int p1, int p2, string@, int[]@ )
{
	Roll( cr, p0, p1, p2 );
}

void unsafe_rolling_GM( Critter& gm, int p0, int p1, int p2, string@, int[]@ vals )
{
	if( !valid(vals) || vals.length() != 4 )
		return;
	
	Critter@ cr = GetCritter( vals[3] );
	if(!valid(cr)) return;
	
	Roll( cr, vals[0], vals[1], vals[2] );
}

void Roll( Critter& cr, int stat, int n, int val )
{
	if( stat < 0 || stat > 7 || n < 0 || val < 0 ) return;
	/*
	Map@ map = cr.GetMap();
	if( !valid( map ) ) return;
	
	Critter@[] seeing, origin = { cr };
	int count = map.GetCrittersSeeing( origin, true, FIND_ALL, seeing );
	*/
	
	string result = "";
	int summ = 0;
	if( stat != 0 )
	{
		string[] stat_names = { "СИЛА", "ВОСПРИЯТИЕ", "ВЫНОСЛИВОСТЬ", "ХАРИЗМА", "ИНТЕЛЛЕКТ", "ЛОВКОСТЬ", "УДАЧА" };
		string[] skill_names = { "ЛО", "ТО", "ЭО", "РУКОП", "МИЛИ", "МЕТАТЕЛЬНОЕ", "САНИТАР", "ДОКТОР", "СКРЫТНОСТЬ", "ВЗЛОМ", "ВОРОВСТВО", "ЛОВУШКИ", "НАУКА", "РЕМОНТ", "КРАСНОРЕЧИЕ", "ТОРГОВЛЯ", "АЗАРТ", "СКИТАЛЕЦ" };
		if( stat < 8 )
			result = stat_names[ stat - 1 ];// + "[" + cr.Stat[stat - 1] + "]";
		else
			result = skill_names[ stat - 200 ];
		summ += cr.Stat[stat - 1]; //Random( 1, cr.Stat[stat] );
		
	}
	
	if( n != 0 && val != 0 )
	{
		result += ( stat != 0 ? " + " : "" );
		result += n + "d" + val + " =";
		for( int i = 0; i < n; i++ )
			summ += Random( 1, val );
		result += " " + summ;
	}
	else
	{
		result += " " + summ;
	}

	cr.Say( SAY_NORM, "|0xA6EEF900 " + result );
	/*
	for( int i = 0; i < count; i++ )
	{
		seeing[i].Say( SAY_NETMSG, "|0xFFFF0000 " + result );
	}
	*/
}

void test( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    if( not valid( map ) )
        return;
    Item@ car = map.AddItem( p0, p1, PID_HUMMER, 1 );
    // if(not valid(car)) return;
    SETFLAG( car.Flags, ITEM_GECK );
    car.Update();
}

void test1( Critter& cr, int p0, int p1, int p2 )
{
    cr.Say( SAY_NORM, "русские буквы АБВгДееейёёёё!" );
}

class Example
{
    int    a;
    int8   b;
    uint16 c;
    uint64[] arr;
    string str;
}

#include "serializator.fos"
void test2( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    e.a = -100;
    e.b = 123;
    e.c = 60000;
    e.str = "Example!";
    e.arr.resize( 5000 );

    for( uint i = 0; i < 10; i++ )
    {
        Serializator save;
        save.Set( e.arr ).Set( e.a ).Set( e.b ).Set( e.c ).Set( e.str ).Save( "Example_" + i );
    }

    cr.Say( SAY_NETMSG, "0<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void test3( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    for( uint i = 0; i < 10; i++ )
    {
        Serializator load;
        if( load.Load( "Example_" + i ) )
            load.Get( e.arr ).Get( e.a ).Get( e.b ).Get( e.c ).Get( e.str );
    }


    cr.Say( SAY_NETMSG, "1<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void zero( Critter& cr, int p0, int p1, int p2 )
{
//	float timeout = 2.0f;
//	float factor = 0.5f;
    float t = 1.0f / 0.9f;
    cr.Say( SAY_NETMSG, "!!!!!!!!!!!!!!" );
}

void test4( Critter& cr, int p0, int p1, int p2 )
{
    uint16 year = 0;
    uint16 month = 0;
    uint16 day_of_week = 0;
    uint16 day = 0;
    uint16 hour = 0;
    uint16 minute = 0;
    uint16 second = 0;
    GetGameTime( __FullSecond, year, month, day, day_of_week, hour, minute, second );
    uint   fm = GetFullSecond( year, month, day, hour, minute, second );

    Log( "Real: " + "FullSecond " + __FullSecond + " Year " + __Year + " Month " + __Month + " Day " + __Day + " Hour " + __Hour + " Minute " + __Minute + " Second " + __Second );
    Log( "Calc: " + "FullSecond " + fm + " Year " + year + " Month " + month + " Day " + day + " Hour " + hour + " Minute " + minute + " Second " + second + " DayOfWeek " + day_of_week );
}

/*
   void init(Critter@ npc, bool firstTime)
   {
        if(firstTime) npc.AddItem(PID_ADVANCED_POWER_ARMOR_MK2,1);
        npc.Wait(20000);
   }

   void idle(Critter@ npc)
   {
   //	TestMove(npc);
        TestObjMove(npc);
   //	TestVars(npc);
   }

   void TestMove(Critter@ npc)
   {
        _CritAnimateUse(npc);

        if(npc.HexX==260 && npc.HexY==209) return;
        npc.AddWalkPlane(260,209,3,false,0);
   }

   void TestObjMove(Critter@ npc)
   {
        npc.Say(SAY_NORM_ON_HEAD,"Эээх мой броник");

        Item@ armor=_CritGetItemArmor(npc);
        if(@armor==null)
        {
                @armor=_CritGetItem(npc,PID_ADVANCED_POWER_ARMOR_MK2);
                if(@armor==null)
                {
                        npc.Say(SAY_NORM_ON_HEAD,"Украли броник");
                        return;
                }

                _CritMoveItem(npc,armor,SLOT_ARMOR);
        }
        else
        {
                _CritMoveItem(npc,armor,SLOT_INV);
        }

        npc.Wait(10000);
   }

   void TestVars(Critter@ npc)
   {
        GameVar@ var=GetGlobalVar(GVAR_game_state);
        if(@var==null)
        {
                npc.Say(SAY_NORM_ON_HEAD,"Not found");
                return;
        }

        int v=var.GetValue();

        npc.Say(SAY_NORM_ON_HEAD,"var="+v);

        var=Random(0,5);

        npc.Wait(5000);
   }

 */

void answer_Generic( Critter& player, uint answerI, string& answerS )
{
    player.Say( SAY_NETMSG, "Answer integer<" + answerI + ">, string<" + answerS + ">." );
}

void elevator( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_ELEVATOR, ELEVATOR_BOS_1234( p0 ), "answer_Generic" );
}

void dlgbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_DIALOGBOX, 5, "answer_Generic" );
    cr.Say( SAY_DIALOGBOX_TEXT, "Choose you button dude." );
    cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Button0" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Button1" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "Button2" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "Button3" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "Button4" );
}

void skillbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SKILLBOX, 0, "answer_Generic" );
}

void say( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SAY, p0, "answer_Generic" );
    cr.Say( SAY_SAY_TITLE, "Choose you..." );
    cr.Say( SAY_SAY_TEXT, "sometext" );
}

void timer( Critter& cr, int p0, int p1, int p2 )
{
    ProtoItem@ proto = GetProtoItem( PID_BOTTLE_CAPS );
    cr.ShowScreen( SCREEN_TIMER, proto.PicInv, "answer_Generic" );
}

void bag( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_BAG, 0, "answer_Generic" );
}

void inventory( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_INVENTORY, 0, "" );
}

void cha( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CHARACTER, 0, "" );
}

void fixboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
}

void pipboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_PIPBOY, 0, "" );
}

void minimap( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_MINIMAP, 0, "" );
}

void close( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CLOSE, 0, "" );
}









// ok, just predictable log message about null pointer exception
// string@ SomeFunc(string& str)

// results in ICE: Assertion failed: tempVariables.GetLength() == 0, file ..\..\source\as_compiler.cpp, line 611
// string SomeFunc(string& str)

// crash
/*string SomeFunc(string& str)
   {
        string@[]@ forms = split(str, " ");
           // uncomment to reproduce crash
        // SomeFunc1(forms);
        return null;
   }

   void SomeFunc1(string@[]@ arr)
   {
        Log("Ok");
   }*/




void DLog( string& str )
{
    Log( str );
}


#include "_macros.fos"
#include "entire.fos"

// ent number for i-th room
// global value, but we can change it to be different per-npc
#define ENT    # (i)        ( 50 + i )



class SomeClassA
{
    int A;

    ~SomeClassA()
    {
        Log( "destruct" );
    }
}

class SomeClassB
{
    SomeClassA@ nullptr;
    SomeClassB( SomeClassA@ aPtr )
    {
        this.nullptr.A = 100;       // Null pointer access, but after this class a is destroyed
    }
}

void test10( Critter& crit, int p0, int p1, int p2 )
{
    SomeClassA a;
    SomeClassB( a );
}
/*
   void test11(Critter& cr, int p0, int p1, int p2)
   {
        Critter@ npc=GetCritter(uint(p0)+5000000);
        if(not valid(npc)) return;

        npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN,"_Begin");
        npc.SetEvent(CRITTER_EVENT_PLANE_END,"_End");

        NpcPlane@ plane=CreatePlane();
        plane.Type=AI_PLANE_WALK;
        plane.Priority=0;
        plane.Walk_HexX=p1;
        plane.Walk_HexY=p2;
        plane.Walk_Run=false;
        plane.Walk_Cut=0;

        NpcPlane@ plane2=CreatePlane();
        @plane.Child=plane2;
        plane2.Type=AI_PLANE_WALK;
        plane2.Priority=0;
        plane2.Walk_HexX=p1+10;
        plane2.Walk_HexY=p2;
        plane2.Walk_Run=false;
        plane2.Walk_Cut=0;

        npc.AddPlane(plane);
   }*/

void _Begin( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "Begin, reason: " + reason + "." );
}

void _End( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "End, reason: " + reason + "." );
}

#include "npc_planes.fos"
void test12( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    AddWalkPlane( npc, 2, cr.HexX, cr.HexY, cr.Dir, false, 2 );
    AddMiscPlane( npc, 1, __FullSecond + 3 * 60, null );
}

void plane_Misc( Critter& npc )
{
    npc.Say( SAY_NORM, "Ho-ho-ho." );
}


void test13( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    Log( "begin" );
    if( map.Reload() )
        Log( "ok" );
}

void test14( Critter& cr, int p0, int p1, int p2 )
{
    Map@ location = cr.GetMap();
    Log( "begin loc" );
    if( location.Reload() )
        Log( "ok" );
}

void test15( Critter& cr, int p0, int p1, int p2 )
{
    cr.RunClientScript( "__Test", p0, p1, p2, null, null );
}

void test16( Critter& cr, int p0, int p1, int p2 )
{
    uint[] ui( 3 );
    ui[ 0 ] = p0;
    ui[ 1 ] = p1;
    ui[ 2 ] = p2;
    CreateTimeEvent( __FullSecond + 5 * 60, "e_Test", ui, true );
}

uint e_Test( uint[] @ values )
{
    Log( "Values (" + values.length() + "): " + values[ 0 ] + ", " + values[ 1 ] + ", " + values[ 2 ] + "." );
    return REAL_SECOND( 5 );
}

void test17( Critter& cr, int p0, int p1, int p2 )
{
    Log( "Show callback." );
}

void testGroup( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;
    Critter@ npc2 = GetCritter( uint( p1 ) + 5000000 );
    if( not valid( npc2 ) )
        return;

    Critter@[] group( 2 );
    @group[ 0 ] = npc;
    @group[ 1 ] = npc2;

    cr.TransitToGlobal( group );
}

void testLex( Critter& cr, int p0, int p1, int p2 )
{
    Item@[] items;
    cr.GetItems( -1, items );
    for( uint i = 0; i < items.length(); i++ )
        items[ i ].SetLexems( "$Number" + Random( 100, 200 ) );

    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    npc.SetLexems( "$name" + "Dude" );
    Log( "Done" );
}

void testFly( Critter& cr, int p0, int p1, int p2 )
{
    Log( "x " + cr.HexX + " y " + cr.HexY );
    cr.GetMap().RunFlyEffect( p0, null, null, cr.HexX, cr.HexY, p1, p2 );
}

void testDelItem( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cl = GetCritter( uint( p0 ) );
    if( not valid( cl ) )
        return;
    DeleteItem( cl.GetItem( 0, p1 ) );
}

void testSwap( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr1 = GetCritter( uint( p0 ) );
    Critter@ cr2 = GetCritter( uint( p1 ) );
    SwapCritters( cr1, cr2, true, true );
}


/*#pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
#pragma globalvar "bool aaaa = true"*/


void test_find( Critter& cr, int p0, int p1, int param2 )
{
    Map@ map = cr.GetMap();
    int  f = 0;
    switch( p0 )
    {
    case 0:
        f = FIND_LIFE;
        break;
    case 1:
        f = FIND_KO;
        break;
    case 2:
        f = FIND_DEAD;
        break;
    case 3:
        f = FIND_LIFE_AND_KO;
        break;
    case 4:
        f = FIND_LIFE_AND_DEAD;
        break;
    case 5:
        f = FIND_KO_AND_DEAD;
        break;
    case 6:
        f = FIND_ALL;
        break;
    }
    uint count = map.GetNpcCount( param2, f );
    for( uint i = 0; i < count; i++ )
    {
        Critter@ cow = map.GetNpc( param2, f, i );
        map.SetText( cow.HexX, cow.HexY, COLOR_RGB( 255, 0, 0 ), "" + count );
    }
    cr.Say( SAY_NORM_ON_HEAD, "" + f );
}


import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void AffectPoison( Critter& cr, int value ) from "poison";

void testPlague( Critter& cr, int isRad, int value, int p2 )
{
    if( isRad != 0 )
        AffectRadiation( cr, value );
    else
        AffectPoison( cr, value );
    cr.Say( SAY_NETMSG, "rad " + cr.Stat[ ST_RADIATION_LEVEL ] );
    cr.Say( SAY_NETMSG, "psn " + cr.Stat[ ST_POISONING_LEVEL ] );
}

void LocInfo( Critter& cr, int isRad, int value, int p2 )
{
    Location@ loc = cr.GetMap().GetLocation();
    cr.Say( SAY_NETMSG, "MapPid " + cr.GetMap().GetProtoId() );
    cr.Say( SAY_NETMSG, "LocPid " + loc.GetProtoId() );
    cr.Say( SAY_NETMSG, "Visible " + ( loc.Visible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckVisible " + ( loc.GeckVisible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "AutoGarbage " + ( loc.AutoGarbage ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckCount " + loc.GeckCount );
    cr.Say( SAY_NETMSG, "Radius " + loc.Radius );
}

void GetCrIds( Critter& cr, int onlyNpc, int, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] critters;
        for( uint i = 0, j = map.GetCritters( 0, FIND_ALL | ( onlyNpc == 1 ? FIND_ONLY_NPC : 0 ), critters ); i < j; i++ )
            cr.Say( SAY_NETMSG, critters[ i ].Name + " " + critters[ i ].Id );
    }
}

void CrAddItem( Critter& cr, int crId, int pid, int count )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.AddItem( pid, count );
}

void AddExp( Critter& cr, int crId, int val, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ ST_EXPERIENCE ] += val;
}

void SetStat( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ num ] = val;
}

void SetSkill( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.SkillBase[ num ] = val;
}

void SetPerk( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.PerkBase[ num ] = val;
}

/*
   import void ExplodeEx(Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId) from "explode";

   void Boom(Critter& cr, int damage, int damageRadius, int effRadius)
   {
        Map@ map=cr.GetMap();
        if(valid(map)) ExplodeEx(map,cr.HexX,cr.HexY,PID_EXPLODE_ROCKET,effRadius,damage,DAMAGE_EXPLODE,damageRadius,0);
   }
 */

void TestLoc( Critter& cr, int locPid, int count, int )
{
    for( int i = 0; i < count; i++ )
    {
        Location@ loc = GetLocation( CreateLocation( locPid, 100, 100, null ) );
        Map@      map = loc.GetMapByIndex( 0 );
        Critter@[] critters;
        uint      crCount = map.GetCritters( 0, FIND_ALL, critters );
        for( uint j = 0; j < crCount; j++ )
        {
            for( uint k = 0; k < crCount; k++ )
            {
                if( j != k )
                    AddAttackPlane( critters[ j ], 0, critters[ k ] );
            }
        }
    }
}

void TestWorld( Critter& cr, int, int, int )
{
    // 1000 locations and maps
    // 100000 items
    // 5000 npc
    for( uint i = 0; i < 1000; i++ )
        CreateLocation( 101, 100, 100, null );
    // 242000
    for( uint i = 0; i < 242000; i++ )
        GetLocalVar( 3040, i );
    for( uint i = 0; i < 87000; i++ )
        GetUnicumVar( 2020, i, i );


// npc 7300 +
// uvar 87000 +
// lvar 242000 +
// holo 110 -
// maps 708 +
// loc 524 +
// items 105000 +
// anyd 1800 -
}

void CrClearInv( Critter& cr, int crId, int, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        Item@[] items;
        toCr.GetItems( -1, items );
        for( uint i = 0, j = items.length(); i < j; i++ )
            DeleteItem( items[ i ] );
    }
}

void SetType( Critter& cr, int crId, int crType, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ChangeCrType( crType );
        toCr.StatBase[ ST_BASE_CRTYPE ] = crType;
    }
}

void ChangeLook( Critter& cr, int, int, int )
{}

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId ) from "explode";
void        Boom( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
            ExplodeEx( cr.GetMap(), critters[ i ].HexX, critters[ i ].HexY, PID_EXPLODE_ROCKET, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
}

void RandomTypes( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            int type = Random( 20, 90 );
            critters[ i ].ChangeCrType( type );
            critters[ i ].StatBase[ ST_BASE_CRTYPE ] = type;
        }
    }
}

void AllToVaultBoys( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            critters[ i ].ChangeCrType( 249 );
            critters[ i ].StatBase[ ST_BASE_CRTYPE ] = 249;
        }
    }
}

void AllMapsEveryBoom( Critter& cr, int, int, int )
{
    Map@[] maps;
    ::GetAllMaps( 0, maps );
    for( uint i = 0, j = maps.length(); i < j; i++ )
    {
        Map@   map = maps[ i ];
        uint16 locPid = map.GetLocation().GetProtoId();
        if( LOCATION_IS_CITY( locPid ) )
            CreateTimeEvent( __FullSecond, "e_Boom", map.Id, true );
    }
}

void RandomEveryBoom( Critter& cr, int, int, int )
{
    CreateTimeEvent( __FullSecond, "e_Boom", cr.GetMap().Id, true );
}

uint e_Boom( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
    {
        for( int i = 0; i < 4; i++ )
            ExplodeEx( map, Random( 10, map.GetWidth() - 10 ), Random( 10, map.GetHeight() - 10 ), PID_EXPLODE_ROCKET, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
    return REAL_SECOND( Random( 1, 4 ) );
}

void AllToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void NpcToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void AllToDead( Critter& cr, int deadType, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToDead( deadType, null );
    }
}

void ShowIds( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "My id is " + critters[ i ].Id );
}

void SetDustyScript( Critter& cr, int dustyId, int, int )
{
    Critter@ dusty = GetCritter( dustyId );
    if( valid( dusty ) )
        dusty.SetScript( "ncr_dusty@_DustyInit" );
}

void TestIndex( Critter& cr, int i, int, int )
{
    cr.StatBase[ ST_STRENGTH ] = 20;
    const int ii = cr.Stat[ ST_STRENGTH ];
    Log( "Strenght " + cr.Stat[ ST_STRENGTH ] );
}

void Transit( Critter& cr, int hx, int hy, int )
{
    cr.TransitToHex( hx, hy, 6 );
}

void GlobalCar( Critter& iam, int crId, int, int )
{
    Critter@ cr = ::GetCritter( crId );
    if( valid( cr ) )
    {
        Item@[] items;
        cr.GetItemsByType( ITEM_TYPE_CAR, items );
        for( uint i = 0; i < items.length(); i++ )
        {
            Item@ car = items[ i ];
            car.Charge = car.Proto.Car_TankVolume;
            car.Deterioration = 0;
            car.Update();
            iam.Say( SAY_NETMSG, "Done." );
        }
    }
}

void NullPtr( Critter& iam, int crId, int, int )
{
    Critter@ cr = GetCritter( 666 );
    if( iam.SkillBase[ 555 ] == 11 )
        crId = 0;
}

void AddHellTurret( Critter& iam, int pid, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( pid != 0 ? pid : 480, hx, hy, iam.Dir, null, null, null );
    turret.SetScript( "replication_hell@_TurretInit" );
}

uint NpcCrazyId = 0;
void NpcCrazyEvent( Critter& cr, int off, int, int )
{
    if( off != 0 )
        EraseTimeEvent( NpcCrazyId );
    else
        NpcCrazyId = CreateTimeEvent( __FullSecond, "e_NpcCrazy", cr.GetMap().Id, true );
}

uint e_NpcCrazy( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@[] players;
        map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players );
        for( uint l = 0, m = players.length(); l < m; l++ )
            AddAttackPlane( critters[ i ], 0, players[ l ] );
    }
    return REAL_SECOND( Random( 10, 40 ) );
}

void AddMadRobot( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( 480, hx, hy, iam.Dir, null, null, null );
    turret.StatBase[ ST_TEAM_ID ] = 19;
    turret.SetScript( "replication_hell@_TurretInit" );
//	turret.SetStat(ST_REPLICATION_TIME,1);
//	turret.SetPerk(PE_TERMINATOR,1);
    turret.AddItem( 520, 2 );
}

void AllNpcSetParam( Critter& cr, int index, int value, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].ParamBase[ index ] = value;
}

void AddGuard( Critter& cr, int, int, int )
{
    int[] params = { ST_DIALOG_ID, 2200, ST_TEAM_ID, 5 };
    int[] items = { PID_END_BOSS_PLASMA_GUN, 3, SLOT_INV };
    Critter@ guard = cr.GetMap().AddNpc( 369, cr.HexX, cr.HexY - 1, 2, params, items, "map_barter_ground@_GuardInit" );
}

void NpcFullDead( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_REPLICATION_TIME ] = -1;
        critters[ i ].ToDead( 1, null );
    }
}

void NpcReturn( Critter& cr, int replTime, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_REPLICATION_TIME ] = replTime;
        critters[ i ].ToLife();
    }
}

#include "_npc_pids.fos"
//const uint16[] pids = { 54, 54, 54, 54, NPC_PID_MaleOrphan, NPC_PID_FemaleOrphan, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_MaleOrphan, NPC_PID_FemaleOrphan, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_AverageMerchantMale, NPC_PID_WeakMeleeGuardMale, NPC_PID_RaiderMale, NPC_PID_RaiderFemale };

/*
void AddHostile( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ hostile = map.AddNpc( pids[ Random( 0, pids.length() - 1 ) ], hx, hy, iam.Dir, null, null, null );
    hostile.StatBase[ ST_TEAM_ID ] = 19;
    // hostile.SetStat(ST_REPLICATION_TIME,Random(5,10));
    CreateTimeEvent( __FullSecond, "e_HostileMove", hostile.Id, true );
}*/

uint SufferingLastTime = 0;
uint e_HostileMove( uint[] @ values )
{
    Critter@ hostile = ::GetCritter( values[ 0 ] );
    if( not valid( hostile ) )
        return 0;

    if( hostile.IsLife() )
    {
        hostile.MoveRandom();

        if( __FullSecond > SufferingLastTime )
        {
            string say;
            switch( Random( 0, 50 ) )
            {
            case 0:
                say = "Малые страдания выводят нас из себя, великие же - возвращают нас самим себе.";
                break;
            case 1:
                say = "Минутное удовольствие часто бывает причиной долгих страданий. ";
                break;
            case 2:
                say = "Кто боится страдания, тот уже страдает от боязни.";
                break;
            case 3:
                say = "Язвы желудка возникают не от того, что вы едите, а от того, что съедает вас. ";
                break;
            case 4:
                say = "Бедное раздавленное насекомое страдает так же, как умирающий гигант. ";
                break;
            case 5:
                say = "Молчание - величайшее из человеческих страданий; святые никогда не молчали. ";
                break;
            case 6:
                say = "Раны, нанесенные собственной рукой, всегда заживают медленнее, чем те, которые нанес противник. ";
                break;
            case 7:
                say = "Не умеешь нести бремя невзгод - усугубляешь их тяжесть. ";
                break;
            case 8:
                say = "Есть два способа преодолевать трудности: либо вы изменяете сами трудности, чтобы было легче с ними справится, либо, справляясь с ними изменяетесь сами. ";
                break;
            case 9:
                say = "Если мы еще можем любить тех, кто заставил нас страдать, то любовь наша лишь становится сильнее.  ";
                break;
            case 10:
                say = "Мужественный человек обыкновенно страдает, не жалуясь, человек же слабый жалуется, не страдая.";
                break;
            case 11:
                say = "Величайшее зло - страдание.";
                break;
            case 12:
                say = "Всеми страданиями вокруг нас должны страдать и мы. У всех у нас не одно тело, но одно развитие, а это проводит нас через все боли в той или иной форме. Как дитя проходит в своем развитии через все стадии жизни вплоть до старости и до смерти (и каждая стадия, в сущности, от страха или от желания, кажется предыдущей недостижимою), точно так же и мы (связанные с человечеством не менее глубоко, чем с самими собой) проходим в своем развитии через все страдания этого мира. Справедливости при таком положении нет места, но нет места и страху перед страданием или возможности истолковать страдание как заслугу.";
                break;
            case 13:
                say = "Издевательство над чужими страданиями не должно быть прощаемо.";
                break;
            case 14:
                say = "К величию есть только один путь, и этот путь проходит через страдания.";
                break;
            case 15:
                say = "Когда мне не дают роли, чувствую себя пианисткой, которой отрубили руки.";
                break;
            case 16:
                say = "Мы стремимся в большей степени к тому, чтобы отвести от себя страдания, нежели к тому, чтобы получить удовольствие.";
                break;
            case 17:
                say = "Обусловленное существование есть страдание. У страдания есть причина. У страдания есть конец, и есть пути, ведущие к этому концу.";
                break;
            case 18:
                say = "Только здесь страдать – это страдать. Не в том смысле, что те, кто страдает здесь, где-то в другом месте из-за этого страдания будут возвышенны, а в том смысле, что то, что именуется в этом мире страданием, в другом мире не изменяется, а только освобождено от своей противоположности, блаженства.";
                break;
            case 19:
                say = "Ты можешь отстраняться от страданий мира, это тебе разрешается и соответствует твоей природе, но, быть может, как раз это отстранение и есть единственное страдание, которого ты мог бы избежать.";
                break;
            case 20:
                say = "Человеческий разум может излечить от иллюзий, но не от страданий.";
                break;
            case 21:
                say = "Чем больше любят, тем больше страдают. Вся возможная для каждой души боль пропорциональна степени ее совершенства.";
                break;
            case 22:
                say = "Мудрый не горюет о потерянном, об умершем и о прошлом. Тем он отличается от глупца.";
                break;
            case 23:
                say = "Размышляй об изгнании, пытках, войнах, болезнях, кораблекрушениях, чтобы не быть новичком ни при каких бедствиях.";
                break;
            case 24:
                say = "Подлинное душевное спокойствие достигается примирением с самым худшим.";
                break;
            case 25:
                say = "Кто страдает раньше, чем это необходимо, тот страдает больше необходимого.";
                break;
            case 26:
                say = "Кто боится страданий, тот уже страдает от боязни.";
                break;
            case 27:
                say = "Ничтожным не бывает то, что больно нам.";
                break;
            case 28:
                say = "Моря человеческих слез не были бы так огромны, если бы не были бы так мелки.";
                break;
            case 29:
                say = "Чувствительный человек – точно безоружный среди хорошо вооруженных.";
                break;
            case 30:
                say = "Люди не бывают очень несчастны, если им не в чем раскаиваться.";
                break;
            case 31:
                say = "Чужие бедствия могут быть поводом к безропотности, но не к утешению.";
                break;
            case 32:
                say = "Огорчение существует не само по себе, а в нашем представлении.";
                break;
            case 33:
                say = "Мы созданы для несчастий. Слезы для сердца, что вода для рыб.";
                break;
            case 34:
                say = "В этом мире самым надежным развлечением для нас являются тревоги и страдания.";
                break;
            case 35:
                say = "Наш мир есть ничто иное, как скопление громадных страданий.";
                break;
            case 36:
                say = "Горечь – единственное накопление человека в жизни.";
                break;
            case 37:
                say = "Единственный способ быть счастливым – это любить страдания.";
                break;
            case 38:
                say = "В жизни, как и в природе, бывает гораздо больше пасмурных дней, чем безоблачных.";
                break;
            case 39:
                say = "Не чувствовать страданий не свойственно человеку, а не уметь их переносить не подобает мужчине.";
                break;
            case 40:
                say = "Ни с кем не случается ничего такого, что он не в силах был бы вынести.";
                break;
            case 41:
                say = "Мужайтесь и храните себя для благоприятных времен.";
                break;
            case 42:
                say = "Переноси с достоинством то, что изменить не сможешь.";
                break;
            case 43:
                say = "Кто переносит нетерпеливо, тот страдает вдвойне.";
                break;
            case 44:
                say = "Слезы для женщины – облегчение, для мужчины – пытка.";
                break;
            case 45:
                say = "Хочешь быть счастливым – выучись сперва страдать.";
                break;
            default:
                break;
            }
            if( say != "" )
                hostile.Say( SAY_NORM, say );
            SufferingLastTime = __FullSecond + Random( 1, 3 ) * 60;
        }
        else if( Random( 0, 10 ) == 0 )
            hostile.ToDead( Random( ANIM2_DEAD_BLOODY_SINGLE, ANIM2_DEAD_BURN_RUN ), null );                           // ExplodeEx(hostile.GetMap(),hostile.HexX,hostile.HexY,PID_EXPLODE_ROCKET,10,666,DAMAGE_EXPLODE,10,0);
    }

    return REAL_SECOND( Random( 10, 20 ) );
}

void AttackTurret( Critter& cr, int, int, int )
{
    Critter@ turret;
    Map@     map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() == 480 )
        {
            @turret = critters[ i ];
            break;
        }

    }

    critters.resize( 0 );
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() != 480 )
        {
            AddAttackPlane( critters[ i ], 100, turret );
        }
    }
}


void TurretFrags( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() == 480 )
        {
            CreateTimeEvent( __FullSecond, "e_HostileMove", critters[ i ].Id, true );
            break;
        }

    }
}

uint e_TurretFrags( uint[] @ values )
{
    Critter@ turret = ::GetCritter( values[ 0 ] );
    uint     frags = 0; // =turret.GetKill(BT_MEN)+turret.GetKill(BT_WOMEN)+turret.GetKill(BT_CHILDREN);
    turret.Say( SAY_NORM_ON_HEAD, "Frags " + frags );
    return REAL_SECOND( 3 );
}

void TurretParam( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_BONUS_LOOK ] = 1000;
    }
}

void CreateCar( Critter& cr, int pid, int ox, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX + ox, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;

    uint keyId = Random( 10000, 50000 );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;
    cr.AddItem( PID_BLUE_PASS_KEY, 1 ).LockerId = keyId;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." );
}

void CreateCarPersonal( Critter& cr, int pid, int crId, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;
    _CarSetNoLockpick( car );

    uint keyId = _CritEyesDoorId( crId );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." );
}

void AllTo3d( Critter& cr, int, int, int )
{
    Critter@[] critters;
    cr.GetMap().GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        int rnd = Random( 290, 316 );
        critters[ i ].ChangeCrType( rnd );
        critters[ i ].StatBase[ ST_BASE_CRTYPE ] = rnd;
    }
}

void TestLexem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.SetLexems( "test test test" );
        item.Update();
    }
}

class Prop
{
    void set_Test( uint value ) {}
    uint get_Test() const       { return 0; }
};
void TestProp( Critter& cr, int, int, int )
{
    Prop p;
    uint i = ( p.Test - 1 );
}

// #pragma bindfunc "uint TestFunc(int, int) -> fo_test.dll TestFunc"
/*#pragma bindfunc "uint TestFunc(int, int) -> fo_test.dll TestFunc"
   #pragma bindfunc "bool Critter::TestMethod(int, uint, bool) -> fo_test.dll Critter_TestMethod"

   void TestDll(Critter& cr, int, int, int)
   {
        int i = TestFunc(1, 2);
        Log("TestFunc = " + i);

        i = cr.TestMethod(1, 2, true) ? 1 : 0;
        Log("TestMethod " + i);

        cr.SetEvent(CRITTER_EVENT_TALK, " fo_test.dll @ EventTalk ");
        i = cr.EventTalk(cr, true,666) ? 1 : 0;
        Log("EventTalk " + i);
   }*/

void TestScriptTimeout( Critter& cr, int, int, int )
{
    Test2();
}
void Test2()
{
    Test3();
}
void Test3()
{
    int ggg = 1;
    do
    {
        ggg = Random( 1, 100 );
    }
    while( ggg != 0 );
}

void TestNullptr( Critter&, int, int, int )
{
    Critter@ cr;
    Log( "begin" );
    uint     id = cr.Id;
    Log( "end" );
}

// Synchronizer TestLocker;
void TestScriptConcurrent( Critter& cr, int test, int, int )
{
    // TestLocker.Lock();

    Synchronize();
    Map@ map = cr.GetMap();
    Resynchronize();

    if( test == 1 )
        Resynchronize();             // Invalid call
    else if( test == 2 )
        Synchronize();               // Call without Resynchronize

    if( test == 5 )
    {
        for( int i = 0; i < 1000; i++ )
            CreateTimeEvent( 0, "e_TestScriptConcurrent", true );
    }
}

int Data = 0;
uint e_TestScriptConcurrent( uint[] @ values )
{
    // TestLocker.Lock();

    if( Data == 0 )
        Data++;
    else if( Data == 1 )
        Data--;
    else
        Log( "Fail!" );
    return 1;
}

void TestLog( Critter& cr, int, int, int )
{
    for( uint i = 0; i < 10000; i++ )
        Log( "Test message " + i );
}

void TestMapLoop( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetEvent( MAP_EVENT_LOOP_3, "_MapLoopEvent" );
    map.SetLoopTime( 3, 1000 );
    Log( "ok" );
}

void _MapLoopEvent( Map& map )
{
    Log( "_MapLoopEvent " + map.Id );
}

void patchBunker( Critter& cr, int, int, int )
{
    Location @ loc = GetLocationByPid( 21, 0 );    // LOCATION_TechBunker(21)
    if( @loc != null )
    {
        uint locId = loc.Id;
        DeleteLocation( locId );
        cr.Say( 11, "Location deleted. Id" + locId );     // SAY_NETMSG (11)
    }

    uint id = CreateLocation( 21, 1000, 1397, null );
    if( id == 0 )
    {
        cr.Say( 11, "Create location error: " + GetLastError() );
        return;
    }
    @ loc = GetLocation( id );

    if( @loc == null )
    {
        cr.Say( 11, "Get location error: " + GetLastError() );
        return;
    }

    loc.Visible = false;
    loc.GeckVisible = false;
    loc.AutoGarbage = false;
    loc.Radius = 6;
}

/*
   import void ClearPermanentDeath() from "replication";
   void ClearPermanentDeath(Critter& cr, int, int, int)
   {
        ClearPermanentDeath();
   }
 */

void TestBlockItem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_RADIO, 1 );
    item.SetEvent( ITEM_EVENT_SKILL, "_ChangeMode" );
    UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
}

bool _ChangeMode( Item& item, Critter& cr, int skill )
{
    if( FLAG( item.Flags, ITEM_NO_BLOCK ) )
    {
        UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    else
    {
        SETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    item.Update();
    return false;
}

void DeleteTimeEvent( Critter& cr, int id, int, int )
{
    ::EraseTimeEvent( uint( id ) );
}

void HandToGround( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
        ::MoveItem( item, 0, cr.GetMap(), cr.HexX, cr.HexY );
}

void PatchItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        bool  canPickUp = false;
        switch( item.GetType() )
        {
        case ITEM_TYPE_ARMOR:
        case ITEM_TYPE_DRUG:
        case ITEM_TYPE_WEAPON:
        case ITEM_TYPE_AMMO:
        case ITEM_TYPE_MISC:
        case ITEM_TYPE_KEY:
            canPickUp = true;
            break;
        // case ITEM_TYPE_MISC_EX:
        case ITEM_TYPE_CONTAINER:
            canPickUp = FLAG( item.Flags, ITEM_CAN_PICKUP );
            break;
        case ITEM_TYPE_DOOR:
            SETFLAG( item.Flags, ITEM_NO_HIGHLIGHT );
            break;
        default:
            break;
        }
        switch( item.GetProtoId() )
        {
        case 148:
        case 150:
        case 154:
        case 156:
        case 850:
        case 851:
        case 852:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
            canPickUp = false;
            break;
        default:
            break;
        }
        if( canPickUp )
            SETFLAG( item.Flags, ITEM_CAN_PICKUP );
        else
            UNSETFLAG( item.Flags, ITEM_CAN_PICKUP );
    }
}

void ColorizeHandItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightIntensity = Random( 30, 80 );
        item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        item.LightDistance = ( dist != 0 ? dist : Random( 5, 15 ) );
        item.LightFlags = 0;

        if( ( flags % 10 ) == 1 )
        {
            _LightSetIgnoreDir( item, 0 );
            _LightSetIgnoreDir( item, 2 );
            _LightSetIgnoreDir( item, 4 );
        }
        else if( ( flags % 10 ) == 2 )
        {
            _LightSetIgnoreDir( item, 1 );
            _LightSetIgnoreDir( item, 3 );
            _LightSetIgnoreDir( item, 5 );
        }
        if( ( flags / 10 ) == 1 )
            _LightSetInverse( item );

        SETFLAG( item.Flags, ITEM_LIGHT );
        item.Update();
    }
}

void ColorizeHandItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void ColorizeLegsItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        // SETFLAG(item.Flags,ITEM_COLORIZE);
        item.Update();
    }
}

void ColorizeLegsItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_COLORIZE ) )
            UNSETFLAG( item.Flags, ITEM_COLORIZE );
        else
            SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void PatchLight( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        if( item.LightIntensity != 0 || item.Proto.LightIntensity != 0 )
            SETFLAG( item.Flags, ITEM_LIGHT );
    }
}

void ItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = cr.GetMap().GetItems( cr.HexX, cr.HexY, items );
    for( uint i = 0; i < count; i++ )
        cr.Say( SAY_NETMSG, "item " + items[ i ].GetProtoId() + " flags " + items[ i ].Flags );
}

void CheckAccess( Critter& cr, int, int, int )
{
    Map@[] maps;
    uint mapsCount = ::GetAllMaps( 0, maps );
    for( uint i = 0; i < mapsCount; i++ )
    {
        Map@ map = maps[ i ];
        Critter@[] players;
        uint count = map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, players );
        for( uint j = 0; j < count; j++ )
        {
            Critter@ player = players[ j ];
            if( player.GetAccess() > 0 )
                cr.Say( SAY_NETMSG, "Player " + player.Name + " access " + player.GetAccess() + "." );
        }
    }
    cr.Say( SAY_NETMSG, "Search complete." );
}

void Effect( Critter& cr, int radius, int, int )
{
    cr.GetMap().RunEffect( PID_EXPLODE_EMP, cr.HexX, cr.HexY + 10, radius );
}

void AddLoc( Critter& cr, int pid, int x, int y )
{
    if( ::CreateLocation( pid, x, y, null ) != 0 )
        cr.Say( SAY_NETMSG, "Success." );
    else
        cr.Say( SAY_NETMSG, "Fail." );
}

void DeleteNpc( Critter& cr, int crId, int, int )
{
    DeleteNpc( GetCritter( crId ) );
}

void EndTB( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetTurnBasedAvailability( false );
    map.EndTurnBased();
}

void TestVar( Critter& cr, int i, int, int )
{
    /*GameVar@ var=GetLocalVar(LMVAR_test_local_map,cr.GetMapId());
       Log("var="+var.GetValue());

       if(i!=0) var=i;

       Log("var="+var.GetValue());

       Log("begin vars generating");
       for(int i=1;i<1000000;i++)
       {
            GameVar@ var=GetLocalVar(LIVAR_test_local_item,i);
            var=Random(0,10);
            var=7;
       }
       Log("end vars generating");
     */
//	GVAR_test_global
//	LVAR_test_local
//	UVAR_test_unicum
//	LLVAR_test_local_loc
//	LMVAR_test_local_map
//	LIVAR_test_local_item
}

void TestTE( Critter& cr, int set, int, int )
{
    uint num = CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_TestTE", -8, true );
    Log( "created " + num );

    uint duration = 0;
    uint[] values;
    if( GetTimeEvent( num, duration, values ) )
    {
        Log( "get ok+ duration " + duration );
        for( uint i = 0; i < values.length(); i++ )
            Log( i + ") " + values[ i ] );
        Log( "get ok-" );

        if( set != 0 )
        {
            values[ 0 ] = 123;
            uint value = 456;
            values.insertLast( value );
            if( SetTimeEvent( num, duration, values ) )
            {
                Log( "set ok+" );
                for( uint i = 0; i < values.length(); i++ )
                    Log( i + ") " + values[ i ] );
                Log( "set ok-" );
            }
        }
    }
}

uint e_TestTE( int[] @ values )
{
    Log( "e_TestTE+" );
    for( uint i = 0; i < values.length(); i++ )
        Log( i + ") " + values[ i ] );
    Log( "e_TestTE-" );
    return 0;
}

void DoorKey( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;
    map.MoveHexByDir( hx, hy, cr.Dir, 1 );
    Item@ door = map.GetDoor( hx, hy );
    if( not valid( door ) )
        return;
    Item@ key = cr.AddItem( PID_TEMPLE_KEY, 1 );
    if( not valid( key ) )
        return;
    key.LockerId = door.LockerId;
    key.Update();
}

void HandToInv( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        if( cr.MoveItem( item.Id, 0, SLOT_INV ) )
            Log( "ok" );
        else
            Log( "fail" );
    }
}

void KillSpawn( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;

    map.MoveHexByDir( hx, hy, cr.Dir, 1 );

    Critter@ oldNpc = map.GetCritter( hx, hy );
    if( not valid( oldNpc ) )
        return;

    DeleteNpc( oldNpc );

    uint[] values = { map.Id, hx, hy };
    CreateTimeEvent( __FullSecond + REAL_MS( 50 ), "e_KillSpawn", values, true );
}

uint e_KillSpawn( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
        map.AddNpc( 20 + Random( 0, 10 ), values[ 1 ], values[ 2 ], 2, null, null, null );
    return 0;
}

import void DropDrugEffects( Critter& cr ) from "drugs";
void        DropDrugs( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < 10; i++ )
    {
        map.MoveHexByDir( hx, hy, iam.Dir, 1 );
        Critter@ cr = map.GetCritter( hx, hy );
        if( valid( cr ) )
        {
            DropDrugEffects( cr );
            cr.Say( SAY_NORM, "Drugs dropped." );
            break;
        }
    }
}

void ClearExplode( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    map.GetItems( PID_ACTIVE_DYNAMITE, items );
    map.GetItems( PID_ACTIVE_PLASTIC_EXPLOSIVE, items );
    map.GetItems( PID_ACTIVE_MINE, items );

    DeleteItems( items );
}
/*
   void Sandbags(Critter& iam, int lineLen, int skipLen, int stackCount)
   {
        Map@ map=iam.GetMap();
        if(not valid(map)) return;

        uint16 pid=PID_SANDBAG_EMPTY;
        if(stackCount!=0) pid=PID_SANDBAG_1-1+stackCount;

        uint16 hx=iam.HexX,hy=iam.HexY;
        for(uint i=0;i<uint(lineLen);i++)
        {
                if(skipLen!=0) skipLen--;
                else
                {
                        map.MoveHexByDir(hx,hy,iam.Dir,1);
                        map.AddItem(hx,hy,pid,1);
                }
        }
   }
 */
void ClearItems( Critter& iam, int lineLen, int skipLen, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.GetItems( hx, hy, items );
        }
    }

    DeleteItems( items );
}

import void PlayMusic( Map& map, string& musicName, uint pos, uint repeat ) from "media";
void        BattleMusic( Critter& iam, int index, int, int )
{
    if( index == 1 )
        PlayMusic( iam.GetMap(), "02 - Into The Dust.ogg", 0, 0 );
    else if( index == 2 )
        PlayMusic( iam.GetMap(), "07 - Echelon.ogg", 0, 0 );
    else if( index == 3 )
        PlayMusic( iam.GetMap(), "11 - Face To Face.ogg", 0, 0 );
    else if( index == 4 )
        PlayMusic( iam.GetMap(), "16 - Stranglet.ogg", 0, 0 );
    else if( index == 5 )
        PlayMusic( iam.GetMap(), "17 - Trinity.ogg", 0, 0 );
    else
        PlayMusic( iam.GetMap(), "01 - No Fate No Fear.ogg", 0, 0 );
}

void SetAnim1( Critter& cr, int value, int, int )
{
    cr.SetAnims( 0, value, 0 );
}

void Pos( Critter& cr, int newPos, int, int )
{
    // 0 - stand, 1 - crouch, 2 - prone
    int curPos = ( ( cr.Anim1Life & ANIM1_CROUCH ) != 0 ? 1 : ( ( cr.Anim1Life & ANIM1_PRONE ) != 0 ? 2 : 0 ) );
    switch( curPos )
    {
    case 0:
        switch( newPos )
        {
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_PRONE, null, false, true );
            break;
        default:
            break;
        }
        break;
    case 1:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_STAND, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_PRONE, null, true, true );
            break;
        default:
            break;
        }
        break;
    case 2:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_STAND, null, false, true );
            break;
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }
    switch( newPos )
    {
    case 0:
        cr.SetAnims( 0, 0, 0 );
        break;
    case 1:
        cr.SetAnims( 0, ANIM1_CROUCH, 0 );
        break;
    case 2:
        cr.SetAnims( 0, ANIM1_PRONE, 0 );
        break;
    default:
        break;
    }
}

void ColorOffset( Critter& cr, int skin, int hair, int armor )
{
    cr.SetAnims( 0, ANIM1_COLOR_SKIN( skin ) | ANIM1_COLOR_HAIR( hair ) | ANIM1_COLOR_ARMOR( armor ), 0 );
}

void Shield( Critter& cr, int on, int, int )
{
    if( on != 0 )
        cr.SetAnims( 0, ANIM1_SHIELD, 0 );
    else
        cr.SetAnims( 0, 0, 0 );
}

void Palette( Critter& cr, int index, int, int )
{
    cr.SetAnims( 0, ANIM1_PALETTE( index ), 0 );
}

void SetWalk( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_WALK_TIME ] = time;
    cr.ModeBase[ MODE_NO_WALK ] = off;
}

void SetRun( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_RUN_TIME ] = time;
    cr.ModeBase[ MODE_NO_RUN ] = off;
}



void excep0( Critter& cr, int, int, int )
{
    Log( "excep0" );
    excep1( cr );
}
void excep1( Critter& cr )
{
    Log( "excep1" );
    int y = 100;
    excep2( 6 );
}
void excep2( int i )
{
    Log( "excep2" );
    for( int k = 0; k < 10; k++ )
        excep3();
}
void excep3()
{
    Log( "excep3" );
    int h = 0;
    int k = 10 / h;
}

void toDead( Critter& cr, int, int, int )
{
    cr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, null );
}
void toLife( Critter& cr, int, int, int )
{
    cr.ToLife();
}
void toKO( Critter& cr, int, int, int )
{
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, cr.HexX, cr.HexY );
}

#pragma bindfunc "bool TestScriptCallNative(string&, string&) -> fonline_test.dll TestScriptCallNative"
void testScriptCall( Critter&, int, int, int )
{
    if( TestScriptCallNative( "test", "double TestScriptCallAS(int v1, uint64 v2, float v3, string@ v4)" ) )
        Log( "testScriptCall success." );
    else
        Log( "testScriptCall fail." );
}
double TestScriptCallAS( int v1, uint64 v2, float v3, string@ v4 )
{
    Log( "TestScriptCall: " + v1 + ", " + v2 + ", " + v3 + ", " + v4 + "." );
    return 1.234567890;
}

#pragma bindfunc "void StringExample() -> fonline_test.dll StringExample"
void testStringExample( Critter&, int, int, int )
{
    StringExample();
}


void animate( Critter& cr, int anim1, int anim2, int )
{
    cr.Animate( anim1, anim2, null, true, true );
}
