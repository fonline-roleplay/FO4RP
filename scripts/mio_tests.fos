#include "_macros.fos"


#define VERSION									( 23 )					// Номер обновления клиента.


//~run mio_tests go 0 0 0
void go( Critter& cr, int, int, int )
{
	foo_test_class(cr);
	foo_test_array(cr);
}

#ifndef __TESTING_DATATYPES
	#define __TESTING_DATATYPES

	class Range_class
	{
		int min;
		int max;
		Range_class( int min, int max )
		{
			this.min = min;
			this.max = max;
		}
	}

	Range_class foo_class()
	{
		return Range_class( 0, 10 );
	}

	void foo_test_class( Critter& cr )
	{
		Range_class data = foo_class();
		cr.Say( SAY_NETMSG, "Class: " + data.min + " - " + data.max + ";" );
	}

	int[] foo_array( int min, int max )
	{
		int[] range = { min, max };
		return range;    
	}

	void foo_test_array( Critter& cr )
	{
		int[] data = foo_array( 5, 25 );
		cr.Say( SAY_NETMSG, "Array: " + data[0] + " - " + data[1] + ";" );
	}
#endif

#ifndef __TESTING_BYTEWORKS
	#define __TESTING_BYTEWORKS
	bool uint_vs_int( uint a, int b, string@ info = null )
	{
		if( valid( info ) )
			info += a + ( ( int( a ) == b ) ? " == " : " != " ) + b;

		return ( int( a ) == b );
	}

	void int_bytelength( Critter& cr )
	{
		
		uint t1 = uint( -1 ); int t2 = t1 >> 1; int t3 = t2 + 1;
		string result = "Max UINT32 = " + t1 + "\nMin INT32 = " + t3 + "\nMax INT32 = " + t2 ;
		
		int index = 0;
		while( t1 > 0 )
		{
			t1 = t1 >> 1;
			index++;
		}
		result += "\nIt's really 2^" + index;
		
		t1 = uint( -1 ); t2 = ( t2 << 1 ) + 1;
		result += "\nAlso, ";
		uint_vs_int( t1, t2, result );
		
		cr.Say( SAY_NORM, result );
	}
#endif

#ifndef __TESTING_FOR_CYCLE
	#define __TESTING_FOR_CYCLE

	void init( int& a, int& b )
	{
		a = 0;
		b = 10;
	}

	bool check( int& a, int& b )
	{
		return a < b;
	}

	void action( int& a, int& b )
	{
		a++;
		b--;
	}

	void forTest( Critter& cr )
	{
		int a = 100, b = 10;
		for( init(a,b); check(a,b); action(a,b) )
		{
			cr.Say( SAY_NORM, a + "/" + b );
		}
	}
#endif

#ifndef __TESTING_CLASS_INHERITANCE
	#define __TESTING_CLASS_INHERITANCE
	void runTest( Critter& cr )
	{
		//Данная запись позволяет избежать бессмысленного создания переменной для хранения указателя на объект класса:
		//Animal@ a = Animal(); a.test(cr);
		TestAnimal( cr, Animal() );
		TestAnimal( cr, Dog() );
		TestAnimal( cr, Cat() );
		TestAnimal( cr, Lion() );
		TestAnimal( cr, Kitten() );
		TestAnimal( cr, Human() );
	}

	void TestAnimal( Critter& cr, Animal@ subject )
	{
		subject.test(cr);
	}

	class Animal
	{
		string name;

		Animal( )
		{
			init( "Животне" );
		}
		
		Animal( string name )
		{
			init( name );
		}
		
		void init( string name )
		{
			this.name = name;
		}
		
		string say() //override
		{
			return "нихуя себе!";
		} 
		
		void test( Critter& cr )
		{
			cr.Say( SAY_NORM, this.name + " говорит: '" + this.say() + "'" );
		}
	}

	class Dog : Animal
	{
		Dog( )
		{
			super( "Собака сутулая" );
		}
		
		Dog( string name )
		{
			super( name );
		}
		
		string say() override
		{
			return "Гафк!";
		}
	}

	class Cat : Animal
	{
		Cat( )
		{
			super( "Дикий кац" );
		}
		
		Cat( string name )
		{
			super( name );
		}
		
		string say() override
		{
			return "Мурк!";
		}
	}

	class Lion : Cat
	{
		Lion( )
		{
			super( "Лёва" );
		}
		
		Lion( string name )
		{
			super( name );
		}
		
		string say() override
		{
			return "Рооар!";
		}
	}

	class Kitten : Cat
	{
		Kitten( )
		{
			super( "Домашний каджит" );
		}
		
		Kitten( string name )
		{
			super( name );
		}
		
		string say() override
		{
			return "Скуума!";
		}
	}

	class Human : Animal
	{
		Human( )
		{
			super( "Френк Кост" );
		}
		
		Human( string name )
		{
			super( name );
		}
		
		string say() override
		{
			return "Вы кто такие? Я вас не звал, идите нахуй!";
		}
	}
#endif





// Pain and suffering begin here.

void PAAuth( Critter& cr )
{
	Item@ item = cr.GetItem( 0, SLOT_ARMOR );
	if( item !is null && ( item.GetProtoId() == PID_POWERED_ARMOR || item.GetProtoId() == PID_HARDENED_POWER_ARMOR ) )
	{
		if( item.Val9 == 10)
		{
			if( cr.Id == uint (item.Val8) )
			{
				string[] gndrPA = { "Приятный женский", "Приятный мужской", "Тёплый ламповый", "Бездушный сухой", "Зловещий холодный" };
				string gndr = cr.Stat[ ST_GENDER ] == 1 ? "хозяйка" : "хозяин";
				cr.Say( SAY_NETMSG, "|0xFF00FF " +gndrPA[ item.Id % 5 ]+ " электронный голос: |0xF8F993 Личность распознана. Приветствую, " +gndr+"." );
			
			} else {
				cr.AddTimeEvent( "cte_PAAuthFail", REAL_SECOND( 10 ), CTE_DRAGGING, 0 ); 
				cr.Say( SAY_EMOTE_ON_HEAD, "Нарастающий гул реактора" ); 
			}
		} else if( item.Val9 == 5 ) { 
			item.Val9 = 10; 
			item.Val8 = cr.Id; 
		}
	}
}
uint cte_PAAuthFail( Critter& cr, int identifier, uint& rate )
{
	Item@ item = cr.GetItem( 0, SLOT_ARMOR );
	if( item !is null && ( item.GetProtoId() == PID_POWERED_ARMOR || item.GetProtoId() == PID_HARDENED_POWER_ARMOR ) && item.Val9 == 10 ) {
		cr.MoveItem( item.Id, 1, SLOT_GROUND );
		
		if( cr.Karma[ KARMA_SEPARATED ] == 0 ) { 
			cr.ToDead( ANIM2_DEAD_PULSE_DUST, null ); 
			
		} else {
			cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( ( Random( 0, 1 ) == 0 ) ), 1000, cr.HexX, cr.HexY );
			cr.Say( SAY_EMOTE_ON_HEAD, "Получает разряд и выброс из брони" );
		}
	}
	return 0;
}

void Version( Critter& cr )
{
	if( cr.Param[ UPD_VERSION ] < VERSION )
	{
		cr.ShowScreen( SCREEN_DIALOGBOX, 1, "Version_true" );
		cr.Say( SAY_DIALOGBOX_TEXT, "|0xFF0000 !!! ТЫ ОБНОВИЛ КЛИЕНТ ???" );
		cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Да" );
	}
}
void Version_true( Critter& cr, uint answerI, string& answerS ) { if( answerI == 0 ) { cr.ParamBase[ UPD_VERSION ] = VERSION; } }

void ScouringStick( Critter& cr, Item& item )
{
	if( @item != @cr.GetItem( 0, SLOT_HAND1 ) ) { cr.Say( SAY_NETMSG, "Нужно взять набор для чистки в руку." ); return; }
	Item@ targetItem = cr.GetItem( 0, SLOT_HAND2 );
	if( !valid( targetItem ) ) { cr.Say( SAY_NETMSG, "Нужно взять оружие во вторую руку." ); return; }
	if( targetItem.GetType() != ITEM_TYPE_WEAPON ) { cr.Say( SAY_NETMSG, "Это похоже на набор для ухода за своим любимым оружием." ); return; }
	if( targetItem.Deterioration > 1000 ) { cr.Say( SAY_NETMSG, "Оружие как девушка, оно требует своевременного внимания и ухода. А теперь его нужно чинить." ); return; }

	cr.StatBase[ ST_EXPERIENCE ] += targetItem.Deterioration * 0.1;
	targetItem.Deterioration = 0;
	string[] TXT = { "С любовью", "С нежностью", "Ласково", "Нежно", "Бережно", "Брутально" };
	string[] TXT2 = { "прочищает свой ствол", "чистит дуло", "смазывает канал ствола" };
	string result = TXT[ Random( 0, TXT.length()-1 ) ] + " " + TXT2[ Random( 0, TXT2.length()-1 ) ];
	cr.Say( SAY_EMOTE, result );
	targetItem.Update();
			//Кустарный процесс удаления смазки и возврата суперрема
			item.Val0 -= 30; 
			if( item.Val0 <1 )
				{
				cr.DeleteItem( PID_GUNSMITH, 1 ); 
				cr.Say( SAY_NETMSG, "Смазка в наборе закончилась." );
				cr.AddItem( PID_SUPER_TOOL_KIT, 1);
				}
}

bool Action( Critter& player, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
	uint16 moverHexX = player.HexX, moverHexY = player.HexY, aimHexX = 0, aimHexY = 0;
		 if( valid( targetCr ) )   { aimHexX = targetCr.HexX;   aimHexY = targetCr.HexY; }
	else if( valid( targetItem ) ) { aimHexX = targetItem.HexX; aimHexY = targetItem.HexY; }
	else if( valid( targetScen ) ) { aimHexX = targetScen.HexX; aimHexY = targetScen.HexY; }
	else { return false; }

	uint dist = GetDistantion( moverHexX, moverHexY, aimHexX, aimHexY );
	if( dist > 1 ) { player.Say( SAY_NETMSG, "Слишком далеко." ); return false; }
	uint8 dir = GetDirection( moverHexX, moverHexY, aimHexX, aimHexY );
	player.SetDir( dir );
	player.Action( ACTION_PICK_CRITTER, 3, null );
	return true;
}

import bool UseSkillOnLocker( Critter& cr, Item& locker, int skill ) from "lockers";
import bool e_UseAutoCloseDoor( Item& door, Critter& cr, int skill ) from "item";
void OpenDoor( Critter& player )
{
	if( player.IsDead() || player.IsKnockout() || player.IsBusy() || player.Timeout[ TO_SK_STEAL ] > 0 ) { return; }

	Map@ map = player.GetMap();
	uint16 hexX, hexY;
	uint8 dir;
	for( uint8 i = 0; i < 6; i++ )
	{
		hexX = player.HexX;
		hexY = player.HexY;
		dir = ( player.Dir + i + 2 ) % 6;
		map.MoveHexByDir( hexX, hexY, dir, 1 );
		Item@ door = map.GetDoor( hexX, hexY );
		if( valid( door ) )
		{
			if( !Action( player, null, door, null ) ) { break; }
			player.TimeoutBase[ TO_SK_STEAL ] = __FullSecond + REAL_SECOND( 2 );
			UseSkillOnLocker( player, door, SKILL_PICK_ON_GROUND );
			e_UseAutoCloseDoor( door, player, -1 );

			Critter@[] critters;
			uint8 crs = map.GetCrittersHex( door.HexX, door.HexY, 30, FIND_ALL | FIND_ONLY_PLAYERS, critters );
			for( uint8 i = 0, l = critters.length(); i < l; i++ ) { critters[ i ].RunClientScript( "client_main@SoundDoor", critters[ i ].Id, door.Id, 0, null, null ); }
			break;
		}
	}
}



// Упаковка.
import int BitUnpacker( int storage, uint8 index, uint8 bit ) from "mio_deviants_toolkit";
import int BitPacker( int cell, int storage, uint8 index, uint8 bit ) from "mio_deviants_toolkit";
import uint GetDaysInMonth( uint16 year, uint16 month ) from "time";

// ####################################################################################################
// #                                           Time Control                                           #
// ####################################################################################################

#define MISSED_DAYS								( 10 )						// Лимит дней до выброса персонажа из игровой зоны.
#define SEWERAGE_LOC							( Random( 0, 1 ) == 0 ? 53 : 64 )						// Локация куда выносит спящих красавиц.
#define SEWERAGE_MAP							( 0 )						// Индекс карты на локации выше.
#define SEWERAGE_X								( 180 )						// Координаты посадки по X.
#define SEWERAGE_Y								( 255 )						// Координаты посадки по Y.
#define SEWERAGE_DIR							( 5 )						// Направление кабины после приземления.



// Не кодерам не лезть.
#define STORAGE									( WAKE_DATE )				// 

#define NUM_DAY									( 1 )						// 
#define BIT_DAY									( 5 )						// 
#define NUM_MONTH								( 6 )						// 
#define BIT_MONTH								( 4 )						// 
#define NUM_YEAR								( 10 )						// 
#define BIT_YEAR								( 12 )						// 

#define STARTING_POINT							( 1 )						// 
#define INDEX									# ( X ) ( X - STARTING_POINT )

void SetDay( Critter& player, int num )
{
	player.ParamBase[ STORAGE ] = BitPacker( num, player.Param[ STORAGE ], INDEX( NUM_DAY ), BIT_DAY );
}
uint16 GetDay( Critter& player )
{
	return BitUnpacker( player.Param[ STORAGE ], INDEX( NUM_DAY ), BIT_DAY );
}
void SetMonth( Critter& player, int num )
{
	player.ParamBase[ STORAGE ] = BitPacker( num, player.Param[ STORAGE ], INDEX( NUM_MONTH ), BIT_MONTH );
}
uint16 GetMonth( Critter& player )
{
	return BitUnpacker( player.Param[ STORAGE ], INDEX( NUM_MONTH ), BIT_MONTH );
}
void SetYear( Critter& player, int num )
{
	player.ParamBase[ STORAGE ] = BitPacker( num, player.Param[ STORAGE ], INDEX( NUM_YEAR ), BIT_YEAR );
}
uint16 GetYear( Critter& player )
{
	return BitUnpacker( player.Param[ STORAGE ], INDEX( NUM_YEAR ), BIT_YEAR );
}
void SetDate( Critter& player )
{
	uint16 year = 0;
	uint16 month = 0;
	uint16 day = 0;
	uint16 pass;
	GetTime( year, month, day, pass, pass, pass, pass, pass );

	SetDay( player, day );
	SetMonth( player, month );
	SetYear( player, year );
}

//~run mio_tests test_ToiletBowl 0 0 0
void test_ToiletBowl( Critter& cr, int, int, int )
{
	cr.ParamBase[WAKE_DATE] = 1;
	ToiletBowl(cr);
}

void ToiletBowl( Critter& cr )
{
	uint16 year = 0;
	uint16 month = 0;
	uint16 day = 0;
	uint16 pass;
	GetTime( year, month, day, pass, pass, pass, pass, pass );

	if( cr.Param[ STORAGE ] != 0 )
	{
		bool SleepingBeauty = false;
		uint8 VisitDay = GetDay( cr );
		uint8 VisitMonth = GetMonth( cr );
		uint16 VisitYear = GetYear( cr );
		int8 GapDay;
		int8 GapMonth;

		if( year == VisitYear ) { GapMonth = month - VisitMonth; }
		else if( year == VisitYear + 1 ) { GapMonth = ( 11 - VisitMonth ) + month; }
		else { SleepingBeauty = true; }
		if( GapMonth > 1 ) { SleepingBeauty = true; }

		if( !SleepingBeauty )
		{
			if( month == VisitMonth ) { GapDay = day - VisitDay; }
			else if( month == VisitMonth + 1 ) { GapDay = ( GetDaysInMonth( year, VisitMonth ) - 1 - VisitDay ) + day; }
			if( GapDay > MISSED_DAYS ) { SleepingBeauty = true; }
		}

		if( SleepingBeauty )
		{
			Log_OfflineLimits( cr );

			Location@ loc = GetLocationByPid( SEWERAGE_LOC, 0 );
			if( !valid( loc ) ) { Log( "Локация отсутствует!" ); return; }
			Map@ map = loc.GetMapByIndex( SEWERAGE_MAP );
			if( !valid( map ) ) { Log( "Карта отсутствует!" ); return; }

			uint[] exceptions = { MAP_UTILITY_START, MAP_UTILITY_ARCADE, MAP_HEAVEN, MAP_HELL }; // Карты, с которых не выбросит (теоретически).
			uint mapid = cr.GetMap().GetProtoId();
			for( uint8 i = 0, l = exceptions.length(); i < l; i++ )
			{
				if( mapid == exceptions[ i ] ) { return; }
			}

			if( cr.TransitToMap( map.Id, SEWERAGE_X, SEWERAGE_Y, SEWERAGE_DIR ) )
			{
				SetDate( cr );
				cr.Say( SAY_NETMSG, "|0xFF0000 Сработала защита от варп-домушников. Если это случилось по ошибке обратитесь к надзирателям. Ня! ^_^" );
			}
		}
	}
}

string TimeToString()
{
	uint16 year = 0;
	uint16 month = 0;
	uint16 dayOfWeek = 0;
	uint16 day = 0;
	uint16 hour = 0;
	uint16 minute = 0;
	uint16 second = 0;
	uint16 milliseconds = 0;
	GetTime( year, month, day, dayOfWeek, hour, minute, second, milliseconds );
	return "" + ( day > 9 ? ( "" + day ) : ( "0" + day ) ) + "." + ( month > 9 ? ( "" + month ) : ( "0" + month ) ) + "." + year + " " + ( hour > 9 ? ( "" + hour ) : ( "0" + hour ) ) + ":" + ( minute > 9 ? ( "" + minute ) : ( "0" + minute ) );
}
void Log_OfflineLimits( Critter& player )
{
	file f;
	if( f.open( "logs\\discarded.txt", "a" ) >= 0 )
	{
		string dateonline = GetDay( player ) + "." + GetMonth( player ) + "." + GetYear( player );
		string coord = player.GetMap().Id + " - " + player.HexX + ":" + player.HexY;
		string date = TimeToString();

		f.writeString( "" + date + "\t" + player.Id + "\t" + GetPlayerName( player.Id ) + "\t"+"\t" + " Активность: " + dateonline + "\t" + " Точка входа: " + coord + "\n" );
		f.close();
	}
}



import void ShowInputBoxScreen( Critter& cr, string funcName, uint16 textLength, uint8 flags ) from "main";

// ####################################################################################################
// #                                        Manual Description                                        #
// ####################################################################################################

#define TARGETID								( ST_VAR0 )					// Параметр криттера содержащий ID, с которым происходит взаимодействие.



void DescriptionUse( Critter& player, Item& item )
{
	if( !valid( item ) ) { player.Say( SAY_NETMSG, "Предмет не найден!" ); return; }
	if( item.Val0 > 0 ) { player.Say( SAY_NETMSG, "Предмет уже имеет отличительные особенности." ); return; }

	player.ParamBase[ TARGETID ] = item.Id;
	ShowInputBoxScreen( player, "mio_tests@unsafe_LongDescription#Первая строка", 0, INPUTBOX_CLOSE_ON_ENTER );
	item.Val0 = 1;
}

string BufferMemory;
void unsafe_LongDescription( Critter& player, int param0, int param1, int param2, string@ param3, int[] @ param4 )
{
	Item@ item = GetItem( player.Param[ TARGETID ] );
	if( !valid( item ) ) { player.Say( SAY_NETMSG, "Предмет не найден!" ); return; }

	if( item.Val0 == 1 )
	{
		BufferMemory = param3;
		ShowInputBoxScreen( player, "mio_tests@unsafe_LongDescription#Вторая строка", 0, INPUTBOX_CLOSE_ON_ENTER );
		item.Val0 = 2;
		return;
	}
	BufferMemory += " " + param3;

	if( BufferMemory.length() > 1 )
	{
		player.Say( SAY_NETMSG, "Теперь этот предмет имеет отличительные особенности." );
		item.SetLexems( BufferMemory );
	} else { player.Say( SAY_NETMSG, "Вы сделали так, что бы этот предмет больше ничем не выделялся." ); }

	BufferMemory = "";
	item.Update();
}


