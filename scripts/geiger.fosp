                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

uint __GetColor(int r,int g,int b)
{
	r=(((r)>(255))?(255):(((r)<(0))?(0):(r)));
	g=(((g)>(255))?(255):(((g)<(0))?(0):(g)));
	b=(((b)>(255))?(255):(((b)<(0))?(0):(b)));
	return(uint((0xFF<<24)|(((r)&0xFF)<<16)|(((g)&0xFF)<<8)|((b)&0xFF)));
}

uint __GetGradient(uint colorStart,uint colorEnd,uint8 pos)
{
	pos=(((pos)>(100))?(100):(((pos)<(1))?(1):(pos)));
	
	int aS=(colorStart>>24)&0xFF,
	rS=((colorStart>>16)&0xFF),
	gS=((colorStart>>8)&0xFF),
	bS=((colorStart)&0xFF),
	
	aE=(colorEnd>>24)&0xFF,
	rE=((colorEnd>>16)&0xFF),
	gE=((colorEnd>>8)&0xFF),
	bE=((colorEnd)&0xFF); 
	
	rS=(((rE-int(rS*(pos*0.01)))>0)?(rE-int(rS*(pos*0.01))):-(rE-int(rS*(pos*0.01))));
	gS=(((gE-int(gS*(pos*0.01)))>0)?(gE-int(gS*(pos*0.01))):-(gE-int(gS*(pos*0.01))));
	bS=(((bE-int(bS*(pos*0.01)))>0)?(bE-int(bS*(pos*0.01))):-(bE-int(bS*(pos*0.01))));
	
	return __GetColor(rS,gS,bS);
}

uint __GetColor(uint8&a,uint8&r,uint8&g,uint8&b,uint color){
	a=(color>>24)&0xFF;
	r=((color>>16)&0xFF);
	g=((color>>8)&0xFF);
	b=((color)&0xFF);
	
	return 0;
}                                                                                  

bool UseGeiger(Critter&cr,Item&geiger)
{
	if(geiger.Val1==1)
	{
		geiger.Val1=0;
		if(geiger.Val3!=0)
		EraseTimeEvent(geiger.Val3);
		cr.SayMsg((11),(3),(10352));
	}
	else
	{
		if(geiger.Val2==0)
		{
			cr.SayMsg((11),(3),(10350));
			return true;
		}
		
		cr.SayMsg((11),(3),(10353),"$rem"+cr.Stat[(74)]);
		
		geiger.Val2--;
		if(geiger.Val2==0)
		{
			cr.SayMsg((11),(3),(10350));
		}
		else
		{
			
			geiger.Val1=1;
			geiger.Val3=CreateTimeEvent(__FullSecond+(((5)*__TimeMultiplier)),"e_Geiger",geiger.Id,true);
			cr.PlaySound("GEIGER.ACM",true);
		}
	}
	
	geiger.Update();
	return true;
}

bool UseItemOnGeiger(Critter&cr,Item&geiger,Item&item)
{
	uint16 itemPid=item.GetProtoId();
	if((itemPid==(38)||itemPid==(39))&&geiger.Val2<geiger.Proto.StartValue_2)
	{
		uint needCharge=geiger.Proto.StartValue_2-geiger.Val2;
		uint charge=(itemPid==(38)?(10):(50));
		uint needItems=needCharge/charge;
		if((needCharge%charge)!=0)
		needItems++;
		if(needItems>item.GetCount())
		needItems=item.GetCount();
		geiger.Val2+=needItems*charge;
		if(geiger.Val2>geiger.Proto.StartValue_2)
		geiger.Val2=geiger.Proto.StartValue_2;
		geiger.Update();
		do{if(item.GetCount()>(needItems))
			item.SetCount(item.GetCount()-(needItems));else
			DeleteItem(item);}while(false);
		cr.SayMsg((11),(3),(10356));
	}
	else
	{
		cr.SayMsg((11),(3),(10355));
	}
	return true;
}

bool UseSkillOnGeiger(Critter&cr,Item&geiger,int skill)
{
	if(skill<0)
	return false;
	
	if(skill==(212))
	{
		cr.SayMsg((11),(3),(10357),"$cur"+geiger.Val2+"$max"+geiger.Proto.StartValue_2);
	}
	else
	{
		cr.SayMsg((11),(3),(10355));
	}
	return true;
}

uint e_Geiger(uint[]@values)
{
	Item@geiger=GetItem(values[0]);
	if(not(@geiger!=null))
	return 0;
	
	if(geiger.Val1==0)
	return 0;
	if(geiger.Val2>0)
	geiger.Val2--; 
	
	if(geiger.Accessory==(1))
	{
		Critter@cr=GetCritter(geiger.CritId);
		if((@cr!=null))
		{
			cr.SayMsg((11),(3),(10354),"$rem"+cr.Stat[(74)]);
			if(geiger.Val2==0)
			{
				cr.SayMsg((11),(3),(10350));
				cr.SayMsg((11),(3),(10352));
				cr.PlaySound("GEIGER.ACM",true);
			}
		}
	}
	else if(geiger.Accessory==(2))
	{
		uint16 hx=0,hy=0;
		Map@map=geiger.GetMapPosition(hx,hy);
		if((@map!=null))
		{
			Critter@[]critters;
			map.GetCrittersHex(hx,hy,(20)-1,(0x0F),critters);
			
			uint aproxValue=0;
			for(uint i=0,j=critters.length();i<j;i++)
			{
				Critter@cr=critters[i];
				uint value=cr.Stat[(74)]*((20)-GetDistantion(cr.HexX,cr.HexY,hx,hy))/(20);
				if(value>aproxValue)
				aproxValue=value;
			}
			
			map.SetTextMsg(hx,hy,((uint((0xFF<<24)|(((0x7F)&0xFF)<<16)|(((0x7F)&0xFF)<<8)|((0x7F)&0xFF)))),(3),(10354),"$rem"+aproxValue);
		}
	}
	
	if(geiger.Val2==0)
	{
		geiger.Val1=0;
		geiger.Val3=0;
	}
	
	geiger.Update();
	return geiger.Val2==0?0:(((5)*__TimeMultiplier));
}
