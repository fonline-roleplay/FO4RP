                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

bool LocIsModoc(uint locPid)
{
	return(locPid<=(6));
}

bool LocIsCity(uint locPid)
{
	return(locPid<=(25)||locPid==(40)||locPid==(42)||locPid==26||locPid==27||locPid==29||locPid>=96);
}

bool LocIsMasked(uint locPid)
{
	return(locPid==(41));
}

bool LocIsHidden(uint locPid)
{
	return false;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             

const uint16[]DiscPids=
{
	(1900),
	(1901),
	(1902),
	(1903),
	(1904),
	(1905),
	(1906),
	(1907),
	(1908),
	(1909),
	(1910),
	(1911),
	(1912),
	(1913),
	(1914),
	(1915),
	(1916),
	(1917),
	(1918),
	(1919),
	(1920),
	(1921),
	(1922),
	(1923),
	(1924),
	(1925),
	(1926),
	(1927),
	(1928),
	(1929),
	(1930),
	(1931),
	(1932),
	(1933),
	(1934),
	(1935),
	(1936),
	(1937),
	(1938),
	(1939),
	(1940),
	(1941),
	(1942),
	(1943),
	(1944),
	(1945),
	(1946),
	(1947),
	(1948),
	(1949),
	(1950),
	(1951),
	(1952),
	(1953),
	(1954),
	(1955),
	(1956)
}; 

const string[]SoundFiles=
{
	"xfiles.ogg",
	"tmnt.ogg",
	"afterdark.ogg",
	"terminator2.ogg",
	"sixteentons.ogg",
	"maybe.ogg",
	"worldonfire.ogg",
	"rockies.ogg",
	"zerg.ogg",
	"fiftymegatons.ogg",
	"darkeyes.ogg",
	"radioactivemama.ogg",
	"summertime.ogg",
	"imperialmarch.ogg",
	"soldtheworld.ogg",
	"loveshair.ogg",
	"severnavsegda.ogg",
	"radioaktivnirocknroll.ogg",
	"roundtable.ogg",
	"holygrail.ogg",
	"falloutshelter.ogg",
	"lovedbyyou.ogg",
	"Dreamon.ogg",
	"wonderfulworld.ogg",
	"imperialmarch0.ogg",
	"laika.ogg",
	"darksideblues.ogg",
	"tampico.ogg",
	"stillalive.ogg",
	"cantinaband.ogg",
	"askmenice.ogg",
	"somebodytolove.ogg",
	"ritz.ogg",
	"hbombrock.ogg",
	"atombomb.ogg",
	"ghostbusters.ogg",
	"atomiccocktail.ogg",
	"moonwasyellow.ogg",
	"coldwarwithyou.ogg",
	"AtomBombBaby.ogg",
	"rockininrhythm.ogg",
	"bluelou.ogg",
	"newjunkcity.ogg",
	"uranium.ogg",
	"twistagain.ogg",
	"vodka.ogg",
	"nocommunist.ogg",
	"atomicpower.ogg",
	"waytovegas.ogg",
	"onemore.ogg",
	"paranoid.ogg",
	"falloutshelter0.ogg",
	"stranasovetov.ogg",
	"auctiondoroga.ogg",
	"atomicbaby.ogg",
	"tnt.ogg",
	"javabar.ogg"
};

const string[]DiscNames=
{
	"Секретные Материалы",
	"Черепашки Мутанты Нинзя",
	"От заката до рассвета",
	"Терминатор 2",
	"The Platters - Sixteen Tons",
	"The Ink Spots - Maybe",
	"The Ink Spots - I Don't Want To Set The World On Fire",
	"Tex Ritter - When It's Springtime In The Rockies",
	"StarCraft - A Zerg Shotgun and You",
	"Sonny Russell - Fifty Megatons",
	"Slam Stewart - Dark-Eyes",
	"Sheldon Allman - Radioactive Mama",
	"Sarah Vaughan - Summertime",
	"Richard Cheese - Imperial March",
	"Nirvana - The Man Who Sold The World",
	"Nina Simone - Black Is The Color Of My True Loves Hair",
	"Невидимка - Север Навсегда",
	"Невидимка - Радиоактивный РокНРолл",
	"Monty Pythons Spamalot Knights Of The Round Table",
	"Monty Python And The Holy Grail",
	"Mike Winters & Bernie Winters - Fallout Shelter",
	"Marilyn Monroe - I Wanna Be Loved by You",
	"Louis Armstrong - A Kiss To Build A Dream On",
	"Louis Armstrong - Wonderful World",
	"London Symphony Orchestra - The Imperial March",
	"Laika and The Cosmonauts - C'mon Do The Laika",
	"Kazuhiko Toyama - Darkside Blues",
	"June - Christy Tampico",
	"Jonathan Coulton & Ellen McLain - Still Alive",
	"John Williams - Cantina Band",
	"John Hammond - Ask Me Nice",
	"Jefferson Airplane - Somebody to Love",
	"Harry Richman Orchestra - Puttin on the Ritz",
	"H-Bomb Ferguson - Rock H-Bomb Rock",
	"Glenn Barber - Atom Bomb",
	"Охотники За Привидениями",
	"Gaillard Slim Quartette - Atomic Cocktail",
	"Frank Sinatra - The Moon Was Yellow (And The Night Was Young)",
	"Floyd Tillman - This Cold War With you",
	"Five Stars - Atom Bomb Baby",
	"Ella Fitzgerald - Rockin In Rhythm",
	"Ella Fitzgerald - Blue Lou",
	"Earthworm Jim - New Junk City",
	"Commodores - Uranium",
	"Chubby Checker - Lets Twist Again",
	"Chris De Burgh - Moonlight And Vodka",
	"Carson Robison - I'm No Communist",
	"Buchanan Brothers - Atomic Power",
	"Brian Tyler - On My Way To Vegas",
	"Bob Dylan Honey - Just Allow Me One More",
	"Rock'N'Roll Racing - Paranoid (Black Sabbath)",
	"Billy Chambers - Fallout Shelter",
	"Белка и Стрелка - Страна Советов",
	"АукцЫон - Дорога",
	"Amos Milburn - Atomic Baby",
	"AC \ DC - TNT",
	"Java Bar"
};

const uint[]SongTimeouts=
{
	260,
	94,
	260,
	121,
	166,
	180,
	180,
	114,
	204,
	136,
	164,
	109,
	181,
	139,
	220,
	205,
	186,
	167,
	350,
	116,
	159,
	170,
	266,
	135,
	181,
	129,
	175,
	156,
	175,
	169,
	297,
	167,
	236,
	134,
	186,
	243,
	165,
	192,
	166,
	144,
	310,
	157,
	146,
	136,
	140,
	217,
	167,
	158,
	247,
	118,
	172,
	165,
	76,
	205,
	154,
	221,
	169
};  

uint GetSongCost(int discNumber)
{
	return(5);
}             

import void PlayMusic(Map&map,string&musicName,uint pos,uint repeat)from"media";
import bool IsKeyAviable(Critter&cr,uint lockerId)from"lockers";

int64 GetItemIndexByPid(uint16 pid,Item@[]&items)
{
	for(uint i=0;i<items.length();++i)
	{
		if((@items[i]!=null)&&items[i].GetProtoId()==pid)
		{
			return i;
		}
	}
	return-1;
}

void _JukeboxInit(Item&jukebox,bool firstTime)
{
	jukebox.Val0=(0);
	jukebox.Val1=0;
	jukebox.Val2=0;
	jukebox.LockerId=0;
	jukebox.SetEvent((4),"_JukeboxSkillUse");
	jukebox.SetEvent((3),"_JukeboxItemUse");
}

bool _JukeboxItemUse(Item&jukebox,Critter&cr,Item@usedItem)
{
	if(!(@usedItem!=null))
	{
		return false;
	}
	uint16 usedItemProto=usedItem.GetProtoId();
	if(usedItemProto==(41))
	{
		cr.StatBase[(130)]=jukebox.Id;
		RunDialog(cr,(93),jukebox.HexX,jukebox.HexY,false);
		return true;
	}
	if(usedItemProto==(82))
	{
		return KeyUsedOnJukebox(jukebox,usedItem,cr);
	}
	return false;
}

bool _JukeboxSkillUse(Item&jukebox,Critter&cr,int skill)
{
	if(skill==(-1))
	{
		cr.StatBase[(130)]=jukebox.Id;
		RunDialog(cr,(93),jukebox.HexX,jukebox.HexY,false);
		return true;
	}
	if(skill==(213))
	{
		if((((jukebox.LockerCondition)&((0x01)))!=0)||jukebox.LockerId==0||
		(((jukebox.LockerCondition)&((0x08)))!=0)||IsKeyAviable(cr,jukebox.LockerId))
		{
			JukeboxContainerRequested(jukebox,cr);
			return true;
		}
	}
	return false;
}

bool KeyUsedOnJukebox(Item&jukebox,Item&key,Critter&user)
{
	if(jukebox.LockerId!=0&&jukebox.LockerId==key.LockerId&&!(((jukebox.LockerCondition)&((0x08)))!=0))
	{
		JukeboxContainerRequested(jukebox,user);
		return true;
	}
	return false;
}

void JukeboxContainerRequested(Item&jukebox,Critter&cr)
{
	if(jukebox.Proto.Container_Changeble)
	{
		if((((jukebox.LockerCondition)&((0x01)))!=0))
		{
			jukebox.LockerClose();
		}
		else
		{
			jukebox.LockerOpen();
			cr.ShowContainer(null,jukebox,jukebox.Proto.GroundLevel?(2):(1));
		}
	}
	else
	{
		cr.ShowContainer(null,jukebox,jukebox.Proto.GroundLevel?(2):(1));
	}
}  

bool JukeboxSongRequested(Item&jukebox)
{
	if(jukebox.Val0!=(0))
	{
		return false;
	}
	uint16 discPid=jukebox.Val2;
	if(!JukeboxContainsDisc(jukebox,discPid))
	{
		return false;
	}
	int discNumber=GetDiscNumber(discPid);
	if(discNumber==-1)
	{
		return false;
	}
	uint16 hx=0,hy=0;
	Map@map=jukebox.GetMapPosition(hx,hy);
	if(!(@map!=null))
	{
		return false;
	}
	jukebox.Val0=(1);
	if(SongTimeouts[discNumber]==0)
	{
		
		CreateTimeEvent(__FullSecond+(((300))*__TimeMultiplier),"e_EnableOrders",jukebox.Id,false);
	}
	else
	{
		
		CreateTimeEvent(__FullSecond+((SongTimeouts[discNumber])*__TimeMultiplier),"e_EnableOrders",jukebox.Id,false);
	}
	PlayMusic(map,"DUMMY",0,0);
	map.PlaySound(SoundFiles[discNumber],hx,hy,0);
	return true;
}

uint e_EnableOrders(uint[]@values)
{
	Item@jukebox=GetItem(values[0]);
	if((@jukebox!=null))
	{
		jukebox.Val0=(0);
	}
	return 0;
}

bool IsDisc(uint16 pid)
{
	uint discAmount=DiscPids.length();
	for(uint i=0;i<discAmount;++i)
	{
		if(DiscPids[i]==pid)
		{
			return true;
		}
	}
	return false;
}

bool IsDisc(Item@item)
{
	return((@item!=null)&&IsDisc(item.GetProtoId()));
}

int GetDiscNumber(uint16 discPid)
{
	uint discAmount;
	discAmount=DiscPids.length();
	for(uint i=0;i<discAmount;++i)
	{
		if(DiscPids[i]==discPid)
		{
			return i;
		}
	}
	return-1;
} 

bool JukeboxContainsDisc(Item&jukebox,uint16 discPid)
{
	if(IsDisc(discPid))
	{
		Item@disc=jukebox.GetItem(discPid,uint(-1));
		if(!(@disc!=null))
		{
			return false;
		}
		return true;
	}
	return false;
} 

uint GetJukeboxDiscs(Item&jukebox,Item@[]@+discs)
{
	if(!(@discs!=null))
	{
		return 0;
	}
	uint discAmount=0;
	Item@[]jukeboxItems;
	jukebox.GetItems(uint(-1),jukeboxItems);
	for(uint i=0;i<jukeboxItems.length();++i)
	{
		if(IsDisc(jukeboxItems[i]))
		{
			discs.insertLast(jukeboxItems[i]);
			++discAmount;
		}
	}
	return discAmount;
}

int GetRandomJukeboxDiscNumber(Item&jukebox)
{
	Item@[]discs;
	GetJukeboxDiscs(jukebox,discs);
	if(discs.length()==0)
	{
		return-1;
	}
	Item@discToPlay=discs[Random(0,discs.length()-1)];
	if(!(@discToPlay!=null))
	{
		return-1;
	}
	int discNumber=GetDiscNumber(discToPlay.GetProtoId());
	return discNumber;
} 

bool IsJukeboxCurrentDiscValid(Item&jukebox)
{
	int currentDiscNumber=GetDiscNumber(jukebox.Val2);
	if(currentDiscNumber==-1||!JukeboxContainsDisc(jukebox,jukebox.Val2))
	{
		currentDiscNumber=GetRandomJukeboxDiscNumber(jukebox);
		if(currentDiscNumber==-1)
		{
			return false;
		}
		else
		{
			jukebox.Val2=DiscPids[currentDiscNumber];
			return true;
		}
	}
	return true;
}

bool IsPlayActive(Item&jukebox)
{
	return(IsJukeboxCurrentDiscValid(jukebox)&&uint(jukebox.Val1)>=GetSongCost(GetDiscNumber(jukebox.Val2))&&jukebox.Val0==(0));
}

void SwitchJukeboxCurrentSong(Item&jukebox,uint8 direction)
{
	Item@[]discs;
	GetJukeboxDiscs(jukebox,discs);
	if(!(@discs!=null))
	{
		return;
	}
	int64 currentDiscIndex=GetItemIndexByPid(jukebox.Val2,discs);
	if(currentDiscIndex==-1)
	{
		return;
	}
	if(direction==(1))
	{
		do
		{
			--currentDiscIndex;
			if(currentDiscIndex==-1)
			{
				currentDiscIndex=discs.length()-1;
			}
		}
		while(!(@discs[currentDiscIndex]!=null));
	}
	else
	{
		do
		{
			++currentDiscIndex;
			if(uint(currentDiscIndex)==discs.length())
			{
				currentDiscIndex=0;
			}
		}
		while(!(@discs[currentDiscIndex]!=null));
	}
	jukebox.Val2=discs[currentDiscIndex].GetProtoId();
}

Item@GetJukebox(Critter&player)
{
	Map@map=player.GetMap();
	if((@map!=null))
	{
		return map.GetItem(player.StatBase[(130)]);
	}
	return null;
}  

void dlg_JukeboxMainDialog(Critter&player,Critter@cr,string@lexems)
{
	if(!((@lexems!=null)&&lexems.length()==0))
	{
		return;
	}
	const string IS_PLAY_ACTIVE_LEX_NAME="is_play_active";
	string isPlayActiveLexValue;
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null)||!IsJukeboxCurrentDiscValid(jukebox))
	{
		FillBasicJukeboxLexems(jukebox,lexems,true);
		isPlayActiveLexValue="error";
	}
	else
	{
		FillBasicJukeboxLexems(jukebox,lexems,false);
		isPlayActiveLexValue=IsPlayActive(jukebox)?(" Горит кнопка \"Play\"."):"";
	}
	lexems+=("$")+IS_PLAY_ACTIVE_LEX_NAME+(" ")+isPlayActiveLexValue;
}

void dlg_JukeboxCoinboxDialog(Critter&player,Critter@cr,string@lexems)
{
	if(!((@lexems!=null)&&lexems.length()==0))
	{
		return;
	}
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null)||!IsJukeboxCurrentDiscValid(jukebox))
	{
		FillBasicJukeboxLexems(jukebox,lexems,true);
	}
	else
	{
		FillBasicJukeboxLexems(jukebox,lexems,false);
	}
}

void r_CoinsInserted(Critter&player,Critter@cr,int moneyAmount)
{
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null))
	{
		return;
	}
	if(player.CountItem((41))>=uint(moneyAmount))
	{
		player.DeleteItem((41),moneyAmount);
		jukebox.AddItem((41),moneyAmount,uint(-1));
		jukebox.Val1+=moneyAmount;
	}
}

void r_PlayPressed(Critter&player,Critter@cr)
{
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null))
	{
		return;
	}
	if(JukeboxSongRequested(jukebox)==true)
	{
		jukebox.Val1-=GetSongCost(GetDiscNumber(jukebox.Val2));
	}
}

bool d_IsPlayActive(Critter&player,Critter@cr)
{
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null))
	{
		return false;
	}
	return IsPlayActive(jukebox);
}

void r_LeftArrowPressed(Critter&player,Critter@cr)
{
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null))
	{
		return;
	}
	SwitchJukeboxCurrentSong(jukebox,(1));
}

void r_RightArrowPressed(Critter&player,Critter@cr)
{
	Item@jukebox=GetJukebox(player);
	if(!(@jukebox!=null))
	{
		return;
	}
	SwitchJukeboxCurrentSong(jukebox,(0));
}  

void FillBasicJukeboxLexems(Item@jukebox,string@lexems,bool fillWithErrors)
{
	if(!(@lexems!=null))
	{
		return;
	}
	if(!(@jukebox!=null))
	{
		fillWithErrors=true;
	}
	const string SONG_NAME_LEX_NAME="song_name";
	const string SONG_COST_LEX_NAME="song_cost";
	const string CREDIT_LEX_NAME="credit";
	const string STATUS_LEX_NAME="status";
	string songNameLexValue;
	string songCostLexValue;
	string creditLexValue;
	string statusLexValue;
	if(!fillWithErrors)
	{
		int currentDiscNumber=GetDiscNumber(jukebox.Val2);
		songNameLexValue="song123";
		songNameLexValue=DiscNames[currentDiscNumber];
		songCostLexValue=GetSongCost(currentDiscNumber);
		creditLexValue=jukebox.Val1;
		statusLexValue=jukebox.Val0==(0)?("Ничего не играет."):("Играет музыка. Подождите.");
	}
	else
	{
		songNameLexValue="error";
		songCostLexValue="error";
		creditLexValue="error";
		statusLexValue="error";
	}
	lexems+=("$")+SONG_NAME_LEX_NAME+(" ")+songNameLexValue;
	lexems+=("$")+SONG_COST_LEX_NAME+(" ")+songCostLexValue;
	lexems+=("$")+CREDIT_LEX_NAME+(" ")+creditLexValue;
	lexems+=("$")+STATUS_LEX_NAME+(" ")+statusLexValue;
}
