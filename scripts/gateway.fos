#include "_macros.fos"

uint[] guards;

import bool AddAttackPlane( Critter& npc, uint priority, Critter& target, int minHp ) from "npc_planes";
import uint EraseAttackPlane( Critter& npc, Critter& target ) from "npc_planes";

import void PlayMusic(Critter& cr, string& musicName, uint pos, uint repeat) from "media";

void t_EnterHex( Critter& cr, Scenery& trigger, bool entered, uint8 dir, int val )
{
    if( cr.IsNpc() )
        return;

	Map@ map = cr.GetMap();
	if(!valid(map))return;
	Location@ loc = map.GetLocation();
	if(!valid(loc))return;
	
	if( loc.GetProtoId() == 25 ) //Саттерский бот:
	{
		if(entered)
		{
			if( cr.Dir >= 0 && cr.Dir <= 2 )
			{
				Critter@[] turrets;
				map.GetCritters( 77, FIND_LIFE | FIND_ONLY_NPC, turrets );
				if( turrets.length() < 1 ) { Log( "Робо-лерой куда-то проебался!" ); return; }
				Critter@ turret = turrets[0];

				GameVar@ robot_access = ::GetUnicumVar( UVAR_loyality, turret.Id, cr.Id );
				if( val == 5 && robot_access == 6 ) return; //Не реагирует на авторизованных
				
				turret.Say( SAY_EMOTE_ON_HEAD, "угрожающе повернулся" );
				uint8 dir = GetDirection( turret.HexX, turret.HexY, cr.HexX, cr.HexY );
				turret.SetDir( dir );
				cr.SetEvent( CRITTER_EVENT_IDLE, null );
				cr.Wait( 1000 );
				PlayMusic( cr, "Alarm.ogg", 1, 0 );

				if( cr.CountItem( PID_BLUE_PASS_KEY ) > 0 )
				{
					if( val == 4 )
						cr.Say( SAY_EMOTE_ON_HEAD, "показывает пропуск" );
					RunDialog( cr, turret, true );
				}
				else
				{
					if( val == 5 )
					{
						turret.Say( SAY_SHOUT_ON_HEAD, "НАРУШИТЕЛЬ !!! УНИЧТОЖИТЬ" );
						AddAttackPlane( turret, 0, cr, -10 );
						if( cr.Param[ QST_GAMEMODE ] != GAME_ARCADE && cr.Stat[ ST_BODY_TYPE ] != BT_ZOMBIE )
							cr.SetEvent( CRITTER_EVENT_KNOCKOUT, "_KoAndCatch2" );
					}
					else
						RunDialog( cr, turret, true );
				}
			}
		}
	}
	else //Модокский старый код:
	{
		int      ck = cr.ParamBase[ QST_GAMEMODE ];

		GameVar@ citizenship = GetLocalVar( LVAR_modoc_citizenship, cr.Id );
		GameVar@ border_mode = GetGlobalVar( GVAR_inf_modoc_border_mode );
		GameVar@ faction = GetLocalVar( LVAR_faction, cr.Id );

		if( entered && border_mode.GetValue() != 5 && ( citizenship.GetValue() <= 1 && cr.Param[ QST_INVIS ] == 0 ||
														citizenship.GetValue() == 10 ||
														( border_mode.GetValue() == 1 && citizenship.GetValue() <= 2 ) ||
														( border_mode.GetValue() == 2 && citizenship.GetValue() <= 3 ) ||
														( border_mode.GetValue() == 3 && citizenship.GetValue() <= 3 ) ||
														( border_mode.GetValue() == 4 && ( faction.GetValue() == 0 || faction.GetValue() >= 3 ) ) ) )
		{
			// Log("нелегал");
			if( val == 5 )
			{
				if( border_mode.GetValue() <= 2 && citizenship.GetValue() == 1 )
				{
					if( border_mode.GetValue() == 0 && ( cr.Dir == 0 || cr.Dir == 5 || cr.Dir == 4 ) )
					{
						cr.Say( SAY_EMOTE_ON_HEAD, "показывает пропуск" );
						return;
					}
					else if( cr.Dir == 1 || cr.Dir == 2 || cr.Dir == 3 )
					{
						citizenship.opAssign( 0 );
						cr.Say( SAY_EMOTE_ON_HEAD, "сдает пропуск охране" );
						return;
					}
					else
						AttackAndCatch( cr );
				}
				else if( border_mode.GetValue() <= 2 && citizenship.GetValue() == 2 && ( cr.Dir == 1 || cr.Dir == 2 || cr.Dir == 3 ) )
					return;
				else
					AttackAndCatch( cr );
			}
			else if( val == 4 )
			{
				if( citizenship.GetValue() == 1 && border_mode.GetValue() == 0 )
					return;
				// Log("кричим");
				Critter@ gu = null;
				for( uint i = 0, len = guards.length(); i < len; i++ )
				{
					Critter@ tgu = GetCritter( guards[ i ] );
					if( (tgu is null) || GetDistantion( cr.HexX, cr.HexY, tgu.HexX, tgu.HexY ) > 15 || !tgu.IsSee( cr ) )
						continue;
					@gu = tgu;
					if( tgu.Param[ ST_DIALOG_ID ] == 330 )
						break;
				}
				if( gu is null )
					return;

				// Log("123");

				uint8 dir = GetDirection( gu.HexX, gu.HexY, cr.HexX, cr.HexY );

				// uint8 dir2 = (dir+3)%6;

				// Log("мой "+cr.Dir+" а dir "+dir);

				if( cr.Dir == dir || cr.Dir == ( ( dir + 1 ) % 6 ) || cr.Dir == ( dir + 5 ) % 6 )
					return;

				// Log("345");

				gu.Say( SAY_SHOUT_ON_HEAD, "Стоять! Тебе нельзя в город!" );
				gu.SetDir( dir );
				cr.SetEvent( CRITTER_EVENT_IDLE, null );
				cr.Wait( 1000 );
			}
		}
	}
}

void AttackAndCatch( Critter& cr )
{
    Map@ map = cr.GetMap();
    if( map is null )
        return;

    for( uint i = 0; i < guards.length(); i++ )
    {
        Critter@ guard = GetCritter( guards[ i ] );
        if( guard is null )
            continue;

        uint len = GetDistantion( cr.HexX, cr.HexY, guard.HexX, guard.HexY );
        if( len > 25 || !guard.IsSee( cr ) || ( cr.GetMap().Id != guard.GetMap().Id ) )
            continue;

        AddAttackPlane( guard, 0, cr, -10 );
    }

    if( cr.Param[ QST_GAMEMODE ] != GAME_ARCADE && cr.Stat[ ST_BODY_TYPE ] != BT_ZOMBIE )
        cr.SetEvent( CRITTER_EVENT_KNOCKOUT, "_KoAndCatch" );

}

void _KoAndCatch( Critter& cr, uint anim2begin, uint anim2idle, uint anim2end, uint lostAp, uint knockDist )
{
    int  ck = cr.ParamBase[ QST_GAMEMODE ];

    bool ck2 = false;

    if( !cr.IsDead() /*&& ck!=ACT_CODE && ck!=ACT_GM*/ )
    {
        for( uint i = 0; i < guards.length(); i++ )
        {
            Critter@ guard = GetCritter( guards[ i ] );

            if( (guard is null) )
                continue;
            if( cr.GetMap().Id != guard.GetMap().Id )
                continue;

            EraseAttackPlane( guard, cr );

            if( ck2 || ( !guard.IsSee( cr ) ) )
                continue;

            if( !catch( cr ) )
                Log( "Fail with catch!" );

            ck2 = true;
        }
    }

    cr.SetEvent( CRITTER_EVENT_KNOCKOUT, null );
}

void _KoAndCatch2( Critter& cr, uint anim2begin, uint anim2idle, uint anim2end, uint lostAp, uint knockDist )
{
	cr.SetEvent( CRITTER_EVENT_KNOCKOUT, null );
	
	Map@ map = cr.GetMap();
	if(!valid(map))	return;
	
	Critter@[] turrets;
	map.GetCritters( 77, FIND_LIFE | FIND_ONLY_NPC, turrets );
	if( turrets.length() < 1 ) { Log( "Робо-лерой куда-то проебался!" ); return; }
	Critter@ turret = turrets[0];
	EraseAttackPlane( turret, cr );
	if( !cr.IsDead() )
		catch( cr );
}

bool catch( Critter& cr )
{
    bool ch = false;
    Map @ map = cr.GetMap();
    if( map is null )
        return false;
    Location @ loc = map.GetLocation();
    if( ( loc.GetProtoId() >= 1 && loc.GetProtoId() <= 4 ) || loc.GetProtoId() == 6 )
    {
        Map @ map2 = GetLocationByPid( 5, 0 ).GetMapByIndex( 0 );
        if( map2 is null )
        {
            Log( "gw map" );
            return false;
        }
        ch = cr.TransitToMap( map2.Id, 0 );
        return ch;
    }
	if( loc.GetProtoId() == 5 ) //Модок.
	{
		ch = cr.TransitToHex( 120 + Random( -5, 5 ), 240 + Random( -5, 5 ), 6 );
		cr.Say( SAY_NETMSG, "Вас выкинули из Модока. Оно и к лучшему, правда?" );
		return ch;
	}
	if( loc.GetProtoId() == 25 ) //Саттер.
	{
		ch = cr.TransitToHex( 536 + Random( -2, 2 ), 410 + Random( -2, 2 ), 6 );
		cr.Say( SAY_NETMSG, "Вас выкинули из Форта. Лучше не испытывайте судьбу второй раз, робот шуток не понимает." );
	}
    return ch;

/*	uint16 hexX=0, hexY=0;

        if(!map.GetEntireCoords (58, 0, hexX, hexY)) return false;

        Item@ toCont = map.	GetItem(hexX, hexY, 188); //ищем шкаф с pid 188 на гексе #58

        if(valid(toCont))
        {
                Item@[] items;
                cr.GetItems(SLOT_INV,items);
                cr.GetItems(SLOT_HAND1,items);
                cr.GetItems(SLOT_HAND2,items);

                MoveItems(items,  toCont, cr.Id); //прячем вещички в шкаф с замком 300
        }

        uint last = map.GetData(55); // в какую клетку в последний раз пихали

        bool ch=false;

        for(uint i=0; i<3 && !ch; i++) //пробуем засунуть в одну из клеток по очереди
        {
                if(!map.GetEntireCoords(55+last, 0, hexX, hexY)) continue;

                ch = cr.TransitToHex(hexX, hexY, 2);

                last+=1; if(last>2) last=0;
        }

        map.SetData(55, last);

        return ch;
 */
}

void addGuard( Critter& npc )
// void _InitGuard(Critter& npc, bool firstTime)
{
    guards.insertLast( npc.Id );
    // if(npc.Param[ST_DIALOG_ID]!=330)
    // {
//		npc.ParamBase[]
    // }
}


void r_toHex( Critter& master, Critter@ slave, int val )
{
    Map@ map = master.GetMap();

    if( map is null )
        return;

    uint16 hexX = 0, hexY = 0;

    if( !map.GetEntireCoords( val, 0, hexX, hexY ) )
        return;

    master.TransitToHex( hexX, hexY, 5 );
}

bool d_isGoOut( Critter& master, Critter@ slave )
{
    Map@ map = master.GetMap();

    if( map is null )
        return false;

    uint16 hexX = 0, hexY = 0;

    if( !map.GetEntireCoords( 83, 0, hexX, hexY ) )
        return false;

    if( master.HexX == hexX && master.HexY == hexY )
        return true;

    uint8 dir = GetDirection( master.HexX, master.HexY, hexX, hexY );

    return ( dir > 0 && dir < 4 );

}

void AttackAndCatch( Critter& player, int id, int param1, int param2 )
{
    Critter@ cr = GetCritter( uint( id ) );
    if( cr is null )
        return;
    AttackAndCatch( cr );
}

void Release( Critter& player, int id, int param1, int param2 )
{
    Critter@ cr = GetCritter( id );
    if( cr is null )
        return;
    Map@ map = cr.GetMap();
    if( map is null || map.GetProtoId() != 18 )
        return;
    if( cr.HexX >= 120 || cr.HexX <= 100 || cr.HexY >= 220 || cr.HexY <= 210 )
        return;

    //	uint16 hexX=0, hexY=0;
    //	if(!map.GetEntireCoords(0, 0, hexX, hexY) || !cr.TransitToHex(hexX, hexY, 5)) return;
    //	player.Say(SAY_NETMSG, "Transfer ok.");
    //	if(param1==0) return;
    //	hexX=0; hexY=0;
    //	if(!map.GetEntireCoords(58, 0, hexX, hexY)) return;

    cr.TransitToHex( player.HexX + 1, player.HexY + 1, 5 );
    Item@ toCont = map.GetItem( 117, 208, 188 );   // ищем шкаф с pid 188 на гексе #58
    if( valid( toCont ) )
    {
        Item@[] items;
        toCont.GetItems( cr.Id, items );

        MoveItems( items, cr );       // прячем вещички в шкаф с замком 300

        player.Say( SAY_NETMSG, "Item return ok." );
    }
}
